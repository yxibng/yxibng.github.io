{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"59c6ef1e5601c94d7113ecc8948d2806f59fc68b","modified":1709781049879},{"_id":"source/_posts/.DS_Store","hash":"0a3d229aac44f23609732d4b9c75c538519ef82e","modified":1709780593977},{"_id":"source/_posts/2022-05-11-命令行修改 xcode pbxproj 文件.md","hash":"d729d1d68d2b79a7b9bc294c80f14a44d50e7cf5","modified":1709725993562},{"_id":"source/_posts/2022-12-21-rbenv.md","hash":"984f48ba85cabc312a88cad0523fc8b9708c1c6d","modified":1709725993562},{"_id":"source/_posts/2023-03-07-open-your-terminal-from-xcode.md","hash":"7e5face379b9e65e62f696a71f9d5f54b8e007be","modified":1709725993562},{"_id":"source/about/index.md","hash":"70b4f2598f7be89eddd5f4c6b6ad379b5a15d896","modified":1709726013622},{"_id":"source/_posts/Shell/2022-02-25-Shell 数组.md","hash":"ea649457b5083aff925f89b279cd8a0762675fe5","modified":1709725993563},{"_id":"source/_posts/Shell/2022-02-25-shell 循环语句.md","hash":"53c2061667f76cce940e5095abf2ef87e93bb518","modified":1709725993563},{"_id":"source/_posts/Shell/2022-02-25-Shell 变量.md","hash":"31d9bbf2857dfd5c6e90d22f5c217da6d52f6481","modified":1709725993562},{"_id":"source/_posts/Shell/2022-02-25-shell 函数.md","hash":"bae1a65ffb688f98c226afa6904c59d9b14d9bf2","modified":1709725993563},{"_id":"source/_posts/Shell/2022-02-25-shell 条件语句.md","hash":"6704063d5281a147be167e283e25ef3b59d816be","modified":1709725993563},{"_id":"source/_posts/Shell/2022-03-09-shell 脚本，带名字的参数.md","hash":"d42936b0f4036657394f11c4c62da75cdaa606fc","modified":1709725993563},{"_id":"source/_posts/Shell/2022-02-25-shell 运算符.md","hash":"de3a1f02d709171377bac95815ecf3d676f46cae","modified":1709725993563},{"_id":"source/_posts/Shell/2022-02-25-shell 特殊变量.md","hash":"003695b65b7703b8a1be9f6f309849684b0eb0ed","modified":1709725993563},{"_id":"source/_posts/Shell/2022-11-16-命令行重启iPhone.md","hash":"68d894d99a3d1ceba81b4170096f4a6d0068b68a","modified":1709725993563},{"_id":"source/_posts/Shell/2023-05-17-oh my zsh 展示路径.md","hash":"b47c570743be2a71b7f072d4dc4895a48e4890f1","modified":1709725993563},{"_id":"source/_posts/Shell/常用的shell语句.md","hash":"3aa7d2753bb90d76e6968aac0205343b779fef86","modified":1709780760029},{"_id":"source/_posts/aac/2022-09-23-aac-adts.md","hash":"9e53f8abfd562e8f195904bc98138fe2c8566077","modified":1709725993564},{"_id":"source/_posts/c++/2022-03-19-pragma once 用法总结.md","hash":"c4b581c5e58ac526c7b9cc9738c530d290d27090","modified":1709725993564},{"_id":"source/_posts/aac/2022-09-23-fdk-aac.md","hash":"1cc45d2a2dd532b548f93f8cc063fc67df0e2dac","modified":1709725993564},{"_id":"source/_posts/c++/2022-10-29-Xcode 配置 clang-format 格式化 c++ 代码.md","hash":"81271ff87f353b3fd2ed68fcb3668342363c7a18","modified":1709725993564},{"_id":"source/_posts/c++/2023-06-09-位域 高低位.md","hash":"9a517bae6b3a44a40b4b12f820187b8ac5c1ff81","modified":1709725993564},{"_id":"source/_posts/cmake/2022-03-13-cmake find_package.md","hash":"c73545be664e0add06a6ebd2cdc1b1467ae4f9d7","modified":1709725993564},{"_id":"source/_posts/c++/2022-03-21-git hook clang-format.md","hash":"8ccd9cbf60302ac4751c84343cafdd859e908b97","modified":1709725993564},{"_id":"source/_posts/cmake/2022-03-17-cmake 入门.md","hash":"3ce6fb0884b7766e2770b9a4380bd37c63d61234","modified":1709725993564},{"_id":"source/_posts/cmake/2022-10-23-cmake add_custom_command.md","hash":"b9fca4574bcf46fd678c68939e5a151a25d3948f","modified":1709725993564},{"_id":"source/_posts/cmake/2022-10-24-cmake Importing and Exporting Guide.md","hash":"4fe9e1280b0ce5e7c14215a84bc9c7a7ef4538f8","modified":1709725993564},{"_id":"source/_posts/hls/2022-10-12-MPEG-TS 格式分析.md","hash":"3090a4f1fde93aa15311310c4f34fdcb2f0b7a1d","modified":1709725993566},{"_id":"source/_posts/cmake/2022-10-25 Clion Google sannitizers.md ","hash":"72f008c99508975fe3457cb8e021634b5b715812","modified":1709725993565},{"_id":"source/_posts/ffmpeg/2022-03-09-使用Xcode调试ffmpeg.md","hash":"a56c1dcfe60017101ab7726debbc6d1ec7b3b57f","modified":1709725993565},{"_id":"source/_posts/hls/2022-10-13-HLS-介绍.md","hash":"b18f4ac14db7525c7b5a953ed6e9a8bb6ab438c6","modified":1709725993567},{"_id":"source/_posts/ffmpeg/2022-03-09-如何使用vscode在macOS平台调试ffmpeg.md","hash":"17f04ffad678bba21e0d1735416f9b03a45e4824","modified":1709725993565},{"_id":"source/_posts/ffmpeg/2022-03-11-ffmpeg example 学习 2.md","hash":"f852558147139ce1a375ea3d39d73386131c873a","modified":1709725993565},{"_id":"source/_posts/ffmpeg/2022-03-12-ffmpeg example 学习 3.md","hash":"7e1fb6ca21232be54ad8392150b155e52d6b3027","modified":1709725993565},{"_id":"source/_posts/ffmpeg/2022-03-13-ffmpeg+nginx+rtmp搭建推流服务器.md","hash":"46285cafb0a086a09581141c799a8788b21ef13d","modified":1709725993565},{"_id":"source/_posts/ffmpeg/2022-03-10-ffmpeg example 学习 1.md","hash":"2d5872891c5a0db3ea14dd5b9820fabd178dd17c","modified":1709725993565},{"_id":"source/_posts/ffmpeg/2022-03-14-ffmpeg example 学习 5.md","hash":"9c4a5fdef9cb98680f9560cd531c5e892e0d6f24","modified":1709725993565},{"_id":"source/_posts/ffmpeg/2022-03-14-ffplay-packet queue  分析.md","hash":"b745b0c5b58885be63646dab1f2d8ba67f402674","modified":1709725993566},{"_id":"source/_posts/ffmpeg/2022-03-13-ffmpeg example 学习 4.md","hash":"ef3c745d4e7349975f55a05d4fa2ee2f78ccb9bd","modified":1709725993565},{"_id":"source/_posts/ffmpeg/2022-03-15-ffmpeg filters.md","hash":"92cef37691508bee7bd0befb8e919e626c9d8d92","modified":1709780852474},{"_id":"source/_posts/ffmpeg/2022-03-15-ffplay-frame queue 分析.md","hash":"f61a9e1c7f7a8042bad2e0389391108b5536711d","modified":1709725993566},{"_id":"source/_posts/ffmpeg/2022-03-26-mac上通过 doxygen + graphviz生成函数调用图.md","hash":"6fd071539d7c17a0397b8126db9dbec6b35cf3fb","modified":1709725993566},{"_id":"source/_posts/ffmpeg/2022-03-27-ffplay 代码结构与总结.md","hash":"7a4f17f822e358fe49ca136b53ae632c58783366","modified":1709725993566},{"_id":"source/_posts/ffmpeg/2022-03-22-ffplay video_thread 分析.md","hash":"b1b84a01c1affb3cc5082b23be8ec48922ba7786","modified":1709725993566},{"_id":"source/_posts/ffmpeg/2022-09-23-ffmpeg-命令.md","hash":"882b34cc6e795fb6ed356f3fa3b52b9531fcff67","modified":1709725993566},{"_id":"source/_posts/ios/2023-03-14-使用Apple Configurator 获取 ipa 文件.md","hash":"3fea58ad4f5068286ed7e416303754a21f08ff16","modified":1709725993567},{"_id":"source/_posts/lldb/2023-05-23-GDB Examining Memory.md","hash":"135a579e51c14bcd37640e0f18275c85daf4614c","modified":1709725993567},{"_id":"source/_posts/ffmpeg/2022-03-20-ffplay read_thread 分析.md","hash":"03974761fa3a37f417260c5ba5dc4c2c0d424c5e","modified":1709725993566},{"_id":"source/_posts/webrtc/2023-05-09-webrtc-调试.md","hash":"b6a75607f88f8c52858d229be1eda36891ac7cb5","modified":1709725993567},{"_id":"source/_posts/ios/2022-11-26-ios keychain 总结.md","hash":"f3ec9863c7591dea13efd7b06cc4856a49836f94","modified":1709725993567},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1709726012845},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1709726012828},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1709726012827},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1709726012828},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"c640b57695b7b6002399711f1a7708b0f6c05b84","modified":1709726012836},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1709726012828},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"ff9b0e1fb9dba665af2f1e4a577f8cb9e840464b","modified":1709726012828},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"759d78d97cfe364a4bcf0b5cd2d3505967674276","modified":1709726012828},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1709726012828},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1709726012828},{"_id":"node_modules/hexo-theme-fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":1709726012828},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1709726012829},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1709726012829},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1709726012829},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1709726012835},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1709726012835},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"2253e1bc61694b3bdc5e434ea2660d13d941b50e","modified":1709726012829},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1709726012835},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1709726012835},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1709726012835},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1709726012835},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1709726012835},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1709726012836},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"33c3317cdcee062789de2336dd8d0cc7f86d3650","modified":1709726012835},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1709726012836},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1709726012829},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1709726012829},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1709726012831},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1709726012832},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1709726012829},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"9bf0d357a607a282f3b9cb04525a4df0cc2a8b76","modified":1709726012836},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1709726012836},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":1709726012832},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1709726012832},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1709726012837},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1709726012829},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1709726012837},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1709726012832},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":1709726012837},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":1709726012838},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"82bb06686158ebe160a631c79f156cd4fde35656","modified":1709726012837},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":1709726012837},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1709726012838},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1709726012838},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":1709726012838},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1709726012838},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1709726012832},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1709726012838},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1709726012835},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1709726012838},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"966689d7c5e4320008285395fbaa2751f6209be5","modified":1709726012839},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1709726012838},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"4d48c424e47ff9a17a563167ea5f480890267adf","modified":1709726012839},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1709726012834},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1709726012839},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1709726012838},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/fold.js","hash":"73e4fd12ce3e47981479391ed354b7d9d3279f70","modified":1709726012839},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"0857aa86db2a711ae5c77218a9e3fa686d0e87b1","modified":1709726012839},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1709726012839},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1709726012839},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":1709726012839},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1709726012840},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1709726012839},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1709726012840},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1709726012840},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1709726012840},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1709726012846},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1709726012846},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1709726012846},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1709726012846},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1709726012846},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/crypto.js","hash":"ae4ad8a188ef5b3fa6818b01629fc962b3de8551","modified":1709726012840},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1709726012847},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1709726012848},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1709726012847},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1709726012848},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"c5939d14065d38c86e16d1642e154dde5a23e830","modified":1709726012848},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1709726012847},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1709726012848},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1709726012849},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1709726012830},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1709726012848},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1709726012848},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"5891534506b959a2f559f29e122baa3eb9159d93","modified":1709726012848},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1709726012830},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":1709726012830},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1709726012830},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1709726012831},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1709726012848},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1709726012831},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1709726012831},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":1709726012831},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1709726012831},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1709726012831},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1709726012831},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1709726012831},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1709726012832},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1709726012832},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1709726012832},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"37d750428772d7c71ba36ce0c2540780d90fadea","modified":1709726012832},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"4f68c80bd1395e2f6d11e373116e54de11cb62e8","modified":1709726012833},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1709726012833},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1709726012833},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1709726012833},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1709726012833},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":1709726012833},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1709726012833},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":1709726012833},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1709726012833},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":1709726012834},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/moment.ejs","hash":"4ff3fb1b60ccc95a0af3bbdbd0757fedefc088b5","modified":1709726012833},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1709726012834},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"529f3069742b3d338c769ba2d836e7f3c342a09d","modified":1709726012834},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":1709726012834},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"c19ac8050b82c3676b0332a56099ccfcc36d9d52","modified":1709726012836},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1709726012834},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1709726012834},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1709726012836},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"bd8376e1cf7892dc2daa58f2f443574be559fdbf","modified":1709726012836},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"a5fe1deccb73b5f578797dbb11038efc15f63ce8","modified":1709726012836},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1709726012837},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1709726012837},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1709726012834},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1709726012837},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1709726012841},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1709726012840},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1709726012845},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1709726012834},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1709726012845},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1709726012841},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1709726012841},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1709726012843},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1709726012845},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":1709726012843},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1709726012844},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1709726012845},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1709726012843},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"85492ef64d7e5f70f0f7e46d570bbc911e686d7e","modified":1709726012843},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1709726012843},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"cd432a6411ccac7df47e6a300fb1a872cfc763e7","modified":1709726012845},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1709726012844},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"c96d36aa8fe20f0c3c1a29ee2473cd8064b10f73","modified":1709726012845},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1709726012845},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1709726012843},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"25fb6fa4c783b847c632584c49a7e1593cdb2f5d","modified":1709726012844},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1709726012844},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1709726012844},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1709726012841},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1709726012841},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1709726012841},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1709726012841},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1709726012842},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1709726012842},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"c4459248c66ea1326feed021179b847ae91d465f","modified":1709726012842},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1709726012842},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1709726012842},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1709726012842},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1709726012842},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1709726012842},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1709726012842},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1709726012843},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1709726012843},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1709726012843},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1709726012847},{"_id":"public/local-search.xml","hash":"8094c79f3321f638b5d950c1afe3f115679466c6","modified":1709783088627},{"_id":"public/about/index.html","hash":"6aec2980bd8c6f3ecb1fabdae7e8a2f24858b473","modified":1709783088627},{"_id":"public/archives/index.html","hash":"fa64bff2a7081d7c3aadc794533fcf36eade6bbc","modified":1709783088627},{"_id":"public/archives/page/2/index.html","hash":"c0f6939901a2b2325ec7c4e00134cfe40aab61c8","modified":1709783088627},{"_id":"public/archives/page/3/index.html","hash":"4102a3b47370977a3a5ebf05ca81ae5c0c90f84e","modified":1709783088627},{"_id":"public/archives/page/4/index.html","hash":"5ec31b8c32c8f451e389704894e874489b183fd7","modified":1709783088627},{"_id":"public/archives/page/5/index.html","hash":"8dff3069fda7c25fa20c434190f268eaf7fe46d8","modified":1709783088627},{"_id":"public/archives/2022/index.html","hash":"9c484bc00fc698714de75ad4b5ddea27904b9e4a","modified":1709783088627},{"_id":"public/archives/2022/page/2/index.html","hash":"fa4f17ecfa59b1ff605f0efd830897324af9901b","modified":1709783088627},{"_id":"public/archives/2022/page/3/index.html","hash":"aeb5d397c1ebe6c8ea472f90b5c0e8636e8fe289","modified":1709783088627},{"_id":"public/archives/2022/page/4/index.html","hash":"9d6143ad9b0099a25107e06c1b6938fef7a98a91","modified":1709783088627},{"_id":"public/archives/2022/02/index.html","hash":"23537ca8c4c8596424d564c6a4690add42ac196e","modified":1709783088627},{"_id":"public/archives/2022/03/index.html","hash":"f3bff451dba0047459daf2c60c9efb6645665486","modified":1709783088627},{"_id":"public/archives/2022/03/page/2/index.html","hash":"86c99c79276b0e90ad9fe8b04d3fcdc0cafd0273","modified":1709783088627},{"_id":"public/archives/2022/05/index.html","hash":"a4aaae5c1125d3e7a7b356e41ad69ee6ca3ba768","modified":1709783088627},{"_id":"public/archives/2022/09/index.html","hash":"6faf0bad4789dafb5efaff61252fab373f4542bc","modified":1709783088627},{"_id":"public/archives/2022/10/index.html","hash":"e5bf42fb8530f857565aa52c02d467be74906e82","modified":1709783088627},{"_id":"public/archives/2022/11/index.html","hash":"85989bccf35ea989bb5a52b562482f33954551f3","modified":1709783088627},{"_id":"public/archives/2022/12/index.html","hash":"0dfaf171b4d1fba4369d95dbb37e0af9bd9f8c6f","modified":1709783088627},{"_id":"public/archives/2023/index.html","hash":"9a6175cda42242bf5445a875709bd44e3d3e2b22","modified":1709783088627},{"_id":"public/archives/2023/03/index.html","hash":"a4e7f2f89b061ed4bfe9ec01bb59cb5dd8e7678d","modified":1709783088627},{"_id":"public/archives/2023/05/index.html","hash":"3e0a44261a11a2e42e2a91cc2db0d015ffb6ef0a","modified":1709783088627},{"_id":"public/archives/2023/06/index.html","hash":"bded11d95900e19f905a37130ce92e15959fe4e6","modified":1709783088627},{"_id":"public/tags/Shell/index.html","hash":"14a952c112dd1ef095fed6fad0d68c68f26a6287","modified":1709783088627},{"_id":"public/tags/Shell/page/2/index.html","hash":"63365e2e4625769aec2ce72f4fea81042d91b247","modified":1709783088627},{"_id":"public/tags/ruby/index.html","hash":"f441d6cde83f0614d40224a93cdd6ab266c39fd2","modified":1709783088627},{"_id":"public/tags/shell/index.html","hash":"d6a20592cfd8b2818eb390e5d305ec51f5dfa09a","modified":1709783088627},{"_id":"public/tags/aac/index.html","hash":"41e2764aedce57c163307dcd340d1dfe8b12fa7c","modified":1709783088627},{"_id":"public/tags/c/index.html","hash":"1b29e4fbe2fe2756be4c6b3b39d2e08abb871b39","modified":1709783088627},{"_id":"public/tags/cmake/index.html","hash":"1e7404f21ba9a89f8b67ffe36b317295539ae902","modified":1709783088627},{"_id":"public/tags/hls/index.html","hash":"8076b0a40ebafe631d787517ffe88c0233430e4c","modified":1709783088627},{"_id":"public/tags/hls-m3u8/index.html","hash":"21caccf906930d4b04d9a8da2667ea4db7bcf67e","modified":1709783088627},{"_id":"public/tags/ffmpeg/index.html","hash":"a45fe17dcb49974619a399ea3ab30ef24a0f641d","modified":1709783088627},{"_id":"public/tags/ffmpeg/page/2/index.html","hash":"152c5ebf7d22b880de64891c62a9c450f0291804","modified":1709783088627},{"_id":"public/tags/iOS/index.html","hash":"5d3d2160c6c1b0c5910137a6d665cd78de1415e5","modified":1709783088627},{"_id":"public/tags/lldb/index.html","hash":"146801e27d74f5c5ce4678c43828bdb325dba008","modified":1709783088627},{"_id":"public/tags/webrtc/index.html","hash":"c08b97b0ebee2ad67f306e2e5759a1364473bd61","modified":1709783088627},{"_id":"public/tags/index.html","hash":"77e3b3538e369aafb7c30797fde2cd45039db242","modified":1709783088627},{"_id":"public/404.html","hash":"f391ef590740e9d66adf4435162e98d944a6869e","modified":1709783088627},{"_id":"public/categories/index.html","hash":"cdd383554105fc654b376c013ea1f05c0eb40b44","modified":1709783088627},{"_id":"public/2023/06/09/c++/2023-06-09-位域 高低位/index.html","hash":"4cd4a7b01c3678b9790a247eb86069c837442c26","modified":1709783088627},{"_id":"public/2023/05/23/lldb/2023-05-23-GDB Examining Memory/index.html","hash":"4553f8be1c1b652e0b4c0ad4ff4ec103540c9d36","modified":1709783088627},{"_id":"public/2023/05/17/Shell/2023-05-17-oh my zsh 展示路径/index.html","hash":"3f08a62c38d39478d9399bfbefbc6ed828252031","modified":1709783088627},{"_id":"public/2023/05/09/webrtc/2023-05-09-webrtc-调试/index.html","hash":"296dd42b1041ba343617870adf7757907d9d8b77","modified":1709783088627},{"_id":"public/2023/03/14/ios/2023-03-14-使用Apple Configurator 获取 ipa 文件/index.html","hash":"bd201a9de4d315e4e2e5c95daf381c1900c9817f","modified":1709783088627},{"_id":"public/2023/03/07/2023-03-07-open-your-terminal-from-xcode/index.html","hash":"4eea678b78792beb3ca114d1b53f6cc54fdb39f7","modified":1709783088627},{"_id":"public/2022/12/21/2022-12-21-rbenv/index.html","hash":"87a18cec51b25b0c499f092427462c1a8f32391e","modified":1709783088627},{"_id":"public/2022/11/16/Shell/2022-11-16-命令行重启iPhone/index.html","hash":"30ce5f50825b23c3ac0a4dce0691f3dacac20791","modified":1709783088627},{"_id":"public/2022/11/26/ios/2022-11-26-ios keychain 总结/index.html","hash":"479309c544d50d43aa5784947d13771a0a3edf0e","modified":1709783088627},{"_id":"public/2022/10/29/c++/2022-10-29-Xcode 配置 clang-format 格式化 c++ 代码/index.html","hash":"62f540941f91f4625e4c933a44a9e669dc60775c","modified":1709783088627},{"_id":"public/2022/10/24/cmake/2022-10-24-cmake Importing and Exporting Guide/index.html","hash":"ea714e91cf83161e0ecb96c84e6787e27c1a5159","modified":1709783088627},{"_id":"public/2022/10/23/cmake/2022-10-23-cmake add_custom_command/index.html","hash":"b32b52b703c6ccf6e6c3177940f797cc0b2bd7da","modified":1709783088627},{"_id":"public/2022/10/13/hls/2022-10-13-HLS-介绍/index.html","hash":"f013514c85a73f0b4a815d41bc67117e3a2c7409","modified":1709783088627},{"_id":"public/2022/10/12/hls/2022-10-12-MPEG-TS 格式分析/index.html","hash":"2d07f662f17a26600062dcff9c62cb9525b21556","modified":1709783088627},{"_id":"public/2022/09/23/aac/2022-09-23-aac-adts/index.html","hash":"ef86a488f023dc2861898ebb319aab558665958f","modified":1709783088627},{"_id":"public/2022/09/23/aac/2022-09-23-fdk-aac/index.html","hash":"89b16a5400988b0c48ddcc640aa434b5210dd64d","modified":1709783088627},{"_id":"public/2022/09/23/ffmpeg/2022-09-23-ffmpeg-命令/index.html","hash":"f752aa0c41ea1455ee6cb64642aa3d5641e47924","modified":1709783088627},{"_id":"public/2022/05/11/2022-05-11-命令行修改 xcode pbxproj 文件/index.html","hash":"5a1aa0c6757a85b83f18b12f9b4af8945802d841","modified":1709783088627},{"_id":"public/2022/03/27/ffmpeg/2022-03-27-ffplay 代码结构与总结/index.html","hash":"a7ef87e6bd7054eddeb141268539726304487807","modified":1709783088627},{"_id":"public/2022/03/26/ffmpeg/2022-03-26-mac上通过 doxygen + graphviz生成函数调用图/index.html","hash":"df0bffde46d6ea25e57843cbeb9c349d7298ab6c","modified":1709783088627},{"_id":"public/2022/03/22/ffmpeg/2022-03-22-ffplay video_thread 分析/index.html","hash":"77f0e38fc59fc6d49f603df1ebb5b290b6dc744c","modified":1709783088627},{"_id":"public/2022/03/21/c++/2022-03-21-git hook clang-format/index.html","hash":"d8b8280b993f8419d35f1af723326e9c40cd50c4","modified":1709783088627},{"_id":"public/2022/03/20/ffmpeg/2022-03-20-ffplay read_thread 分析/index.html","hash":"5a8b7f112431996f2d712ca8fee130d2ea07cd40","modified":1709783088627},{"_id":"public/2022/03/19/c++/2022-03-19-pragma once 用法总结/index.html","hash":"5b204bc33c9688dcd8e353d6db7ec4b52e7cd0c3","modified":1709783088627},{"_id":"public/2022/03/17/cmake/2022-03-17-cmake 入门/index.html","hash":"33bed278cfa32ab684492b7507ed096a347cbf18","modified":1709783088627},{"_id":"public/2022/03/15/ffmpeg/2022-03-15-ffmpeg filters/index.html","hash":"2a1a9c3aa2be3bc84bcbe2928fe5b938ba54eef9","modified":1709783088627},{"_id":"public/2022/03/15/ffmpeg/2022-03-15-ffplay-frame queue 分析/index.html","hash":"5099b6ae3c1047c2918b4c9ed025d75ce85f5d61","modified":1709783088627},{"_id":"public/2022/03/14/ffmpeg/2022-03-14-ffplay-packet queue  分析/index.html","hash":"28c98c44e503f84e5f01d77b3ac40967f1564d13","modified":1709783088627},{"_id":"public/2022/03/13/cmake/2022-03-13-cmake find_package/index.html","hash":"fdec068f01a1c9e465975f9bfc27c76cc35cfbef","modified":1709783088627},{"_id":"public/2022/03/13/ffmpeg/2022-03-13-ffmpeg example 学习 4/index.html","hash":"bede70e9bc8de8934da4c138ca0ed806b51f3bbb","modified":1709783088627},{"_id":"public/2022/03/13/ffmpeg/2022-03-13-ffmpeg+nginx+rtmp搭建推流服务器/index.html","hash":"1b124c7bace9c0bb5a683bf4dd1371d81b686f02","modified":1709783088627},{"_id":"public/2022/03/13/ffmpeg/2022-03-14-ffmpeg example 学习 5/index.html","hash":"6cc3566edc38eb90bd61858acbeb67655d1ff466","modified":1709783088627},{"_id":"public/2022/03/12/ffmpeg/2022-03-12-ffmpeg example 学习 3/index.html","hash":"2b9c31d783da4da08e2b822fe2c355d8abfe5caf","modified":1709783088627},{"_id":"public/2022/03/11/ffmpeg/2022-03-11-ffmpeg example 学习 2/index.html","hash":"a09cfee83439f28d62012501f9b6bf2552ffd4bd","modified":1709783088627},{"_id":"public/2022/03/10/ffmpeg/2022-03-10-ffmpeg example 学习 1/index.html","hash":"0d1bd7762b6a08772b6c281a5e228decaaeeabf9","modified":1709783088627},{"_id":"public/2022/03/09/ffmpeg/2022-03-09-使用Xcode调试ffmpeg/index.html","hash":"2db6ec6f331ff110f360b772ea7ea3bf7af69e00","modified":1709783088627},{"_id":"public/2022/03/09/ffmpeg/2022-03-09-如何使用vscode在macOS平台调试ffmpeg/index.html","hash":"040622548bd69196d44534494f8e6725692e39d5","modified":1709783088627},{"_id":"public/2022/02/25/Shell/2022-02-25-Shell 变量/index.html","hash":"e30c76b0ebb709c58282dc1e59d9b9be9a84c444","modified":1709783088627},{"_id":"public/2022/02/25/Shell/2022-02-25-Shell 数组/index.html","hash":"359ebceacfcbf081d1959220291684be398455ee","modified":1709783088627},{"_id":"public/2022/02/25/Shell/2022-02-25-shell 函数/index.html","hash":"daf99695280a325f9a5dc7bf0b68184b0a9f7469","modified":1709783088627},{"_id":"public/2022/02/25/Shell/2022-02-25-shell 循环语句/index.html","hash":"3dcab65d84fcd9e740d30eefabe8610f064f0eea","modified":1709783088627},{"_id":"public/2022/02/25/Shell/2022-02-25-shell 条件语句/index.html","hash":"e7d007f459a09ae489f17abe614ab1222bdb1f48","modified":1709783088627},{"_id":"public/2022/02/25/Shell/2022-02-25-shell 特殊变量/index.html","hash":"672ccaa841827d01f631cf072e22e232b1b39230","modified":1709783088627},{"_id":"public/2022/02/25/Shell/2022-02-25-shell 运算符/index.html","hash":"9998ca5fd0ce1177ed28f20794adc9c07bfd23fe","modified":1709783088627},{"_id":"public/2022/02/25/Shell/2022-03-09-shell 脚本，带名字的参数/index.html","hash":"521c961fe7a29060228eb7bb093ab9a79f6b51ac","modified":1709783088627},{"_id":"public/2022/02/24/Shell/常用的shell语句/index.html","hash":"55b9e10a0915c7fc9d9ad377be089fe2d0e9ec44","modified":1709783088627},{"_id":"public/index.html","hash":"acfcb29bd5b63236c0de3e5d1b72cf9339c67a05","modified":1709783088627},{"_id":"public/page/3/index.html","hash":"e974fbdcb9f5b5cfba62e32199c8fce5164b0a80","modified":1709783088627},{"_id":"public/page/2/index.html","hash":"7c40e508a92d121f90172383502d0c3490e140ff","modified":1709783088627},{"_id":"public/page/4/index.html","hash":"1033a50a387d28ec6642ccd741c5f0777fb540c7","modified":1709783088627},{"_id":"public/page/5/index.html","hash":"d7ce96e1a1fb665965959733cfad4c5629967605","modified":1709783088627},{"_id":"public/links/index.html","hash":"9aef625b1ad747388521fa1ac55f848533dfd6b2","modified":1709783088627},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1709783088627},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1709783088627},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1709783088627},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1709783088627},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1709783088627},{"_id":"public/css/highlight-dark.css","hash":"902294bada4323c0f51502d67cba8c3a0298952f","modified":1709783088627},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1709783088627},{"_id":"public/css/highlight.css","hash":"04d4ddbb5e1d1007447c2fe293ee05aae9b9563e","modified":1709783088627},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1709783088627},{"_id":"public/js/color-schema.js","hash":"c5939d14065d38c86e16d1642e154dde5a23e830","modified":1709783088627},{"_id":"public/js/events.js","hash":"5891534506b959a2f559f29e122baa3eb9159d93","modified":1709783088627},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1709783088627},{"_id":"public/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1709783088627},{"_id":"public/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1709783088627},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1709783088627},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1709783088627},{"_id":"public/css/main.css","hash":"7d7590cfe0261084ad357d5f51cb14d13db826d8","modified":1709783088627},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1709783088627}],"Category":[],"Data":[],"Page":[{"title":"about","layout":"about","_content":"\n一些开发中的笔记！","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\n---\n\n一些开发中的笔记！","date":"2024-03-06T11:53:33.622Z","updated":"2024-03-06T11:53:33.622Z","path":"about/index.html","comments":1,"_id":"cltgopen00000qywhdddz4x45","content":"<p>一些开发中的笔记！</p>\n","excerpt":"","more":"<p>一些开发中的笔记！</p>\n"}],"Post":[{"layout":"post","title":"通过脚本修改xcode pbxproj文件","date":"2022-05-10T16:00:00.000Z","_content":"\n\n\n## 分析 xcode pbxproj 文件格式\n\n 创建一个新的iOS工程`demo`, 进入工程目录, 找到`project.pbxproj`。\n\n```\n➜  demo git:(main) ✗ ls\ndemo           demo.xcodeproj demoTests      demoUITests\n➜  demo git:(main) ✗ cd demo.xcodeproj\n➜  demo.xcodeproj git:(main) ✗ ls\nproject.pbxproj     project.xcworkspace xcuserdata\n```\n\n通过code打开看看文件内容。\n\n> The Xcode project file is an old-style plist (Next style) based on braces to delimit the hierarchy. The file begins with an explicit encoding information, usually the UTF-8 one.\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521761658021652176165259.png)\n\n`project.pbxproj`文件格式是旧式的plist，通过`plutil`将project.pbxproj转换为json\n\n```\nplutil -convert json project.pbxproj\n```\n\n通过可视化工具分析json内容\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521715227351652171521885.png)\n\nrootObject 对应的value是24位16进制的UUID。\n\n展开objects 找到`FEF5F49A2829212600E85303`对应的object\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521733421961652173342151.png)\n\nbuildConfigurationList 保存了配置信息，对应的UUID为 FEF5F49D2829212600E85303\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521737007771652173700399.png)\n\nbuildConfigurations是个数组，我们分析第一个。找到FEF5F4CF2829212700E85303对应的object\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521738897811652173889220.png)\n\n展开buildSettings看一看\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521739817831652173981353.png)\n\n在xcode-build settings中可以找到对应的设置。\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521742047871652174204307.png)\n\n说明：\n\n1. objects数组包含了所有object 对象的信息， 包含rootObject， rootObject 的isa 是`PBXProject`\n\n2. 通过rootObject，根据UUID在objects数组找到对应的object, 可以构建一棵树，这棵树描述了xcode工程的所有配置信息。\n\n## 通过脚本修改pbxproj文件的方法\n\n1. 通过`plutil`将pbxproj转换为json或xml， 编辑转换后的json或者xml。虽然文件内容会被转换为json或者xml， 但是xcode 依然可以加载修改后的pbxproj文件。 通过xcode 修改任何配置信息后，pbxproj会被重新改写为旧式的plist文件格式。\n\n2. 通过现成的一些工具\n   \n   - [GitHub - CocoaPods/Xcodeproj: Create and modify Xcode projects from Ruby.](https://github.com/CocoaPods/Xcodeproj)\n   \n   - [GitHub - tuist/XcodeProj: 📝 Read, update and write your Xcode projects](https://github.com/tuist/XcodeProj)\n   \n   - [GitHub - kronenthaler/mod-pbxproj: A python module to manipulate XCode projects](https://github.com/kronenthaler/mod-pbxproj)\n   \n   - [GitHub - alunny/node-xcode: tools and utilities for working with xcode/ios projects](https://github.com/alunny/node-xcode)\n   \n   - \n\n### [Xcodeproj](https://github.com/CocoaPods/Xcodeproj) 使用介绍\n\n1. 安装\n   \n   ```\n   gem install xcodeproj\n   ```\n\n2. 写ruby脚本，不会的可以去学一下ruby， 入门很很简单\n   \n   ```\n   require 'xcodeproj'\n   project_path = '/your_path/your_project.xcodeproj'\n   project = Xcodeproj::Project.open(project_path)\n   project.targets.each do |target|\n     target.build_configurations.each do |config|\n       config.build_settings['MY_CUSTOM_FLAG'] ||= 'TRUE'\n     end\n   end\n   project.save\n   ```\n\n参考：\n\n[Let's Talk About project.pbxproj](http://yulingtianxia.com/blog/2016/09/28/Let-s-Talk-About-project-pbxproj/)\n\n[Xcode Project File Format](http://www.monobjc.net/xcode-project-file-format.html)\n","source":"_posts/2022-05-11-命令行修改 xcode pbxproj 文件.md","raw":"---\n\nlayout: post\ntitle: \"通过脚本修改xcode pbxproj文件\"\ndate: 2022-05-11 \ntag: Shell\n\n---\n\n\n\n## 分析 xcode pbxproj 文件格式\n\n 创建一个新的iOS工程`demo`, 进入工程目录, 找到`project.pbxproj`。\n\n```\n➜  demo git:(main) ✗ ls\ndemo           demo.xcodeproj demoTests      demoUITests\n➜  demo git:(main) ✗ cd demo.xcodeproj\n➜  demo.xcodeproj git:(main) ✗ ls\nproject.pbxproj     project.xcworkspace xcuserdata\n```\n\n通过code打开看看文件内容。\n\n> The Xcode project file is an old-style plist (Next style) based on braces to delimit the hierarchy. The file begins with an explicit encoding information, usually the UTF-8 one.\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521761658021652176165259.png)\n\n`project.pbxproj`文件格式是旧式的plist，通过`plutil`将project.pbxproj转换为json\n\n```\nplutil -convert json project.pbxproj\n```\n\n通过可视化工具分析json内容\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521715227351652171521885.png)\n\nrootObject 对应的value是24位16进制的UUID。\n\n展开objects 找到`FEF5F49A2829212600E85303`对应的object\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521733421961652173342151.png)\n\nbuildConfigurationList 保存了配置信息，对应的UUID为 FEF5F49D2829212600E85303\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521737007771652173700399.png)\n\nbuildConfigurations是个数组，我们分析第一个。找到FEF5F4CF2829212700E85303对应的object\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521738897811652173889220.png)\n\n展开buildSettings看一看\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521739817831652173981353.png)\n\n在xcode-build settings中可以找到对应的设置。\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521742047871652174204307.png)\n\n说明：\n\n1. objects数组包含了所有object 对象的信息， 包含rootObject， rootObject 的isa 是`PBXProject`\n\n2. 通过rootObject，根据UUID在objects数组找到对应的object, 可以构建一棵树，这棵树描述了xcode工程的所有配置信息。\n\n## 通过脚本修改pbxproj文件的方法\n\n1. 通过`plutil`将pbxproj转换为json或xml， 编辑转换后的json或者xml。虽然文件内容会被转换为json或者xml， 但是xcode 依然可以加载修改后的pbxproj文件。 通过xcode 修改任何配置信息后，pbxproj会被重新改写为旧式的plist文件格式。\n\n2. 通过现成的一些工具\n   \n   - [GitHub - CocoaPods/Xcodeproj: Create and modify Xcode projects from Ruby.](https://github.com/CocoaPods/Xcodeproj)\n   \n   - [GitHub - tuist/XcodeProj: 📝 Read, update and write your Xcode projects](https://github.com/tuist/XcodeProj)\n   \n   - [GitHub - kronenthaler/mod-pbxproj: A python module to manipulate XCode projects](https://github.com/kronenthaler/mod-pbxproj)\n   \n   - [GitHub - alunny/node-xcode: tools and utilities for working with xcode/ios projects](https://github.com/alunny/node-xcode)\n   \n   - \n\n### [Xcodeproj](https://github.com/CocoaPods/Xcodeproj) 使用介绍\n\n1. 安装\n   \n   ```\n   gem install xcodeproj\n   ```\n\n2. 写ruby脚本，不会的可以去学一下ruby， 入门很很简单\n   \n   ```\n   require 'xcodeproj'\n   project_path = '/your_path/your_project.xcodeproj'\n   project = Xcodeproj::Project.open(project_path)\n   project.targets.each do |target|\n     target.build_configurations.each do |config|\n       config.build_settings['MY_CUSTOM_FLAG'] ||= 'TRUE'\n     end\n   end\n   project.save\n   ```\n\n参考：\n\n[Let's Talk About project.pbxproj](http://yulingtianxia.com/blog/2016/09/28/Let-s-Talk-About-project-pbxproj/)\n\n[Xcode Project File Format](http://www.monobjc.net/xcode-project-file-format.html)\n","slug":"2022-05-11-命令行修改 xcode pbxproj 文件","published":1,"updated":"2024-03-06T11:53:13.562Z","comments":1,"photos":[],"_id":"cltgopen20001qywh0n11gbkl","content":"<h2 id=\"分析-xcode-pbxproj-文件格式\"><a href=\"#分析-xcode-pbxproj-文件格式\" class=\"headerlink\" title=\"分析 xcode pbxproj 文件格式\"></a>分析 xcode pbxproj 文件格式</h2><p> 创建一个新的iOS工程<code>demo</code>, 进入工程目录, 找到<code>project.pbxproj</code>。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\">➜  <span class=\"hljs-built_in\">demo</span> git:(main) ✗ ls<br><span class=\"hljs-built_in\">demo</span>           <span class=\"hljs-built_in\">demo</span>.xcodeproj demoTests      demoUITests<br>➜  <span class=\"hljs-built_in\">demo</span> git:(main) ✗ cd <span class=\"hljs-built_in\">demo</span>.xcodeproj<br>➜  <span class=\"hljs-built_in\">demo</span>.xcodeproj git:(main) ✗ ls<br>project.pbxproj     project.xcworkspace xcuserdata<br></code></pre></td></tr></table></figure>\n\n<p>通过code打开看看文件内容。</p>\n<blockquote>\n<p>The Xcode project file is an old-style plist (Next style) based on braces to delimit the hierarchy. The file begins with an explicit encoding information, usually the UTF-8 one.</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521761658021652176165259.png\"></p>\n<p><code>project.pbxproj</code>文件格式是旧式的plist，通过<code>plutil</code>将project.pbxproj转换为json</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">plutil -convert json <span class=\"hljs-keyword\">project</span>.pbxproj<br></code></pre></td></tr></table></figure>\n\n<p>通过可视化工具分析json内容</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521715227351652171521885.png\"></p>\n<p>rootObject 对应的value是24位16进制的UUID。</p>\n<p>展开objects 找到<code>FEF5F49A2829212600E85303</code>对应的object</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521733421961652173342151.png\"></p>\n<p>buildConfigurationList 保存了配置信息，对应的UUID为 FEF5F49D2829212600E85303</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521737007771652173700399.png\"></p>\n<p>buildConfigurations是个数组，我们分析第一个。找到FEF5F4CF2829212700E85303对应的object</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521738897811652173889220.png\"></p>\n<p>展开buildSettings看一看</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521739817831652173981353.png\"></p>\n<p>在xcode-build settings中可以找到对应的设置。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521742047871652174204307.png\"></p>\n<p>说明：</p>\n<ol>\n<li><p>objects数组包含了所有object 对象的信息， 包含rootObject， rootObject 的isa 是<code>PBXProject</code></p>\n</li>\n<li><p>通过rootObject，根据UUID在objects数组找到对应的object, 可以构建一棵树，这棵树描述了xcode工程的所有配置信息。</p>\n</li>\n</ol>\n<h2 id=\"通过脚本修改pbxproj文件的方法\"><a href=\"#通过脚本修改pbxproj文件的方法\" class=\"headerlink\" title=\"通过脚本修改pbxproj文件的方法\"></a>通过脚本修改pbxproj文件的方法</h2><ol>\n<li><p>通过<code>plutil</code>将pbxproj转换为json或xml， 编辑转换后的json或者xml。虽然文件内容会被转换为json或者xml， 但是xcode 依然可以加载修改后的pbxproj文件。 通过xcode 修改任何配置信息后，pbxproj会被重新改写为旧式的plist文件格式。</p>\n</li>\n<li><p>通过现成的一些工具</p>\n<ul>\n<li><p><a href=\"https://github.com/CocoaPods/Xcodeproj\">GitHub - CocoaPods&#x2F;Xcodeproj: Create and modify Xcode projects from Ruby.</a></p>\n</li>\n<li><p><a href=\"https://github.com/tuist/XcodeProj\">GitHub - tuist&#x2F;XcodeProj: 📝 Read, update and write your Xcode projects</a></p>\n</li>\n<li><p><a href=\"https://github.com/kronenthaler/mod-pbxproj\">GitHub - kronenthaler&#x2F;mod-pbxproj: A python module to manipulate XCode projects</a></p>\n</li>\n<li><p><a href=\"https://github.com/alunny/node-xcode\">GitHub - alunny&#x2F;node-xcode: tools and utilities for working with xcode&#x2F;ios projects</a></p>\n</li>\n<li></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Xcodeproj-使用介绍\"><a href=\"#Xcodeproj-使用介绍\" class=\"headerlink\" title=\"Xcodeproj 使用介绍\"></a><a href=\"https://github.com/CocoaPods/Xcodeproj\">Xcodeproj</a> 使用介绍</h3><ol>\n<li><p>安装</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">gem <span class=\"hljs-keyword\">install</span> xcodeproj<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>写ruby脚本，不会的可以去学一下ruby， 入门很很简单</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">require <span class=\"hljs-string\">&#x27;xcodeproj&#x27;</span><br>project_path = <span class=\"hljs-string\">&#x27;/your_path/your_project.xcodeproj&#x27;</span><br><span class=\"hljs-keyword\">project</span> = Xcodeproj::<span class=\"hljs-keyword\">Project</span>.open(project_path)<br><span class=\"hljs-keyword\">project</span>.targets.<span class=\"hljs-keyword\">each</span> <span class=\"hljs-keyword\">do</span> |target|<br>  target.build_configurations.<span class=\"hljs-keyword\">each</span> <span class=\"hljs-keyword\">do</span> |config|<br>    config.build_settings[<span class=\"hljs-string\">&#x27;MY_CUSTOM_FLAG&#x27;</span>] ||= <span class=\"hljs-string\">&#x27;TRUE&#x27;</span><br>  end<br>end<br><span class=\"hljs-keyword\">project</span>.save<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>参考：</p>\n<p><a href=\"http://yulingtianxia.com/blog/2016/09/28/Let-s-Talk-About-project-pbxproj/\">Let’s Talk About project.pbxproj</a></p>\n<p><a href=\"http://www.monobjc.net/xcode-project-file-format.html\">Xcode Project File Format</a></p>\n","excerpt":"","more":"<h2 id=\"分析-xcode-pbxproj-文件格式\"><a href=\"#分析-xcode-pbxproj-文件格式\" class=\"headerlink\" title=\"分析 xcode pbxproj 文件格式\"></a>分析 xcode pbxproj 文件格式</h2><p> 创建一个新的iOS工程<code>demo</code>, 进入工程目录, 找到<code>project.pbxproj</code>。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\">➜  <span class=\"hljs-built_in\">demo</span> git:(main) ✗ ls<br><span class=\"hljs-built_in\">demo</span>           <span class=\"hljs-built_in\">demo</span>.xcodeproj demoTests      demoUITests<br>➜  <span class=\"hljs-built_in\">demo</span> git:(main) ✗ cd <span class=\"hljs-built_in\">demo</span>.xcodeproj<br>➜  <span class=\"hljs-built_in\">demo</span>.xcodeproj git:(main) ✗ ls<br>project.pbxproj     project.xcworkspace xcuserdata<br></code></pre></td></tr></table></figure>\n\n<p>通过code打开看看文件内容。</p>\n<blockquote>\n<p>The Xcode project file is an old-style plist (Next style) based on braces to delimit the hierarchy. The file begins with an explicit encoding information, usually the UTF-8 one.</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521761658021652176165259.png\"></p>\n<p><code>project.pbxproj</code>文件格式是旧式的plist，通过<code>plutil</code>将project.pbxproj转换为json</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">plutil -convert json <span class=\"hljs-keyword\">project</span>.pbxproj<br></code></pre></td></tr></table></figure>\n\n<p>通过可视化工具分析json内容</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521715227351652171521885.png\"></p>\n<p>rootObject 对应的value是24位16进制的UUID。</p>\n<p>展开objects 找到<code>FEF5F49A2829212600E85303</code>对应的object</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521733421961652173342151.png\"></p>\n<p>buildConfigurationList 保存了配置信息，对应的UUID为 FEF5F49D2829212600E85303</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521737007771652173700399.png\"></p>\n<p>buildConfigurations是个数组，我们分析第一个。找到FEF5F4CF2829212700E85303对应的object</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521738897811652173889220.png\"></p>\n<p>展开buildSettings看一看</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521739817831652173981353.png\"></p>\n<p>在xcode-build settings中可以找到对应的设置。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16521742047871652174204307.png\"></p>\n<p>说明：</p>\n<ol>\n<li><p>objects数组包含了所有object 对象的信息， 包含rootObject， rootObject 的isa 是<code>PBXProject</code></p>\n</li>\n<li><p>通过rootObject，根据UUID在objects数组找到对应的object, 可以构建一棵树，这棵树描述了xcode工程的所有配置信息。</p>\n</li>\n</ol>\n<h2 id=\"通过脚本修改pbxproj文件的方法\"><a href=\"#通过脚本修改pbxproj文件的方法\" class=\"headerlink\" title=\"通过脚本修改pbxproj文件的方法\"></a>通过脚本修改pbxproj文件的方法</h2><ol>\n<li><p>通过<code>plutil</code>将pbxproj转换为json或xml， 编辑转换后的json或者xml。虽然文件内容会被转换为json或者xml， 但是xcode 依然可以加载修改后的pbxproj文件。 通过xcode 修改任何配置信息后，pbxproj会被重新改写为旧式的plist文件格式。</p>\n</li>\n<li><p>通过现成的一些工具</p>\n<ul>\n<li><p><a href=\"https://github.com/CocoaPods/Xcodeproj\">GitHub - CocoaPods&#x2F;Xcodeproj: Create and modify Xcode projects from Ruby.</a></p>\n</li>\n<li><p><a href=\"https://github.com/tuist/XcodeProj\">GitHub - tuist&#x2F;XcodeProj: 📝 Read, update and write your Xcode projects</a></p>\n</li>\n<li><p><a href=\"https://github.com/kronenthaler/mod-pbxproj\">GitHub - kronenthaler&#x2F;mod-pbxproj: A python module to manipulate XCode projects</a></p>\n</li>\n<li><p><a href=\"https://github.com/alunny/node-xcode\">GitHub - alunny&#x2F;node-xcode: tools and utilities for working with xcode&#x2F;ios projects</a></p>\n</li>\n<li></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Xcodeproj-使用介绍\"><a href=\"#Xcodeproj-使用介绍\" class=\"headerlink\" title=\"Xcodeproj 使用介绍\"></a><a href=\"https://github.com/CocoaPods/Xcodeproj\">Xcodeproj</a> 使用介绍</h3><ol>\n<li><p>安装</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">gem <span class=\"hljs-keyword\">install</span> xcodeproj<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>写ruby脚本，不会的可以去学一下ruby， 入门很很简单</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">require <span class=\"hljs-string\">&#x27;xcodeproj&#x27;</span><br>project_path = <span class=\"hljs-string\">&#x27;/your_path/your_project.xcodeproj&#x27;</span><br><span class=\"hljs-keyword\">project</span> = Xcodeproj::<span class=\"hljs-keyword\">Project</span>.open(project_path)<br><span class=\"hljs-keyword\">project</span>.targets.<span class=\"hljs-keyword\">each</span> <span class=\"hljs-keyword\">do</span> |target|<br>  target.build_configurations.<span class=\"hljs-keyword\">each</span> <span class=\"hljs-keyword\">do</span> |config|<br>    config.build_settings[<span class=\"hljs-string\">&#x27;MY_CUSTOM_FLAG&#x27;</span>] ||= <span class=\"hljs-string\">&#x27;TRUE&#x27;</span><br>  end<br>end<br><span class=\"hljs-keyword\">project</span>.save<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>参考：</p>\n<p><a href=\"http://yulingtianxia.com/blog/2016/09/28/Let-s-Talk-About-project-pbxproj/\">Let’s Talk About project.pbxproj</a></p>\n<p><a href=\"http://www.monobjc.net/xcode-project-file-format.html\">Xcode Project File Format</a></p>\n"},{"layout":"post","title":"用 rbenv 来安装ruby","date":"2022-12-20T16:00:00.000Z","_content":"\n参考： [rbenv](https://github.com/rbenv/rbenv)\n\n```\n# Install Homebrew\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Install rbenv and ruby-build\nbrew install rbenv\n\n# Set up rbenv integration with your shell\nrbenv init\n\n# Check your installation\ncurl -fsSL https://github.com/rbenv/rbenv-installer/raw/main/bin/rbenv-doctor | bash\n```\n\n配置 .zshrc\n\n```\n# rbenv\neval \"$(rbenv init - zsh)\"\n```\n\nRestart your terminal to apply your changes. Next, you can install the Ruby version you want. Let’s install the latest stable version:\n\n```\nrbenv install 3.0.0\nrbenv global 3.0.0\nruby -v\nruby 3.0.0p0 (2020-12-25 revision 95aff21468)\n```","source":"_posts/2022-12-21-rbenv.md","raw":"---\n\nlayout: post\ntitle: \"用 rbenv 来安装ruby\"\ndate: 2022-12-21 \ntag: ruby\n\n---\n\n参考： [rbenv](https://github.com/rbenv/rbenv)\n\n```\n# Install Homebrew\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Install rbenv and ruby-build\nbrew install rbenv\n\n# Set up rbenv integration with your shell\nrbenv init\n\n# Check your installation\ncurl -fsSL https://github.com/rbenv/rbenv-installer/raw/main/bin/rbenv-doctor | bash\n```\n\n配置 .zshrc\n\n```\n# rbenv\neval \"$(rbenv init - zsh)\"\n```\n\nRestart your terminal to apply your changes. Next, you can install the Ruby version you want. Let’s install the latest stable version:\n\n```\nrbenv install 3.0.0\nrbenv global 3.0.0\nruby -v\nruby 3.0.0p0 (2020-12-25 revision 95aff21468)\n```","slug":"2022-12-21-rbenv","published":1,"updated":"2024-03-06T11:53:13.562Z","comments":1,"photos":[],"_id":"cltgopen30002qywh26c132ej","content":"<p>参考： <a href=\"https://github.com/rbenv/rbenv\">rbenv</a></p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-comment\"># Install Homebrew</span><br><span class=\"hljs-regexp\">/bin/</span>bash -c <span class=\"hljs-string\">&quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</span><br><br><span class=\"hljs-comment\"># Install rbenv and ruby-build</span><br>brew install rbenv<br><br><span class=\"hljs-comment\"># Set up rbenv integration with your shell</span><br>rbenv init<br><br><span class=\"hljs-comment\"># Check your installation</span><br>curl -fsSL https:<span class=\"hljs-regexp\">//gi</span>thub.com<span class=\"hljs-regexp\">/rbenv/</span>rbenv-installer<span class=\"hljs-regexp\">/raw/m</span>ain<span class=\"hljs-regexp\">/bin/</span>rbenv-doctor | bash<br></code></pre></td></tr></table></figure>\n\n<p>配置 .zshrc</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># rbenv</span><br><span class=\"hljs-built_in\">eval</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(rbenv init - zsh)</span>&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>Restart your terminal to apply your changes. Next, you can install the Ruby version you want. Let’s install the latest stable version:</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">rbenv</span> install <span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">rbenv</span> global <span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">ruby</span> -v<br><span class=\"hljs-attribute\">ruby</span> <span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">0</span>p0 (<span class=\"hljs-number\">2020</span>-<span class=\"hljs-number\">12</span>-<span class=\"hljs-number\">25</span> revision <span class=\"hljs-number\">95</span>aff21468)<br></code></pre></td></tr></table></figure>","excerpt":"","more":"<p>参考： <a href=\"https://github.com/rbenv/rbenv\">rbenv</a></p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-comment\"># Install Homebrew</span><br><span class=\"hljs-regexp\">/bin/</span>bash -c <span class=\"hljs-string\">&quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</span><br><br><span class=\"hljs-comment\"># Install rbenv and ruby-build</span><br>brew install rbenv<br><br><span class=\"hljs-comment\"># Set up rbenv integration with your shell</span><br>rbenv init<br><br><span class=\"hljs-comment\"># Check your installation</span><br>curl -fsSL https:<span class=\"hljs-regexp\">//gi</span>thub.com<span class=\"hljs-regexp\">/rbenv/</span>rbenv-installer<span class=\"hljs-regexp\">/raw/m</span>ain<span class=\"hljs-regexp\">/bin/</span>rbenv-doctor | bash<br></code></pre></td></tr></table></figure>\n\n<p>配置 .zshrc</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># rbenv</span><br><span class=\"hljs-built_in\">eval</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(rbenv init - zsh)</span>&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>Restart your terminal to apply your changes. Next, you can install the Ruby version you want. Let’s install the latest stable version:</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">rbenv</span> install <span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">rbenv</span> global <span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">ruby</span> -v<br><span class=\"hljs-attribute\">ruby</span> <span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">0</span>p0 (<span class=\"hljs-number\">2020</span>-<span class=\"hljs-number\">12</span>-<span class=\"hljs-number\">25</span> revision <span class=\"hljs-number\">95</span>aff21468)<br></code></pre></td></tr></table></figure>"},{"layout":"post","title":"open your terminal from xcode","date":"2023-03-06T16:00:00.000Z","_content":"\n参考： [Open your terminal from Xcode](https://blog.eidinger.info/open-your-terminal-from-xcode)\n\n\n实现方式： \n\n添加一个 Xcode Behaviors， 给 behavior 指定一个 shell script， behavior 触发的时候， 执行改脚本以当前目录打开 terminal。\n\n\n\n# 步骤\n\n创建一个 shell 脚本\n\n> open-iterm-from-xcode\n\n```\n#!/bin/sh\ndir=\"$PWD\"\n# remove a potential suffix in case Xcode shows a Swift Package\nsuffix=\"/.swiftpm/xcode\"\ndir=${dir//$suffix/}\nopen -a iterm \"$dir\n```\n\n添加执行权限\n\n```\nchmod +x open-iterm-from-xcode\n```\n\n\n添加 Xcode Behaviors\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16781590158101678159015713.png)\n\n\n打开终端\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16781591208101678159120572.png)\n\n\n也可以使用，快捷键 `cmd + T`\n\n","source":"_posts/2023-03-07-open-your-terminal-from-xcode.md","raw":"---\n\nlayout: post\ntitle: \"open your terminal from xcode\"\ndate: 2023-03-07\ntag: shell\n\n---\n\n参考： [Open your terminal from Xcode](https://blog.eidinger.info/open-your-terminal-from-xcode)\n\n\n实现方式： \n\n添加一个 Xcode Behaviors， 给 behavior 指定一个 shell script， behavior 触发的时候， 执行改脚本以当前目录打开 terminal。\n\n\n\n# 步骤\n\n创建一个 shell 脚本\n\n> open-iterm-from-xcode\n\n```\n#!/bin/sh\ndir=\"$PWD\"\n# remove a potential suffix in case Xcode shows a Swift Package\nsuffix=\"/.swiftpm/xcode\"\ndir=${dir//$suffix/}\nopen -a iterm \"$dir\n```\n\n添加执行权限\n\n```\nchmod +x open-iterm-from-xcode\n```\n\n\n添加 Xcode Behaviors\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16781590158101678159015713.png)\n\n\n打开终端\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16781591208101678159120572.png)\n\n\n也可以使用，快捷键 `cmd + T`\n\n","slug":"2023-03-07-open-your-terminal-from-xcode","published":1,"updated":"2024-03-06T11:53:13.562Z","comments":1,"photos":[],"_id":"cltgopen40004qywhbvseg3wd","content":"<p>参考： <a href=\"https://blog.eidinger.info/open-your-terminal-from-xcode\">Open your terminal from Xcode</a></p>\n<p>实现方式： </p>\n<p>添加一个 Xcode Behaviors， 给 behavior 指定一个 shell script， behavior 触发的时候， 执行改脚本以当前目录打开 terminal。</p>\n<h1 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h1><p>创建一个 shell 脚本</p>\n<blockquote>\n<p>open-iterm-from-xcode</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/sh</span><br><span class=\"hljs-built_in\">dir</span>=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$PWD</span>&quot;</span><br><span class=\"hljs-comment\"># remove a potential suffix in case Xcode shows a Swift Package</span><br>suffix=<span class=\"hljs-string\">&quot;/.swiftpm/xcode&quot;</span><br><span class=\"hljs-built_in\">dir</span>=<span class=\"hljs-variable\">$&#123;dir//$suffix/&#125;</span><br>open -a iterm <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$dir</span></span><br></code></pre></td></tr></table></figure>\n\n<p>添加执行权限</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">chmod +x <span class=\"hljs-built_in\">open</span>-iterm-<span class=\"hljs-built_in\">from</span>-xcode<br></code></pre></td></tr></table></figure>\n\n\n<p>添加 Xcode Behaviors</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16781590158101678159015713.png\"></p>\n<p>打开终端</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16781591208101678159120572.png\"></p>\n<p>也可以使用，快捷键 <code>cmd + T</code></p>\n","excerpt":"","more":"<p>参考： <a href=\"https://blog.eidinger.info/open-your-terminal-from-xcode\">Open your terminal from Xcode</a></p>\n<p>实现方式： </p>\n<p>添加一个 Xcode Behaviors， 给 behavior 指定一个 shell script， behavior 触发的时候， 执行改脚本以当前目录打开 terminal。</p>\n<h1 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h1><p>创建一个 shell 脚本</p>\n<blockquote>\n<p>open-iterm-from-xcode</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/sh</span><br><span class=\"hljs-built_in\">dir</span>=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$PWD</span>&quot;</span><br><span class=\"hljs-comment\"># remove a potential suffix in case Xcode shows a Swift Package</span><br>suffix=<span class=\"hljs-string\">&quot;/.swiftpm/xcode&quot;</span><br><span class=\"hljs-built_in\">dir</span>=<span class=\"hljs-variable\">$&#123;dir//$suffix/&#125;</span><br>open -a iterm <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$dir</span></span><br></code></pre></td></tr></table></figure>\n\n<p>添加执行权限</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">chmod +x <span class=\"hljs-built_in\">open</span>-iterm-<span class=\"hljs-built_in\">from</span>-xcode<br></code></pre></td></tr></table></figure>\n\n\n<p>添加 Xcode Behaviors</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16781590158101678159015713.png\"></p>\n<p>打开终端</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16781591208101678159120572.png\"></p>\n<p>也可以使用，快捷键 <code>cmd + T</code></p>\n"},{"layout":"post","title":"Shell 变量","date":"2022-02-24T16:00:00.000Z","_content":"  \n\n# Shell 变量\n\n## 变量名\n\nThe name of a variable can contain only letters (a to z or A to Z), numbers ( 0 to 9) or the underscore character ( _).\n\nBy convention, Unix shell variables will have their names in UPPERCASE.\n\n合法的变量\n\n```shell\n_ALI\nTOKEN_A\nVAR_1\nVAR_2\n```\n\n非法变量\n\n```shell\n2_VAR\n-VARIABLE\nVAR1-VAR2\nVAR_A!\n```\n\n## 定义变量\n\n```shell\nvariable_name=variable_value\n```\n\n例如：\n\n```shell\nNAME=\"Zara Ali\"\n```\n\nshell 允许变量存你想要的任何值， 例如\n\n```shell\nVAR1=\"Zara Ali\"\nVAR2=100\n```\n\n## 获取变量的值\n\n通过在变量前添加`$`来引用变量\n\n```shell\n#!/bin/sh\n\nNAME=\"Zara Ali\"\necho $NAME\n```\n\n输出\n\n```shell\nZara Ali\n```\n\n## 只读变量\n\n在变量前添加`readonly`将变量标记为只读，只读变量不允许被修改。\n\n```shell\n#!/bin/sh\n\nNAME=\"Zara Ali\"\nreadonly NAME\nNAME=\"Qadiri\"\n```\n\n报错\n\n```shell\nNAME: readonly variable\n```\n\n## 删除一个变量\n\n使用`unset`命令删除一个变量，变量被删除后，无法访问该变量的值。\n\n```shell\nunset variable_name\n```\n\n例如\n\n```shell\n#!/bin/sh\n\nNAME=\"Zara Ali\"\nunset NAME\necho $NAME\n```\n\n\bNAME 被删除， 输出为空。\n\n## 变量类型\n\n- 本地变量\n  \n  - 使用`local`关键字修饰的变量\n  - 只能用在函数内部\n  - 如果与全局变量同名，在函数内部，会屏蔽同名的全局变量\n  - 函数的参数是`local`的\n\n- shell 全局变量\n  \n  - 在 Shell 中定义的变量，默认就是全局变量。\n  - 在函数内部定义的变量，没有用`local`关键字修饰，也是全局变量\n    \n    \n\n- 环境变量\n  \n  - 全局变量只在当前 Shell 进程中有效，对其它 Shell 进程和子进程都无效。如果使用`export`命令将全局变量导出，那么它就在所有的子进程中也有效了，这称为“环境变量”。\n\n在shell 函数中定义的变量也是全局变量\n\n```shell\n#!/bin/bash\n#定义函数\nfunction func(){\n    a=99\n}\n#调用函数\nfunc\n#输出函数内部的变量\necho $a\n```\n\n输出结果： \n\n```\n99\n```\n\n要想变量的作用域仅限于函数内部，可以在定义时加上`local`命令，此时该变量就成了局部变量。\n\n```shell\n#!/bin/bash\n\n#定义函数\nfunction func(){\n    local a=99\n}\n\n#调用函数\nfunc\n\n#输出函数内部的变量\necho $a\n```\n\n输出结果为空，表明变量 a 在函数外部无效，是一个局部变量。\n","source":"_posts/Shell/2022-02-25-Shell 变量.md","raw":"---\n\nlayout: post\ntitle: \"Shell 变量\"\ndate: 2022-02-25 \ntag: Shell\n\n---  \n\n# Shell 变量\n\n## 变量名\n\nThe name of a variable can contain only letters (a to z or A to Z), numbers ( 0 to 9) or the underscore character ( _).\n\nBy convention, Unix shell variables will have their names in UPPERCASE.\n\n合法的变量\n\n```shell\n_ALI\nTOKEN_A\nVAR_1\nVAR_2\n```\n\n非法变量\n\n```shell\n2_VAR\n-VARIABLE\nVAR1-VAR2\nVAR_A!\n```\n\n## 定义变量\n\n```shell\nvariable_name=variable_value\n```\n\n例如：\n\n```shell\nNAME=\"Zara Ali\"\n```\n\nshell 允许变量存你想要的任何值， 例如\n\n```shell\nVAR1=\"Zara Ali\"\nVAR2=100\n```\n\n## 获取变量的值\n\n通过在变量前添加`$`来引用变量\n\n```shell\n#!/bin/sh\n\nNAME=\"Zara Ali\"\necho $NAME\n```\n\n输出\n\n```shell\nZara Ali\n```\n\n## 只读变量\n\n在变量前添加`readonly`将变量标记为只读，只读变量不允许被修改。\n\n```shell\n#!/bin/sh\n\nNAME=\"Zara Ali\"\nreadonly NAME\nNAME=\"Qadiri\"\n```\n\n报错\n\n```shell\nNAME: readonly variable\n```\n\n## 删除一个变量\n\n使用`unset`命令删除一个变量，变量被删除后，无法访问该变量的值。\n\n```shell\nunset variable_name\n```\n\n例如\n\n```shell\n#!/bin/sh\n\nNAME=\"Zara Ali\"\nunset NAME\necho $NAME\n```\n\n\bNAME 被删除， 输出为空。\n\n## 变量类型\n\n- 本地变量\n  \n  - 使用`local`关键字修饰的变量\n  - 只能用在函数内部\n  - 如果与全局变量同名，在函数内部，会屏蔽同名的全局变量\n  - 函数的参数是`local`的\n\n- shell 全局变量\n  \n  - 在 Shell 中定义的变量，默认就是全局变量。\n  - 在函数内部定义的变量，没有用`local`关键字修饰，也是全局变量\n    \n    \n\n- 环境变量\n  \n  - 全局变量只在当前 Shell 进程中有效，对其它 Shell 进程和子进程都无效。如果使用`export`命令将全局变量导出，那么它就在所有的子进程中也有效了，这称为“环境变量”。\n\n在shell 函数中定义的变量也是全局变量\n\n```shell\n#!/bin/bash\n#定义函数\nfunction func(){\n    a=99\n}\n#调用函数\nfunc\n#输出函数内部的变量\necho $a\n```\n\n输出结果： \n\n```\n99\n```\n\n要想变量的作用域仅限于函数内部，可以在定义时加上`local`命令，此时该变量就成了局部变量。\n\n```shell\n#!/bin/bash\n\n#定义函数\nfunction func(){\n    local a=99\n}\n\n#调用函数\nfunc\n\n#输出函数内部的变量\necho $a\n```\n\n输出结果为空，表明变量 a 在函数外部无效，是一个局部变量。\n","slug":"Shell/2022-02-25-Shell 变量","published":1,"updated":"2024-03-06T11:53:13.562Z","comments":1,"photos":[],"_id":"cltgopen40005qywh8lpwfb2y","content":"<h1 id=\"Shell-变量\"><a href=\"#Shell-变量\" class=\"headerlink\" title=\"Shell 变量\"></a>Shell 变量</h1><h2 id=\"变量名\"><a href=\"#变量名\" class=\"headerlink\" title=\"变量名\"></a>变量名</h2><p>The name of a variable can contain only letters (a to z or A to Z), numbers ( 0 to 9) or the underscore character ( _).</p>\n<p>By convention, Unix shell variables will have their names in UPPERCASE.</p>\n<p>合法的变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">_ALI<br>TOKEN_A<br>VAR_1<br>VAR_2<br></code></pre></td></tr></table></figure>\n\n<p>非法变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">2_VAR<br>-VARIABLE<br>VAR1-VAR2<br>VAR_A!<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"定义变量\"><a href=\"#定义变量\" class=\"headerlink\" title=\"定义变量\"></a>定义变量</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">variable_name=variable_value<br></code></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">NAME=&quot;Zara Ali&quot;<br></code></pre></td></tr></table></figure>\n\n<p>shell 允许变量存你想要的任何值， 例如</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">VAR1=&quot;Zara Ali&quot;<br>VAR2=100<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"获取变量的值\"><a href=\"#获取变量的值\" class=\"headerlink\" title=\"获取变量的值\"></a>获取变量的值</h2><p>通过在变量前添加<code>$</code>来引用变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>NAME=&quot;Zara Ali&quot;<br>echo $NAME<br></code></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">Zara Ali<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"只读变量\"><a href=\"#只读变量\" class=\"headerlink\" title=\"只读变量\"></a>只读变量</h2><p>在变量前添加<code>readonly</code>将变量标记为只读，只读变量不允许被修改。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>NAME=&quot;Zara Ali&quot;<br>readonly NAME<br>NAME=&quot;Qadiri&quot;<br></code></pre></td></tr></table></figure>\n\n<p>报错</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">NAME: readonly variable<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"删除一个变量\"><a href=\"#删除一个变量\" class=\"headerlink\" title=\"删除一个变量\"></a>删除一个变量</h2><p>使用<code>unset</code>命令删除一个变量，变量被删除后，无法访问该变量的值。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">unset variable_name<br></code></pre></td></tr></table></figure>\n\n<p>例如</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>NAME=&quot;Zara Ali&quot;<br>unset NAME<br>echo $NAME<br></code></pre></td></tr></table></figure>\n\n<p>\bNAME 被删除， 输出为空。</p>\n<h2 id=\"变量类型\"><a href=\"#变量类型\" class=\"headerlink\" title=\"变量类型\"></a>变量类型</h2><ul>\n<li><p>本地变量</p>\n<ul>\n<li>使用<code>local</code>关键字修饰的变量</li>\n<li>只能用在函数内部</li>\n<li>如果与全局变量同名，在函数内部，会屏蔽同名的全局变量</li>\n<li>函数的参数是<code>local</code>的</li>\n</ul>\n</li>\n<li><p>shell 全局变量</p>\n<ul>\n<li>在 Shell 中定义的变量，默认就是全局变量。</li>\n<li>在函数内部定义的变量，没有用<code>local</code>关键字修饰，也是全局变量</li>\n</ul>\n</li>\n<li><p>环境变量</p>\n<ul>\n<li>全局变量只在当前 Shell 进程中有效，对其它 Shell 进程和子进程都无效。如果使用<code>export</code>命令将全局变量导出，那么它就在所有的子进程中也有效了，这称为“环境变量”。</li>\n</ul>\n</li>\n</ul>\n<p>在shell 函数中定义的变量也是全局变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">定义函数</span><br>function func()&#123;<br>    a=99<br>&#125;<br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">调用函数</span><br>func<br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">输出函数内部的变量</span><br>echo $a<br></code></pre></td></tr></table></figure>\n\n<p>输出结果： </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">99<br></code></pre></td></tr></table></figure>\n\n<p>要想变量的作用域仅限于函数内部，可以在定义时加上<code>local</code>命令，此时该变量就成了局部变量。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">定义函数</span><br>function func()&#123;<br>    local a=99<br>&#125;<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">调用函数</span><br>func<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">输出函数内部的变量</span><br>echo $a<br></code></pre></td></tr></table></figure>\n\n<p>输出结果为空，表明变量 a 在函数外部无效，是一个局部变量。</p>\n","excerpt":"","more":"<h1 id=\"Shell-变量\"><a href=\"#Shell-变量\" class=\"headerlink\" title=\"Shell 变量\"></a>Shell 变量</h1><h2 id=\"变量名\"><a href=\"#变量名\" class=\"headerlink\" title=\"变量名\"></a>变量名</h2><p>The name of a variable can contain only letters (a to z or A to Z), numbers ( 0 to 9) or the underscore character ( _).</p>\n<p>By convention, Unix shell variables will have their names in UPPERCASE.</p>\n<p>合法的变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">_ALI<br>TOKEN_A<br>VAR_1<br>VAR_2<br></code></pre></td></tr></table></figure>\n\n<p>非法变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">2_VAR<br>-VARIABLE<br>VAR1-VAR2<br>VAR_A!<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"定义变量\"><a href=\"#定义变量\" class=\"headerlink\" title=\"定义变量\"></a>定义变量</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">variable_name=variable_value<br></code></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">NAME=&quot;Zara Ali&quot;<br></code></pre></td></tr></table></figure>\n\n<p>shell 允许变量存你想要的任何值， 例如</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">VAR1=&quot;Zara Ali&quot;<br>VAR2=100<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"获取变量的值\"><a href=\"#获取变量的值\" class=\"headerlink\" title=\"获取变量的值\"></a>获取变量的值</h2><p>通过在变量前添加<code>$</code>来引用变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>NAME=&quot;Zara Ali&quot;<br>echo $NAME<br></code></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">Zara Ali<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"只读变量\"><a href=\"#只读变量\" class=\"headerlink\" title=\"只读变量\"></a>只读变量</h2><p>在变量前添加<code>readonly</code>将变量标记为只读，只读变量不允许被修改。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>NAME=&quot;Zara Ali&quot;<br>readonly NAME<br>NAME=&quot;Qadiri&quot;<br></code></pre></td></tr></table></figure>\n\n<p>报错</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">NAME: readonly variable<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"删除一个变量\"><a href=\"#删除一个变量\" class=\"headerlink\" title=\"删除一个变量\"></a>删除一个变量</h2><p>使用<code>unset</code>命令删除一个变量，变量被删除后，无法访问该变量的值。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">unset variable_name<br></code></pre></td></tr></table></figure>\n\n<p>例如</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>NAME=&quot;Zara Ali&quot;<br>unset NAME<br>echo $NAME<br></code></pre></td></tr></table></figure>\n\n<p>\bNAME 被删除， 输出为空。</p>\n<h2 id=\"变量类型\"><a href=\"#变量类型\" class=\"headerlink\" title=\"变量类型\"></a>变量类型</h2><ul>\n<li><p>本地变量</p>\n<ul>\n<li>使用<code>local</code>关键字修饰的变量</li>\n<li>只能用在函数内部</li>\n<li>如果与全局变量同名，在函数内部，会屏蔽同名的全局变量</li>\n<li>函数的参数是<code>local</code>的</li>\n</ul>\n</li>\n<li><p>shell 全局变量</p>\n<ul>\n<li>在 Shell 中定义的变量，默认就是全局变量。</li>\n<li>在函数内部定义的变量，没有用<code>local</code>关键字修饰，也是全局变量</li>\n</ul>\n</li>\n<li><p>环境变量</p>\n<ul>\n<li>全局变量只在当前 Shell 进程中有效，对其它 Shell 进程和子进程都无效。如果使用<code>export</code>命令将全局变量导出，那么它就在所有的子进程中也有效了，这称为“环境变量”。</li>\n</ul>\n</li>\n</ul>\n<p>在shell 函数中定义的变量也是全局变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">定义函数</span><br>function func()&#123;<br>    a=99<br>&#125;<br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">调用函数</span><br>func<br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">输出函数内部的变量</span><br>echo $a<br></code></pre></td></tr></table></figure>\n\n<p>输出结果： </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">99<br></code></pre></td></tr></table></figure>\n\n<p>要想变量的作用域仅限于函数内部，可以在定义时加上<code>local</code>命令，此时该变量就成了局部变量。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/bash</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">定义函数</span><br>function func()&#123;<br>    local a=99<br>&#125;<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">调用函数</span><br>func<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">输出函数内部的变量</span><br>echo $a<br></code></pre></td></tr></table></figure>\n\n<p>输出结果为空，表明变量 a 在函数外部无效，是一个局部变量。</p>\n"},{"layout":"post","title":"Shell 数组","date":"2022-02-24T16:00:00.000Z","_content":"  \n\n# Shell 数组\n\n参考： [Shell中的数组及其相关操作_杰瑞的专栏-CSDN博客](https://blog.csdn.net/Jerry_1126/article/details/52027539)\n\n应用场景：\n\n1. 求数组的长度\n\n2. 元素长度\n\n3. 遍历数组\n\n4. 元素切片\n\n5. 替换\n\n6. 删除\n\n\n\n备注：\n\n1. Shell中的数组不像JAVA/C，只能是一维数组， 没有二维数组\n\n2. 数组元素大小无约束，也无需先定义数组的元素个数\n\n3. 索引从0开始\n\n4. 不像JAVA/C等强编程语言，在赋值前必须声明；SHELL只是弱编程语言，可事先声明也可不声明；\n\n5. 用unset来撤销数组，可用unset array_name[i]来删除里面的元素\n\n\n\n## 声明\n\n```shell\ndeclare -a array_name       # 声明数组，也可不声明\ndeclare -a nums=(1 2 3 4)   # 声明数组， 同时赋值\nunset array_name            # 删除数组，撤销数组\nunset nums[0]               # 删除数组中某个元素\n```\n\n## 定义\n\n```shell\n#方式一：\narray_names=(\nvalue0\nvaluel\nvalue2\nvalue3\n)\n#方式二：\nnames=(Jerry Alice David wendy)\n#方式三：\nnames[0]=Jerry\nnames[1]=Alice\nnames[2]=David\nnames[3]=Wendy\n#方式四：\nnames=([0]=Jerry [1]=Alice [2]=David [3]=Wendy)\n#方式五：\nstr=\"Jerry Alice David Wendy\"\nnames=($str)\n```\n\n备注：\n\n1. 数组中的元素，必须用\"空格\"来隔开\n\n2. 定义数组索引，可以不按顺序来，例如，`names=([0]=Jerry [1]=Alice [2]=David [8]=Wendy)`\n\n3. 字符串是SHELL中最重要的数据类型，其也可通过`($str)`来转成数组，操作起来非常方便\n\n## 数组长度\n\n```shell\nnums=(Jerry Alice David Wendy)\n\n#方式1 ${#数组名[@]}\n~ echo ${#nums[@]}\n4\n#方式2 ${#数组名[*]}\n~ echo ${#nums[*]}\n4\n```\n\n备注：\n\n1) 使用`${array_name[@]}` 或者 `${array_name[*]}` 都可以全部显示数组中的元素\n\n2) 同样道理`${#array_name[@]}` 或者 `${#array_name[*]}`都可以用来求数组的长度\n\n3) 求数组中元素的长度方法有很多，相当于求字符串的长度\n   \n\n## 数组遍历\n\n```shell\nnames=(Jerry Alice David Wendy)\n\n# 方式一： 按索引来遍历\nfor((i=0;i<${#names[@]};i++))\ndo \n    echo ${names[$i]}\ndone\n\n# 方式二： 不按索引来遍历\nindex=0\nfor name in ${names[@]} \ndo \n    echo \"第${index}个元素的值为：==> ${name}\"\n    let index++\ndone\n\n```\n\n## 数组赋值\n\n```shell\nnums=(1 2 3 4)  # 定义数组\nnums[3]=44      # 第三个元素重新赋值\necho ${nums[@]} # 结果变成了 1 2 3 44\n```\n\n**备注:**\n\n1) 第一种是给已经存在的元素项重新赋值\n\n2) 当然也可以给不存在的索引添加赋值，可以看下面的示例\n\n```shell\n### 数组添加元素\n\n# 方式-： 给不存在的索引赋值\nnums=(1 2 3 4)  # 定义数组\nnums[4]=5       # 给第四个新元素赋值\necho ${nums[@]} # 结果变成了 1 2 3 4 5\nnums[8]=8       # 给第8个元素赋值\necho ${nums[@]} # 结果变成了 1 2 3 4 5 8\n\n# 方式二： 直接使用 新数组=(旧数组 新元素) 的方法添加元素\nold=(1 2 3 4)\nnew=(${old[*]} 5)\necho ${new[@]}\n```\n\n\n","source":"_posts/Shell/2022-02-25-Shell 数组.md","raw":"---\nlayout: post\ntitle: \"Shell 数组\"\ndate: 2022-02-25 \ntag: Shell\n---  \n\n# Shell 数组\n\n参考： [Shell中的数组及其相关操作_杰瑞的专栏-CSDN博客](https://blog.csdn.net/Jerry_1126/article/details/52027539)\n\n应用场景：\n\n1. 求数组的长度\n\n2. 元素长度\n\n3. 遍历数组\n\n4. 元素切片\n\n5. 替换\n\n6. 删除\n\n\n\n备注：\n\n1. Shell中的数组不像JAVA/C，只能是一维数组， 没有二维数组\n\n2. 数组元素大小无约束，也无需先定义数组的元素个数\n\n3. 索引从0开始\n\n4. 不像JAVA/C等强编程语言，在赋值前必须声明；SHELL只是弱编程语言，可事先声明也可不声明；\n\n5. 用unset来撤销数组，可用unset array_name[i]来删除里面的元素\n\n\n\n## 声明\n\n```shell\ndeclare -a array_name       # 声明数组，也可不声明\ndeclare -a nums=(1 2 3 4)   # 声明数组， 同时赋值\nunset array_name            # 删除数组，撤销数组\nunset nums[0]               # 删除数组中某个元素\n```\n\n## 定义\n\n```shell\n#方式一：\narray_names=(\nvalue0\nvaluel\nvalue2\nvalue3\n)\n#方式二：\nnames=(Jerry Alice David wendy)\n#方式三：\nnames[0]=Jerry\nnames[1]=Alice\nnames[2]=David\nnames[3]=Wendy\n#方式四：\nnames=([0]=Jerry [1]=Alice [2]=David [3]=Wendy)\n#方式五：\nstr=\"Jerry Alice David Wendy\"\nnames=($str)\n```\n\n备注：\n\n1. 数组中的元素，必须用\"空格\"来隔开\n\n2. 定义数组索引，可以不按顺序来，例如，`names=([0]=Jerry [1]=Alice [2]=David [8]=Wendy)`\n\n3. 字符串是SHELL中最重要的数据类型，其也可通过`($str)`来转成数组，操作起来非常方便\n\n## 数组长度\n\n```shell\nnums=(Jerry Alice David Wendy)\n\n#方式1 ${#数组名[@]}\n~ echo ${#nums[@]}\n4\n#方式2 ${#数组名[*]}\n~ echo ${#nums[*]}\n4\n```\n\n备注：\n\n1) 使用`${array_name[@]}` 或者 `${array_name[*]}` 都可以全部显示数组中的元素\n\n2) 同样道理`${#array_name[@]}` 或者 `${#array_name[*]}`都可以用来求数组的长度\n\n3) 求数组中元素的长度方法有很多，相当于求字符串的长度\n   \n\n## 数组遍历\n\n```shell\nnames=(Jerry Alice David Wendy)\n\n# 方式一： 按索引来遍历\nfor((i=0;i<${#names[@]};i++))\ndo \n    echo ${names[$i]}\ndone\n\n# 方式二： 不按索引来遍历\nindex=0\nfor name in ${names[@]} \ndo \n    echo \"第${index}个元素的值为：==> ${name}\"\n    let index++\ndone\n\n```\n\n## 数组赋值\n\n```shell\nnums=(1 2 3 4)  # 定义数组\nnums[3]=44      # 第三个元素重新赋值\necho ${nums[@]} # 结果变成了 1 2 3 44\n```\n\n**备注:**\n\n1) 第一种是给已经存在的元素项重新赋值\n\n2) 当然也可以给不存在的索引添加赋值，可以看下面的示例\n\n```shell\n### 数组添加元素\n\n# 方式-： 给不存在的索引赋值\nnums=(1 2 3 4)  # 定义数组\nnums[4]=5       # 给第四个新元素赋值\necho ${nums[@]} # 结果变成了 1 2 3 4 5\nnums[8]=8       # 给第8个元素赋值\necho ${nums[@]} # 结果变成了 1 2 3 4 5 8\n\n# 方式二： 直接使用 新数组=(旧数组 新元素) 的方法添加元素\nold=(1 2 3 4)\nnew=(${old[*]} 5)\necho ${new[@]}\n```\n\n\n","slug":"Shell/2022-02-25-Shell 数组","published":1,"updated":"2024-03-06T11:53:13.563Z","comments":1,"photos":[],"_id":"cltgopen50006qywhdhai3mu5","content":"<h1 id=\"Shell-数组\"><a href=\"#Shell-数组\" class=\"headerlink\" title=\"Shell 数组\"></a>Shell 数组</h1><p>参考： <a href=\"https://blog.csdn.net/Jerry_1126/article/details/52027539\">Shell中的数组及其相关操作_杰瑞的专栏-CSDN博客</a></p>\n<p>应用场景：</p>\n<ol>\n<li><p>求数组的长度</p>\n</li>\n<li><p>元素长度</p>\n</li>\n<li><p>遍历数组</p>\n</li>\n<li><p>元素切片</p>\n</li>\n<li><p>替换</p>\n</li>\n<li><p>删除</p>\n</li>\n</ol>\n<p>备注：</p>\n<ol>\n<li><p>Shell中的数组不像JAVA&#x2F;C，只能是一维数组， 没有二维数组</p>\n</li>\n<li><p>数组元素大小无约束，也无需先定义数组的元素个数</p>\n</li>\n<li><p>索引从0开始</p>\n</li>\n<li><p>不像JAVA&#x2F;C等强编程语言，在赋值前必须声明；SHELL只是弱编程语言，可事先声明也可不声明；</p>\n</li>\n<li><p>用unset来撤销数组，可用unset array_name[i]来删除里面的元素</p>\n</li>\n</ol>\n<h2 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">declare -a array_name       # 声明数组，也可不声明<br>declare -a nums=(1 2 3 4)   # 声明数组， 同时赋值<br>unset array_name            # 删除数组，撤销数组<br>unset nums[0]               # 删除数组中某个元素<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">方式一：</span><br>array_names=(<br>value0<br>valuel<br>value2<br>value3<br>)<br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">方式二：</span><br>names=(Jerry Alice David wendy)<br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">方式三：</span><br>names[0]=Jerry<br>names[1]=Alice<br>names[2]=David<br>names[3]=Wendy<br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">方式四：</span><br>names=([0]=Jerry [1]=Alice [2]=David [3]=Wendy)<br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">方式五：</span><br>str=&quot;Jerry Alice David Wendy&quot;<br>names=($str)<br></code></pre></td></tr></table></figure>\n\n<p>备注：</p>\n<ol>\n<li><p>数组中的元素，必须用”空格”来隔开</p>\n</li>\n<li><p>定义数组索引，可以不按顺序来，例如，<code>names=([0]=Jerry [1]=Alice [2]=David [8]=Wendy)</code></p>\n</li>\n<li><p>字符串是SHELL中最重要的数据类型，其也可通过<code>($str)</code>来转成数组，操作起来非常方便</p>\n</li>\n</ol>\n<h2 id=\"数组长度\"><a href=\"#数组长度\" class=\"headerlink\" title=\"数组长度\"></a>数组长度</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">nums=(Jerry Alice David Wendy)<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">方式1 <span class=\"hljs-variable\">$&#123;#数组名[@]&#125;</span></span><br>~ echo $&#123;#nums[@]&#125;<br>4<br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">方式2 <span class=\"hljs-variable\">$&#123;#数组名[*]&#125;</span></span><br>~ echo $&#123;#nums[*]&#125;<br>4<br></code></pre></td></tr></table></figure>\n\n<p>备注：</p>\n<ol>\n<li><p>使用<code>$&#123;array_name[@]&#125;</code> 或者 <code>$&#123;array_name[*]&#125;</code> 都可以全部显示数组中的元素</p>\n</li>\n<li><p>同样道理<code>$&#123;#array_name[@]&#125;</code> 或者 <code>$&#123;#array_name[*]&#125;</code>都可以用来求数组的长度</p>\n</li>\n<li><p>求数组中元素的长度方法有很多，相当于求字符串的长度</p>\n</li>\n</ol>\n<h2 id=\"数组遍历\"><a href=\"#数组遍历\" class=\"headerlink\" title=\"数组遍历\"></a>数组遍历</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">names=(Jerry Alice David Wendy)<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">方式一： 按索引来遍历</span><br>for((i=0;i&lt;$&#123;#names[@]&#125;;i++))<br>do <br>    echo $&#123;names[$i]&#125;<br>done<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">方式二： 不按索引来遍历</span><br>index=0<br>for name in $&#123;names[@]&#125; <br>do <br>    echo &quot;第$&#123;index&#125;个元素的值为：==&gt; $&#123;name&#125;&quot;<br>    let index++<br>done<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数组赋值\"><a href=\"#数组赋值\" class=\"headerlink\" title=\"数组赋值\"></a>数组赋值</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">nums=(1 2 3 4)  # 定义数组<br>nums[3]=44      # 第三个元素重新赋值<br>echo $&#123;nums[@]&#125; # 结果变成了 1 2 3 44<br></code></pre></td></tr></table></figure>\n\n<p><strong>备注:</strong></p>\n<ol>\n<li><p>第一种是给已经存在的元素项重新赋值</p>\n</li>\n<li><p>当然也可以给不存在的索引添加赋值，可以看下面的示例</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\"><span class=\"hljs-comment\">## 数组添加元素</span></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">方式-： 给不存在的索引赋值</span><br>nums=(1 2 3 4)  # 定义数组<br>nums[4]=5       # 给第四个新元素赋值<br>echo $&#123;nums[@]&#125; # 结果变成了 1 2 3 4 5<br>nums[8]=8       # 给第8个元素赋值<br>echo $&#123;nums[@]&#125; # 结果变成了 1 2 3 4 5 8<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">方式二： 直接使用 新数组=(旧数组 新元素) 的方法添加元素</span><br>old=(1 2 3 4)<br>new=($&#123;old[*]&#125; 5)<br>echo $&#123;new[@]&#125;<br></code></pre></td></tr></table></figure>\n\n\n","excerpt":"","more":"<h1 id=\"Shell-数组\"><a href=\"#Shell-数组\" class=\"headerlink\" title=\"Shell 数组\"></a>Shell 数组</h1><p>参考： <a href=\"https://blog.csdn.net/Jerry_1126/article/details/52027539\">Shell中的数组及其相关操作_杰瑞的专栏-CSDN博客</a></p>\n<p>应用场景：</p>\n<ol>\n<li><p>求数组的长度</p>\n</li>\n<li><p>元素长度</p>\n</li>\n<li><p>遍历数组</p>\n</li>\n<li><p>元素切片</p>\n</li>\n<li><p>替换</p>\n</li>\n<li><p>删除</p>\n</li>\n</ol>\n<p>备注：</p>\n<ol>\n<li><p>Shell中的数组不像JAVA&#x2F;C，只能是一维数组， 没有二维数组</p>\n</li>\n<li><p>数组元素大小无约束，也无需先定义数组的元素个数</p>\n</li>\n<li><p>索引从0开始</p>\n</li>\n<li><p>不像JAVA&#x2F;C等强编程语言，在赋值前必须声明；SHELL只是弱编程语言，可事先声明也可不声明；</p>\n</li>\n<li><p>用unset来撤销数组，可用unset array_name[i]来删除里面的元素</p>\n</li>\n</ol>\n<h2 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">declare -a array_name       # 声明数组，也可不声明<br>declare -a nums=(1 2 3 4)   # 声明数组， 同时赋值<br>unset array_name            # 删除数组，撤销数组<br>unset nums[0]               # 删除数组中某个元素<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">方式一：</span><br>array_names=(<br>value0<br>valuel<br>value2<br>value3<br>)<br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">方式二：</span><br>names=(Jerry Alice David wendy)<br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">方式三：</span><br>names[0]=Jerry<br>names[1]=Alice<br>names[2]=David<br>names[3]=Wendy<br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">方式四：</span><br>names=([0]=Jerry [1]=Alice [2]=David [3]=Wendy)<br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">方式五：</span><br>str=&quot;Jerry Alice David Wendy&quot;<br>names=($str)<br></code></pre></td></tr></table></figure>\n\n<p>备注：</p>\n<ol>\n<li><p>数组中的元素，必须用”空格”来隔开</p>\n</li>\n<li><p>定义数组索引，可以不按顺序来，例如，<code>names=([0]=Jerry [1]=Alice [2]=David [8]=Wendy)</code></p>\n</li>\n<li><p>字符串是SHELL中最重要的数据类型，其也可通过<code>($str)</code>来转成数组，操作起来非常方便</p>\n</li>\n</ol>\n<h2 id=\"数组长度\"><a href=\"#数组长度\" class=\"headerlink\" title=\"数组长度\"></a>数组长度</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">nums=(Jerry Alice David Wendy)<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">方式1 <span class=\"hljs-variable\">$&#123;#数组名[@]&#125;</span></span><br>~ echo $&#123;#nums[@]&#125;<br>4<br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">方式2 <span class=\"hljs-variable\">$&#123;#数组名[*]&#125;</span></span><br>~ echo $&#123;#nums[*]&#125;<br>4<br></code></pre></td></tr></table></figure>\n\n<p>备注：</p>\n<ol>\n<li><p>使用<code>$&#123;array_name[@]&#125;</code> 或者 <code>$&#123;array_name[*]&#125;</code> 都可以全部显示数组中的元素</p>\n</li>\n<li><p>同样道理<code>$&#123;#array_name[@]&#125;</code> 或者 <code>$&#123;#array_name[*]&#125;</code>都可以用来求数组的长度</p>\n</li>\n<li><p>求数组中元素的长度方法有很多，相当于求字符串的长度</p>\n</li>\n</ol>\n<h2 id=\"数组遍历\"><a href=\"#数组遍历\" class=\"headerlink\" title=\"数组遍历\"></a>数组遍历</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">names=(Jerry Alice David Wendy)<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">方式一： 按索引来遍历</span><br>for((i=0;i&lt;$&#123;#names[@]&#125;;i++))<br>do <br>    echo $&#123;names[$i]&#125;<br>done<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">方式二： 不按索引来遍历</span><br>index=0<br>for name in $&#123;names[@]&#125; <br>do <br>    echo &quot;第$&#123;index&#125;个元素的值为：==&gt; $&#123;name&#125;&quot;<br>    let index++<br>done<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数组赋值\"><a href=\"#数组赋值\" class=\"headerlink\" title=\"数组赋值\"></a>数组赋值</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">nums=(1 2 3 4)  # 定义数组<br>nums[3]=44      # 第三个元素重新赋值<br>echo $&#123;nums[@]&#125; # 结果变成了 1 2 3 44<br></code></pre></td></tr></table></figure>\n\n<p><strong>备注:</strong></p>\n<ol>\n<li><p>第一种是给已经存在的元素项重新赋值</p>\n</li>\n<li><p>当然也可以给不存在的索引添加赋值，可以看下面的示例</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\"><span class=\"hljs-comment\">## 数组添加元素</span></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">方式-： 给不存在的索引赋值</span><br>nums=(1 2 3 4)  # 定义数组<br>nums[4]=5       # 给第四个新元素赋值<br>echo $&#123;nums[@]&#125; # 结果变成了 1 2 3 4 5<br>nums[8]=8       # 给第8个元素赋值<br>echo $&#123;nums[@]&#125; # 结果变成了 1 2 3 4 5 8<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">方式二： 直接使用 新数组=(旧数组 新元素) 的方法添加元素</span><br>old=(1 2 3 4)<br>new=($&#123;old[*]&#125; 5)<br>echo $&#123;new[@]&#125;<br></code></pre></td></tr></table></figure>\n\n\n"},{"layout":"post","title":"Shell 函数","date":"2022-02-24T16:00:00.000Z","_content":"  \n\n# shell 函数\n\n语法\n\n```shell\nfunction_name () { \n   list of commands\n}\n```\n\n示例\n\n```shell\n#!/bin/sh\n\n# Define your function here\nHello () {\n   echo \"Hello World\"\n}\n\n# Invoke your function\nHello\n```\n\n## 函数传参\n\n函数传参类似于脚本传参`$1, $2..$n`\n\n```shell\n#!/bin/sh\n\n# Define your function here\nHello () {\n   echo \"Hello World $1 $2\"\n}\n\n# Invoke your function\nHello Zara Ali\n```\n\n## 返回值\n\n```shell\n#!/bin/sh\n\n# Define your function here\nHello () {\n   echo \"Hello World $1 $2\"\n   return 10\n}\n\n# Invoke your function\nHello Zara Ali\n\n# Capture value returnd by last command\nret=$?\n\necho \"Return value is $ret\"\n```\n\n## 函数嵌套\n\n```shell\n\n#!/bin/sh\n\n# Calling one function from another\nnumber_one () {\n   echo \"This is the first function speaking...\"\n   number_two\n}\n\nnumber_two () {\n   echo \"This is now the second function speaking...\"\n}\n\n# Calling function one.\nnumber_one\n\n```\n","source":"_posts/Shell/2022-02-25-shell 函数.md","raw":"---\nlayout: post\ntitle: \"Shell 函数\"\ndate: 2022-02-25 \ntag: Shell\n---  \n\n# shell 函数\n\n语法\n\n```shell\nfunction_name () { \n   list of commands\n}\n```\n\n示例\n\n```shell\n#!/bin/sh\n\n# Define your function here\nHello () {\n   echo \"Hello World\"\n}\n\n# Invoke your function\nHello\n```\n\n## 函数传参\n\n函数传参类似于脚本传参`$1, $2..$n`\n\n```shell\n#!/bin/sh\n\n# Define your function here\nHello () {\n   echo \"Hello World $1 $2\"\n}\n\n# Invoke your function\nHello Zara Ali\n```\n\n## 返回值\n\n```shell\n#!/bin/sh\n\n# Define your function here\nHello () {\n   echo \"Hello World $1 $2\"\n   return 10\n}\n\n# Invoke your function\nHello Zara Ali\n\n# Capture value returnd by last command\nret=$?\n\necho \"Return value is $ret\"\n```\n\n## 函数嵌套\n\n```shell\n\n#!/bin/sh\n\n# Calling one function from another\nnumber_one () {\n   echo \"This is the first function speaking...\"\n   number_two\n}\n\nnumber_two () {\n   echo \"This is now the second function speaking...\"\n}\n\n# Calling function one.\nnumber_one\n\n```\n","slug":"Shell/2022-02-25-shell 函数","published":1,"updated":"2024-03-06T11:53:13.563Z","comments":1,"photos":[],"_id":"cltgopen50009qywhd2mg9cri","content":"<h1 id=\"shell-函数\"><a href=\"#shell-函数\" class=\"headerlink\" title=\"shell 函数\"></a>shell 函数</h1><p>语法</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">function_name () &#123; <br>   list of commands<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>示例</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Define your <span class=\"hljs-keyword\">function</span> here</span><br>Hello () &#123;<br>   echo &quot;Hello World&quot;<br>&#125;<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Invoke your <span class=\"hljs-keyword\">function</span></span><br>Hello<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"函数传参\"><a href=\"#函数传参\" class=\"headerlink\" title=\"函数传参\"></a>函数传参</h2><p>函数传参类似于脚本传参<code>$1, $2..$n</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Define your <span class=\"hljs-keyword\">function</span> here</span><br>Hello () &#123;<br>   echo &quot;Hello World $1 $2&quot;<br>&#125;<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Invoke your <span class=\"hljs-keyword\">function</span></span><br>Hello Zara Ali<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Define your <span class=\"hljs-keyword\">function</span> here</span><br>Hello () &#123;<br>   echo &quot;Hello World $1 $2&quot;<br>   return 10<br>&#125;<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Invoke your <span class=\"hljs-keyword\">function</span></span><br>Hello Zara Ali<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Capture value returnd by last <span class=\"hljs-built_in\">command</span></span><br>ret=$?<br><br>echo &quot;Return value is $ret&quot;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"函数嵌套\"><a href=\"#函数嵌套\" class=\"headerlink\" title=\"函数嵌套\"></a>函数嵌套</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Calling one <span class=\"hljs-keyword\">function</span> from another</span><br>number_one () &#123;<br>   echo &quot;This is the first function speaking...&quot;<br>   number_two<br>&#125;<br><br>number_two () &#123;<br>   echo &quot;This is now the second function speaking...&quot;<br>&#125;<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Calling <span class=\"hljs-keyword\">function</span> one.</span><br>number_one<br><br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"shell-函数\"><a href=\"#shell-函数\" class=\"headerlink\" title=\"shell 函数\"></a>shell 函数</h1><p>语法</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">function_name () &#123; <br>   list of commands<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>示例</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Define your <span class=\"hljs-keyword\">function</span> here</span><br>Hello () &#123;<br>   echo &quot;Hello World&quot;<br>&#125;<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Invoke your <span class=\"hljs-keyword\">function</span></span><br>Hello<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"函数传参\"><a href=\"#函数传参\" class=\"headerlink\" title=\"函数传参\"></a>函数传参</h2><p>函数传参类似于脚本传参<code>$1, $2..$n</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Define your <span class=\"hljs-keyword\">function</span> here</span><br>Hello () &#123;<br>   echo &quot;Hello World $1 $2&quot;<br>&#125;<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Invoke your <span class=\"hljs-keyword\">function</span></span><br>Hello Zara Ali<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Define your <span class=\"hljs-keyword\">function</span> here</span><br>Hello () &#123;<br>   echo &quot;Hello World $1 $2&quot;<br>   return 10<br>&#125;<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Invoke your <span class=\"hljs-keyword\">function</span></span><br>Hello Zara Ali<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Capture value returnd by last <span class=\"hljs-built_in\">command</span></span><br>ret=$?<br><br>echo &quot;Return value is $ret&quot;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"函数嵌套\"><a href=\"#函数嵌套\" class=\"headerlink\" title=\"函数嵌套\"></a>函数嵌套</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Calling one <span class=\"hljs-keyword\">function</span> from another</span><br>number_one () &#123;<br>   echo &quot;This is the first function speaking...&quot;<br>   number_two<br>&#125;<br><br>number_two () &#123;<br>   echo &quot;This is now the second function speaking...&quot;<br>&#125;<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Calling <span class=\"hljs-keyword\">function</span> one.</span><br>number_one<br><br></code></pre></td></tr></table></figure>\n"},{"layout":"post","title":"Shell 循环语句","date":"2022-02-24T16:00:00.000Z","_content":"  \n\n# shell 循环语句\n\n## while 循环\n\nwhile 循环可以嵌套，语法如下\n\n```shell\nwhile command1 ; # this is loop1, the outer loop\ndo\n   Statement(s) to be executed if command1 is true\n\n   while command2 ; # this is loop2, the inner loop\n   do\n      Statement(s) to be executed if command2 is true\n   done\n\n   Statement(s) to be executed if command1 is true\ndone\n```\n\n示例\n\n```shell\n#!/bin/sh\n\na=0\nwhile [ \"$a\" -lt 10 ]    # this is loop1\ndo\n   b=\"$a\"\n   while [ \"$b\" -ge 0 ]  # this is loop2\n   do\n      echo -n \"$b \"\n      b=`expr $b - 1`\n   done\n   echo\n   a=`expr $a + 1`\ndone\n```\n\n## break/continue\n\n语法\n\n```shell\nbreak       #跳出当前循环\nbreak n     #跳出多重循环\n\ncontinue    #当前循环 continue\ncontinue n  #n指定的外层循环 continue\n```\n\n跳出当前循环\n\n```shell\n#!/bin/sh\n\na=0\n\nwhile [ $a -lt 10 ]\ndo\n   echo $a\n   if [ $a -eq 5 ]\n   then\n      break\n   fi\n   a=`expr $a + 1`\ndone\n```\n\n跳出外层循环\n\n```shell\n#!/bin/sh\n\nfor var1 in 1 2 3\ndo\n   for var2 in 0 5\n   do\n      if [ $var1 -eq 2 -a $var2 -eq 0 ]\n      then\n         break 2\n      else\n         echo \"$var1 $var2\"\n      fi\n   done\ndone\n```\n\n## for 循环\n\n```shell\n#!/bin/sh\n\nNUMS=\"1 2 3 4 5 6 7\"\n\nfor NUM in $NUMS\ndo\n   Q=`expr $NUM % 2`\n   if [ $Q -eq 0 ]\n   then\n      echo \"Number is an even number!!\"\n      continue\n   fi\n   echo \"Found odd number\"\ndone\n```\n\n## until 循环\n\n```shell\n#!/bin/sh\n\na=10\n\nuntil [ $a -lt 10 ]\ndo\n   echo $a\n   a=`expr $a + 1`\ndone\n```\n\n\n","source":"_posts/Shell/2022-02-25-shell 循环语句.md","raw":"---\nlayout: post\ntitle: \"Shell 循环语句\"\ndate: 2022-02-25 \ntag: Shell\n---  \n\n# shell 循环语句\n\n## while 循环\n\nwhile 循环可以嵌套，语法如下\n\n```shell\nwhile command1 ; # this is loop1, the outer loop\ndo\n   Statement(s) to be executed if command1 is true\n\n   while command2 ; # this is loop2, the inner loop\n   do\n      Statement(s) to be executed if command2 is true\n   done\n\n   Statement(s) to be executed if command1 is true\ndone\n```\n\n示例\n\n```shell\n#!/bin/sh\n\na=0\nwhile [ \"$a\" -lt 10 ]    # this is loop1\ndo\n   b=\"$a\"\n   while [ \"$b\" -ge 0 ]  # this is loop2\n   do\n      echo -n \"$b \"\n      b=`expr $b - 1`\n   done\n   echo\n   a=`expr $a + 1`\ndone\n```\n\n## break/continue\n\n语法\n\n```shell\nbreak       #跳出当前循环\nbreak n     #跳出多重循环\n\ncontinue    #当前循环 continue\ncontinue n  #n指定的外层循环 continue\n```\n\n跳出当前循环\n\n```shell\n#!/bin/sh\n\na=0\n\nwhile [ $a -lt 10 ]\ndo\n   echo $a\n   if [ $a -eq 5 ]\n   then\n      break\n   fi\n   a=`expr $a + 1`\ndone\n```\n\n跳出外层循环\n\n```shell\n#!/bin/sh\n\nfor var1 in 1 2 3\ndo\n   for var2 in 0 5\n   do\n      if [ $var1 -eq 2 -a $var2 -eq 0 ]\n      then\n         break 2\n      else\n         echo \"$var1 $var2\"\n      fi\n   done\ndone\n```\n\n## for 循环\n\n```shell\n#!/bin/sh\n\nNUMS=\"1 2 3 4 5 6 7\"\n\nfor NUM in $NUMS\ndo\n   Q=`expr $NUM % 2`\n   if [ $Q -eq 0 ]\n   then\n      echo \"Number is an even number!!\"\n      continue\n   fi\n   echo \"Found odd number\"\ndone\n```\n\n## until 循环\n\n```shell\n#!/bin/sh\n\na=10\n\nuntil [ $a -lt 10 ]\ndo\n   echo $a\n   a=`expr $a + 1`\ndone\n```\n\n\n","slug":"Shell/2022-02-25-shell 循环语句","published":1,"updated":"2024-03-06T11:53:13.563Z","comments":1,"photos":[],"_id":"cltgopen6000bqywhbntoglll","content":"<h1 id=\"shell-循环语句\"><a href=\"#shell-循环语句\" class=\"headerlink\" title=\"shell 循环语句\"></a>shell 循环语句</h1><h2 id=\"while-循环\"><a href=\"#while-循环\" class=\"headerlink\" title=\"while 循环\"></a>while 循环</h2><p>while 循环可以嵌套，语法如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">while command1 ; # this is loop1, the outer loop<br>do<br>   Statement(s) to be executed if command1 is true<br><br>   while command2 ; # this is loop2, the inner loop<br>   do<br>      Statement(s) to be executed if command2 is true<br>   done<br><br>   Statement(s) to be executed if command1 is true<br>done<br></code></pre></td></tr></table></figure>\n\n<p>示例</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>a=0<br>while [ &quot;$a&quot; -lt 10 ]    # this is loop1<br>do<br>   b=&quot;$a&quot;<br>   while [ &quot;$b&quot; -ge 0 ]  # this is loop2<br>   do<br>      echo -n &quot;$b &quot;<br>      b=`expr $b - 1`<br>   done<br>   echo<br>   a=`expr $a + 1`<br>done<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"break-continue\"><a href=\"#break-continue\" class=\"headerlink\" title=\"break&#x2F;continue\"></a>break&#x2F;continue</h2><p>语法</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">break       #跳出当前循环<br>break n     #跳出多重循环<br><br>continue    #当前循环 continue<br>continue n  #n指定的外层循环 continue<br></code></pre></td></tr></table></figure>\n\n<p>跳出当前循环</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>a=0<br><br>while [ $a -lt 10 ]<br>do<br>   echo $a<br>   if [ $a -eq 5 ]<br>   then<br>      break<br>   fi<br>   a=`expr $a + 1`<br>done<br></code></pre></td></tr></table></figure>\n\n<p>跳出外层循环</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>for var1 in 1 2 3<br>do<br>   for var2 in 0 5<br>   do<br>      if [ $var1 -eq 2 -a $var2 -eq 0 ]<br>      then<br>         break 2<br>      else<br>         echo &quot;$var1 $var2&quot;<br>      fi<br>   done<br>done<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"for-循环\"><a href=\"#for-循环\" class=\"headerlink\" title=\"for 循环\"></a>for 循环</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>NUMS=&quot;1 2 3 4 5 6 7&quot;<br><br>for NUM in $NUMS<br>do<br>   Q=`expr $NUM % 2`<br>   if [ $Q -eq 0 ]<br>   then<br>      echo &quot;Number is an even number!!&quot;<br>      continue<br>   fi<br>   echo &quot;Found odd number&quot;<br>done<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"until-循环\"><a href=\"#until-循环\" class=\"headerlink\" title=\"until 循环\"></a>until 循环</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>a=10<br><br>until [ $a -lt 10 ]<br>do<br>   echo $a<br>   a=`expr $a + 1`<br>done<br></code></pre></td></tr></table></figure>\n\n\n","excerpt":"","more":"<h1 id=\"shell-循环语句\"><a href=\"#shell-循环语句\" class=\"headerlink\" title=\"shell 循环语句\"></a>shell 循环语句</h1><h2 id=\"while-循环\"><a href=\"#while-循环\" class=\"headerlink\" title=\"while 循环\"></a>while 循环</h2><p>while 循环可以嵌套，语法如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">while command1 ; # this is loop1, the outer loop<br>do<br>   Statement(s) to be executed if command1 is true<br><br>   while command2 ; # this is loop2, the inner loop<br>   do<br>      Statement(s) to be executed if command2 is true<br>   done<br><br>   Statement(s) to be executed if command1 is true<br>done<br></code></pre></td></tr></table></figure>\n\n<p>示例</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>a=0<br>while [ &quot;$a&quot; -lt 10 ]    # this is loop1<br>do<br>   b=&quot;$a&quot;<br>   while [ &quot;$b&quot; -ge 0 ]  # this is loop2<br>   do<br>      echo -n &quot;$b &quot;<br>      b=`expr $b - 1`<br>   done<br>   echo<br>   a=`expr $a + 1`<br>done<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"break-continue\"><a href=\"#break-continue\" class=\"headerlink\" title=\"break&#x2F;continue\"></a>break&#x2F;continue</h2><p>语法</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">break       #跳出当前循环<br>break n     #跳出多重循环<br><br>continue    #当前循环 continue<br>continue n  #n指定的外层循环 continue<br></code></pre></td></tr></table></figure>\n\n<p>跳出当前循环</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>a=0<br><br>while [ $a -lt 10 ]<br>do<br>   echo $a<br>   if [ $a -eq 5 ]<br>   then<br>      break<br>   fi<br>   a=`expr $a + 1`<br>done<br></code></pre></td></tr></table></figure>\n\n<p>跳出外层循环</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>for var1 in 1 2 3<br>do<br>   for var2 in 0 5<br>   do<br>      if [ $var1 -eq 2 -a $var2 -eq 0 ]<br>      then<br>         break 2<br>      else<br>         echo &quot;$var1 $var2&quot;<br>      fi<br>   done<br>done<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"for-循环\"><a href=\"#for-循环\" class=\"headerlink\" title=\"for 循环\"></a>for 循环</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>NUMS=&quot;1 2 3 4 5 6 7&quot;<br><br>for NUM in $NUMS<br>do<br>   Q=`expr $NUM % 2`<br>   if [ $Q -eq 0 ]<br>   then<br>      echo &quot;Number is an even number!!&quot;<br>      continue<br>   fi<br>   echo &quot;Found odd number&quot;<br>done<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"until-循环\"><a href=\"#until-循环\" class=\"headerlink\" title=\"until 循环\"></a>until 循环</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>a=10<br><br>until [ $a -lt 10 ]<br>do<br>   echo $a<br>   a=`expr $a + 1`<br>done<br></code></pre></td></tr></table></figure>\n\n\n"},{"layout":"post","title":"Shell 条件语句","date":"2022-02-24T16:00:00.000Z","_content":"  \n\n# shell 条件语句\n\n# if\n\n```shell\nif test-commands; then\n  consequent-commands;\n[elif more-test-commands; then\n  more-consequents;]\n[else alternate-consequents;]\nfi\n```\n\n## case\n\n```shell\ncase word in\n    [ [(] pattern [| pattern]…) command-list ;;]…\nesac\n```\n\n示例\n\n```shell\necho -n \"Enter the name of an animal: \"\nread ANIMAL\necho -n \"The $ANIMAL has \"\ncase $ANIMAL in\n  horse | dog | cat) echo -n \"four\";;\n  man | kangaroo ) echo -n \"two\";;\n  *) echo -n \"an unknown number of\";;\nesac\necho \" legs.\"\n```\n\n备注：\n\n1. `*)`相当于其他语言的default\n\n2. `;;`相当于break， `;&`相当于fall through\n\n3. `|`分割多个模式，相当于or\n","source":"_posts/Shell/2022-02-25-shell 条件语句.md","raw":"---\nlayout: post\ntitle: \"Shell 条件语句\"\ndate: 2022-02-25 \ntag: Shell\n---  \n\n# shell 条件语句\n\n# if\n\n```shell\nif test-commands; then\n  consequent-commands;\n[elif more-test-commands; then\n  more-consequents;]\n[else alternate-consequents;]\nfi\n```\n\n## case\n\n```shell\ncase word in\n    [ [(] pattern [| pattern]…) command-list ;;]…\nesac\n```\n\n示例\n\n```shell\necho -n \"Enter the name of an animal: \"\nread ANIMAL\necho -n \"The $ANIMAL has \"\ncase $ANIMAL in\n  horse | dog | cat) echo -n \"four\";;\n  man | kangaroo ) echo -n \"two\";;\n  *) echo -n \"an unknown number of\";;\nesac\necho \" legs.\"\n```\n\n备注：\n\n1. `*)`相当于其他语言的default\n\n2. `;;`相当于break， `;&`相当于fall through\n\n3. `|`分割多个模式，相当于or\n","slug":"Shell/2022-02-25-shell 条件语句","published":1,"updated":"2024-03-06T11:53:13.563Z","comments":1,"photos":[],"_id":"cltgopen6000eqywh5438ce5k","content":"<h1 id=\"shell-条件语句\"><a href=\"#shell-条件语句\" class=\"headerlink\" title=\"shell 条件语句\"></a>shell 条件语句</h1><h1 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">if test-commands; then<br>  consequent-commands;<br>[elif more-test-commands; then<br>  more-consequents;]<br>[else alternate-consequents;]<br>fi<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"case\"><a href=\"#case\" class=\"headerlink\" title=\"case\"></a>case</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">case word in<br>    [ [(] pattern [| pattern]…) command-list ;;]…<br>esac<br></code></pre></td></tr></table></figure>\n\n<p>示例</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">echo -n &quot;Enter the name of an animal: &quot;<br>read ANIMAL<br>echo -n &quot;The $ANIMAL has &quot;<br>case $ANIMAL in<br>  horse | dog | cat) echo -n &quot;four&quot;;;<br>  man | kangaroo ) echo -n &quot;two&quot;;;<br>  *) echo -n &quot;an unknown number of&quot;;;<br>esac<br>echo &quot; legs.&quot;<br></code></pre></td></tr></table></figure>\n\n<p>备注：</p>\n<ol>\n<li><p><code>*)</code>相当于其他语言的default</p>\n</li>\n<li><p><code>;;</code>相当于break， <code>;&amp;</code>相当于fall through</p>\n</li>\n<li><p><code>|</code>分割多个模式，相当于or</p>\n</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"shell-条件语句\"><a href=\"#shell-条件语句\" class=\"headerlink\" title=\"shell 条件语句\"></a>shell 条件语句</h1><h1 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">if test-commands; then<br>  consequent-commands;<br>[elif more-test-commands; then<br>  more-consequents;]<br>[else alternate-consequents;]<br>fi<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"case\"><a href=\"#case\" class=\"headerlink\" title=\"case\"></a>case</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">case word in<br>    [ [(] pattern [| pattern]…) command-list ;;]…<br>esac<br></code></pre></td></tr></table></figure>\n\n<p>示例</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">echo -n &quot;Enter the name of an animal: &quot;<br>read ANIMAL<br>echo -n &quot;The $ANIMAL has &quot;<br>case $ANIMAL in<br>  horse | dog | cat) echo -n &quot;four&quot;;;<br>  man | kangaroo ) echo -n &quot;two&quot;;;<br>  *) echo -n &quot;an unknown number of&quot;;;<br>esac<br>echo &quot; legs.&quot;<br></code></pre></td></tr></table></figure>\n\n<p>备注：</p>\n<ol>\n<li><p><code>*)</code>相当于其他语言的default</p>\n</li>\n<li><p><code>;;</code>相当于break， <code>;&amp;</code>相当于fall through</p>\n</li>\n<li><p><code>|</code>分割多个模式，相当于or</p>\n</li>\n</ol>\n"},{"layout":"post","title":"Shell 特殊变量","date":"2022-02-24T16:00:00.000Z","_content":"  \n\n# 特殊变量\n## $$\n\n当前 shell 的进程ID\n\n```shell\n$echo $$\n```\n\n输出当前进程的pid\n\n```\n➜  ~ echo $$\n19248\n```\n\n| $0  | 当前脚本的文件名                                           |\n| --- | -------------------------------------------------- |\n| $n  | 当前脚本的参数，从1开始 `$1`第一个参数，`$2`第二个参数，`$n`第n个参数         |\n| $#  | 脚本参数的总个数                                           |\n| $*  | 脚本参数集合，所有的参数被双引号包裹。如果脚本2个参数，`$*`=`\"$1 $2\"`         |\n| $@  | 脚本参数集合，每个参数被单独的双引号包裹。如果脚本2个参数，`$*`=`\"$1\" \"$2\"`     |\n| $?  | 上个命令的返回值。                                          |\n| $$  | 当前shell 的进程ID。                                     |\n| $!  | The process number of the last background command. |\n\n示例\n\n```shell\n#!/bin/sh\n\necho \"File Name: $0\"\necho \"First Parameter : $1\"\necho \"Second Parameter : $2\"\necho \"Quoted Values: $@\"\necho \"Quoted Values: $*\"\necho \"Total Number of Parameters : $#\"\n```\n\n输出\n\n```shell\n$./test.sh Zara Ali\nFile Name : ./test.sh\nFirst Parameter : Zara\nSecond Parameter : Ali\nQuoted Values: Zara Ali\nQuoted Values: Zara Ali\nTotal Number of Parameters : 2\n```\n\n## `$* `和`$@`\n\nthe `$*` special parameter takes the entire list as one argument with spaces between and the `$@` special parameter takes the entire list and separates it into separate arguments.\n\n```shell\n#!/bin/sh\n\nfor TOKEN in $*\ndo\n   echo $TOKEN\ndone\n```\n\n输出\n\n```shell\n$./test.sh Zara Ali 10 Years Old\nZara\nAli\n10\nYears\nOld\n```\n\n## `$?`\n\n检查上个命令是否执行成功。\n\n```shell\n➜  ~ pwd\n/Users/yxb\n➜  ~ echo $?\n0\n```\n\n\n","source":"_posts/Shell/2022-02-25-shell 特殊变量.md","raw":"---\nlayout: post\ntitle: \"Shell 特殊变量\"\ndate: 2022-02-25 \ntag: Shell\n---  \n\n# 特殊变量\n## $$\n\n当前 shell 的进程ID\n\n```shell\n$echo $$\n```\n\n输出当前进程的pid\n\n```\n➜  ~ echo $$\n19248\n```\n\n| $0  | 当前脚本的文件名                                           |\n| --- | -------------------------------------------------- |\n| $n  | 当前脚本的参数，从1开始 `$1`第一个参数，`$2`第二个参数，`$n`第n个参数         |\n| $#  | 脚本参数的总个数                                           |\n| $*  | 脚本参数集合，所有的参数被双引号包裹。如果脚本2个参数，`$*`=`\"$1 $2\"`         |\n| $@  | 脚本参数集合，每个参数被单独的双引号包裹。如果脚本2个参数，`$*`=`\"$1\" \"$2\"`     |\n| $?  | 上个命令的返回值。                                          |\n| $$  | 当前shell 的进程ID。                                     |\n| $!  | The process number of the last background command. |\n\n示例\n\n```shell\n#!/bin/sh\n\necho \"File Name: $0\"\necho \"First Parameter : $1\"\necho \"Second Parameter : $2\"\necho \"Quoted Values: $@\"\necho \"Quoted Values: $*\"\necho \"Total Number of Parameters : $#\"\n```\n\n输出\n\n```shell\n$./test.sh Zara Ali\nFile Name : ./test.sh\nFirst Parameter : Zara\nSecond Parameter : Ali\nQuoted Values: Zara Ali\nQuoted Values: Zara Ali\nTotal Number of Parameters : 2\n```\n\n## `$* `和`$@`\n\nthe `$*` special parameter takes the entire list as one argument with spaces between and the `$@` special parameter takes the entire list and separates it into separate arguments.\n\n```shell\n#!/bin/sh\n\nfor TOKEN in $*\ndo\n   echo $TOKEN\ndone\n```\n\n输出\n\n```shell\n$./test.sh Zara Ali 10 Years Old\nZara\nAli\n10\nYears\nOld\n```\n\n## `$?`\n\n检查上个命令是否执行成功。\n\n```shell\n➜  ~ pwd\n/Users/yxb\n➜  ~ echo $?\n0\n```\n\n\n","slug":"Shell/2022-02-25-shell 特殊变量","published":1,"updated":"2024-03-06T11:53:13.563Z","comments":1,"photos":[],"_id":"cltgopen6000gqywh0uyaca39","content":"<h1 id=\"特殊变量\"><a href=\"#特殊变量\" class=\"headerlink\" title=\"特殊变量\"></a>特殊变量</h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"$$\"></a>$$</h2><p>当前 shell 的进程ID</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\"><span class=\"hljs-built_in\">echo</span> $$</span><br></code></pre></td></tr></table></figure>\n\n<p>输出当前进程的pid</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\">➜  ~ echo <span class=\"hljs-symbol\">$</span><span class=\"hljs-symbol\">$</span><br><span class=\"hljs-number\">19248</span><br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>$0</th>\n<th>当前脚本的文件名</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$n</td>\n<td>当前脚本的参数，从1开始 <code>$1</code>第一个参数，<code>$2</code>第二个参数，<code>$n</code>第n个参数</td>\n</tr>\n<tr>\n<td>$#</td>\n<td>脚本参数的总个数</td>\n</tr>\n<tr>\n<td>$*</td>\n<td>脚本参数集合，所有的参数被双引号包裹。如果脚本2个参数，<code>$*</code>&#x3D;<code>&quot;$1 $2&quot;</code></td>\n</tr>\n<tr>\n<td>$@</td>\n<td>脚本参数集合，每个参数被单独的双引号包裹。如果脚本2个参数，<code>$*</code>&#x3D;<code>&quot;$1&quot; &quot;$2&quot;</code></td>\n</tr>\n<tr>\n<td>$?</td>\n<td>上个命令的返回值。</td>\n</tr>\n<tr>\n<td>$$</td>\n<td>当前shell 的进程ID。</td>\n</tr>\n<tr>\n<td>$!</td>\n<td>The process number of the last background command.</td>\n</tr>\n</tbody></table>\n<p>示例</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>echo &quot;File Name: $0&quot;<br>echo &quot;First Parameter : $1&quot;<br>echo &quot;Second Parameter : $2&quot;<br>echo &quot;Quoted Values: $@&quot;<br>echo &quot;Quoted Values: $*&quot;<br>echo &quot;Total Number of Parameters : $#&quot;<br></code></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\">./test.sh Zara Ali</span><br>File Name : ./test.sh<br>First Parameter : Zara<br>Second Parameter : Ali<br>Quoted Values: Zara Ali<br>Quoted Values: Zara Ali<br>Total Number of Parameters : 2<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"和\"><a href=\"#和\" class=\"headerlink\" title=\"$* 和$@\"></a><code>$* </code>和<code>$@</code></h2><p>the <code>$*</code> special parameter takes the entire list as one argument with spaces between and the <code>$@</code> special parameter takes the entire list and separates it into separate arguments.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>for TOKEN in $*<br>do<br>   echo $TOKEN<br>done<br></code></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\">./test.sh Zara Ali 10 Years Old</span><br>Zara<br>Ali<br>10<br>Years<br>Old<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"$?\"></a><code>$?</code></h2><p>检查上个命令是否执行成功。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">➜  ~ pwd<br>/Users/yxb<br>➜  ~ echo $?<br>0<br></code></pre></td></tr></table></figure>\n\n\n","excerpt":"","more":"<h1 id=\"特殊变量\"><a href=\"#特殊变量\" class=\"headerlink\" title=\"特殊变量\"></a>特殊变量</h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"$$\"></a>$$</h2><p>当前 shell 的进程ID</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\"><span class=\"hljs-built_in\">echo</span> $$</span><br></code></pre></td></tr></table></figure>\n\n<p>输出当前进程的pid</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\">➜  ~ echo <span class=\"hljs-symbol\">$</span><span class=\"hljs-symbol\">$</span><br><span class=\"hljs-number\">19248</span><br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>$0</th>\n<th>当前脚本的文件名</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$n</td>\n<td>当前脚本的参数，从1开始 <code>$1</code>第一个参数，<code>$2</code>第二个参数，<code>$n</code>第n个参数</td>\n</tr>\n<tr>\n<td>$#</td>\n<td>脚本参数的总个数</td>\n</tr>\n<tr>\n<td>$*</td>\n<td>脚本参数集合，所有的参数被双引号包裹。如果脚本2个参数，<code>$*</code>&#x3D;<code>&quot;$1 $2&quot;</code></td>\n</tr>\n<tr>\n<td>$@</td>\n<td>脚本参数集合，每个参数被单独的双引号包裹。如果脚本2个参数，<code>$*</code>&#x3D;<code>&quot;$1&quot; &quot;$2&quot;</code></td>\n</tr>\n<tr>\n<td>$?</td>\n<td>上个命令的返回值。</td>\n</tr>\n<tr>\n<td>$$</td>\n<td>当前shell 的进程ID。</td>\n</tr>\n<tr>\n<td>$!</td>\n<td>The process number of the last background command.</td>\n</tr>\n</tbody></table>\n<p>示例</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>echo &quot;File Name: $0&quot;<br>echo &quot;First Parameter : $1&quot;<br>echo &quot;Second Parameter : $2&quot;<br>echo &quot;Quoted Values: $@&quot;<br>echo &quot;Quoted Values: $*&quot;<br>echo &quot;Total Number of Parameters : $#&quot;<br></code></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\">./test.sh Zara Ali</span><br>File Name : ./test.sh<br>First Parameter : Zara<br>Second Parameter : Ali<br>Quoted Values: Zara Ali<br>Quoted Values: Zara Ali<br>Total Number of Parameters : 2<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"和\"><a href=\"#和\" class=\"headerlink\" title=\"$* 和$@\"></a><code>$* </code>和<code>$@</code></h2><p>the <code>$*</code> special parameter takes the entire list as one argument with spaces between and the <code>$@</code> special parameter takes the entire list and separates it into separate arguments.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>for TOKEN in $*<br>do<br>   echo $TOKEN<br>done<br></code></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\">./test.sh Zara Ali 10 Years Old</span><br>Zara<br>Ali<br>10<br>Years<br>Old<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"$?\"></a><code>$?</code></h2><p>检查上个命令是否执行成功。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">➜  ~ pwd<br>/Users/yxb<br>➜  ~ echo $?<br>0<br></code></pre></td></tr></table></figure>\n\n\n"},{"layout":"post","title":"Shell 运算符","date":"2022-02-24T16:00:00.000Z","_content":"  \n\n# shell 运算符\n\n参考：[Unix / Linux - Shell Basic Operators](https://www.tutorialspoint.com/unix/unix-basic-operators.htm)\n\n## 算数运算符\n\nshell 本身不支持算数运算，使用`awk`  或者`expr`来实现。\n\n示例： 两数相加\n\n```shell\n#!/bin/sh\n\nval=`expr 2 + 2`\necho \"Total value : $val\"\n```\n\n结果\n\n```shell\nTotal value : 4\n```\n\n\n\n假设a=10，b=20\n\n| 运算符 | 描述   | 示例                     |\n| --- | ---- | ---------------------- |\n| +   | 加    | `expr $a + $b`   =  30 |\n| -   | 减    | `expr $a - $b` = -10   |\n| *   | 乘    | `expr $a \\* $b` = 200  |\n| /   | 除    | `expr $b / $a` = 2     |\n| %   | 求余   | `expr $b % $a` = 0     |\n| =   | 赋值   | `a = $b`               |\n| ==  | 判断相等 | `[ $a == $b ]`         |\n| !=  | 不等   | `[ $a != $b ]`         |\n\n## 关系运算符\n\n假设a=10, b=20\n\n| 运算符 | 描述   | 示例                           |\n| --- | ---- | ---------------------------- |\n| -eq | 相等   | `[ $a -eq $b ]` is not true. |\n| -ne | 不等   | `[ $a -ne $b ] `is true.     |\n| -gt | 大于   | `[ $a -gt $b ]` is not true. |\n| -lt | 小于   | `[ $a -lt $b ]` is true.     |\n| -ge | 大于等于 | `[ $a -ge $b ]` is not true. |\n| -le | 小于等于 | `[ $a -le $b ]` is true.     |\n\n## 逻辑运算符\n\n假设a=10, b=20\n\n| 运算符 | 描述  | 示例                                      |\n| --- | --- | --------------------------------------- |\n| !   | 逻辑非 | `[ ! false ]` is true.                  |\n| -o  | 逻辑或 | `[ $a -lt 20 -o $b -gt 100 ]` is true.  |\n| -a  | 逻辑与 | `[ $a -lt 20 -a $b -gt 100 ]` is false. |\n\n## 字符串运算符\n\n假设 a=\"abc\", b =\"efg\"\n\n| 运算符 | 描述                       | 示例                          |\n| --- | ------------------------ | --------------------------- |\n| =   | 相等                       | `[ $a = $b ]`  is not true. |\n| !=  | 不等                       | `[ $a != $b ]` is true.     |\n| -z  | 是否为空,  为空为true， 不空 false | `[ -z $a ]`  is not true.   |\n| -n  | 是否非空， 非空为true， 空为false   | `[ -n $a ]` is not false.   |\n| str | 是否非空，非空为true， 空为false    | `[ $a ]` is not false.      |\n\n## 文件测试运算符\n\n| 运算符     | 描述            | 示例             |\n| ------- | ------------- | -------------- |\n| -d file | 检测 file 是否是目录 | `[ -d $file ]` |\n| -f file | 检测是否是普通文件     | `[ -f $file ]` |\n| -r file | 是否可读          | `[ -r $file ]` |\n| -w file | 是否可写          | `[ -w $file ]` |\n| -x file | 是否可执行         | `[ -x $file ]` |\n| -s file | 文件大小是否大于0     | `[ -s $file ]` |\n| -e file | 文件是否存在        | `[ -e $file ]` |\n\n\n","source":"_posts/Shell/2022-02-25-shell 运算符.md","raw":"---\nlayout: post\ntitle: \"Shell 运算符\"\ndate: 2022-02-25 \ntag: Shell\n---  \n\n# shell 运算符\n\n参考：[Unix / Linux - Shell Basic Operators](https://www.tutorialspoint.com/unix/unix-basic-operators.htm)\n\n## 算数运算符\n\nshell 本身不支持算数运算，使用`awk`  或者`expr`来实现。\n\n示例： 两数相加\n\n```shell\n#!/bin/sh\n\nval=`expr 2 + 2`\necho \"Total value : $val\"\n```\n\n结果\n\n```shell\nTotal value : 4\n```\n\n\n\n假设a=10，b=20\n\n| 运算符 | 描述   | 示例                     |\n| --- | ---- | ---------------------- |\n| +   | 加    | `expr $a + $b`   =  30 |\n| -   | 减    | `expr $a - $b` = -10   |\n| *   | 乘    | `expr $a \\* $b` = 200  |\n| /   | 除    | `expr $b / $a` = 2     |\n| %   | 求余   | `expr $b % $a` = 0     |\n| =   | 赋值   | `a = $b`               |\n| ==  | 判断相等 | `[ $a == $b ]`         |\n| !=  | 不等   | `[ $a != $b ]`         |\n\n## 关系运算符\n\n假设a=10, b=20\n\n| 运算符 | 描述   | 示例                           |\n| --- | ---- | ---------------------------- |\n| -eq | 相等   | `[ $a -eq $b ]` is not true. |\n| -ne | 不等   | `[ $a -ne $b ] `is true.     |\n| -gt | 大于   | `[ $a -gt $b ]` is not true. |\n| -lt | 小于   | `[ $a -lt $b ]` is true.     |\n| -ge | 大于等于 | `[ $a -ge $b ]` is not true. |\n| -le | 小于等于 | `[ $a -le $b ]` is true.     |\n\n## 逻辑运算符\n\n假设a=10, b=20\n\n| 运算符 | 描述  | 示例                                      |\n| --- | --- | --------------------------------------- |\n| !   | 逻辑非 | `[ ! false ]` is true.                  |\n| -o  | 逻辑或 | `[ $a -lt 20 -o $b -gt 100 ]` is true.  |\n| -a  | 逻辑与 | `[ $a -lt 20 -a $b -gt 100 ]` is false. |\n\n## 字符串运算符\n\n假设 a=\"abc\", b =\"efg\"\n\n| 运算符 | 描述                       | 示例                          |\n| --- | ------------------------ | --------------------------- |\n| =   | 相等                       | `[ $a = $b ]`  is not true. |\n| !=  | 不等                       | `[ $a != $b ]` is true.     |\n| -z  | 是否为空,  为空为true， 不空 false | `[ -z $a ]`  is not true.   |\n| -n  | 是否非空， 非空为true， 空为false   | `[ -n $a ]` is not false.   |\n| str | 是否非空，非空为true， 空为false    | `[ $a ]` is not false.      |\n\n## 文件测试运算符\n\n| 运算符     | 描述            | 示例             |\n| ------- | ------------- | -------------- |\n| -d file | 检测 file 是否是目录 | `[ -d $file ]` |\n| -f file | 检测是否是普通文件     | `[ -f $file ]` |\n| -r file | 是否可读          | `[ -r $file ]` |\n| -w file | 是否可写          | `[ -w $file ]` |\n| -x file | 是否可执行         | `[ -x $file ]` |\n| -s file | 文件大小是否大于0     | `[ -s $file ]` |\n| -e file | 文件是否存在        | `[ -e $file ]` |\n\n\n","slug":"Shell/2022-02-25-shell 运算符","published":1,"updated":"2024-03-06T11:53:13.563Z","comments":1,"photos":[],"_id":"cltgopen7000iqywh01h7h05y","content":"<h1 id=\"shell-运算符\"><a href=\"#shell-运算符\" class=\"headerlink\" title=\"shell 运算符\"></a>shell 运算符</h1><p>参考：<a href=\"https://www.tutorialspoint.com/unix/unix-basic-operators.htm\">Unix &#x2F; Linux - Shell Basic Operators</a></p>\n<h2 id=\"算数运算符\"><a href=\"#算数运算符\" class=\"headerlink\" title=\"算数运算符\"></a>算数运算符</h2><p>shell 本身不支持算数运算，使用<code>awk</code>  或者<code>expr</code>来实现。</p>\n<p>示例： 两数相加</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>val=`expr 2 + 2`<br>echo &quot;Total value : $val&quot;<br></code></pre></td></tr></table></figure>\n\n<p>结果</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">Total value : 4<br></code></pre></td></tr></table></figure>\n\n\n\n<p>假设a&#x3D;10，b&#x3D;20</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td>加</td>\n<td><code>expr $a + $b</code>   &#x3D;  30</td>\n</tr>\n<tr>\n<td>-</td>\n<td>减</td>\n<td><code>expr $a - $b</code> &#x3D; -10</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘</td>\n<td><code>expr $a \\* $b</code> &#x3D; 200</td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td>除</td>\n<td><code>expr $b / $a</code> &#x3D; 2</td>\n</tr>\n<tr>\n<td>%</td>\n<td>求余</td>\n<td><code>expr $b % $a</code> &#x3D; 0</td>\n</tr>\n<tr>\n<td>&#x3D;</td>\n<td>赋值</td>\n<td><code>a = $b</code></td>\n</tr>\n<tr>\n<td>&#x3D;&#x3D;</td>\n<td>判断相等</td>\n<td><code>[ $a == $b ]</code></td>\n</tr>\n<tr>\n<td>!&#x3D;</td>\n<td>不等</td>\n<td><code>[ $a != $b ]</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h2><p>假设a&#x3D;10, b&#x3D;20</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-eq</td>\n<td>相等</td>\n<td><code>[ $a -eq $b ]</code> is not true.</td>\n</tr>\n<tr>\n<td>-ne</td>\n<td>不等</td>\n<td><code>[ $a -ne $b ] </code>is true.</td>\n</tr>\n<tr>\n<td>-gt</td>\n<td>大于</td>\n<td><code>[ $a -gt $b ]</code> is not true.</td>\n</tr>\n<tr>\n<td>-lt</td>\n<td>小于</td>\n<td><code>[ $a -lt $b ]</code> is true.</td>\n</tr>\n<tr>\n<td>-ge</td>\n<td>大于等于</td>\n<td><code>[ $a -ge $b ]</code> is not true.</td>\n</tr>\n<tr>\n<td>-le</td>\n<td>小于等于</td>\n<td><code>[ $a -le $b ]</code> is true.</td>\n</tr>\n</tbody></table>\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h2><p>假设a&#x3D;10, b&#x3D;20</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>!</td>\n<td>逻辑非</td>\n<td><code>[ ! false ]</code> is true.</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>逻辑或</td>\n<td><code>[ $a -lt 20 -o $b -gt 100 ]</code> is true.</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>逻辑与</td>\n<td><code>[ $a -lt 20 -a $b -gt 100 ]</code> is false.</td>\n</tr>\n</tbody></table>\n<h2 id=\"字符串运算符\"><a href=\"#字符串运算符\" class=\"headerlink\" title=\"字符串运算符\"></a>字符串运算符</h2><p>假设 a&#x3D;”abc”, b &#x3D;”efg”</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&#x3D;</td>\n<td>相等</td>\n<td><code>[ $a = $b ]</code>  is not true.</td>\n</tr>\n<tr>\n<td>!&#x3D;</td>\n<td>不等</td>\n<td><code>[ $a != $b ]</code> is true.</td>\n</tr>\n<tr>\n<td>-z</td>\n<td>是否为空,  为空为true， 不空 false</td>\n<td><code>[ -z $a ]</code>  is not true.</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>是否非空， 非空为true， 空为false</td>\n<td><code>[ -n $a ]</code> is not false.</td>\n</tr>\n<tr>\n<td>str</td>\n<td>是否非空，非空为true， 空为false</td>\n<td><code>[ $a ]</code> is not false.</td>\n</tr>\n</tbody></table>\n<h2 id=\"文件测试运算符\"><a href=\"#文件测试运算符\" class=\"headerlink\" title=\"文件测试运算符\"></a>文件测试运算符</h2><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-d file</td>\n<td>检测 file 是否是目录</td>\n<td><code>[ -d $file ]</code></td>\n</tr>\n<tr>\n<td>-f file</td>\n<td>检测是否是普通文件</td>\n<td><code>[ -f $file ]</code></td>\n</tr>\n<tr>\n<td>-r file</td>\n<td>是否可读</td>\n<td><code>[ -r $file ]</code></td>\n</tr>\n<tr>\n<td>-w file</td>\n<td>是否可写</td>\n<td><code>[ -w $file ]</code></td>\n</tr>\n<tr>\n<td>-x file</td>\n<td>是否可执行</td>\n<td><code>[ -x $file ]</code></td>\n</tr>\n<tr>\n<td>-s file</td>\n<td>文件大小是否大于0</td>\n<td><code>[ -s $file ]</code></td>\n</tr>\n<tr>\n<td>-e file</td>\n<td>文件是否存在</td>\n<td><code>[ -e $file ]</code></td>\n</tr>\n</tbody></table>\n","excerpt":"","more":"<h1 id=\"shell-运算符\"><a href=\"#shell-运算符\" class=\"headerlink\" title=\"shell 运算符\"></a>shell 运算符</h1><p>参考：<a href=\"https://www.tutorialspoint.com/unix/unix-basic-operators.htm\">Unix &#x2F; Linux - Shell Basic Operators</a></p>\n<h2 id=\"算数运算符\"><a href=\"#算数运算符\" class=\"headerlink\" title=\"算数运算符\"></a>算数运算符</h2><p>shell 本身不支持算数运算，使用<code>awk</code>  或者<code>expr</code>来实现。</p>\n<p>示例： 两数相加</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><br>val=`expr 2 + 2`<br>echo &quot;Total value : $val&quot;<br></code></pre></td></tr></table></figure>\n\n<p>结果</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">Total value : 4<br></code></pre></td></tr></table></figure>\n\n\n\n<p>假设a&#x3D;10，b&#x3D;20</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td>加</td>\n<td><code>expr $a + $b</code>   &#x3D;  30</td>\n</tr>\n<tr>\n<td>-</td>\n<td>减</td>\n<td><code>expr $a - $b</code> &#x3D; -10</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘</td>\n<td><code>expr $a \\* $b</code> &#x3D; 200</td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td>除</td>\n<td><code>expr $b / $a</code> &#x3D; 2</td>\n</tr>\n<tr>\n<td>%</td>\n<td>求余</td>\n<td><code>expr $b % $a</code> &#x3D; 0</td>\n</tr>\n<tr>\n<td>&#x3D;</td>\n<td>赋值</td>\n<td><code>a = $b</code></td>\n</tr>\n<tr>\n<td>&#x3D;&#x3D;</td>\n<td>判断相等</td>\n<td><code>[ $a == $b ]</code></td>\n</tr>\n<tr>\n<td>!&#x3D;</td>\n<td>不等</td>\n<td><code>[ $a != $b ]</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h2><p>假设a&#x3D;10, b&#x3D;20</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-eq</td>\n<td>相等</td>\n<td><code>[ $a -eq $b ]</code> is not true.</td>\n</tr>\n<tr>\n<td>-ne</td>\n<td>不等</td>\n<td><code>[ $a -ne $b ] </code>is true.</td>\n</tr>\n<tr>\n<td>-gt</td>\n<td>大于</td>\n<td><code>[ $a -gt $b ]</code> is not true.</td>\n</tr>\n<tr>\n<td>-lt</td>\n<td>小于</td>\n<td><code>[ $a -lt $b ]</code> is true.</td>\n</tr>\n<tr>\n<td>-ge</td>\n<td>大于等于</td>\n<td><code>[ $a -ge $b ]</code> is not true.</td>\n</tr>\n<tr>\n<td>-le</td>\n<td>小于等于</td>\n<td><code>[ $a -le $b ]</code> is true.</td>\n</tr>\n</tbody></table>\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h2><p>假设a&#x3D;10, b&#x3D;20</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>!</td>\n<td>逻辑非</td>\n<td><code>[ ! false ]</code> is true.</td>\n</tr>\n<tr>\n<td>-o</td>\n<td>逻辑或</td>\n<td><code>[ $a -lt 20 -o $b -gt 100 ]</code> is true.</td>\n</tr>\n<tr>\n<td>-a</td>\n<td>逻辑与</td>\n<td><code>[ $a -lt 20 -a $b -gt 100 ]</code> is false.</td>\n</tr>\n</tbody></table>\n<h2 id=\"字符串运算符\"><a href=\"#字符串运算符\" class=\"headerlink\" title=\"字符串运算符\"></a>字符串运算符</h2><p>假设 a&#x3D;”abc”, b &#x3D;”efg”</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&#x3D;</td>\n<td>相等</td>\n<td><code>[ $a = $b ]</code>  is not true.</td>\n</tr>\n<tr>\n<td>!&#x3D;</td>\n<td>不等</td>\n<td><code>[ $a != $b ]</code> is true.</td>\n</tr>\n<tr>\n<td>-z</td>\n<td>是否为空,  为空为true， 不空 false</td>\n<td><code>[ -z $a ]</code>  is not true.</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>是否非空， 非空为true， 空为false</td>\n<td><code>[ -n $a ]</code> is not false.</td>\n</tr>\n<tr>\n<td>str</td>\n<td>是否非空，非空为true， 空为false</td>\n<td><code>[ $a ]</code> is not false.</td>\n</tr>\n</tbody></table>\n<h2 id=\"文件测试运算符\"><a href=\"#文件测试运算符\" class=\"headerlink\" title=\"文件测试运算符\"></a>文件测试运算符</h2><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-d file</td>\n<td>检测 file 是否是目录</td>\n<td><code>[ -d $file ]</code></td>\n</tr>\n<tr>\n<td>-f file</td>\n<td>检测是否是普通文件</td>\n<td><code>[ -f $file ]</code></td>\n</tr>\n<tr>\n<td>-r file</td>\n<td>是否可读</td>\n<td><code>[ -r $file ]</code></td>\n</tr>\n<tr>\n<td>-w file</td>\n<td>是否可写</td>\n<td><code>[ -w $file ]</code></td>\n</tr>\n<tr>\n<td>-x file</td>\n<td>是否可执行</td>\n<td><code>[ -x $file ]</code></td>\n</tr>\n<tr>\n<td>-s file</td>\n<td>文件大小是否大于0</td>\n<td><code>[ -s $file ]</code></td>\n</tr>\n<tr>\n<td>-e file</td>\n<td>文件是否存在</td>\n<td><code>[ -e $file ]</code></td>\n</tr>\n</tbody></table>\n"},{"layout":"post","title":"Shell 脚本，带名字的参数","date":"2022-02-24T16:00:00.000Z","_content":"\n# shell 脚本，带名字的参数\n\n参考： [bash - Passing named arguments to shell scripts - Unix &amp; Linux Stack Exchange](https://unix.stackexchange.com/questions/129391/passing-named-arguments-to-shell-scripts)\n\nFrom [3.5.3 Shell Parameter Expansion](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#index-parameter-expansion) of the GNU Bash manual:\n\n> **`${parameter:-word}`**  \n> If parameter is unset or null, the expansion of word is substituted. Otherwise, the value of parameter is substituted.\n\n```shell\n#!/usr/bin/env bash\n\nwhile [ $# -gt 0 ]; do\n  case \"$1\" in\n    -p|-p_out|--p_out)\n      p_out=\"$2\"\n      ;;\n    -a|-arg_1|--arg_1)\n      arg_1=\"$2\"\n      ;;\n    *)\n      printf \"***************************\\n\"\n      printf \"* Error: Invalid argument.*\\n\"\n      printf \"***************************\\n\"\n      exit 1\n  esac\n  shift\n  shift\ndone\n\necho \"Without default values:\"\necho \"p_out: ${p_out}\"\necho \"arg_1: ${arg_1}\"\necho\necho \"With default values:\"\necho \"p_out: ${p_out:-\\\"27\\\"}\"\necho \"arg_1: ${arg_1:-\\\"smarties cereal\\\"}\"\n```\n\n调用方式\n\n```shel\n$ ./my-script.sh -a \"lofa\" -p \"miez\"\n$ ./my-script.sh -arg_1 \"lofa\" --p_out \"miez\"\n$ ./my-script.sh --arg_1 \"lofa\" -p \"miez\"\n```\n","source":"_posts/Shell/2022-03-09-shell 脚本，带名字的参数.md","raw":"---\n\nlayout: post\ntitle: \"Shell 脚本，带名字的参数\"\ndate: 2022-02-25 \ntag: Shell\n\n---\n\n# shell 脚本，带名字的参数\n\n参考： [bash - Passing named arguments to shell scripts - Unix &amp; Linux Stack Exchange](https://unix.stackexchange.com/questions/129391/passing-named-arguments-to-shell-scripts)\n\nFrom [3.5.3 Shell Parameter Expansion](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#index-parameter-expansion) of the GNU Bash manual:\n\n> **`${parameter:-word}`**  \n> If parameter is unset or null, the expansion of word is substituted. Otherwise, the value of parameter is substituted.\n\n```shell\n#!/usr/bin/env bash\n\nwhile [ $# -gt 0 ]; do\n  case \"$1\" in\n    -p|-p_out|--p_out)\n      p_out=\"$2\"\n      ;;\n    -a|-arg_1|--arg_1)\n      arg_1=\"$2\"\n      ;;\n    *)\n      printf \"***************************\\n\"\n      printf \"* Error: Invalid argument.*\\n\"\n      printf \"***************************\\n\"\n      exit 1\n  esac\n  shift\n  shift\ndone\n\necho \"Without default values:\"\necho \"p_out: ${p_out}\"\necho \"arg_1: ${arg_1}\"\necho\necho \"With default values:\"\necho \"p_out: ${p_out:-\\\"27\\\"}\"\necho \"arg_1: ${arg_1:-\\\"smarties cereal\\\"}\"\n```\n\n调用方式\n\n```shel\n$ ./my-script.sh -a \"lofa\" -p \"miez\"\n$ ./my-script.sh -arg_1 \"lofa\" --p_out \"miez\"\n$ ./my-script.sh --arg_1 \"lofa\" -p \"miez\"\n```\n","slug":"Shell/2022-03-09-shell 脚本，带名字的参数","published":1,"updated":"2024-03-06T11:53:13.563Z","comments":1,"photos":[],"_id":"cltgopen7000kqywh30fl34ny","content":"<h1 id=\"shell-脚本，带名字的参数\"><a href=\"#shell-脚本，带名字的参数\" class=\"headerlink\" title=\"shell 脚本，带名字的参数\"></a>shell 脚本，带名字的参数</h1><p>参考： <a href=\"https://unix.stackexchange.com/questions/129391/passing-named-arguments-to-shell-scripts\">bash - Passing named arguments to shell scripts - Unix &amp; Linux Stack Exchange</a></p>\n<p>From <a href=\"https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#index-parameter-expansion\">3.5.3 Shell Parameter Expansion</a> of the GNU Bash manual:</p>\n<blockquote>\n<p><strong><code>$&#123;parameter:-word&#125;</code></strong><br>If parameter is unset or null, the expansion of word is substituted. Otherwise, the value of parameter is substituted.</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/usr/bin/env bash</span><br><br>while [ $# -gt 0 ]; do<br>  case &quot;$1&quot; in<br>    -p|-p_out|--p_out)<br>      p_out=&quot;$2&quot;<br>      ;;<br>    -a|-arg_1|--arg_1)<br>      arg_1=&quot;$2&quot;<br>      ;;<br>    *)<br>      printf &quot;***************************\\n&quot;<br>      printf &quot;* Error: Invalid argument.*\\n&quot;<br>      printf &quot;***************************\\n&quot;<br>      exit 1<br>  esac<br>  shift<br>  shift<br>done<br><br>echo &quot;Without default values:&quot;<br>echo &quot;p_out: $&#123;p_out&#125;&quot;<br>echo &quot;arg_1: $&#123;arg_1&#125;&quot;<br>echo<br>echo &quot;With default values:&quot;<br>echo &quot;p_out: $&#123;p_out:-\\&quot;27\\&quot;&#125;&quot;<br>echo &quot;arg_1: $&#123;arg_1:-\\&quot;smarties cereal\\&quot;&#125;&quot;<br></code></pre></td></tr></table></figure>\n\n<p>调用方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shel\">$ ./my-script.sh -a &quot;lofa&quot; -p &quot;miez&quot;<br>$ ./my-script.sh -arg_1 &quot;lofa&quot; --p_out &quot;miez&quot;<br>$ ./my-script.sh --arg_1 &quot;lofa&quot; -p &quot;miez&quot;<br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"shell-脚本，带名字的参数\"><a href=\"#shell-脚本，带名字的参数\" class=\"headerlink\" title=\"shell 脚本，带名字的参数\"></a>shell 脚本，带名字的参数</h1><p>参考： <a href=\"https://unix.stackexchange.com/questions/129391/passing-named-arguments-to-shell-scripts\">bash - Passing named arguments to shell scripts - Unix &amp; Linux Stack Exchange</a></p>\n<p>From <a href=\"https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#index-parameter-expansion\">3.5.3 Shell Parameter Expansion</a> of the GNU Bash manual:</p>\n<blockquote>\n<p><strong><code>$&#123;parameter:-word&#125;</code></strong><br>If parameter is unset or null, the expansion of word is substituted. Otherwise, the value of parameter is substituted.</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/usr/bin/env bash</span><br><br>while [ $# -gt 0 ]; do<br>  case &quot;$1&quot; in<br>    -p|-p_out|--p_out)<br>      p_out=&quot;$2&quot;<br>      ;;<br>    -a|-arg_1|--arg_1)<br>      arg_1=&quot;$2&quot;<br>      ;;<br>    *)<br>      printf &quot;***************************\\n&quot;<br>      printf &quot;* Error: Invalid argument.*\\n&quot;<br>      printf &quot;***************************\\n&quot;<br>      exit 1<br>  esac<br>  shift<br>  shift<br>done<br><br>echo &quot;Without default values:&quot;<br>echo &quot;p_out: $&#123;p_out&#125;&quot;<br>echo &quot;arg_1: $&#123;arg_1&#125;&quot;<br>echo<br>echo &quot;With default values:&quot;<br>echo &quot;p_out: $&#123;p_out:-\\&quot;27\\&quot;&#125;&quot;<br>echo &quot;arg_1: $&#123;arg_1:-\\&quot;smarties cereal\\&quot;&#125;&quot;<br></code></pre></td></tr></table></figure>\n\n<p>调用方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shel\">$ ./my-script.sh -a &quot;lofa&quot; -p &quot;miez&quot;<br>$ ./my-script.sh -arg_1 &quot;lofa&quot; --p_out &quot;miez&quot;<br>$ ./my-script.sh --arg_1 &quot;lofa&quot; -p &quot;miez&quot;<br></code></pre></td></tr></table></figure>\n"},{"layout":"post","title":"命令行重启iPhone","date":"2022-11-15T16:00:00.000Z","_content":"  \n\n\n参考： [Any way to reboot a iDevice that is connected to a USB port via terminal (Mac terminal)?](https://apple.stackexchange.com/questions/150880/any-way-to-reboot-a-idevice-that-is-connected-to-a-usb-port-via-terminal-mac-te)\n\n\n安装`libimobiledevice`\n```\nbrew install libimobiledevice\n\n```\n使用\n\n```\nidevicediagnostics restart\n```\n","source":"_posts/Shell/2022-11-16-命令行重启iPhone.md","raw":"---\nlayout: post\ntitle: \"命令行重启iPhone\"\ndate: 2022-11-16\ntag: Shell\n---  \n\n\n参考： [Any way to reboot a iDevice that is connected to a USB port via terminal (Mac terminal)?](https://apple.stackexchange.com/questions/150880/any-way-to-reboot-a-idevice-that-is-connected-to-a-usb-port-via-terminal-mac-te)\n\n\n安装`libimobiledevice`\n```\nbrew install libimobiledevice\n\n```\n使用\n\n```\nidevicediagnostics restart\n```\n","slug":"Shell/2022-11-16-命令行重启iPhone","published":1,"updated":"2024-03-06T11:53:13.563Z","comments":1,"photos":[],"_id":"cltgopen7000mqywh80aa5bdx","content":"<p>参考： <a href=\"https://apple.stackexchange.com/questions/150880/any-way-to-reboot-a-idevice-that-is-connected-to-a-usb-port-via-terminal-mac-te\">Any way to reboot a iDevice that is connected to a USB port via terminal (Mac terminal)?</a></p>\n<p>安装<code>libimobiledevice</code></p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">brew </span><span class=\"hljs-keyword\">install </span>libimobiledevice<br><br></code></pre></td></tr></table></figure>\n<p>使用</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">idevicediagnostics restart</span><br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>参考： <a href=\"https://apple.stackexchange.com/questions/150880/any-way-to-reboot-a-idevice-that-is-connected-to-a-usb-port-via-terminal-mac-te\">Any way to reboot a iDevice that is connected to a USB port via terminal (Mac terminal)?</a></p>\n<p>安装<code>libimobiledevice</code></p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">brew </span><span class=\"hljs-keyword\">install </span>libimobiledevice<br><br></code></pre></td></tr></table></figure>\n<p>使用</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">idevicediagnostics restart</span><br></code></pre></td></tr></table></figure>\n"},{"layout":"post","title":"oh my zsh prompt 展示当前路径","date":"2023-05-16T16:00:00.000Z","_content":"  \n\n\n使用的主题为\n\n```\nZSH_THEME=\"robbyrussell\"\n```\n\n修改配置, path `~/.oh-my-zsh/themes/robbyrussell.zsh-theme`, 将 `%c` 替换为 `%d`\n\n```\n\n# before\nPROMPT=\"%(?:%{$fg_bold[green]%}➜ :%{$fg_bold[red]%}➜ ) %{$fg[cyan]%}%c%{$reset_color%}\"\nPROMPT+=' $(git_prompt_info)'\n\n# after\nPROMPT=\"%(?:%{$fg_bold[green]%}➜ :%{$fg_bold[red]%}➜ )\"\nPROMPT+=' %{$fg[cyan]%}%d%{$reset_color%} $(git_prompt_info)'\n\n```\n\n参考： [EXPANSION_OF_PROMPT_SEQUENCES](https://links.jianshu.com/go?to=https%3A%2F%2Fjlk.fjfi.cvut.cz%2Farch%2Fmanpages%2Fman%2Fzshmisc.1%23EXPANSION_OF_PROMPT_SEQUENCES)\n\n\nShell state\n\n```\n%#\nA `#' if the shell is running with privileges, a `%' if not. Equivalent to `%(!.#.%%)'. The definition of `privileged', for these purposes, is that either the effective user ID is zero, or, if POSIX.1e capabilities are supported, that at least one capability is raised in either the Effective or Inheritable capability vectors.\n\n%?\nThe return status of the last command executed just before the prompt.\n\n%_\nThe status of the parser, i.e. the shell constructs (like `if' and `for') that have been started on the command line. If given an integer number that many strings will be printed; zero or negative or no integer means print as many as there are. This is most useful in prompts PS2 for continuation lines and PS4 for debugging with the XTRACE option; in the latter case it will also work non-interactively.\n\n%^\nThe status of the parser in reverse. This is the same as `%_' other than the order of strings. It is often used in RPS2.\n\n%d%/\nCurrent working directory. If an integer follows the `%', it specifies a number of trailing components of the current working directory to show; zero means the whole path. A negative integer specifies leading components, i.e. %-1d specifies the first component.\n\n%~\nAs %d and %/, but if the current working directory starts with $HOME, that part is replaced by a `~'. Furthermore, if it has a named directory as its prefix, that part is replaced by a `~' followed by the name of the directory, but only if the result is shorter than the full path; see Dynamic and Static named directories in zshexpn(1).\n\n%e\nEvaluation depth of the current sourced file, shell function, or eval. This is incremented or decremented every time the value of %N is set or reverted to a previous value, respectively. This is most useful for debugging as part of $PS4.\n\n%h%!\nCurrent history event number.\n\n%i\nThe line number currently being executed in the script, sourced file, or shell function given by %N. This is most useful for debugging as part of $PS4.\n\n%I\nThe line number currently being executed in the file %x. This is similar to %i, but the line number is always a line number in the file where the code was defined, even if the code is a shell function.\n\n%j\nThe number of jobs.\n\n%L\nThe current value of $SHLVL.\n\n%N\nThe name of the script, sourced file, or shell function that zsh is currently executing, whichever was started most recently. If there is none, this is equivalent to the parameter $0. An integer may follow the `%' to specify a number of trailing path components to show; zero means the full path. A negative integer specifies leading components.\n\n%x\nThe name of the file containing the source code currently being executed. This behaves as %N except that function and eval command names are not shown, instead the file where they were defined.\n\n%c%.%C\nTrailing component of the current working directory. An integer may follow the `%' to get more than one component. Unless `%C' is used, tilde contraction is performed first. These are deprecated as %c and %C are equivalent to %1~ and %1/, respectively, while explicit positive integers have the same effect as for the latter two sequences.\n\n```\n\n\n","source":"_posts/Shell/2023-05-17-oh my zsh 展示路径.md","raw":"---\nlayout: post\ntitle: \"oh my zsh prompt 展示当前路径\"\ndate: 2023-05-17 \ntag: Shell\n---  \n\n\n使用的主题为\n\n```\nZSH_THEME=\"robbyrussell\"\n```\n\n修改配置, path `~/.oh-my-zsh/themes/robbyrussell.zsh-theme`, 将 `%c` 替换为 `%d`\n\n```\n\n# before\nPROMPT=\"%(?:%{$fg_bold[green]%}➜ :%{$fg_bold[red]%}➜ ) %{$fg[cyan]%}%c%{$reset_color%}\"\nPROMPT+=' $(git_prompt_info)'\n\n# after\nPROMPT=\"%(?:%{$fg_bold[green]%}➜ :%{$fg_bold[red]%}➜ )\"\nPROMPT+=' %{$fg[cyan]%}%d%{$reset_color%} $(git_prompt_info)'\n\n```\n\n参考： [EXPANSION_OF_PROMPT_SEQUENCES](https://links.jianshu.com/go?to=https%3A%2F%2Fjlk.fjfi.cvut.cz%2Farch%2Fmanpages%2Fman%2Fzshmisc.1%23EXPANSION_OF_PROMPT_SEQUENCES)\n\n\nShell state\n\n```\n%#\nA `#' if the shell is running with privileges, a `%' if not. Equivalent to `%(!.#.%%)'. The definition of `privileged', for these purposes, is that either the effective user ID is zero, or, if POSIX.1e capabilities are supported, that at least one capability is raised in either the Effective or Inheritable capability vectors.\n\n%?\nThe return status of the last command executed just before the prompt.\n\n%_\nThe status of the parser, i.e. the shell constructs (like `if' and `for') that have been started on the command line. If given an integer number that many strings will be printed; zero or negative or no integer means print as many as there are. This is most useful in prompts PS2 for continuation lines and PS4 for debugging with the XTRACE option; in the latter case it will also work non-interactively.\n\n%^\nThe status of the parser in reverse. This is the same as `%_' other than the order of strings. It is often used in RPS2.\n\n%d%/\nCurrent working directory. If an integer follows the `%', it specifies a number of trailing components of the current working directory to show; zero means the whole path. A negative integer specifies leading components, i.e. %-1d specifies the first component.\n\n%~\nAs %d and %/, but if the current working directory starts with $HOME, that part is replaced by a `~'. Furthermore, if it has a named directory as its prefix, that part is replaced by a `~' followed by the name of the directory, but only if the result is shorter than the full path; see Dynamic and Static named directories in zshexpn(1).\n\n%e\nEvaluation depth of the current sourced file, shell function, or eval. This is incremented or decremented every time the value of %N is set or reverted to a previous value, respectively. This is most useful for debugging as part of $PS4.\n\n%h%!\nCurrent history event number.\n\n%i\nThe line number currently being executed in the script, sourced file, or shell function given by %N. This is most useful for debugging as part of $PS4.\n\n%I\nThe line number currently being executed in the file %x. This is similar to %i, but the line number is always a line number in the file where the code was defined, even if the code is a shell function.\n\n%j\nThe number of jobs.\n\n%L\nThe current value of $SHLVL.\n\n%N\nThe name of the script, sourced file, or shell function that zsh is currently executing, whichever was started most recently. If there is none, this is equivalent to the parameter $0. An integer may follow the `%' to specify a number of trailing path components to show; zero means the full path. A negative integer specifies leading components.\n\n%x\nThe name of the file containing the source code currently being executed. This behaves as %N except that function and eval command names are not shown, instead the file where they were defined.\n\n%c%.%C\nTrailing component of the current working directory. An integer may follow the `%' to get more than one component. Unless `%C' is used, tilde contraction is performed first. These are deprecated as %c and %C are equivalent to %1~ and %1/, respectively, while explicit positive integers have the same effect as for the latter two sequences.\n\n```\n\n\n","slug":"Shell/2023-05-17-oh my zsh 展示路径","published":1,"updated":"2024-03-06T11:53:13.563Z","comments":1,"photos":[],"_id":"cltgopen8000oqywhecwn2kzc","content":"<p>使用的主题为</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">ZSH_THEME</span>=<span class=\"hljs-string\">&quot;robbyrussell&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>修改配置, path <code>~/.oh-my-zsh/themes/robbyrussell.zsh-theme</code>, 将 <code>%c</code> 替换为 <code>%d</code></p>\n<figure class=\"highlight nsis\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nsis\"><br><span class=\"hljs-comment\"># before</span><br>PROMPT=<span class=\"hljs-string\">&quot;%(?:%&#123;<span class=\"hljs-variable\">$fg_bold</span>[green]%&#125;➜ :%&#123;<span class=\"hljs-variable\">$fg_bold</span>[red]%&#125;➜ ) %&#123;<span class=\"hljs-variable\">$fg</span>[cyan]%&#125;%c%&#123;<span class=\"hljs-variable\">$reset_color</span>%&#125;&quot;</span><br>PROMPT+=<span class=\"hljs-string\">&#x27; <span class=\"hljs-variable\">$(git_prompt_info)</span>&#x27;</span><br><br><span class=\"hljs-comment\"># after</span><br>PROMPT=<span class=\"hljs-string\">&quot;%(?:%&#123;<span class=\"hljs-variable\">$fg_bold</span>[green]%&#125;➜ :%&#123;<span class=\"hljs-variable\">$fg_bold</span>[red]%&#125;➜ )&quot;</span><br>PROMPT+=<span class=\"hljs-string\">&#x27; %&#123;<span class=\"hljs-variable\">$fg</span>[cyan]%&#125;%d%&#123;<span class=\"hljs-variable\">$reset_color</span>%&#125; <span class=\"hljs-variable\">$(git_prompt_info)</span>&#x27;</span><br><br></code></pre></td></tr></table></figure>\n\n<p>参考： <a href=\"https://links.jianshu.com/go?to=https://jlk.fjfi.cvut.cz/arch/manpages/man/zshmisc.1%23EXPANSION_OF_PROMPT_SEQUENCES\">EXPANSION_OF_PROMPT_SEQUENCES</a></p>\n<p>Shell state</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">%<span class=\"hljs-comment\">#</span><br>A `<span class=\"hljs-comment\">#&#x27; if the shell is running with privileges, a `%&#x27; if not. Equivalent to `%(!.#.%%)&#x27;. The definition of `privileged&#x27;, for these purposes, is that either the effective user ID is zero, or, if POSIX.1e capabilities are supported, that at least one capability is raised in either the Effective or Inheritable capability vectors.</span><br><br>%?<br>The <span class=\"hljs-literal\">return</span> status <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-keyword\">last</span> command executed just <span class=\"hljs-keyword\">before</span> <span class=\"hljs-keyword\">the</span> prompt.<br><br>%_<br>The status <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> parser, i.e. <span class=\"hljs-keyword\">the</span> shell constructs (like `<span class=\"hljs-keyword\">if</span>&#x27; <span class=\"hljs-keyword\">and</span> `<span class=\"hljs-keyword\">for</span>&#x27;) <span class=\"hljs-keyword\">that</span> have been started <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">the</span> command line. If <span class=\"hljs-keyword\">given</span> an <span class=\"hljs-built_in\">integer</span> <span class=\"hljs-built_in\">number</span> <span class=\"hljs-keyword\">that</span> many strings will be printed; zero <span class=\"hljs-keyword\">or</span> negative <span class=\"hljs-keyword\">or</span> no <span class=\"hljs-built_in\">integer</span> means print <span class=\"hljs-keyword\">as</span> many <span class=\"hljs-keyword\">as</span> there are. This <span class=\"hljs-keyword\">is</span> most useful <span class=\"hljs-keyword\">in</span> prompts PS2 <span class=\"hljs-keyword\">for</span> continuation lines <span class=\"hljs-keyword\">and</span> PS4 <span class=\"hljs-keyword\">for</span> debugging <span class=\"hljs-keyword\">with</span> <span class=\"hljs-keyword\">the</span> XTRACE option; <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">the</span> latter case <span class=\"hljs-keyword\">it</span> will also work non-interactively.<br><br>%^<br>The status <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> parser <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">reverse</span>. This <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">the</span> same <span class=\"hljs-keyword\">as</span> `%_&#x27; other than <span class=\"hljs-keyword\">the</span> order <span class=\"hljs-keyword\">of</span> strings. It <span class=\"hljs-keyword\">is</span> often used <span class=\"hljs-keyword\">in</span> RPS2.<br><br>%d%/<br>Current working directory. If an <span class=\"hljs-built_in\">integer</span> follows <span class=\"hljs-keyword\">the</span> `%&#x27;, <span class=\"hljs-keyword\">it</span> specifies a <span class=\"hljs-built_in\">number</span> <span class=\"hljs-keyword\">of</span> trailing components <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> current working directory <span class=\"hljs-keyword\">to</span> show; zero means <span class=\"hljs-keyword\">the</span> whole path. A negative <span class=\"hljs-built_in\">integer</span> specifies leading components, i.e. %<span class=\"hljs-number\">-1</span>d specifies <span class=\"hljs-keyword\">the</span> <span class=\"hljs-keyword\">first</span> component.<br><br>%~<br>As %d <span class=\"hljs-keyword\">and</span> %/, <span class=\"hljs-keyword\">but</span> <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">the</span> current working directory <span class=\"hljs-keyword\">starts with</span> $HOME, <span class=\"hljs-keyword\">that</span> part <span class=\"hljs-keyword\">is</span> replaced <span class=\"hljs-keyword\">by</span> a `~&#x27;. Furthermore, <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">it</span> has a named directory <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">its</span> prefix, <span class=\"hljs-keyword\">that</span> part <span class=\"hljs-keyword\">is</span> replaced <span class=\"hljs-keyword\">by</span> a `~&#x27; followed <span class=\"hljs-keyword\">by</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-built_in\">name</span> <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> directory, <span class=\"hljs-keyword\">but</span> only <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-literal\">result</span> <span class=\"hljs-keyword\">is</span> shorter than <span class=\"hljs-keyword\">the</span> full path; see Dynamic <span class=\"hljs-keyword\">and</span> Static named directories <span class=\"hljs-keyword\">in</span> zshexpn(<span class=\"hljs-number\">1</span>).<br><br>%e<br>Evaluation depth <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> current sourced <span class=\"hljs-built_in\">file</span>, shell function, <span class=\"hljs-keyword\">or</span> eval. This <span class=\"hljs-keyword\">is</span> incremented <span class=\"hljs-keyword\">or</span> decremented <span class=\"hljs-keyword\">every</span> <span class=\"hljs-built_in\">time</span> <span class=\"hljs-keyword\">the</span> value <span class=\"hljs-keyword\">of</span> %N <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">set</span> <span class=\"hljs-keyword\">or</span> reverted <span class=\"hljs-keyword\">to</span> a previous value, respectively. This <span class=\"hljs-keyword\">is</span> most useful <span class=\"hljs-keyword\">for</span> debugging <span class=\"hljs-keyword\">as</span> part <span class=\"hljs-keyword\">of</span> $PS4.<br><br>%h%!<br>Current history event <span class=\"hljs-built_in\">number</span>.<br><br>%i<br>The line <span class=\"hljs-built_in\">number</span> currently being executed <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-keyword\">script</span>, sourced <span class=\"hljs-built_in\">file</span>, <span class=\"hljs-keyword\">or</span> shell function <span class=\"hljs-keyword\">given</span> <span class=\"hljs-keyword\">by</span> %N. This <span class=\"hljs-keyword\">is</span> most useful <span class=\"hljs-keyword\">for</span> debugging <span class=\"hljs-keyword\">as</span> part <span class=\"hljs-keyword\">of</span> $PS4.<br><br>%I<br>The line <span class=\"hljs-built_in\">number</span> currently being executed <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-built_in\">file</span> %x. This <span class=\"hljs-keyword\">is</span> similar <span class=\"hljs-keyword\">to</span> %i, <span class=\"hljs-keyword\">but</span> <span class=\"hljs-keyword\">the</span> line <span class=\"hljs-built_in\">number</span> <span class=\"hljs-keyword\">is</span> always a line <span class=\"hljs-built_in\">number</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-built_in\">file</span> <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">the</span> code was defined, even <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">the</span> code <span class=\"hljs-keyword\">is</span> a shell function.<br><br>%j<br>The <span class=\"hljs-built_in\">number</span> <span class=\"hljs-keyword\">of</span> jobs.<br><br>%L<br>The current value <span class=\"hljs-keyword\">of</span> $SHLVL.<br><br>%N<br>The <span class=\"hljs-built_in\">name</span> <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-keyword\">script</span>, sourced <span class=\"hljs-built_in\">file</span>, <span class=\"hljs-keyword\">or</span> shell function <span class=\"hljs-keyword\">that</span> zsh <span class=\"hljs-keyword\">is</span> currently executing, whichever was started most recently. If there <span class=\"hljs-keyword\">is</span> none, this <span class=\"hljs-keyword\">is</span> equivalent <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">the</span> parameter $<span class=\"hljs-number\">0.</span> An <span class=\"hljs-built_in\">integer</span> may follow <span class=\"hljs-keyword\">the</span> `%&#x27; <span class=\"hljs-keyword\">to</span> specify a <span class=\"hljs-built_in\">number</span> <span class=\"hljs-keyword\">of</span> trailing path components <span class=\"hljs-keyword\">to</span> show; zero means <span class=\"hljs-keyword\">the</span> full path. A negative <span class=\"hljs-built_in\">integer</span> specifies leading components.<br><br>%x<br>The <span class=\"hljs-built_in\">name</span> <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-built_in\">file</span> containing <span class=\"hljs-keyword\">the</span> source code currently being executed. This behaves <span class=\"hljs-keyword\">as</span> %N except <span class=\"hljs-keyword\">that</span> function <span class=\"hljs-keyword\">and</span> eval command names are <span class=\"hljs-keyword\">not</span> shown, instead <span class=\"hljs-keyword\">the</span> <span class=\"hljs-built_in\">file</span> <span class=\"hljs-keyword\">where</span> they were defined.<br><br>%c%.%C<br>Trailing component <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> current working directory. An <span class=\"hljs-built_in\">integer</span> may follow <span class=\"hljs-keyword\">the</span> `%&#x27; <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">get</span> more than one component. Unless `%C&#x27; <span class=\"hljs-keyword\">is</span> used, tilde contraction <span class=\"hljs-keyword\">is</span> performed <span class=\"hljs-keyword\">first</span>. These are deprecated <span class=\"hljs-keyword\">as</span> %c <span class=\"hljs-keyword\">and</span> %C are equivalent <span class=\"hljs-keyword\">to</span> %<span class=\"hljs-number\">1</span>~ <span class=\"hljs-keyword\">and</span> %<span class=\"hljs-number\">1</span>/, respectively, <span class=\"hljs-keyword\">while</span> explicit positive integers have <span class=\"hljs-keyword\">the</span> same effect <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">the</span> latter two sequences.<br><br></code></pre></td></tr></table></figure>\n\n\n","excerpt":"","more":"<p>使用的主题为</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">ZSH_THEME</span>=<span class=\"hljs-string\">&quot;robbyrussell&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>修改配置, path <code>~/.oh-my-zsh/themes/robbyrussell.zsh-theme</code>, 将 <code>%c</code> 替换为 <code>%d</code></p>\n<figure class=\"highlight nsis\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nsis\"><br><span class=\"hljs-comment\"># before</span><br>PROMPT=<span class=\"hljs-string\">&quot;%(?:%&#123;<span class=\"hljs-variable\">$fg_bold</span>[green]%&#125;➜ :%&#123;<span class=\"hljs-variable\">$fg_bold</span>[red]%&#125;➜ ) %&#123;<span class=\"hljs-variable\">$fg</span>[cyan]%&#125;%c%&#123;<span class=\"hljs-variable\">$reset_color</span>%&#125;&quot;</span><br>PROMPT+=<span class=\"hljs-string\">&#x27; <span class=\"hljs-variable\">$(git_prompt_info)</span>&#x27;</span><br><br><span class=\"hljs-comment\"># after</span><br>PROMPT=<span class=\"hljs-string\">&quot;%(?:%&#123;<span class=\"hljs-variable\">$fg_bold</span>[green]%&#125;➜ :%&#123;<span class=\"hljs-variable\">$fg_bold</span>[red]%&#125;➜ )&quot;</span><br>PROMPT+=<span class=\"hljs-string\">&#x27; %&#123;<span class=\"hljs-variable\">$fg</span>[cyan]%&#125;%d%&#123;<span class=\"hljs-variable\">$reset_color</span>%&#125; <span class=\"hljs-variable\">$(git_prompt_info)</span>&#x27;</span><br><br></code></pre></td></tr></table></figure>\n\n<p>参考： <a href=\"https://links.jianshu.com/go?to=https://jlk.fjfi.cvut.cz/arch/manpages/man/zshmisc.1%23EXPANSION_OF_PROMPT_SEQUENCES\">EXPANSION_OF_PROMPT_SEQUENCES</a></p>\n<p>Shell state</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">%<span class=\"hljs-comment\">#</span><br>A `<span class=\"hljs-comment\">#&#x27; if the shell is running with privileges, a `%&#x27; if not. Equivalent to `%(!.#.%%)&#x27;. The definition of `privileged&#x27;, for these purposes, is that either the effective user ID is zero, or, if POSIX.1e capabilities are supported, that at least one capability is raised in either the Effective or Inheritable capability vectors.</span><br><br>%?<br>The <span class=\"hljs-literal\">return</span> status <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-keyword\">last</span> command executed just <span class=\"hljs-keyword\">before</span> <span class=\"hljs-keyword\">the</span> prompt.<br><br>%_<br>The status <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> parser, i.e. <span class=\"hljs-keyword\">the</span> shell constructs (like `<span class=\"hljs-keyword\">if</span>&#x27; <span class=\"hljs-keyword\">and</span> `<span class=\"hljs-keyword\">for</span>&#x27;) <span class=\"hljs-keyword\">that</span> have been started <span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">the</span> command line. If <span class=\"hljs-keyword\">given</span> an <span class=\"hljs-built_in\">integer</span> <span class=\"hljs-built_in\">number</span> <span class=\"hljs-keyword\">that</span> many strings will be printed; zero <span class=\"hljs-keyword\">or</span> negative <span class=\"hljs-keyword\">or</span> no <span class=\"hljs-built_in\">integer</span> means print <span class=\"hljs-keyword\">as</span> many <span class=\"hljs-keyword\">as</span> there are. This <span class=\"hljs-keyword\">is</span> most useful <span class=\"hljs-keyword\">in</span> prompts PS2 <span class=\"hljs-keyword\">for</span> continuation lines <span class=\"hljs-keyword\">and</span> PS4 <span class=\"hljs-keyword\">for</span> debugging <span class=\"hljs-keyword\">with</span> <span class=\"hljs-keyword\">the</span> XTRACE option; <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">the</span> latter case <span class=\"hljs-keyword\">it</span> will also work non-interactively.<br><br>%^<br>The status <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> parser <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">reverse</span>. This <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">the</span> same <span class=\"hljs-keyword\">as</span> `%_&#x27; other than <span class=\"hljs-keyword\">the</span> order <span class=\"hljs-keyword\">of</span> strings. It <span class=\"hljs-keyword\">is</span> often used <span class=\"hljs-keyword\">in</span> RPS2.<br><br>%d%/<br>Current working directory. If an <span class=\"hljs-built_in\">integer</span> follows <span class=\"hljs-keyword\">the</span> `%&#x27;, <span class=\"hljs-keyword\">it</span> specifies a <span class=\"hljs-built_in\">number</span> <span class=\"hljs-keyword\">of</span> trailing components <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> current working directory <span class=\"hljs-keyword\">to</span> show; zero means <span class=\"hljs-keyword\">the</span> whole path. A negative <span class=\"hljs-built_in\">integer</span> specifies leading components, i.e. %<span class=\"hljs-number\">-1</span>d specifies <span class=\"hljs-keyword\">the</span> <span class=\"hljs-keyword\">first</span> component.<br><br>%~<br>As %d <span class=\"hljs-keyword\">and</span> %/, <span class=\"hljs-keyword\">but</span> <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">the</span> current working directory <span class=\"hljs-keyword\">starts with</span> $HOME, <span class=\"hljs-keyword\">that</span> part <span class=\"hljs-keyword\">is</span> replaced <span class=\"hljs-keyword\">by</span> a `~&#x27;. Furthermore, <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">it</span> has a named directory <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">its</span> prefix, <span class=\"hljs-keyword\">that</span> part <span class=\"hljs-keyword\">is</span> replaced <span class=\"hljs-keyword\">by</span> a `~&#x27; followed <span class=\"hljs-keyword\">by</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-built_in\">name</span> <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> directory, <span class=\"hljs-keyword\">but</span> only <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-literal\">result</span> <span class=\"hljs-keyword\">is</span> shorter than <span class=\"hljs-keyword\">the</span> full path; see Dynamic <span class=\"hljs-keyword\">and</span> Static named directories <span class=\"hljs-keyword\">in</span> zshexpn(<span class=\"hljs-number\">1</span>).<br><br>%e<br>Evaluation depth <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> current sourced <span class=\"hljs-built_in\">file</span>, shell function, <span class=\"hljs-keyword\">or</span> eval. This <span class=\"hljs-keyword\">is</span> incremented <span class=\"hljs-keyword\">or</span> decremented <span class=\"hljs-keyword\">every</span> <span class=\"hljs-built_in\">time</span> <span class=\"hljs-keyword\">the</span> value <span class=\"hljs-keyword\">of</span> %N <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">set</span> <span class=\"hljs-keyword\">or</span> reverted <span class=\"hljs-keyword\">to</span> a previous value, respectively. This <span class=\"hljs-keyword\">is</span> most useful <span class=\"hljs-keyword\">for</span> debugging <span class=\"hljs-keyword\">as</span> part <span class=\"hljs-keyword\">of</span> $PS4.<br><br>%h%!<br>Current history event <span class=\"hljs-built_in\">number</span>.<br><br>%i<br>The line <span class=\"hljs-built_in\">number</span> currently being executed <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-keyword\">script</span>, sourced <span class=\"hljs-built_in\">file</span>, <span class=\"hljs-keyword\">or</span> shell function <span class=\"hljs-keyword\">given</span> <span class=\"hljs-keyword\">by</span> %N. This <span class=\"hljs-keyword\">is</span> most useful <span class=\"hljs-keyword\">for</span> debugging <span class=\"hljs-keyword\">as</span> part <span class=\"hljs-keyword\">of</span> $PS4.<br><br>%I<br>The line <span class=\"hljs-built_in\">number</span> currently being executed <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-built_in\">file</span> %x. This <span class=\"hljs-keyword\">is</span> similar <span class=\"hljs-keyword\">to</span> %i, <span class=\"hljs-keyword\">but</span> <span class=\"hljs-keyword\">the</span> line <span class=\"hljs-built_in\">number</span> <span class=\"hljs-keyword\">is</span> always a line <span class=\"hljs-built_in\">number</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-built_in\">file</span> <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">the</span> code was defined, even <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">the</span> code <span class=\"hljs-keyword\">is</span> a shell function.<br><br>%j<br>The <span class=\"hljs-built_in\">number</span> <span class=\"hljs-keyword\">of</span> jobs.<br><br>%L<br>The current value <span class=\"hljs-keyword\">of</span> $SHLVL.<br><br>%N<br>The <span class=\"hljs-built_in\">name</span> <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-keyword\">script</span>, sourced <span class=\"hljs-built_in\">file</span>, <span class=\"hljs-keyword\">or</span> shell function <span class=\"hljs-keyword\">that</span> zsh <span class=\"hljs-keyword\">is</span> currently executing, whichever was started most recently. If there <span class=\"hljs-keyword\">is</span> none, this <span class=\"hljs-keyword\">is</span> equivalent <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">the</span> parameter $<span class=\"hljs-number\">0.</span> An <span class=\"hljs-built_in\">integer</span> may follow <span class=\"hljs-keyword\">the</span> `%&#x27; <span class=\"hljs-keyword\">to</span> specify a <span class=\"hljs-built_in\">number</span> <span class=\"hljs-keyword\">of</span> trailing path components <span class=\"hljs-keyword\">to</span> show; zero means <span class=\"hljs-keyword\">the</span> full path. A negative <span class=\"hljs-built_in\">integer</span> specifies leading components.<br><br>%x<br>The <span class=\"hljs-built_in\">name</span> <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-built_in\">file</span> containing <span class=\"hljs-keyword\">the</span> source code currently being executed. This behaves <span class=\"hljs-keyword\">as</span> %N except <span class=\"hljs-keyword\">that</span> function <span class=\"hljs-keyword\">and</span> eval command names are <span class=\"hljs-keyword\">not</span> shown, instead <span class=\"hljs-keyword\">the</span> <span class=\"hljs-built_in\">file</span> <span class=\"hljs-keyword\">where</span> they were defined.<br><br>%c%.%C<br>Trailing component <span class=\"hljs-keyword\">of</span> <span class=\"hljs-keyword\">the</span> current working directory. An <span class=\"hljs-built_in\">integer</span> may follow <span class=\"hljs-keyword\">the</span> `%&#x27; <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">get</span> more than one component. Unless `%C&#x27; <span class=\"hljs-keyword\">is</span> used, tilde contraction <span class=\"hljs-keyword\">is</span> performed <span class=\"hljs-keyword\">first</span>. These are deprecated <span class=\"hljs-keyword\">as</span> %c <span class=\"hljs-keyword\">and</span> %C are equivalent <span class=\"hljs-keyword\">to</span> %<span class=\"hljs-number\">1</span>~ <span class=\"hljs-keyword\">and</span> %<span class=\"hljs-number\">1</span>/, respectively, <span class=\"hljs-keyword\">while</span> explicit positive integers have <span class=\"hljs-keyword\">the</span> same effect <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">the</span> latter two sequences.<br><br></code></pre></td></tr></table></figure>\n\n\n"},{"layout":"post","title":"常用的shell语句","date":"2022-02-23T16:00:00.000Z","_content":"  \n\n\n# 常用的shell语句\n\n[判断软件是否安装](https://blog.csdn.net/baidu_26678247/article/details/103024812)\n\n```\n#!/bin/bash\n\nif [ ! -x \"$(command -v xcodeproj)\" ]; then \n    echo \"xcodeproj is not installed. installing...\" > &2\n    echo \"run 'gem install xcodeproj'\"\n    gem install xcodeproj\nfi\n```\n\n[当前shell脚本所在目录](https://stackoverflow.com/questions/242538/unix-shell-script-find-out-which-directory-the-script-file-resides)\n\n```\nSCRIPT_DIR=\"$(cd \"$(dirname \"$0\")\"; pwd)\";\n```\n","source":"_posts/Shell/常用的shell语句.md","raw":"---\nlayout: post\ntitle: \"常用的shell语句\"\ndate: 2022-02-24\ntag: Shell\n---  \n\n\n# 常用的shell语句\n\n[判断软件是否安装](https://blog.csdn.net/baidu_26678247/article/details/103024812)\n\n```\n#!/bin/bash\n\nif [ ! -x \"$(command -v xcodeproj)\" ]; then \n    echo \"xcodeproj is not installed. installing...\" > &2\n    echo \"run 'gem install xcodeproj'\"\n    gem install xcodeproj\nfi\n```\n\n[当前shell脚本所在目录](https://stackoverflow.com/questions/242538/unix-shell-script-find-out-which-directory-the-script-file-resides)\n\n```\nSCRIPT_DIR=\"$(cd \"$(dirname \"$0\")\"; pwd)\";\n```\n","slug":"Shell/常用的shell语句","published":1,"updated":"2024-03-07T03:06:00.029Z","comments":1,"photos":[],"_id":"cltgopen8000qqywhhs31hnir","content":"<h1 id=\"常用的shell语句\"><a href=\"#常用的shell语句\" class=\"headerlink\" title=\"常用的shell语句\"></a>常用的shell语句</h1><p><a href=\"https://blog.csdn.net/baidu_26678247/article/details/103024812\">判断软件是否安装</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/bash</span><br><br><span class=\"hljs-keyword\">if</span> [ ! -x <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(command -v xcodeproj)</span>&quot;</span> ]; <span class=\"hljs-keyword\">then</span> <br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;xcodeproj is not installed. installing...&quot;</span> &gt; &amp;2<br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;run &#x27;gem install xcodeproj&#x27;&quot;</span><br>    gem install xcodeproj<br><span class=\"hljs-keyword\">fi</span><br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://stackoverflow.com/questions/242538/unix-shell-script-find-out-which-directory-the-script-file-resides\">当前shell脚本所在目录</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">SCRIPT_DIR=<span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(cd <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(dirname <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$0</span>&quot;</span>)</span>&quot;</span>; pwd)</span>&quot;</span>;<br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"常用的shell语句\"><a href=\"#常用的shell语句\" class=\"headerlink\" title=\"常用的shell语句\"></a>常用的shell语句</h1><p><a href=\"https://blog.csdn.net/baidu_26678247/article/details/103024812\">判断软件是否安装</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/bash</span><br><br><span class=\"hljs-keyword\">if</span> [ ! -x <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(command -v xcodeproj)</span>&quot;</span> ]; <span class=\"hljs-keyword\">then</span> <br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;xcodeproj is not installed. installing...&quot;</span> &gt; &amp;2<br>    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;run &#x27;gem install xcodeproj&#x27;&quot;</span><br>    gem install xcodeproj<br><span class=\"hljs-keyword\">fi</span><br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://stackoverflow.com/questions/242538/unix-shell-script-find-out-which-directory-the-script-file-resides\">当前shell脚本所在目录</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">SCRIPT_DIR=<span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(cd <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(dirname <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$0</span>&quot;</span>)</span>&quot;</span>; pwd)</span>&quot;</span>;<br></code></pre></td></tr></table></figure>\n"},{"layout":"post","title":"aac adts 格式分析","date":"2022-09-22T16:00:00.000Z","_content":"\nAAC音频格式在MPEG-2（ISO-13318-7 2003）中有定义。AAC后来又被采用到MPEG-4标准中。\n\nAAC 有两种格式 ADIF(Audio Data Interchange Forma) 和 ADTS(Audio Data Transport Stream)\n\n- ADIF: ADIF只有一个统一的头，所以必须得到所有的数据后解码\n- ADTS: 每一帧都有头信息, 可以在任意帧解码\n\n\n## ADIF\n\nadif头 + 对齐字节 + 数据块\n\n```\nadif_sequence() {\n    adif_header();\n    byte_alignment();\n    raw_data_stream();\n}\n```\n## ADTS\n数据流是一帧一帧的adts，可以在任何位置解码。\n```\nadts_sequence() {\n    while (nextbits() == syncword) \n    { \n        adts_frame();\n    } \n}\n```\n## adts_frame\n```\nadts_frame() {\n    adts_fixed_header();\n    adts_variable_header();\n    if (number_of_raw_data_blocks_in_frame == 0) {\n        adts_error_check();\n        raw_data_block(); \n    }\n    else {\n        adts_header_error_check();\n        for (i = 0; i <= number_of_raw_data_blocks_in_frame; i++) {\n            raw_data_block();\n            adts_raw_data_block_error_check();\n        }\n    }\n} \n```\n\n每一帧都有28位的固定header + 28位的可变header组成的，共7字节。\n### adts_fixed_header\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653251125631665325112115.png)\n\n**syncword**\n\nThe bit string `1111 1111 1111`.\n\n**ID**\n\n0 for MPEG-4, 1 for MPEG-2\n\n**layer**\n\nIndicates which layer is used. Set to `00`.\n\n**protection_absent**\n\nIndicates whether error_check() data is present or not.\n0 存在，1 不存在。\n\n**profile**\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653255915411665325591471.png)\n\n**sampling_frequency_index**\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653256535451665325652832.png)\n\n**private_bit**\n\nBit for private use. This bit will not be used in the future by ISO/IEC.\nset to 0 when encoding, ignore when decoding ？？\n\n**channel_configuration**\n\n声道信息，大于0 根据下表来决定， 等于0？\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653263524151665326351568.png)\n\n**original/copy**\n\nThis bit equals 'O if the bitstream is a copy, '1' if it is an original.\n\n编码时设置为0，解码时忽略?\n\n**home**\n\n编码时设置为0，解码时忽略?\n\n### adts_variable_header\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653274014091665327401231.png)\n\n\n**copyright_identification_bit**\n\n编码时设置为0，解码时忽略?\n\n**copyright_identification_start**\n\n编码时设置为0，解码时忽略?\n\n**frame_length**\n\nLength of the frame including headers and error_check in bytes\n\n\n\n**adts_buffer_fullness**\n> state of the bit reservoir in the course of encoding the ADTS frame, up to and including the first raw_data_block(). It is transmitted as the number of available bits in the bit reservoir divided by NCC divided by 32 and truncated to an integer value (Table 9). A value of hexadecimal 7FF signals that the bitstream is a variable rate bitstream. In this case, buffer fullness is not applicable\n\n0x7FF 代表码率是可变的。\n\n**number_of_raw_data_blocks_in_frame**\n> Number of raw_data_block()’s that are multiplexed in the adts_frame() is equal to\nraw_data_block_position[i]\nnumber_of_raw_data_blocks_in_frame + 1. The minimum value is 0 indicating 1 raw_data_block()\n\n\n根据 `number_of_raw_data_blocks_in_frame` 是否等于 0 做区分\n- 等于0， 该帧里面中只有一个raw_data_block\n- 大于0， 该帧中有`number_of_raw_data_blocks_in_frame + 1`个raw_data_block\n- 大于 0 的情况较少见?\n- 每个raw_data_block对应于1024个采样?\n\n### adts_error_check\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653285183621665328517592.png)\n\n是否开启循环冗余校验，开启后header总长（28 + 28 + 16 = 72）9个字节。\n\n### adts_header_error_check\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653287093611665328708587.png)\n\n\n**raw_data_block_position[i]**\n>Start position of the i-th raw_data_block() in the adts_frame(), measured as an offset in bytes from the start position of the first raw_data_block() in the adts_frame().\n\n如果开启循环冗余校验，并且`number_of_raw_data_blocks_in_frame > 0`, 记录每个`raw_data_block`开始位置，添加crc校验。\n\n### raw_data_block\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653290063481665329006023.png)\n\n判断声道，根据声道会有变化。\n\n###  adts_raw_data_block_error_check\n\n每个`raw_data_block`对应的校验。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653291083431665329107537.png)\n\n\n## 工具\n\n访问[https://www.p23.nl/projects/aac-header/](https://www.p23.nl/projects/aac-header/), 可以输入自己的aac 文件头部， 分析aac header 信息。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653292653371665329265242.png)\n\n","source":"_posts/aac/2022-09-23-aac-adts.md","raw":"---\nlayout: post\ntitle: \"aac adts 格式分析\"\ndate: 2022-09-23 \ntag: aac\n---\n\nAAC音频格式在MPEG-2（ISO-13318-7 2003）中有定义。AAC后来又被采用到MPEG-4标准中。\n\nAAC 有两种格式 ADIF(Audio Data Interchange Forma) 和 ADTS(Audio Data Transport Stream)\n\n- ADIF: ADIF只有一个统一的头，所以必须得到所有的数据后解码\n- ADTS: 每一帧都有头信息, 可以在任意帧解码\n\n\n## ADIF\n\nadif头 + 对齐字节 + 数据块\n\n```\nadif_sequence() {\n    adif_header();\n    byte_alignment();\n    raw_data_stream();\n}\n```\n## ADTS\n数据流是一帧一帧的adts，可以在任何位置解码。\n```\nadts_sequence() {\n    while (nextbits() == syncword) \n    { \n        adts_frame();\n    } \n}\n```\n## adts_frame\n```\nadts_frame() {\n    adts_fixed_header();\n    adts_variable_header();\n    if (number_of_raw_data_blocks_in_frame == 0) {\n        adts_error_check();\n        raw_data_block(); \n    }\n    else {\n        adts_header_error_check();\n        for (i = 0; i <= number_of_raw_data_blocks_in_frame; i++) {\n            raw_data_block();\n            adts_raw_data_block_error_check();\n        }\n    }\n} \n```\n\n每一帧都有28位的固定header + 28位的可变header组成的，共7字节。\n### adts_fixed_header\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653251125631665325112115.png)\n\n**syncword**\n\nThe bit string `1111 1111 1111`.\n\n**ID**\n\n0 for MPEG-4, 1 for MPEG-2\n\n**layer**\n\nIndicates which layer is used. Set to `00`.\n\n**protection_absent**\n\nIndicates whether error_check() data is present or not.\n0 存在，1 不存在。\n\n**profile**\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653255915411665325591471.png)\n\n**sampling_frequency_index**\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653256535451665325652832.png)\n\n**private_bit**\n\nBit for private use. This bit will not be used in the future by ISO/IEC.\nset to 0 when encoding, ignore when decoding ？？\n\n**channel_configuration**\n\n声道信息，大于0 根据下表来决定， 等于0？\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653263524151665326351568.png)\n\n**original/copy**\n\nThis bit equals 'O if the bitstream is a copy, '1' if it is an original.\n\n编码时设置为0，解码时忽略?\n\n**home**\n\n编码时设置为0，解码时忽略?\n\n### adts_variable_header\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653274014091665327401231.png)\n\n\n**copyright_identification_bit**\n\n编码时设置为0，解码时忽略?\n\n**copyright_identification_start**\n\n编码时设置为0，解码时忽略?\n\n**frame_length**\n\nLength of the frame including headers and error_check in bytes\n\n\n\n**adts_buffer_fullness**\n> state of the bit reservoir in the course of encoding the ADTS frame, up to and including the first raw_data_block(). It is transmitted as the number of available bits in the bit reservoir divided by NCC divided by 32 and truncated to an integer value (Table 9). A value of hexadecimal 7FF signals that the bitstream is a variable rate bitstream. In this case, buffer fullness is not applicable\n\n0x7FF 代表码率是可变的。\n\n**number_of_raw_data_blocks_in_frame**\n> Number of raw_data_block()’s that are multiplexed in the adts_frame() is equal to\nraw_data_block_position[i]\nnumber_of_raw_data_blocks_in_frame + 1. The minimum value is 0 indicating 1 raw_data_block()\n\n\n根据 `number_of_raw_data_blocks_in_frame` 是否等于 0 做区分\n- 等于0， 该帧里面中只有一个raw_data_block\n- 大于0， 该帧中有`number_of_raw_data_blocks_in_frame + 1`个raw_data_block\n- 大于 0 的情况较少见?\n- 每个raw_data_block对应于1024个采样?\n\n### adts_error_check\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653285183621665328517592.png)\n\n是否开启循环冗余校验，开启后header总长（28 + 28 + 16 = 72）9个字节。\n\n### adts_header_error_check\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653287093611665328708587.png)\n\n\n**raw_data_block_position[i]**\n>Start position of the i-th raw_data_block() in the adts_frame(), measured as an offset in bytes from the start position of the first raw_data_block() in the adts_frame().\n\n如果开启循环冗余校验，并且`number_of_raw_data_blocks_in_frame > 0`, 记录每个`raw_data_block`开始位置，添加crc校验。\n\n### raw_data_block\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653290063481665329006023.png)\n\n判断声道，根据声道会有变化。\n\n###  adts_raw_data_block_error_check\n\n每个`raw_data_block`对应的校验。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653291083431665329107537.png)\n\n\n## 工具\n\n访问[https://www.p23.nl/projects/aac-header/](https://www.p23.nl/projects/aac-header/), 可以输入自己的aac 文件头部， 分析aac header 信息。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653292653371665329265242.png)\n\n","slug":"aac/2022-09-23-aac-adts","published":1,"updated":"2024-03-06T11:53:13.564Z","comments":1,"photos":[],"_id":"cltgopen8000sqywhgj8t8047","content":"<p>AAC音频格式在MPEG-2（ISO-13318-7 2003）中有定义。AAC后来又被采用到MPEG-4标准中。</p>\n<p>AAC 有两种格式 ADIF(Audio Data Interchange Forma) 和 ADTS(Audio Data Transport Stream)</p>\n<ul>\n<li>ADIF: ADIF只有一个统一的头，所以必须得到所有的数据后解码</li>\n<li>ADTS: 每一帧都有头信息, 可以在任意帧解码</li>\n</ul>\n<h2 id=\"ADIF\"><a href=\"#ADIF\" class=\"headerlink\" title=\"ADIF\"></a>ADIF</h2><p>adif头 + 对齐字节 + 数据块</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">adif_sequence</span>() &#123;<br>    <span class=\"hljs-built_in\">adif_header</span>();<br>    <span class=\"hljs-built_in\">byte_alignment</span>();<br>    <span class=\"hljs-built_in\">raw_data_stream</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"ADTS\"><a href=\"#ADTS\" class=\"headerlink\" title=\"ADTS\"></a>ADTS</h2><p>数据流是一帧一帧的adts，可以在任何位置解码。</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs isbl\"><span class=\"hljs-function\"><span class=\"hljs-title\">adts_sequence</span>() &#123;</span><br><span class=\"hljs-function\">    <span class=\"hljs-variable\"><span class=\"hljs-keyword\">while</span></span> (<span class=\"hljs-title\">nextbits</span>() == <span class=\"hljs-variable\">syncword</span>) </span><br><span class=\"hljs-function\">    &#123; </span><br><span class=\"hljs-function\">        <span class=\"hljs-title\">adts_frame</span>();</span><br><span class=\"hljs-function\">    &#125; </span><br><span class=\"hljs-function\">&#125;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"adts-frame\"><a href=\"#adts-frame\" class=\"headerlink\" title=\"adts_frame\"></a>adts_frame</h2><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">adts_frame</span>() &#123;<br>    <span class=\"hljs-built_in\">adts_fixed_header</span>();<br>    <span class=\"hljs-built_in\">adts_variable_header</span>();<br>    if (number_of_raw_data_blocks_in_frame == <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">adts_error_check</span>();<br>        <span class=\"hljs-built_in\">raw_data_block</span>(); <br>    &#125;<br>    else &#123;<br>        <span class=\"hljs-built_in\">adts_header_error_check</span>();<br>        for (i = <span class=\"hljs-number\">0</span>; i &lt;= number_of_raw_data_blocks_in_frame; i++) &#123;<br>            <span class=\"hljs-built_in\">raw_data_block</span>();<br>            <span class=\"hljs-built_in\">adts_raw_data_block_error_check</span>();<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>\n\n<p>每一帧都有28位的固定header + 28位的可变header组成的，共7字节。</p>\n<h3 id=\"adts-fixed-header\"><a href=\"#adts-fixed-header\" class=\"headerlink\" title=\"adts_fixed_header\"></a>adts_fixed_header</h3><p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653251125631665325112115.png\"></p>\n<p><strong>syncword</strong></p>\n<p>The bit string <code>1111 1111 1111</code>.</p>\n<p><strong>ID</strong></p>\n<p>0 for MPEG-4, 1 for MPEG-2</p>\n<p><strong>layer</strong></p>\n<p>Indicates which layer is used. Set to <code>00</code>.</p>\n<p><strong>protection_absent</strong></p>\n<p>Indicates whether error_check() data is present or not.<br>0 存在，1 不存在。</p>\n<p><strong>profile</strong></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653255915411665325591471.png\"></p>\n<p><strong>sampling_frequency_index</strong></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653256535451665325652832.png\"></p>\n<p><strong>private_bit</strong></p>\n<p>Bit for private use. This bit will not be used in the future by ISO&#x2F;IEC.<br>set to 0 when encoding, ignore when decoding ？？</p>\n<p><strong>channel_configuration</strong></p>\n<p>声道信息，大于0 根据下表来决定， 等于0？</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653263524151665326351568.png\"></p>\n<p><strong>original&#x2F;copy</strong></p>\n<p>This bit equals ‘O if the bitstream is a copy, ‘1’ if it is an original.</p>\n<p>编码时设置为0，解码时忽略?</p>\n<p><strong>home</strong></p>\n<p>编码时设置为0，解码时忽略?</p>\n<h3 id=\"adts-variable-header\"><a href=\"#adts-variable-header\" class=\"headerlink\" title=\"adts_variable_header\"></a>adts_variable_header</h3><p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653274014091665327401231.png\"></p>\n<p><strong>copyright_identification_bit</strong></p>\n<p>编码时设置为0，解码时忽略?</p>\n<p><strong>copyright_identification_start</strong></p>\n<p>编码时设置为0，解码时忽略?</p>\n<p><strong>frame_length</strong></p>\n<p>Length of the frame including headers and error_check in bytes</p>\n<p><strong>adts_buffer_fullness</strong></p>\n<blockquote>\n<p>state of the bit reservoir in the course of encoding the ADTS frame, up to and including the first raw_data_block(). It is transmitted as the number of available bits in the bit reservoir divided by NCC divided by 32 and truncated to an integer value (Table 9). A value of hexadecimal 7FF signals that the bitstream is a variable rate bitstream. In this case, buffer fullness is not applicable</p>\n</blockquote>\n<p>0x7FF 代表码率是可变的。</p>\n<p><strong>number_of_raw_data_blocks_in_frame</strong></p>\n<blockquote>\n<p>Number of raw_data_block()’s that are multiplexed in the adts_frame() is equal to<br>raw_data_block_position[i]<br>number_of_raw_data_blocks_in_frame + 1. The minimum value is 0 indicating 1 raw_data_block()</p>\n</blockquote>\n<p>根据 <code>number_of_raw_data_blocks_in_frame</code> 是否等于 0 做区分</p>\n<ul>\n<li>等于0， 该帧里面中只有一个raw_data_block</li>\n<li>大于0， 该帧中有<code>number_of_raw_data_blocks_in_frame + 1</code>个raw_data_block</li>\n<li>大于 0 的情况较少见?</li>\n<li>每个raw_data_block对应于1024个采样?</li>\n</ul>\n<h3 id=\"adts-error-check\"><a href=\"#adts-error-check\" class=\"headerlink\" title=\"adts_error_check\"></a>adts_error_check</h3><p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653285183621665328517592.png\"></p>\n<p>是否开启循环冗余校验，开启后header总长（28 + 28 + 16 &#x3D; 72）9个字节。</p>\n<h3 id=\"adts-header-error-check\"><a href=\"#adts-header-error-check\" class=\"headerlink\" title=\"adts_header_error_check\"></a>adts_header_error_check</h3><p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653287093611665328708587.png\"></p>\n<p><strong>raw_data_block_position[i]</strong></p>\n<blockquote>\n<p>Start position of the i-th raw_data_block() in the adts_frame(), measured as an offset in bytes from the start position of the first raw_data_block() in the adts_frame().</p>\n</blockquote>\n<p>如果开启循环冗余校验，并且<code>number_of_raw_data_blocks_in_frame &gt; 0</code>, 记录每个<code>raw_data_block</code>开始位置，添加crc校验。</p>\n<h3 id=\"raw-data-block\"><a href=\"#raw-data-block\" class=\"headerlink\" title=\"raw_data_block\"></a>raw_data_block</h3><p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653290063481665329006023.png\"></p>\n<p>判断声道，根据声道会有变化。</p>\n<h3 id=\"adts-raw-data-block-error-check\"><a href=\"#adts-raw-data-block-error-check\" class=\"headerlink\" title=\"adts_raw_data_block_error_check\"></a>adts_raw_data_block_error_check</h3><p>每个<code>raw_data_block</code>对应的校验。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653291083431665329107537.png\"></p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><p>访问<a href=\"https://www.p23.nl/projects/aac-header/\">https://www.p23.nl/projects/aac-header/</a>, 可以输入自己的aac 文件头部， 分析aac header 信息。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653292653371665329265242.png\"></p>\n","excerpt":"","more":"<p>AAC音频格式在MPEG-2（ISO-13318-7 2003）中有定义。AAC后来又被采用到MPEG-4标准中。</p>\n<p>AAC 有两种格式 ADIF(Audio Data Interchange Forma) 和 ADTS(Audio Data Transport Stream)</p>\n<ul>\n<li>ADIF: ADIF只有一个统一的头，所以必须得到所有的数据后解码</li>\n<li>ADTS: 每一帧都有头信息, 可以在任意帧解码</li>\n</ul>\n<h2 id=\"ADIF\"><a href=\"#ADIF\" class=\"headerlink\" title=\"ADIF\"></a>ADIF</h2><p>adif头 + 对齐字节 + 数据块</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">adif_sequence</span>() &#123;<br>    <span class=\"hljs-built_in\">adif_header</span>();<br>    <span class=\"hljs-built_in\">byte_alignment</span>();<br>    <span class=\"hljs-built_in\">raw_data_stream</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"ADTS\"><a href=\"#ADTS\" class=\"headerlink\" title=\"ADTS\"></a>ADTS</h2><p>数据流是一帧一帧的adts，可以在任何位置解码。</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs isbl\"><span class=\"hljs-function\"><span class=\"hljs-title\">adts_sequence</span>() &#123;</span><br><span class=\"hljs-function\">    <span class=\"hljs-variable\"><span class=\"hljs-keyword\">while</span></span> (<span class=\"hljs-title\">nextbits</span>() == <span class=\"hljs-variable\">syncword</span>) </span><br><span class=\"hljs-function\">    &#123; </span><br><span class=\"hljs-function\">        <span class=\"hljs-title\">adts_frame</span>();</span><br><span class=\"hljs-function\">    &#125; </span><br><span class=\"hljs-function\">&#125;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"adts-frame\"><a href=\"#adts-frame\" class=\"headerlink\" title=\"adts_frame\"></a>adts_frame</h2><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">adts_frame</span>() &#123;<br>    <span class=\"hljs-built_in\">adts_fixed_header</span>();<br>    <span class=\"hljs-built_in\">adts_variable_header</span>();<br>    if (number_of_raw_data_blocks_in_frame == <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">adts_error_check</span>();<br>        <span class=\"hljs-built_in\">raw_data_block</span>(); <br>    &#125;<br>    else &#123;<br>        <span class=\"hljs-built_in\">adts_header_error_check</span>();<br>        for (i = <span class=\"hljs-number\">0</span>; i &lt;= number_of_raw_data_blocks_in_frame; i++) &#123;<br>            <span class=\"hljs-built_in\">raw_data_block</span>();<br>            <span class=\"hljs-built_in\">adts_raw_data_block_error_check</span>();<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>\n\n<p>每一帧都有28位的固定header + 28位的可变header组成的，共7字节。</p>\n<h3 id=\"adts-fixed-header\"><a href=\"#adts-fixed-header\" class=\"headerlink\" title=\"adts_fixed_header\"></a>adts_fixed_header</h3><p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653251125631665325112115.png\"></p>\n<p><strong>syncword</strong></p>\n<p>The bit string <code>1111 1111 1111</code>.</p>\n<p><strong>ID</strong></p>\n<p>0 for MPEG-4, 1 for MPEG-2</p>\n<p><strong>layer</strong></p>\n<p>Indicates which layer is used. Set to <code>00</code>.</p>\n<p><strong>protection_absent</strong></p>\n<p>Indicates whether error_check() data is present or not.<br>0 存在，1 不存在。</p>\n<p><strong>profile</strong></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653255915411665325591471.png\"></p>\n<p><strong>sampling_frequency_index</strong></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653256535451665325652832.png\"></p>\n<p><strong>private_bit</strong></p>\n<p>Bit for private use. This bit will not be used in the future by ISO&#x2F;IEC.<br>set to 0 when encoding, ignore when decoding ？？</p>\n<p><strong>channel_configuration</strong></p>\n<p>声道信息，大于0 根据下表来决定， 等于0？</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653263524151665326351568.png\"></p>\n<p><strong>original&#x2F;copy</strong></p>\n<p>This bit equals ‘O if the bitstream is a copy, ‘1’ if it is an original.</p>\n<p>编码时设置为0，解码时忽略?</p>\n<p><strong>home</strong></p>\n<p>编码时设置为0，解码时忽略?</p>\n<h3 id=\"adts-variable-header\"><a href=\"#adts-variable-header\" class=\"headerlink\" title=\"adts_variable_header\"></a>adts_variable_header</h3><p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653274014091665327401231.png\"></p>\n<p><strong>copyright_identification_bit</strong></p>\n<p>编码时设置为0，解码时忽略?</p>\n<p><strong>copyright_identification_start</strong></p>\n<p>编码时设置为0，解码时忽略?</p>\n<p><strong>frame_length</strong></p>\n<p>Length of the frame including headers and error_check in bytes</p>\n<p><strong>adts_buffer_fullness</strong></p>\n<blockquote>\n<p>state of the bit reservoir in the course of encoding the ADTS frame, up to and including the first raw_data_block(). It is transmitted as the number of available bits in the bit reservoir divided by NCC divided by 32 and truncated to an integer value (Table 9). A value of hexadecimal 7FF signals that the bitstream is a variable rate bitstream. In this case, buffer fullness is not applicable</p>\n</blockquote>\n<p>0x7FF 代表码率是可变的。</p>\n<p><strong>number_of_raw_data_blocks_in_frame</strong></p>\n<blockquote>\n<p>Number of raw_data_block()’s that are multiplexed in the adts_frame() is equal to<br>raw_data_block_position[i]<br>number_of_raw_data_blocks_in_frame + 1. The minimum value is 0 indicating 1 raw_data_block()</p>\n</blockquote>\n<p>根据 <code>number_of_raw_data_blocks_in_frame</code> 是否等于 0 做区分</p>\n<ul>\n<li>等于0， 该帧里面中只有一个raw_data_block</li>\n<li>大于0， 该帧中有<code>number_of_raw_data_blocks_in_frame + 1</code>个raw_data_block</li>\n<li>大于 0 的情况较少见?</li>\n<li>每个raw_data_block对应于1024个采样?</li>\n</ul>\n<h3 id=\"adts-error-check\"><a href=\"#adts-error-check\" class=\"headerlink\" title=\"adts_error_check\"></a>adts_error_check</h3><p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653285183621665328517592.png\"></p>\n<p>是否开启循环冗余校验，开启后header总长（28 + 28 + 16 &#x3D; 72）9个字节。</p>\n<h3 id=\"adts-header-error-check\"><a href=\"#adts-header-error-check\" class=\"headerlink\" title=\"adts_header_error_check\"></a>adts_header_error_check</h3><p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653287093611665328708587.png\"></p>\n<p><strong>raw_data_block_position[i]</strong></p>\n<blockquote>\n<p>Start position of the i-th raw_data_block() in the adts_frame(), measured as an offset in bytes from the start position of the first raw_data_block() in the adts_frame().</p>\n</blockquote>\n<p>如果开启循环冗余校验，并且<code>number_of_raw_data_blocks_in_frame &gt; 0</code>, 记录每个<code>raw_data_block</code>开始位置，添加crc校验。</p>\n<h3 id=\"raw-data-block\"><a href=\"#raw-data-block\" class=\"headerlink\" title=\"raw_data_block\"></a>raw_data_block</h3><p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653290063481665329006023.png\"></p>\n<p>判断声道，根据声道会有变化。</p>\n<h3 id=\"adts-raw-data-block-error-check\"><a href=\"#adts-raw-data-block-error-check\" class=\"headerlink\" title=\"adts_raw_data_block_error_check\"></a>adts_raw_data_block_error_check</h3><p>每个<code>raw_data_block</code>对应的校验。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653291083431665329107537.png\"></p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><p>访问<a href=\"https://www.p23.nl/projects/aac-header/\">https://www.p23.nl/projects/aac-header/</a>, 可以输入自己的aac 文件头部， 分析aac header 信息。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16653292653371665329265242.png\"></p>\n"},{"layout":"post","title":"fdk aac","date":"2022-09-22T16:00:00.000Z","_content":"\ngithub 地址： https://github.com/mstorsjo/fdk-aac\n\nfdk-aac 提供了跨平台的编解码 aac 的功能。\n\n## 编译\nfdk-aac提供了CMake构建静态库和动态库。\n```\ncd fdk-aac\nmkidr build \n#BUILD_SHARED_LIBS 控制构建静态库还是动态库\ncmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=OFF\ncmake --build --config Release\n# install\ncmake --install <dir> --prefix <prefix>\n```\n## 文档\n\n在documentation目录下，有两个pdf文件，分别对应编码和解码相关的文档。\n```\naacDecoder.pdf\naacEncoder.pdf\n```\n\n## demo\nfdk-aac 提供一个编码的示例`aac-enc.c`， 主要介绍如何实现aac 编码功能\n该demo 可以通过cmake来调试。\n首先在cmake 中启用该程序，给cmake 传递参数`-DBUILD_PROGRAMS=TRUE`\n\n运行构建后的程序 \n```\naac-enc [-r bitrate] [-t aot] [-a afterburner] [-s sbr] [-v vbr] in.wav out.aac\n```\n该程序可以读取wav音频文件，编码为aac，将编码后的数据写入`out.aac` 文件中。\n\n\n## 注意事项\n\nfdk-aac 只支持采样格式为`int16`类型的定点格式，不支持如`float32`类型的浮点格式。\n\nfdk-aac 默认一帧1024个采样。\n\n\n\n\n\n\n\n\n\n","source":"_posts/aac/2022-09-23-fdk-aac.md","raw":"---\nlayout: post\ntitle: \"fdk aac\"\ndate: 2022-09-23 \ntag: aac\n---\n\ngithub 地址： https://github.com/mstorsjo/fdk-aac\n\nfdk-aac 提供了跨平台的编解码 aac 的功能。\n\n## 编译\nfdk-aac提供了CMake构建静态库和动态库。\n```\ncd fdk-aac\nmkidr build \n#BUILD_SHARED_LIBS 控制构建静态库还是动态库\ncmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=OFF\ncmake --build --config Release\n# install\ncmake --install <dir> --prefix <prefix>\n```\n## 文档\n\n在documentation目录下，有两个pdf文件，分别对应编码和解码相关的文档。\n```\naacDecoder.pdf\naacEncoder.pdf\n```\n\n## demo\nfdk-aac 提供一个编码的示例`aac-enc.c`， 主要介绍如何实现aac 编码功能\n该demo 可以通过cmake来调试。\n首先在cmake 中启用该程序，给cmake 传递参数`-DBUILD_PROGRAMS=TRUE`\n\n运行构建后的程序 \n```\naac-enc [-r bitrate] [-t aot] [-a afterburner] [-s sbr] [-v vbr] in.wav out.aac\n```\n该程序可以读取wav音频文件，编码为aac，将编码后的数据写入`out.aac` 文件中。\n\n\n## 注意事项\n\nfdk-aac 只支持采样格式为`int16`类型的定点格式，不支持如`float32`类型的浮点格式。\n\nfdk-aac 默认一帧1024个采样。\n\n\n\n\n\n\n\n\n\n","slug":"aac/2022-09-23-fdk-aac","published":1,"updated":"2024-03-06T11:53:13.564Z","comments":1,"photos":[],"_id":"cltgopen8000uqywhhyxa98om","content":"<p>github 地址： <a href=\"https://github.com/mstorsjo/fdk-aac\">https://github.com/mstorsjo/fdk-aac</a></p>\n<p>fdk-aac 提供了跨平台的编解码 aac 的功能。</p>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><p>fdk-aac提供了CMake构建静态库和动态库。</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\"><span class=\"hljs-keyword\">cd</span> fdk-aac<br>mkidr build <br><span class=\"hljs-comment\">#BUILD_SHARED_LIBS 控制构建静态库还是动态库</span><br>cmake <span class=\"hljs-string\">..</span> -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=OFF<br>cmake <span class=\"hljs-params\">--build</span> <span class=\"hljs-params\">--config</span> Release<br><span class=\"hljs-comment\"># install</span><br>cmake <span class=\"hljs-params\">--install</span> &lt;dir&gt; <span class=\"hljs-params\">--prefix</span> &lt;prefix&gt;<br></code></pre></td></tr></table></figure>\n<h2 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h2><p>在documentation目录下，有两个pdf文件，分别对应编码和解码相关的文档。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">aacDecoder<span class=\"hljs-selector-class\">.pdf</span><br>aacEncoder.pdf<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h2><p>fdk-aac 提供一个编码的示例<code>aac-enc.c</code>， 主要介绍如何实现aac 编码功能<br>该demo 可以通过cmake来调试。<br>首先在cmake 中启用该程序，给cmake 传递参数<code>-DBUILD_PROGRAMS=TRUE</code></p>\n<p>运行构建后的程序 </p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">aac-enc <span class=\"hljs-selector-attr\">[-r bitrate]</span> <span class=\"hljs-selector-attr\">[-t aot]</span> <span class=\"hljs-selector-attr\">[-a afterburner]</span> <span class=\"hljs-selector-attr\">[-s sbr]</span> <span class=\"hljs-selector-attr\">[-v vbr]</span> <span class=\"hljs-keyword\">in</span><span class=\"hljs-selector-class\">.wav</span> out.aac<br></code></pre></td></tr></table></figure>\n<p>该程序可以读取wav音频文件，编码为aac，将编码后的数据写入<code>out.aac</code> 文件中。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>fdk-aac 只支持采样格式为<code>int16</code>类型的定点格式，不支持如<code>float32</code>类型的浮点格式。</p>\n<p>fdk-aac 默认一帧1024个采样。</p>\n","excerpt":"","more":"<p>github 地址： <a href=\"https://github.com/mstorsjo/fdk-aac\">https://github.com/mstorsjo/fdk-aac</a></p>\n<p>fdk-aac 提供了跨平台的编解码 aac 的功能。</p>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><p>fdk-aac提供了CMake构建静态库和动态库。</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\"><span class=\"hljs-keyword\">cd</span> fdk-aac<br>mkidr build <br><span class=\"hljs-comment\">#BUILD_SHARED_LIBS 控制构建静态库还是动态库</span><br>cmake <span class=\"hljs-string\">..</span> -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=OFF<br>cmake <span class=\"hljs-params\">--build</span> <span class=\"hljs-params\">--config</span> Release<br><span class=\"hljs-comment\"># install</span><br>cmake <span class=\"hljs-params\">--install</span> &lt;dir&gt; <span class=\"hljs-params\">--prefix</span> &lt;prefix&gt;<br></code></pre></td></tr></table></figure>\n<h2 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h2><p>在documentation目录下，有两个pdf文件，分别对应编码和解码相关的文档。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">aacDecoder<span class=\"hljs-selector-class\">.pdf</span><br>aacEncoder.pdf<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h2><p>fdk-aac 提供一个编码的示例<code>aac-enc.c</code>， 主要介绍如何实现aac 编码功能<br>该demo 可以通过cmake来调试。<br>首先在cmake 中启用该程序，给cmake 传递参数<code>-DBUILD_PROGRAMS=TRUE</code></p>\n<p>运行构建后的程序 </p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">aac-enc <span class=\"hljs-selector-attr\">[-r bitrate]</span> <span class=\"hljs-selector-attr\">[-t aot]</span> <span class=\"hljs-selector-attr\">[-a afterburner]</span> <span class=\"hljs-selector-attr\">[-s sbr]</span> <span class=\"hljs-selector-attr\">[-v vbr]</span> <span class=\"hljs-keyword\">in</span><span class=\"hljs-selector-class\">.wav</span> out.aac<br></code></pre></td></tr></table></figure>\n<p>该程序可以读取wav音频文件，编码为aac，将编码后的数据写入<code>out.aac</code> 文件中。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>fdk-aac 只支持采样格式为<code>int16</code>类型的定点格式，不支持如<code>float32</code>类型的浮点格式。</p>\n<p>fdk-aac 默认一帧1024个采样。</p>\n"},{"layout":"post","title":"#pragma once 用法总结","date":"2022-03-18T16:00:00.000Z","_content":"\n# pragma once 用法总结\n\n## pragma once 这个宏有什么用？\n\n为了避免同一个头文件被包含（include）多次，C/C++中有两种宏实现方式：一种是#ifndef方式；另一种是#pragma once方式。\n\n在能够支持这两种方式的编译器上，二者并没有太大的区别。但两者仍然有一些细微的区别。\n\n## 两者的使用方式有何区别？\n\n方式1：\n\n```\n#ifndef  __SOMEFILE_H__\n#define   __SOMEFILE_H__\n ... ... // 声明、定义语句\n#endif\n```\n\n方式2：\n\n```\n#pragma once\n ... ... // 声明、定义语句\n```\n\n## 两者各有和特点？\n\n### #ifndef\n\n1. #ifndef的方式受C/C++语言标准支持\n\n2. 通过宏来检测，宏的范围可以是单个文件，也可以是代码片段。保证文件或者代码片段不被重复包含，针对文件的内容。\n\n3. 可能会发生宏冲突，导致你看到头文件明明存在，但编译器却硬说找不到声明的状况（遇到过一次，查了一晚上）\n\n### #pragma once\n\n1. pragma once由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件\n\n2. #pragma once`不是一个标准的指令，但是大多的的编译器已经支持\n\n3. `#pragma once`代替include防范将加快编译速度，ifndef方式需要先打开文件\n\n4. 你无法对一个头文件中的一段代码作pragma once声明，而只能针对文件\n\n5. 好处是，你不必再担心宏名冲突了，当然也就不会出现宏名冲突引发的奇怪问题\n\n参考： [#pragma once用法总结_西北老码农的博客-CSDN博客_#pragma once](https://blog.csdn.net/fanyun_01/article/details/77413992)\n","source":"_posts/c++/2022-03-19-pragma once 用法总结.md","raw":"---\n\nlayout: post\ntitle: \"#pragma once 用法总结\"\ndate: 2022-03-19 \ntag: c++\n\n---\n\n# pragma once 用法总结\n\n## pragma once 这个宏有什么用？\n\n为了避免同一个头文件被包含（include）多次，C/C++中有两种宏实现方式：一种是#ifndef方式；另一种是#pragma once方式。\n\n在能够支持这两种方式的编译器上，二者并没有太大的区别。但两者仍然有一些细微的区别。\n\n## 两者的使用方式有何区别？\n\n方式1：\n\n```\n#ifndef  __SOMEFILE_H__\n#define   __SOMEFILE_H__\n ... ... // 声明、定义语句\n#endif\n```\n\n方式2：\n\n```\n#pragma once\n ... ... // 声明、定义语句\n```\n\n## 两者各有和特点？\n\n### #ifndef\n\n1. #ifndef的方式受C/C++语言标准支持\n\n2. 通过宏来检测，宏的范围可以是单个文件，也可以是代码片段。保证文件或者代码片段不被重复包含，针对文件的内容。\n\n3. 可能会发生宏冲突，导致你看到头文件明明存在，但编译器却硬说找不到声明的状况（遇到过一次，查了一晚上）\n\n### #pragma once\n\n1. pragma once由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件\n\n2. #pragma once`不是一个标准的指令，但是大多的的编译器已经支持\n\n3. `#pragma once`代替include防范将加快编译速度，ifndef方式需要先打开文件\n\n4. 你无法对一个头文件中的一段代码作pragma once声明，而只能针对文件\n\n5. 好处是，你不必再担心宏名冲突了，当然也就不会出现宏名冲突引发的奇怪问题\n\n参考： [#pragma once用法总结_西北老码农的博客-CSDN博客_#pragma once](https://blog.csdn.net/fanyun_01/article/details/77413992)\n","slug":"c++/2022-03-19-pragma once 用法总结","published":1,"updated":"2024-03-06T11:53:13.564Z","comments":1,"photos":[],"_id":"cltgopen9000xqywhdz9p67rt","content":"<h1 id=\"pragma-once-用法总结\"><a href=\"#pragma-once-用法总结\" class=\"headerlink\" title=\"pragma once 用法总结\"></a>pragma once 用法总结</h1><h2 id=\"pragma-once-这个宏有什么用？\"><a href=\"#pragma-once-这个宏有什么用？\" class=\"headerlink\" title=\"pragma once 这个宏有什么用？\"></a>pragma once 这个宏有什么用？</h2><p>为了避免同一个头文件被包含（include）多次，C&#x2F;C++中有两种宏实现方式：一种是#ifndef方式；另一种是#pragma once方式。</p>\n<p>在能够支持这两种方式的编译器上，二者并没有太大的区别。但两者仍然有一些细微的区别。</p>\n<h2 id=\"两者的使用方式有何区别？\"><a href=\"#两者的使用方式有何区别？\" class=\"headerlink\" title=\"两者的使用方式有何区别？\"></a>两者的使用方式有何区别？</h2><p>方式1：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span>  __SOMEFILE_H__</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>   __SOMEFILE_H__</span><br> ... ... <span class=\"hljs-comment\">// 声明、定义语句</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br></code></pre></td></tr></table></figure>\n\n<p>方式2：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\"><span class=\"hljs-comment\">#pragma once</span><br> <span class=\"hljs-string\">...</span> <span class=\"hljs-string\">...</span> <span class=\"hljs-string\">//</span> 声明、定义语句<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"两者各有和特点？\"><a href=\"#两者各有和特点？\" class=\"headerlink\" title=\"两者各有和特点？\"></a>两者各有和特点？</h2><h3 id=\"ifndef\"><a href=\"#ifndef\" class=\"headerlink\" title=\"#ifndef\"></a>#ifndef</h3><ol>\n<li><p>#ifndef的方式受C&#x2F;C++语言标准支持</p>\n</li>\n<li><p>通过宏来检测，宏的范围可以是单个文件，也可以是代码片段。保证文件或者代码片段不被重复包含，针对文件的内容。</p>\n</li>\n<li><p>可能会发生宏冲突，导致你看到头文件明明存在，但编译器却硬说找不到声明的状况（遇到过一次，查了一晚上）</p>\n</li>\n</ol>\n<h3 id=\"pragma-once\"><a href=\"#pragma-once\" class=\"headerlink\" title=\"#pragma once\"></a>#pragma once</h3><ol>\n<li><p>pragma once由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件</p>\n</li>\n<li><p>#pragma once&#96;不是一个标准的指令，但是大多的的编译器已经支持</p>\n</li>\n<li><p><code>#pragma once</code>代替include防范将加快编译速度，ifndef方式需要先打开文件</p>\n</li>\n<li><p>你无法对一个头文件中的一段代码作pragma once声明，而只能针对文件</p>\n</li>\n<li><p>好处是，你不必再担心宏名冲突了，当然也就不会出现宏名冲突引发的奇怪问题</p>\n</li>\n</ol>\n<p>参考： <a href=\"https://blog.csdn.net/fanyun_01/article/details/77413992\">#pragma once用法总结_西北老码农的博客-CSDN博客_#pragma once</a></p>\n","excerpt":"","more":"<h1 id=\"pragma-once-用法总结\"><a href=\"#pragma-once-用法总结\" class=\"headerlink\" title=\"pragma once 用法总结\"></a>pragma once 用法总结</h1><h2 id=\"pragma-once-这个宏有什么用？\"><a href=\"#pragma-once-这个宏有什么用？\" class=\"headerlink\" title=\"pragma once 这个宏有什么用？\"></a>pragma once 这个宏有什么用？</h2><p>为了避免同一个头文件被包含（include）多次，C&#x2F;C++中有两种宏实现方式：一种是#ifndef方式；另一种是#pragma once方式。</p>\n<p>在能够支持这两种方式的编译器上，二者并没有太大的区别。但两者仍然有一些细微的区别。</p>\n<h2 id=\"两者的使用方式有何区别？\"><a href=\"#两者的使用方式有何区别？\" class=\"headerlink\" title=\"两者的使用方式有何区别？\"></a>两者的使用方式有何区别？</h2><p>方式1：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span>  __SOMEFILE_H__</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>   __SOMEFILE_H__</span><br> ... ... <span class=\"hljs-comment\">// 声明、定义语句</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br></code></pre></td></tr></table></figure>\n\n<p>方式2：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\"><span class=\"hljs-comment\">#pragma once</span><br> <span class=\"hljs-string\">...</span> <span class=\"hljs-string\">...</span> <span class=\"hljs-string\">//</span> 声明、定义语句<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"两者各有和特点？\"><a href=\"#两者各有和特点？\" class=\"headerlink\" title=\"两者各有和特点？\"></a>两者各有和特点？</h2><h3 id=\"ifndef\"><a href=\"#ifndef\" class=\"headerlink\" title=\"#ifndef\"></a>#ifndef</h3><ol>\n<li><p>#ifndef的方式受C&#x2F;C++语言标准支持</p>\n</li>\n<li><p>通过宏来检测，宏的范围可以是单个文件，也可以是代码片段。保证文件或者代码片段不被重复包含，针对文件的内容。</p>\n</li>\n<li><p>可能会发生宏冲突，导致你看到头文件明明存在，但编译器却硬说找不到声明的状况（遇到过一次，查了一晚上）</p>\n</li>\n</ol>\n<h3 id=\"pragma-once\"><a href=\"#pragma-once\" class=\"headerlink\" title=\"#pragma once\"></a>#pragma once</h3><ol>\n<li><p>pragma once由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件</p>\n</li>\n<li><p>#pragma once&#96;不是一个标准的指令，但是大多的的编译器已经支持</p>\n</li>\n<li><p><code>#pragma once</code>代替include防范将加快编译速度，ifndef方式需要先打开文件</p>\n</li>\n<li><p>你无法对一个头文件中的一段代码作pragma once声明，而只能针对文件</p>\n</li>\n<li><p>好处是，你不必再担心宏名冲突了，当然也就不会出现宏名冲突引发的奇怪问题</p>\n</li>\n</ol>\n<p>参考： <a href=\"https://blog.csdn.net/fanyun_01/article/details/77413992\">#pragma once用法总结_西北老码农的博客-CSDN博客_#pragma once</a></p>\n"},{"layout":"post","title":"git hooks  结合 clang-format 提交前自动格式化代码","date":"2022-03-20T16:00:00.000Z","_content":"\n## [ClangFormat ](https://clang.llvm.org/docs/ClangFormat.html)\n\nClangFormat 描述了一组构建在 [LibFormat]((https://clang.llvm.org/docs/LibFormat.html)) 之上的工具。它可以以多种方式支持您的工作流，包括独立工具和编辑器集成。\n\n其中独立的工具就是clang-format, 可用于格式化 c/c + +/Java/JavaScript/JSON/Objective-C/Protobuf/c # 代码。\n\nclang-format的默认配置文件是`.clang-format`或`_clang-format`, 也可以通过`clang-format -style=file`指定配置文件。\n\n\n\n`.clang-format` 使用yaml格式，指定了如何对文件格式化的规则。\n\n可以基于预定义的样式，快速创建`.clang-format`文件。\n\n- `LLVM` A style complying with the [LLVM coding standards](https://llvm.org/docs/CodingStandards.html)\n\n- `Google` A style complying with [Google’s C++ style guide](https://google.github.io/styleguide/cppguide.html)\n\n- `Chromium` A style complying with [Chromium’s style guide](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md)\n\n- `Mozilla` A style complying with [Mozilla’s style guide](https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html)\n\n- `WebKit` A style complying with [WebKit’s style guide](https://www.webkit.org/coding/coding-style.html)\n\n- `Microsoft` A style complying with [Microsoft’s style guide](https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference)\n\n- `GNU` A style complying with the [GNU coding standards](https://www.gnu.org/prep/standards/standards.html)\n\n例如生成llvm风格的：\n\n```\nclang-format -style=llvm -dump-config > .clang-format\n```\n\n 然后可以基于生成的`.clang-format`文件修改参数，定制自己的样式。\n\n更多参考： [Clang-Format Style Options ](https://clang.llvm.org/docs/ClangFormatStyleOptions.html)\n\n\n\n\n\nmac 下安装 clang-format\n\n```\nbrew install clang-format\n```\n\n将生成的`.clang-format`放入工程目录，执行命令格式化文件\n\n```\nclang-format -i xx.cpp\n```\n\n`-i`格式化当前文件，并将格式化后的内容输出到当前文件。不加`-i`会将格式化的内容输出到标准输出。\n\n\n\n然后我们希望在提交的时候根据我们的配置，自动格式化代码，如何做呢？\n\n可以通过git hooks 结合clang-format 在提交的时候自动格式化我们的代码。\n\n## [pre-commit](https://pre-commit.com/)\n\n> A framework for managing and maintaining multi-language pre-commit hooks.\n\n\n\n 安装：\n\n```\n$ brew install pre-commit\n# 查看版本\n$ pre-commit --version\npre-commit 2.17.0\n```\n\n\n\n添加配置文件`.pre-commit-config.yaml`，通过[`pre-commit sample-config`](https://pre-commit.com/#pre-commit-sample-config)\n\n命令快速生成一个基本的配置文件。 更多关于文件中选项的配置，参考[pre-commit](https://pre-commit.com/#plugins)\n\n```\n➜  ~ pre-commit sample-config\n# See https://pre-commit.com for more information\n# See https://pre-commit.com/hooks.html for more hooks\nrepos:\n-   repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v3.2.0\n    hooks:\n    -   id: trailing-whitespace\n    -   id: end-of-file-fixer\n    -   id: check-yaml\n    -   id: check-added-large-files\n```\n\n上面配置指定了如何去格式化python代码，pre commit 支持格式化其他的编程语言，参考\n\n[supported hooks](https://pre-commit.com/hooks.html)查看所有支持的语言。\n\n\n\n想结合clang-format对工程中的c++代码自动格式化。在[supported hooks](https://pre-commit.com/hooks.html)找到了[GitHub - doublify/pre-commit-clang-format: ClangFormat hook for pre-commit](https://github.com/doublify/pre-commit-clang-format)\n\n\n\n如何使用呢?\n\n1. 在工程中创建`.pre-commit-config.yaml`文件\n\n2. 配置`.pre-commit-config.yaml`文件\n   \n   ```\n   repos:\n   -   repo: https://github.com/doublify/pre-commit-clang-format.git\n       rev: 62302476d0da01515660132d76902359bed0f782\n       hooks:\n       -   id: clang-format\n   ```\n\n3. 安装git hooks 脚本\n   \n   ```\n   $ pre-commit install\n   pre-commit installed at .git/hooks/pre-commit\n   ```\n\n4.  (可选)手动调用pre commit，看看格式化后的效果\n   \n   ```\n   $ pre-commit run --all-files\n   ```\n\n5.  调用`git commit`, 会触发git hook，调用`clang-format`自动化格式代码。\n\n\n","source":"_posts/c++/2022-03-21-git hook clang-format.md","raw":"---\n\nlayout: post\ntitle: \"git hooks  结合 clang-format 提交前自动格式化代码\"\ndate: 2022-03-21 \ntag: c++\n\n---\n\n## [ClangFormat ](https://clang.llvm.org/docs/ClangFormat.html)\n\nClangFormat 描述了一组构建在 [LibFormat]((https://clang.llvm.org/docs/LibFormat.html)) 之上的工具。它可以以多种方式支持您的工作流，包括独立工具和编辑器集成。\n\n其中独立的工具就是clang-format, 可用于格式化 c/c + +/Java/JavaScript/JSON/Objective-C/Protobuf/c # 代码。\n\nclang-format的默认配置文件是`.clang-format`或`_clang-format`, 也可以通过`clang-format -style=file`指定配置文件。\n\n\n\n`.clang-format` 使用yaml格式，指定了如何对文件格式化的规则。\n\n可以基于预定义的样式，快速创建`.clang-format`文件。\n\n- `LLVM` A style complying with the [LLVM coding standards](https://llvm.org/docs/CodingStandards.html)\n\n- `Google` A style complying with [Google’s C++ style guide](https://google.github.io/styleguide/cppguide.html)\n\n- `Chromium` A style complying with [Chromium’s style guide](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md)\n\n- `Mozilla` A style complying with [Mozilla’s style guide](https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html)\n\n- `WebKit` A style complying with [WebKit’s style guide](https://www.webkit.org/coding/coding-style.html)\n\n- `Microsoft` A style complying with [Microsoft’s style guide](https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference)\n\n- `GNU` A style complying with the [GNU coding standards](https://www.gnu.org/prep/standards/standards.html)\n\n例如生成llvm风格的：\n\n```\nclang-format -style=llvm -dump-config > .clang-format\n```\n\n 然后可以基于生成的`.clang-format`文件修改参数，定制自己的样式。\n\n更多参考： [Clang-Format Style Options ](https://clang.llvm.org/docs/ClangFormatStyleOptions.html)\n\n\n\n\n\nmac 下安装 clang-format\n\n```\nbrew install clang-format\n```\n\n将生成的`.clang-format`放入工程目录，执行命令格式化文件\n\n```\nclang-format -i xx.cpp\n```\n\n`-i`格式化当前文件，并将格式化后的内容输出到当前文件。不加`-i`会将格式化的内容输出到标准输出。\n\n\n\n然后我们希望在提交的时候根据我们的配置，自动格式化代码，如何做呢？\n\n可以通过git hooks 结合clang-format 在提交的时候自动格式化我们的代码。\n\n## [pre-commit](https://pre-commit.com/)\n\n> A framework for managing and maintaining multi-language pre-commit hooks.\n\n\n\n 安装：\n\n```\n$ brew install pre-commit\n# 查看版本\n$ pre-commit --version\npre-commit 2.17.0\n```\n\n\n\n添加配置文件`.pre-commit-config.yaml`，通过[`pre-commit sample-config`](https://pre-commit.com/#pre-commit-sample-config)\n\n命令快速生成一个基本的配置文件。 更多关于文件中选项的配置，参考[pre-commit](https://pre-commit.com/#plugins)\n\n```\n➜  ~ pre-commit sample-config\n# See https://pre-commit.com for more information\n# See https://pre-commit.com/hooks.html for more hooks\nrepos:\n-   repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v3.2.0\n    hooks:\n    -   id: trailing-whitespace\n    -   id: end-of-file-fixer\n    -   id: check-yaml\n    -   id: check-added-large-files\n```\n\n上面配置指定了如何去格式化python代码，pre commit 支持格式化其他的编程语言，参考\n\n[supported hooks](https://pre-commit.com/hooks.html)查看所有支持的语言。\n\n\n\n想结合clang-format对工程中的c++代码自动格式化。在[supported hooks](https://pre-commit.com/hooks.html)找到了[GitHub - doublify/pre-commit-clang-format: ClangFormat hook for pre-commit](https://github.com/doublify/pre-commit-clang-format)\n\n\n\n如何使用呢?\n\n1. 在工程中创建`.pre-commit-config.yaml`文件\n\n2. 配置`.pre-commit-config.yaml`文件\n   \n   ```\n   repos:\n   -   repo: https://github.com/doublify/pre-commit-clang-format.git\n       rev: 62302476d0da01515660132d76902359bed0f782\n       hooks:\n       -   id: clang-format\n   ```\n\n3. 安装git hooks 脚本\n   \n   ```\n   $ pre-commit install\n   pre-commit installed at .git/hooks/pre-commit\n   ```\n\n4.  (可选)手动调用pre commit，看看格式化后的效果\n   \n   ```\n   $ pre-commit run --all-files\n   ```\n\n5.  调用`git commit`, 会触发git hook，调用`clang-format`自动化格式代码。\n\n\n","slug":"c++/2022-03-21-git hook clang-format","published":1,"updated":"2024-03-06T11:53:13.564Z","comments":1,"photos":[],"_id":"cltgopen9000zqywh6fvg97yh","content":"<h2 id=\"ClangFormat\"><a href=\"#ClangFormat\" class=\"headerlink\" title=\"ClangFormat \"></a><a href=\"https://clang.llvm.org/docs/ClangFormat.html\">ClangFormat </a></h2><p>ClangFormat 描述了一组构建在 <a href=\"(https://clang.llvm.org/docs/LibFormat.html)\">LibFormat</a> 之上的工具。它可以以多种方式支持您的工作流，包括独立工具和编辑器集成。</p>\n<p>其中独立的工具就是clang-format, 可用于格式化 c&#x2F;c + +&#x2F;Java&#x2F;JavaScript&#x2F;JSON&#x2F;Objective-C&#x2F;Protobuf&#x2F;c # 代码。</p>\n<p>clang-format的默认配置文件是<code>.clang-format</code>或<code>_clang-format</code>, 也可以通过<code>clang-format -style=file</code>指定配置文件。</p>\n<p><code>.clang-format</code> 使用yaml格式，指定了如何对文件格式化的规则。</p>\n<p>可以基于预定义的样式，快速创建<code>.clang-format</code>文件。</p>\n<ul>\n<li><p><code>LLVM</code> A style complying with the <a href=\"https://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></p>\n</li>\n<li><p><code>Google</code> A style complying with <a href=\"https://google.github.io/styleguide/cppguide.html\">Google’s C++ style guide</a></p>\n</li>\n<li><p><code>Chromium</code> A style complying with <a href=\"https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md\">Chromium’s style guide</a></p>\n</li>\n<li><p><code>Mozilla</code> A style complying with <a href=\"https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html\">Mozilla’s style guide</a></p>\n</li>\n<li><p><code>WebKit</code> A style complying with <a href=\"https://www.webkit.org/coding/coding-style.html\">WebKit’s style guide</a></p>\n</li>\n<li><p><code>Microsoft</code> A style complying with <a href=\"https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference\">Microsoft’s style guide</a></p>\n</li>\n<li><p><code>GNU</code> A style complying with the <a href=\"https://www.gnu.org/prep/standards/standards.html\">GNU coding standards</a></p>\n</li>\n</ul>\n<p>例如生成llvm风格的：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lua\">clang-<span class=\"hljs-built_in\">format</span> -style=llvm -<span class=\"hljs-built_in\">dump</span>-<span class=\"hljs-built_in\">config</span> &gt; .clang-<span class=\"hljs-built_in\">format</span><br></code></pre></td></tr></table></figure>\n\n<p> 然后可以基于生成的<code>.clang-format</code>文件修改参数，定制自己的样式。</p>\n<p>更多参考： <a href=\"https://clang.llvm.org/docs/ClangFormatStyleOptions.html\">Clang-Format Style Options </a></p>\n<p>mac 下安装 clang-format</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">brew </span><span class=\"hljs-keyword\">install </span>clang-format<br></code></pre></td></tr></table></figure>\n\n<p>将生成的<code>.clang-format</code>放入工程目录，执行命令格式化文件</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">clang-format -<span class=\"hljs-selector-tag\">i</span> xx<span class=\"hljs-selector-class\">.cpp</span><br></code></pre></td></tr></table></figure>\n\n<p><code>-i</code>格式化当前文件，并将格式化后的内容输出到当前文件。不加<code>-i</code>会将格式化的内容输出到标准输出。</p>\n<p>然后我们希望在提交的时候根据我们的配置，自动格式化代码，如何做呢？</p>\n<p>可以通过git hooks 结合clang-format 在提交的时候自动格式化我们的代码。</p>\n<h2 id=\"pre-commit\"><a href=\"#pre-commit\" class=\"headerlink\" title=\"pre-commit\"></a><a href=\"https://pre-commit.com/\">pre-commit</a></h2><blockquote>\n<p>A framework for managing and maintaining multi-language pre-commit hooks.</p>\n</blockquote>\n<p> 安装：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">$ brew install pre<span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">commit</span><br># 查看版本<br>$ pre<span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">commit</span> <span class=\"hljs-comment\">--version</span><br>pre<span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">commit</span> <span class=\"hljs-number\">2.17</span><span class=\"hljs-number\">.0</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>添加配置文件<code>.pre-commit-config.yaml</code>，通过<a href=\"https://pre-commit.com/#pre-commit-sample-config\"><code>pre-commit sample-config</code></a></p>\n<p>命令快速生成一个基本的配置文件。 更多关于文件中选项的配置，参考<a href=\"https://pre-commit.com/#plugins\">pre-commit</a></p>\n<figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs smali\">➜  ~ pre-commit sample-config<br><span class=\"hljs-comment\"># See https://pre-commit.com for more information</span><br><span class=\"hljs-comment\"># See https://pre-commit.com/hooks.html for more hooks</span><br>repos:<br>-   repo: https://github.com/pre-commit/pre-commit-hooks<br>    rev: v3.2.0<br>    hooks:<br>    -   id: trailing-whitespace<br>    -   id: end-of-file-fixer<br>    -   id:<span class=\"hljs-built_in\"> check-yaml</span><br><span class=\"hljs-built_in\"></span>    -   id: check-added-large-files<br></code></pre></td></tr></table></figure>\n\n<p>上面配置指定了如何去格式化python代码，pre commit 支持格式化其他的编程语言，参考</p>\n<p><a href=\"https://pre-commit.com/hooks.html\">supported hooks</a>查看所有支持的语言。</p>\n<p>想结合clang-format对工程中的c++代码自动格式化。在<a href=\"https://pre-commit.com/hooks.html\">supported hooks</a>找到了<a href=\"https://github.com/doublify/pre-commit-clang-format\">GitHub - doublify&#x2F;pre-commit-clang-format: ClangFormat hook for pre-commit</a></p>\n<p>如何使用呢?</p>\n<ol>\n<li><p>在工程中创建<code>.pre-commit-config.yaml</code>文件</p>\n</li>\n<li><p>配置<code>.pre-commit-config.yaml</code>文件</p>\n<figure class=\"highlight nestedtext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nestedtext\"><span class=\"hljs-attribute\">repos</span><span class=\"hljs-punctuation\">:</span><br><span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">  repo: https://github.com/doublify/pre-commit-clang-format.git</span><br>    <span class=\"hljs-attribute\">rev</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">62302476d0da01515660132d76902359bed0f782</span><br>    <span class=\"hljs-attribute\">hooks</span><span class=\"hljs-punctuation\">:</span><br>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">  id: clang-format</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>安装git hooks 脚本</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">$ pre<span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">commit</span> install<br>pre<span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">commit</span> installed <span class=\"hljs-keyword\">at</span> .git<span class=\"hljs-operator\">/</span>hooks<span class=\"hljs-operator\">/</span>pre<span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">commit</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>(可选)手动调用pre commit，看看格式化后的效果</p>\n</li>\n</ol>\n   <figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-symbol\">$</span> pre-commit run --<span class=\"hljs-keyword\">all</span>-<span class=\"hljs-keyword\">files</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>调用<code>git commit</code>, 会触发git hook，调用<code>clang-format</code>自动化格式代码。</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"ClangFormat\"><a href=\"#ClangFormat\" class=\"headerlink\" title=\"ClangFormat \"></a><a href=\"https://clang.llvm.org/docs/ClangFormat.html\">ClangFormat </a></h2><p>ClangFormat 描述了一组构建在 <a href=\"(https://clang.llvm.org/docs/LibFormat.html)\">LibFormat</a> 之上的工具。它可以以多种方式支持您的工作流，包括独立工具和编辑器集成。</p>\n<p>其中独立的工具就是clang-format, 可用于格式化 c&#x2F;c + +&#x2F;Java&#x2F;JavaScript&#x2F;JSON&#x2F;Objective-C&#x2F;Protobuf&#x2F;c # 代码。</p>\n<p>clang-format的默认配置文件是<code>.clang-format</code>或<code>_clang-format</code>, 也可以通过<code>clang-format -style=file</code>指定配置文件。</p>\n<p><code>.clang-format</code> 使用yaml格式，指定了如何对文件格式化的规则。</p>\n<p>可以基于预定义的样式，快速创建<code>.clang-format</code>文件。</p>\n<ul>\n<li><p><code>LLVM</code> A style complying with the <a href=\"https://llvm.org/docs/CodingStandards.html\">LLVM coding standards</a></p>\n</li>\n<li><p><code>Google</code> A style complying with <a href=\"https://google.github.io/styleguide/cppguide.html\">Google’s C++ style guide</a></p>\n</li>\n<li><p><code>Chromium</code> A style complying with <a href=\"https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md\">Chromium’s style guide</a></p>\n</li>\n<li><p><code>Mozilla</code> A style complying with <a href=\"https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html\">Mozilla’s style guide</a></p>\n</li>\n<li><p><code>WebKit</code> A style complying with <a href=\"https://www.webkit.org/coding/coding-style.html\">WebKit’s style guide</a></p>\n</li>\n<li><p><code>Microsoft</code> A style complying with <a href=\"https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference\">Microsoft’s style guide</a></p>\n</li>\n<li><p><code>GNU</code> A style complying with the <a href=\"https://www.gnu.org/prep/standards/standards.html\">GNU coding standards</a></p>\n</li>\n</ul>\n<p>例如生成llvm风格的：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lua\">clang-<span class=\"hljs-built_in\">format</span> -style=llvm -<span class=\"hljs-built_in\">dump</span>-<span class=\"hljs-built_in\">config</span> &gt; .clang-<span class=\"hljs-built_in\">format</span><br></code></pre></td></tr></table></figure>\n\n<p> 然后可以基于生成的<code>.clang-format</code>文件修改参数，定制自己的样式。</p>\n<p>更多参考： <a href=\"https://clang.llvm.org/docs/ClangFormatStyleOptions.html\">Clang-Format Style Options </a></p>\n<p>mac 下安装 clang-format</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">brew </span><span class=\"hljs-keyword\">install </span>clang-format<br></code></pre></td></tr></table></figure>\n\n<p>将生成的<code>.clang-format</code>放入工程目录，执行命令格式化文件</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">clang-format -<span class=\"hljs-selector-tag\">i</span> xx<span class=\"hljs-selector-class\">.cpp</span><br></code></pre></td></tr></table></figure>\n\n<p><code>-i</code>格式化当前文件，并将格式化后的内容输出到当前文件。不加<code>-i</code>会将格式化的内容输出到标准输出。</p>\n<p>然后我们希望在提交的时候根据我们的配置，自动格式化代码，如何做呢？</p>\n<p>可以通过git hooks 结合clang-format 在提交的时候自动格式化我们的代码。</p>\n<h2 id=\"pre-commit\"><a href=\"#pre-commit\" class=\"headerlink\" title=\"pre-commit\"></a><a href=\"https://pre-commit.com/\">pre-commit</a></h2><blockquote>\n<p>A framework for managing and maintaining multi-language pre-commit hooks.</p>\n</blockquote>\n<p> 安装：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">$ brew install pre<span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">commit</span><br># 查看版本<br>$ pre<span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">commit</span> <span class=\"hljs-comment\">--version</span><br>pre<span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">commit</span> <span class=\"hljs-number\">2.17</span><span class=\"hljs-number\">.0</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>添加配置文件<code>.pre-commit-config.yaml</code>，通过<a href=\"https://pre-commit.com/#pre-commit-sample-config\"><code>pre-commit sample-config</code></a></p>\n<p>命令快速生成一个基本的配置文件。 更多关于文件中选项的配置，参考<a href=\"https://pre-commit.com/#plugins\">pre-commit</a></p>\n<figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs smali\">➜  ~ pre-commit sample-config<br><span class=\"hljs-comment\"># See https://pre-commit.com for more information</span><br><span class=\"hljs-comment\"># See https://pre-commit.com/hooks.html for more hooks</span><br>repos:<br>-   repo: https://github.com/pre-commit/pre-commit-hooks<br>    rev: v3.2.0<br>    hooks:<br>    -   id: trailing-whitespace<br>    -   id: end-of-file-fixer<br>    -   id:<span class=\"hljs-built_in\"> check-yaml</span><br><span class=\"hljs-built_in\"></span>    -   id: check-added-large-files<br></code></pre></td></tr></table></figure>\n\n<p>上面配置指定了如何去格式化python代码，pre commit 支持格式化其他的编程语言，参考</p>\n<p><a href=\"https://pre-commit.com/hooks.html\">supported hooks</a>查看所有支持的语言。</p>\n<p>想结合clang-format对工程中的c++代码自动格式化。在<a href=\"https://pre-commit.com/hooks.html\">supported hooks</a>找到了<a href=\"https://github.com/doublify/pre-commit-clang-format\">GitHub - doublify&#x2F;pre-commit-clang-format: ClangFormat hook for pre-commit</a></p>\n<p>如何使用呢?</p>\n<ol>\n<li><p>在工程中创建<code>.pre-commit-config.yaml</code>文件</p>\n</li>\n<li><p>配置<code>.pre-commit-config.yaml</code>文件</p>\n<figure class=\"highlight nestedtext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nestedtext\"><span class=\"hljs-attribute\">repos</span><span class=\"hljs-punctuation\">:</span><br><span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">  repo: https://github.com/doublify/pre-commit-clang-format.git</span><br>    <span class=\"hljs-attribute\">rev</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">62302476d0da01515660132d76902359bed0f782</span><br>    <span class=\"hljs-attribute\">hooks</span><span class=\"hljs-punctuation\">:</span><br>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">  id: clang-format</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>安装git hooks 脚本</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">$ pre<span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">commit</span> install<br>pre<span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">commit</span> installed <span class=\"hljs-keyword\">at</span> .git<span class=\"hljs-operator\">/</span>hooks<span class=\"hljs-operator\">/</span>pre<span class=\"hljs-operator\">-</span><span class=\"hljs-keyword\">commit</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>(可选)手动调用pre commit，看看格式化后的效果</p>\n</li>\n</ol>\n   <figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-symbol\">$</span> pre-commit run --<span class=\"hljs-keyword\">all</span>-<span class=\"hljs-keyword\">files</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>调用<code>git commit</code>, 会触发git hook，调用<code>clang-format</code>自动化格式代码。</li>\n</ol>\n"},{"layout":"post","title":"Xcode 配置 clang-format 格式化 C++代码","date":"2022-10-28T16:00:00.000Z","_content":"\n在命令行，通过`clang-format`工具，可以对代码进行格式化。但 `clang-fromat` 只能在终端中使用，有没有什么办法可以让它在Xcode中也可以使用呢，这样就很方便的对当前文档进行格式化了。 答案是： 借助 macOS 自带的 Automator 工具。\n\n\n## clang-format 安装\n\n```\nbrew install clang-format\n```\n\n## 添加 Automator 服务\n\n打开 Automator 选择  \"Quick Action\"。\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670101357781667010134833.png)\n\n\n左侧 Library 中搜索 \"Run Shell Script\" 并拖动到右侧。在脚本编辑框中输入以下内容：\n```\nsource ~/.zshrc\nclang-format\n```\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670116407351667011639954.png)\n\n同时记得勾选上 \"Output replaces selected text\"，然后保存并输入保存的名称，比如 clang-format。\n\n至此一个服务便已添加好。\n\n### Automator 在磁盘上的位置\n\nThe location of the user created services is under:\n\n```\n~/Library/Services/\n```\n\nother locations you get by entering following command in Terminal:\n\n```\nmdfind .workflow\n```\n\n## 使用\n\n用户主目录，创建 `.clang-format` 文件\n\n```\nclang-format -style=google -dump-config > .clang-format\n```\n打开 Xcode， 选中需要格式化的代码并右键唤出菜单。选择 Services-> clang-format，这里 Services 中的名称即为前面步骤中保存的 Services 名称。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670146406641667014640354.png)\n\n### 添加快捷键\n\n显然右键这种方式不够便捷，进一步添加快捷键来实现更加方便的代码格式化。因为 Xcode 中格式化代码默认的快捷键为 control + I，不防我们就设置 clang-format 这个服务的快捷键为这个按键组合。\n\n打开系统的首选项设置（可通过在 SpotLight 中搜索 \"system preference\"），然后打开键盘设置 \"Kyeboard\" 并切换到 \"Shortcuts\" 标签。\n\n选中左侧 \"App Shortcuts\" 然后为 \"Xcode\" 绑定 `control` + `I` 执行 clang-format。\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670145906661667014590001.png)\n\n然后便可通过快捷键方便地进行代码格式化了。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670146746631667014674463.png)\n\n**注意：**\n如果不生效，将 Xcode 中 `control` + `I` 相关的快捷键置空。\n\n## 其他工具\n\n存在一些其他以插件形式的工具，同样能达到使用 clang-format 格式化代码的目的，比如 [travisjeffery/ClangFormat-Xcode](https://github.com/travisjeffery/ClangFormat-Xcode)，但不支持 Xcode 9+，可安装其替代版 [V5zhou/ZZClang-format](https://github.com/V5zhou/ZZClang-format)\n\n该插件安装好后，支持在文件保存时自动格式化，比较方便。\n\n但因为是来自社区的插件，需要先将 Xcode 去掉签名 （unsign），参见 [inket/update_xcode_plugins](https://github.com/inket/update_xcode_plugins)。\n\n\n原文链接： [Xcode 中配置 clang-format 格式化 C++ 代码](https://www.cnblogs.com/Wayou/p/xcode_clang_setup.html)","source":"_posts/c++/2022-10-29-Xcode 配置 clang-format 格式化 c++ 代码.md","raw":"---\n\nlayout: post\ntitle: \"Xcode 配置 clang-format 格式化 C++代码\"\ndate: 2022-10-29\ntag: c++\n\n---\n\n在命令行，通过`clang-format`工具，可以对代码进行格式化。但 `clang-fromat` 只能在终端中使用，有没有什么办法可以让它在Xcode中也可以使用呢，这样就很方便的对当前文档进行格式化了。 答案是： 借助 macOS 自带的 Automator 工具。\n\n\n## clang-format 安装\n\n```\nbrew install clang-format\n```\n\n## 添加 Automator 服务\n\n打开 Automator 选择  \"Quick Action\"。\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670101357781667010134833.png)\n\n\n左侧 Library 中搜索 \"Run Shell Script\" 并拖动到右侧。在脚本编辑框中输入以下内容：\n```\nsource ~/.zshrc\nclang-format\n```\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670116407351667011639954.png)\n\n同时记得勾选上 \"Output replaces selected text\"，然后保存并输入保存的名称，比如 clang-format。\n\n至此一个服务便已添加好。\n\n### Automator 在磁盘上的位置\n\nThe location of the user created services is under:\n\n```\n~/Library/Services/\n```\n\nother locations you get by entering following command in Terminal:\n\n```\nmdfind .workflow\n```\n\n## 使用\n\n用户主目录，创建 `.clang-format` 文件\n\n```\nclang-format -style=google -dump-config > .clang-format\n```\n打开 Xcode， 选中需要格式化的代码并右键唤出菜单。选择 Services-> clang-format，这里 Services 中的名称即为前面步骤中保存的 Services 名称。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670146406641667014640354.png)\n\n### 添加快捷键\n\n显然右键这种方式不够便捷，进一步添加快捷键来实现更加方便的代码格式化。因为 Xcode 中格式化代码默认的快捷键为 control + I，不防我们就设置 clang-format 这个服务的快捷键为这个按键组合。\n\n打开系统的首选项设置（可通过在 SpotLight 中搜索 \"system preference\"），然后打开键盘设置 \"Kyeboard\" 并切换到 \"Shortcuts\" 标签。\n\n选中左侧 \"App Shortcuts\" 然后为 \"Xcode\" 绑定 `control` + `I` 执行 clang-format。\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670145906661667014590001.png)\n\n然后便可通过快捷键方便地进行代码格式化了。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670146746631667014674463.png)\n\n**注意：**\n如果不生效，将 Xcode 中 `control` + `I` 相关的快捷键置空。\n\n## 其他工具\n\n存在一些其他以插件形式的工具，同样能达到使用 clang-format 格式化代码的目的，比如 [travisjeffery/ClangFormat-Xcode](https://github.com/travisjeffery/ClangFormat-Xcode)，但不支持 Xcode 9+，可安装其替代版 [V5zhou/ZZClang-format](https://github.com/V5zhou/ZZClang-format)\n\n该插件安装好后，支持在文件保存时自动格式化，比较方便。\n\n但因为是来自社区的插件，需要先将 Xcode 去掉签名 （unsign），参见 [inket/update_xcode_plugins](https://github.com/inket/update_xcode_plugins)。\n\n\n原文链接： [Xcode 中配置 clang-format 格式化 C++ 代码](https://www.cnblogs.com/Wayou/p/xcode_clang_setup.html)","slug":"c++/2022-10-29-Xcode 配置 clang-format 格式化 c++ 代码","published":1,"updated":"2024-03-06T11:53:13.564Z","comments":1,"photos":[],"_id":"cltgopen90011qywhfzv23w1t","content":"<p>在命令行，通过<code>clang-format</code>工具，可以对代码进行格式化。但 <code>clang-fromat</code> 只能在终端中使用，有没有什么办法可以让它在Xcode中也可以使用呢，这样就很方便的对当前文档进行格式化了。 答案是： 借助 macOS 自带的 Automator 工具。</p>\n<h2 id=\"clang-format-安装\"><a href=\"#clang-format-安装\" class=\"headerlink\" title=\"clang-format 安装\"></a>clang-format 安装</h2><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">brew </span><span class=\"hljs-keyword\">install </span>clang-format<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"添加-Automator-服务\"><a href=\"#添加-Automator-服务\" class=\"headerlink\" title=\"添加 Automator 服务\"></a>添加 Automator 服务</h2><p>打开 Automator 选择  “Quick Action”。<br><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670101357781667010134833.png\"></p>\n<p>左侧 Library 中搜索 “Run Shell Script” 并拖动到右侧。在脚本编辑框中输入以下内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">source</span> ~/.zshrc<br>clang-format<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670116407351667011639954.png\"></p>\n<p>同时记得勾选上 “Output replaces selected text”，然后保存并输入保存的名称，比如 clang-format。</p>\n<p>至此一个服务便已添加好。</p>\n<h3 id=\"Automator-在磁盘上的位置\"><a href=\"#Automator-在磁盘上的位置\" class=\"headerlink\" title=\"Automator 在磁盘上的位置\"></a>Automator 在磁盘上的位置</h3><p>The location of the user created services is under:</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\">~<span class=\"hljs-regexp\">/Library/</span>Services/<br></code></pre></td></tr></table></figure>\n\n<p>other locations you get by entering following command in Terminal:</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\">mdfind <span class=\"hljs-string\">.workflow</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>用户主目录，创建 <code>.clang-format</code> 文件</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lua\">clang-<span class=\"hljs-built_in\">format</span> -style=google -<span class=\"hljs-built_in\">dump</span>-<span class=\"hljs-built_in\">config</span> &gt; .clang-<span class=\"hljs-built_in\">format</span><br></code></pre></td></tr></table></figure>\n<p>打开 Xcode， 选中需要格式化的代码并右键唤出菜单。选择 Services-&gt; clang-format，这里 Services 中的名称即为前面步骤中保存的 Services 名称。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670146406641667014640354.png\"></p>\n<h3 id=\"添加快捷键\"><a href=\"#添加快捷键\" class=\"headerlink\" title=\"添加快捷键\"></a>添加快捷键</h3><p>显然右键这种方式不够便捷，进一步添加快捷键来实现更加方便的代码格式化。因为 Xcode 中格式化代码默认的快捷键为 control + I，不防我们就设置 clang-format 这个服务的快捷键为这个按键组合。</p>\n<p>打开系统的首选项设置（可通过在 SpotLight 中搜索 “system preference”），然后打开键盘设置 “Kyeboard” 并切换到 “Shortcuts” 标签。</p>\n<p>选中左侧 “App Shortcuts” 然后为 “Xcode” 绑定 <code>control</code> + <code>I</code> 执行 clang-format。<br><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670145906661667014590001.png\"></p>\n<p>然后便可通过快捷键方便地进行代码格式化了。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670146746631667014674463.png\"></p>\n<p><strong>注意：</strong><br>如果不生效，将 Xcode 中 <code>control</code> + <code>I</code> 相关的快捷键置空。</p>\n<h2 id=\"其他工具\"><a href=\"#其他工具\" class=\"headerlink\" title=\"其他工具\"></a>其他工具</h2><p>存在一些其他以插件形式的工具，同样能达到使用 clang-format 格式化代码的目的，比如 <a href=\"https://github.com/travisjeffery/ClangFormat-Xcode\">travisjeffery&#x2F;ClangFormat-Xcode</a>，但不支持 Xcode 9+，可安装其替代版 <a href=\"https://github.com/V5zhou/ZZClang-format\">V5zhou&#x2F;ZZClang-format</a></p>\n<p>该插件安装好后，支持在文件保存时自动格式化，比较方便。</p>\n<p>但因为是来自社区的插件，需要先将 Xcode 去掉签名 （unsign），参见 <a href=\"https://github.com/inket/update_xcode_plugins\">inket&#x2F;update_xcode_plugins</a>。</p>\n<p>原文链接： <a href=\"https://www.cnblogs.com/Wayou/p/xcode_clang_setup.html\">Xcode 中配置 clang-format 格式化 C++ 代码</a></p>\n","excerpt":"","more":"<p>在命令行，通过<code>clang-format</code>工具，可以对代码进行格式化。但 <code>clang-fromat</code> 只能在终端中使用，有没有什么办法可以让它在Xcode中也可以使用呢，这样就很方便的对当前文档进行格式化了。 答案是： 借助 macOS 自带的 Automator 工具。</p>\n<h2 id=\"clang-format-安装\"><a href=\"#clang-format-安装\" class=\"headerlink\" title=\"clang-format 安装\"></a>clang-format 安装</h2><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">brew </span><span class=\"hljs-keyword\">install </span>clang-format<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"添加-Automator-服务\"><a href=\"#添加-Automator-服务\" class=\"headerlink\" title=\"添加 Automator 服务\"></a>添加 Automator 服务</h2><p>打开 Automator 选择  “Quick Action”。<br><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670101357781667010134833.png\"></p>\n<p>左侧 Library 中搜索 “Run Shell Script” 并拖动到右侧。在脚本编辑框中输入以下内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">source</span> ~/.zshrc<br>clang-format<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670116407351667011639954.png\"></p>\n<p>同时记得勾选上 “Output replaces selected text”，然后保存并输入保存的名称，比如 clang-format。</p>\n<p>至此一个服务便已添加好。</p>\n<h3 id=\"Automator-在磁盘上的位置\"><a href=\"#Automator-在磁盘上的位置\" class=\"headerlink\" title=\"Automator 在磁盘上的位置\"></a>Automator 在磁盘上的位置</h3><p>The location of the user created services is under:</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\">~<span class=\"hljs-regexp\">/Library/</span>Services/<br></code></pre></td></tr></table></figure>\n\n<p>other locations you get by entering following command in Terminal:</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\">mdfind <span class=\"hljs-string\">.workflow</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>用户主目录，创建 <code>.clang-format</code> 文件</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lua\">clang-<span class=\"hljs-built_in\">format</span> -style=google -<span class=\"hljs-built_in\">dump</span>-<span class=\"hljs-built_in\">config</span> &gt; .clang-<span class=\"hljs-built_in\">format</span><br></code></pre></td></tr></table></figure>\n<p>打开 Xcode， 选中需要格式化的代码并右键唤出菜单。选择 Services-&gt; clang-format，这里 Services 中的名称即为前面步骤中保存的 Services 名称。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670146406641667014640354.png\"></p>\n<h3 id=\"添加快捷键\"><a href=\"#添加快捷键\" class=\"headerlink\" title=\"添加快捷键\"></a>添加快捷键</h3><p>显然右键这种方式不够便捷，进一步添加快捷键来实现更加方便的代码格式化。因为 Xcode 中格式化代码默认的快捷键为 control + I，不防我们就设置 clang-format 这个服务的快捷键为这个按键组合。</p>\n<p>打开系统的首选项设置（可通过在 SpotLight 中搜索 “system preference”），然后打开键盘设置 “Kyeboard” 并切换到 “Shortcuts” 标签。</p>\n<p>选中左侧 “App Shortcuts” 然后为 “Xcode” 绑定 <code>control</code> + <code>I</code> 执行 clang-format。<br><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670145906661667014590001.png\"></p>\n<p>然后便可通过快捷键方便地进行代码格式化了。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16670146746631667014674463.png\"></p>\n<p><strong>注意：</strong><br>如果不生效，将 Xcode 中 <code>control</code> + <code>I</code> 相关的快捷键置空。</p>\n<h2 id=\"其他工具\"><a href=\"#其他工具\" class=\"headerlink\" title=\"其他工具\"></a>其他工具</h2><p>存在一些其他以插件形式的工具，同样能达到使用 clang-format 格式化代码的目的，比如 <a href=\"https://github.com/travisjeffery/ClangFormat-Xcode\">travisjeffery&#x2F;ClangFormat-Xcode</a>，但不支持 Xcode 9+，可安装其替代版 <a href=\"https://github.com/V5zhou/ZZClang-format\">V5zhou&#x2F;ZZClang-format</a></p>\n<p>该插件安装好后，支持在文件保存时自动格式化，比较方便。</p>\n<p>但因为是来自社区的插件，需要先将 Xcode 去掉签名 （unsign），参见 <a href=\"https://github.com/inket/update_xcode_plugins\">inket&#x2F;update_xcode_plugins</a>。</p>\n<p>原文链接： <a href=\"https://www.cnblogs.com/Wayou/p/xcode_clang_setup.html\">Xcode 中配置 clang-format 格式化 C++ 代码</a></p>\n"},{"layout":"post","title":"结构体位域中的高低位问题","date":"2023-06-08T16:00:00.000Z","_content":"\n\n测试代码如下：\n\n```\n#include <iostream>\n\nunion Test {\n    unsigned char ch;\n    struct {\n        uint8_t a: 1;\n        uint8_t b: 3;\n        uint8_t c: 2;\n        uint8_t d: 2;\n    };\n\n};\n\nint main(int argc, const char * argv[]) {\n    Test test;\n    test.a = 1;\n    test.b = 0;\n    test.c = 0;\n    test.d = 0b11;\n\n    std::cout << test.ch << std::endl;\n    return 0;\n}\n```\n\n在 macOS 上断点查看内存如下\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16863024030361686302402947.png)\n\n\n# 结论：\n\n可以看到，定义在前的位域，在字节的低位。\n位域在内存中存储的顺序刚好与定义的先后相反。\n\n\n\n\n","source":"_posts/c++/2023-06-09-位域 高低位.md","raw":"\n---\n\nlayout: post\ntitle: \"结构体位域中的高低位问题\"\ndate: 2023-06-09\ntag: c++\n\n---\n\n\n测试代码如下：\n\n```\n#include <iostream>\n\nunion Test {\n    unsigned char ch;\n    struct {\n        uint8_t a: 1;\n        uint8_t b: 3;\n        uint8_t c: 2;\n        uint8_t d: 2;\n    };\n\n};\n\nint main(int argc, const char * argv[]) {\n    Test test;\n    test.a = 1;\n    test.b = 0;\n    test.c = 0;\n    test.d = 0b11;\n\n    std::cout << test.ch << std::endl;\n    return 0;\n}\n```\n\n在 macOS 上断点查看内存如下\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16863024030361686302402947.png)\n\n\n# 结论：\n\n可以看到，定义在前的位域，在字节的低位。\n位域在内存中存储的顺序刚好与定义的先后相反。\n\n\n\n\n","slug":"c++/2023-06-09-位域 高低位","published":1,"updated":"2024-03-06T11:53:13.564Z","comments":1,"photos":[],"_id":"cltgopena0014qywhetrx82pw","content":"<p>测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-keyword\">union</span> <span class=\"hljs-title class_\">Test</span> &#123;<br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> ch;<br>    <span class=\"hljs-keyword\">struct</span> &#123;<br>        <span class=\"hljs-type\">uint8_t</span> a: <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-type\">uint8_t</span> b: <span class=\"hljs-number\">3</span>;<br>        <span class=\"hljs-type\">uint8_t</span> c: <span class=\"hljs-number\">2</span>;<br>        <span class=\"hljs-type\">uint8_t</span> d: <span class=\"hljs-number\">2</span>;<br>    &#125;;<br><br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> * argv[])</span> </span>&#123;<br>    Test test;<br>    test.a = <span class=\"hljs-number\">1</span>;<br>    test.b = <span class=\"hljs-number\">0</span>;<br>    test.c = <span class=\"hljs-number\">0</span>;<br>    test.d = <span class=\"hljs-number\">0b11</span>;<br><br>    std::cout &lt;&lt; test.ch &lt;&lt; std::endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在 macOS 上断点查看内存如下</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16863024030361686302402947.png\"></p>\n<h1 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h1><p>可以看到，定义在前的位域，在字节的低位。<br>位域在内存中存储的顺序刚好与定义的先后相反。</p>\n","excerpt":"","more":"<p>测试代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-keyword\">union</span> <span class=\"hljs-title class_\">Test</span> &#123;<br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> ch;<br>    <span class=\"hljs-keyword\">struct</span> &#123;<br>        <span class=\"hljs-type\">uint8_t</span> a: <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-type\">uint8_t</span> b: <span class=\"hljs-number\">3</span>;<br>        <span class=\"hljs-type\">uint8_t</span> c: <span class=\"hljs-number\">2</span>;<br>        <span class=\"hljs-type\">uint8_t</span> d: <span class=\"hljs-number\">2</span>;<br>    &#125;;<br><br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> * argv[])</span> </span>&#123;<br>    Test test;<br>    test.a = <span class=\"hljs-number\">1</span>;<br>    test.b = <span class=\"hljs-number\">0</span>;<br>    test.c = <span class=\"hljs-number\">0</span>;<br>    test.d = <span class=\"hljs-number\">0b11</span>;<br><br>    std::cout &lt;&lt; test.ch &lt;&lt; std::endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在 macOS 上断点查看内存如下</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16863024030361686302402947.png\"></p>\n<h1 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h1><p>可以看到，定义在前的位域，在字节的低位。<br>位域在内存中存储的顺序刚好与定义的先后相反。</p>\n"},{"layout":"post","title":"cmake find_package","date":"2022-03-12T16:00:00.000Z","_content":"\n参考：\n\n- 官方文档  [find_package](https://cmake.org/cmake/help/latest/command/find_package.html#id3)\n\n- [Cmake之深入理解find_package()的用法](https://zhuanlan.zhihu.com/p/97369704)\n\n## 使用\n\n通过find_package命令，可以找到三方库对应的头文件路径和库文件路径，不用手动管理这些路径了。例如要引用CURL库，在CMakeLists文件可以简单写成下面的形式\n\n```cmake\nfind_package(CURL)\nadd_executable(curltest curltest.cc)\nif(CURL_FOUND)\n    target_include_directories(clib PRIVATE ${CURL_INCLUDE_DIR})\n    target_link_libraries(curltest ${CURL_LIBRARY})\nelse(CURL_FOUND)\n    message(FATAL_ERROR ”CURL library not found”)\nendif(CURL_FOUND)\n```\n\n## 原理\n\nfind_package 有两种搜索模式\n\n### Module mode\n\n在[`CMAKE_MODULE_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html#variable:CMAKE_MODULE_PATH \"CMAKE_MODULE_PATH\")指定的路径下搜索名为`Find<PackageName>.cmake`的文件\n\n该文件提供了库对应的头文件和库文件路径。\n\n### Config mode\n\n- 搜索`<lowercasePackageName>-config.cmake`或者`<PackageName>Config.cmake`\n\n- 搜索`<lowercasePackageName>-config-version.cmake`或者`<PackageName>ConfigVersion.cmake`\n\n如果找到\n\n- `<PackageName>_FOUND` 为true\n\n- `<PackageName>_INCLUDE_DIR` 会被设置\n\n- `<PackageName>_LIBRARY` 会被设置\n\n找不到\n\n- `<PackageName>_FOUND` 为false\n\n## 如何写`Find<PackageName>.cmake`\n\n[wasmint/FindSDL2.cmake at master · WebAssembly/wasmint · GitHub](https://github.com/WebAssembly/wasmint/blob/master/cmake/FindSDL2.cmake)\n\n1. 调用[find_path](https://cmake.org/cmake/help/latest/command/find_path.html)找头文件路径\n\n2. 调用[find_library](https://cmake.org/cmake/help/latest/command/find_library.html)找库的路径\n\n3. 通过[FindPackageHandleStandardArgs](https://cmake.org/cmake/help/latest/module/FindPackageHandleStandardArgs.html)导出变量\n\n通过CMAKE_MODULE_PATH指定路径，就可以通过find_package命令使用该三方库的头文件和库文件了。\n","source":"_posts/cmake/2022-03-13-cmake find_package.md","raw":"---\nlayout: post\ntitle: \"cmake find_package\"\ndate: 2022-03-13\ntag: cmake\n\n---\n\n参考：\n\n- 官方文档  [find_package](https://cmake.org/cmake/help/latest/command/find_package.html#id3)\n\n- [Cmake之深入理解find_package()的用法](https://zhuanlan.zhihu.com/p/97369704)\n\n## 使用\n\n通过find_package命令，可以找到三方库对应的头文件路径和库文件路径，不用手动管理这些路径了。例如要引用CURL库，在CMakeLists文件可以简单写成下面的形式\n\n```cmake\nfind_package(CURL)\nadd_executable(curltest curltest.cc)\nif(CURL_FOUND)\n    target_include_directories(clib PRIVATE ${CURL_INCLUDE_DIR})\n    target_link_libraries(curltest ${CURL_LIBRARY})\nelse(CURL_FOUND)\n    message(FATAL_ERROR ”CURL library not found”)\nendif(CURL_FOUND)\n```\n\n## 原理\n\nfind_package 有两种搜索模式\n\n### Module mode\n\n在[`CMAKE_MODULE_PATH`](https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html#variable:CMAKE_MODULE_PATH \"CMAKE_MODULE_PATH\")指定的路径下搜索名为`Find<PackageName>.cmake`的文件\n\n该文件提供了库对应的头文件和库文件路径。\n\n### Config mode\n\n- 搜索`<lowercasePackageName>-config.cmake`或者`<PackageName>Config.cmake`\n\n- 搜索`<lowercasePackageName>-config-version.cmake`或者`<PackageName>ConfigVersion.cmake`\n\n如果找到\n\n- `<PackageName>_FOUND` 为true\n\n- `<PackageName>_INCLUDE_DIR` 会被设置\n\n- `<PackageName>_LIBRARY` 会被设置\n\n找不到\n\n- `<PackageName>_FOUND` 为false\n\n## 如何写`Find<PackageName>.cmake`\n\n[wasmint/FindSDL2.cmake at master · WebAssembly/wasmint · GitHub](https://github.com/WebAssembly/wasmint/blob/master/cmake/FindSDL2.cmake)\n\n1. 调用[find_path](https://cmake.org/cmake/help/latest/command/find_path.html)找头文件路径\n\n2. 调用[find_library](https://cmake.org/cmake/help/latest/command/find_library.html)找库的路径\n\n3. 通过[FindPackageHandleStandardArgs](https://cmake.org/cmake/help/latest/module/FindPackageHandleStandardArgs.html)导出变量\n\n通过CMAKE_MODULE_PATH指定路径，就可以通过find_package命令使用该三方库的头文件和库文件了。\n","slug":"cmake/2022-03-13-cmake find_package","published":1,"updated":"2024-03-06T11:53:13.564Z","comments":1,"photos":[],"_id":"cltgopena0015qywhbpa2b9c0","content":"<p>参考：</p>\n<ul>\n<li><p>官方文档  <a href=\"https://cmake.org/cmake/help/latest/command/find_package.html#id3\">find_package</a></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/97369704\">Cmake之深入理解find_package()的用法</a></p>\n</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>通过find_package命令，可以找到三方库对应的头文件路径和库文件路径，不用手动管理这些路径了。例如要引用CURL库，在CMakeLists文件可以简单写成下面的形式</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">find_package</span>(CURL)<br><span class=\"hljs-keyword\">add_executable</span>(curltest curltest.cc)<br><span class=\"hljs-keyword\">if</span>(CURL_FOUND)<br>    <span class=\"hljs-keyword\">target_include_directories</span>(clib PRIVATE <span class=\"hljs-variable\">$&#123;CURL_INCLUDE_DIR&#125;</span>)<br>    <span class=\"hljs-keyword\">target_link_libraries</span>(curltest <span class=\"hljs-variable\">$&#123;CURL_LIBRARY&#125;</span>)<br><span class=\"hljs-keyword\">else</span>(CURL_FOUND)<br>    <span class=\"hljs-keyword\">message</span>(FATAL_ERROR ”CURL library <span class=\"hljs-keyword\">not</span> found”)<br><span class=\"hljs-keyword\">endif</span>(CURL_FOUND)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>find_package 有两种搜索模式</p>\n<h3 id=\"Module-mode\"><a href=\"#Module-mode\" class=\"headerlink\" title=\"Module mode\"></a>Module mode</h3><p>在<a href=\"https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html#variable:CMAKE_MODULE_PATH\" title=\"CMAKE_MODULE_PATH\"><code>CMAKE_MODULE_PATH</code></a>指定的路径下搜索名为<code>Find&lt;PackageName&gt;.cmake</code>的文件</p>\n<p>该文件提供了库对应的头文件和库文件路径。</p>\n<h3 id=\"Config-mode\"><a href=\"#Config-mode\" class=\"headerlink\" title=\"Config mode\"></a>Config mode</h3><ul>\n<li><p>搜索<code>&lt;lowercasePackageName&gt;-config.cmake</code>或者<code>&lt;PackageName&gt;Config.cmake</code></p>\n</li>\n<li><p>搜索<code>&lt;lowercasePackageName&gt;-config-version.cmake</code>或者<code>&lt;PackageName&gt;ConfigVersion.cmake</code></p>\n</li>\n</ul>\n<p>如果找到</p>\n<ul>\n<li><p><code>&lt;PackageName&gt;_FOUND</code> 为true</p>\n</li>\n<li><p><code>&lt;PackageName&gt;_INCLUDE_DIR</code> 会被设置</p>\n</li>\n<li><p><code>&lt;PackageName&gt;_LIBRARY</code> 会被设置</p>\n</li>\n</ul>\n<p>找不到</p>\n<ul>\n<li><code>&lt;PackageName&gt;_FOUND</code> 为false</li>\n</ul>\n<h2 id=\"如何写Find-cmake\"><a href=\"#如何写Find-cmake\" class=\"headerlink\" title=\"如何写Find&lt;PackageName&gt;.cmake\"></a>如何写<code>Find&lt;PackageName&gt;.cmake</code></h2><p><a href=\"https://github.com/WebAssembly/wasmint/blob/master/cmake/FindSDL2.cmake\">wasmint&#x2F;FindSDL2.cmake at master · WebAssembly&#x2F;wasmint · GitHub</a></p>\n<ol>\n<li><p>调用<a href=\"https://cmake.org/cmake/help/latest/command/find_path.html\">find_path</a>找头文件路径</p>\n</li>\n<li><p>调用<a href=\"https://cmake.org/cmake/help/latest/command/find_library.html\">find_library</a>找库的路径</p>\n</li>\n<li><p>通过<a href=\"https://cmake.org/cmake/help/latest/module/FindPackageHandleStandardArgs.html\">FindPackageHandleStandardArgs</a>导出变量</p>\n</li>\n</ol>\n<p>通过CMAKE_MODULE_PATH指定路径，就可以通过find_package命令使用该三方库的头文件和库文件了。</p>\n","excerpt":"","more":"<p>参考：</p>\n<ul>\n<li><p>官方文档  <a href=\"https://cmake.org/cmake/help/latest/command/find_package.html#id3\">find_package</a></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/97369704\">Cmake之深入理解find_package()的用法</a></p>\n</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>通过find_package命令，可以找到三方库对应的头文件路径和库文件路径，不用手动管理这些路径了。例如要引用CURL库，在CMakeLists文件可以简单写成下面的形式</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">find_package</span>(CURL)<br><span class=\"hljs-keyword\">add_executable</span>(curltest curltest.cc)<br><span class=\"hljs-keyword\">if</span>(CURL_FOUND)<br>    <span class=\"hljs-keyword\">target_include_directories</span>(clib PRIVATE <span class=\"hljs-variable\">$&#123;CURL_INCLUDE_DIR&#125;</span>)<br>    <span class=\"hljs-keyword\">target_link_libraries</span>(curltest <span class=\"hljs-variable\">$&#123;CURL_LIBRARY&#125;</span>)<br><span class=\"hljs-keyword\">else</span>(CURL_FOUND)<br>    <span class=\"hljs-keyword\">message</span>(FATAL_ERROR ”CURL library <span class=\"hljs-keyword\">not</span> found”)<br><span class=\"hljs-keyword\">endif</span>(CURL_FOUND)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>find_package 有两种搜索模式</p>\n<h3 id=\"Module-mode\"><a href=\"#Module-mode\" class=\"headerlink\" title=\"Module mode\"></a>Module mode</h3><p>在<a href=\"https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html#variable:CMAKE_MODULE_PATH\" title=\"CMAKE_MODULE_PATH\"><code>CMAKE_MODULE_PATH</code></a>指定的路径下搜索名为<code>Find&lt;PackageName&gt;.cmake</code>的文件</p>\n<p>该文件提供了库对应的头文件和库文件路径。</p>\n<h3 id=\"Config-mode\"><a href=\"#Config-mode\" class=\"headerlink\" title=\"Config mode\"></a>Config mode</h3><ul>\n<li><p>搜索<code>&lt;lowercasePackageName&gt;-config.cmake</code>或者<code>&lt;PackageName&gt;Config.cmake</code></p>\n</li>\n<li><p>搜索<code>&lt;lowercasePackageName&gt;-config-version.cmake</code>或者<code>&lt;PackageName&gt;ConfigVersion.cmake</code></p>\n</li>\n</ul>\n<p>如果找到</p>\n<ul>\n<li><p><code>&lt;PackageName&gt;_FOUND</code> 为true</p>\n</li>\n<li><p><code>&lt;PackageName&gt;_INCLUDE_DIR</code> 会被设置</p>\n</li>\n<li><p><code>&lt;PackageName&gt;_LIBRARY</code> 会被设置</p>\n</li>\n</ul>\n<p>找不到</p>\n<ul>\n<li><code>&lt;PackageName&gt;_FOUND</code> 为false</li>\n</ul>\n<h2 id=\"如何写Find-cmake\"><a href=\"#如何写Find-cmake\" class=\"headerlink\" title=\"如何写Find&lt;PackageName&gt;.cmake\"></a>如何写<code>Find&lt;PackageName&gt;.cmake</code></h2><p><a href=\"https://github.com/WebAssembly/wasmint/blob/master/cmake/FindSDL2.cmake\">wasmint&#x2F;FindSDL2.cmake at master · WebAssembly&#x2F;wasmint · GitHub</a></p>\n<ol>\n<li><p>调用<a href=\"https://cmake.org/cmake/help/latest/command/find_path.html\">find_path</a>找头文件路径</p>\n</li>\n<li><p>调用<a href=\"https://cmake.org/cmake/help/latest/command/find_library.html\">find_library</a>找库的路径</p>\n</li>\n<li><p>通过<a href=\"https://cmake.org/cmake/help/latest/module/FindPackageHandleStandardArgs.html\">FindPackageHandleStandardArgs</a>导出变量</p>\n</li>\n</ol>\n<p>通过CMAKE_MODULE_PATH指定路径，就可以通过find_package命令使用该三方库的头文件和库文件了。</p>\n"},{"layout":"post","title":"cmake 语言初识","date":"2022-03-16T16:00:00.000Z","_content":"\n# 文件组织\n\nCMake源文件用cmake语言编写，共三种组织形式\n\n- [Directories](https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#directories) (`CMakeLists.txt`) 目录\n\n- [Scripts](https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#scripts) (`<script>.cmake`) 脚本\n\n- [Modules](https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#modules) (`<module>.cmake`) 模块\n\n### Directories 目录\n\n用cmake 去编译项目时候，入口是项目顶级目录的`CMakeLists.txt`文件，`CMakeLists.txt`描述了当前项目构建规则。当遇到`add _ subdirectory ()`命令，cmake会去命令指定的子目录中搜索`CMakeLists.txt`，将其添加到构建过程，这是一个递归解析的过程。子目录中的`CMakeLists.txt`描述了子项目的构建规则。\n\n### Scripts 脚本\n\n一个单独的`<script>.cmake`文件可以被当做脚本来处理，可以理解为shell脚本，通过cmake来解析和执行脚本定义的操作。脚本中不允许出现定义构建目标和构建行为的命令，\n\ncmake 脚本不参与构建过程。\n\n```\ncmake [{-D <var>=<value>}...] -P <cmake-script-file> [-- <unparsed-options>...]\n```\n\n> Process the given cmake file as a script written in the CMake language. No configure or generate step is performed and the cache is not modified. If variables are defined using `-D`, this must be done before the `-P` argument.\n\n> Any options after `--` are not parsed by CMake, but they are still included in the set of [`CMAKE_ARGV<n>`](https://cmake.org/cmake/help/latest/variable/CMAKE_ARGV0.html#variable:CMAKE_ARGV0 \"CMAKE_ARGV0\") variables passed to the script (including the `--` itself).\n\n### Modules 模块\n\n就是一个cmake的源文件，形式`<module>.cmake`。可以在当前`CMakeLists.txt`或cmake源文件中，通过`include()`命令，引入其他cmake文件中定义的内容。类似于c语言的\n\n`#include<>`。\n\ncmake 内置了很多的模块，可以通过[cmake-modules](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#manual:cmake-modules(7))查看。项目可以定义自己cmake modules，通过[CMAKE_MODULE_PATH](https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html#variable:CMAKE_MODULE_PATH)来指定他们的路径。\n\n# cmake 变量\n\n1. cmake 变量的值是字符串类型\n\n2. Set ()和 unset ()命令显式地设置或取消设置变量\n\n3. 变量名是区分大小写的,建议只使用由字母数字字符加上 `_ `和`-`组成的名称\n\n4. 根据作用于范围, 变量的类型有normal, cache, or environment variable\n\n### 变量作用范围\n\n参考这篇文章[cmake cache变量_反复研究好几遍，我才发现关于 CMake 变量还可以这样理解！_weixin_39732534的博客-CSDN博客](https://blog.csdn.net/weixin_39732534/article/details/110658282) 可以更好的理解cmake 变量及其作用域范围。\n\n#### 函数作用域\n\ncmake  通过 [`function()`](https://cmake.org/cmake/help/latest/command/function.html#command:function \"function\")命令来定义函数。在函数作用域通过`set`定义的变量，只在函数作用域内有效，函数返回后，该变量失效。\n\n但是通过`set`命令指定 `PARENT_SCOPE`,可以设置函数上级作用域内的变量。\n\n#### CMake 文件中\n\n每个CMakeLists.txt 和 `xx.cmake`文件中都定义一个作用域。上级CMakeLists.txt文件中定义的变量，会传递给下级的CMakeLists.txt文件中。\n\n不在函数用通过`set`和`unset`命令设置的变量，作用范围在当前的文件中。\n\n修改当前CMakeLists.txt文件中定义的变量，在上级CMakeLists.txt文件中不生效，但是通过`set`命令指定 `PARENT_SCOPE`,可以修改上级作用域内的变量。\n\n#### cache 中\n\ncache 变量存被保存在`CMakeCache.txt`文件中。全局变量，多个构建构建中持续生效。\n\n只能通过set命令，指定`CACHE`选项来显示修改。\n\n#### 环境变量\n\n类似于普通变量，但是作用范围是全局，不会被缓存。\n\n变量引用的格式为 $ENV { < Variable > }\n\nCMake 环境变量的初始值是调用进程的初始值。可以使用 set ()和 unset ()命令更改值。这些命令只影响正在运行的 CMake 进程，而不影响整个系统环境。更改后的值不会写回调用进程，后续的构建或测试进程也不会看到它们。\n\n### 变量求值的顺序：\n\n1. 当前函数内查找\n\n2. 当前文件中查找\n\n3. 缓存中查找\n\n4. 最后没找到，计为空字符串。\n\n5. 可以通过`$CACHE{VAR}`跳过前面的过程，直接从缓存中查找。\n\n### set 给变量赋值\n\n#### normal 变量\n\n```\nset(<variable> <value>... [PARENT_SCOPE])\n```\n\n如果指定了PARENT_SCOPE，修改会在上级作用域内生效。\n\n#### Set Cache Entry\n\n```\nset(<variable> <value>... CACHE <type> <docstring> [FORCE])\n```\n\n不加FORCE，修改不会覆盖之前cache中的值。 FORCE 选项覆盖现有条目。\n\ntype的类型必须指定为以下一种：\n\n1. BOOL\n\n2. FILEPATH\n\n3. PATH\n\n4. STRING\n\n5. INTERNAL\n\n> 也可以通过cmake命令，通过`-D<var>=<value>`添加缓存条目。\n\n#### 环境变量\n\n```\nset(ENV{<variable>} [<value>])\n```\n\n设置给定值的环境变量，`$ENV{<variable>}`的后续调用将返回这个新值。\n\n此命令只影响当前的 CMake 进程，而不影响调用 CMake 的进程，也不影响整个系统环境，也不影响后续构建或测试流程的环境。\n\n如果在 `ENV { < variable > }`之后没有给出参数，或者如果 `< value >` 是一个空字符串，那么这个命令将清除任何已存在的环境变量\n\n## list 变量\n\n> Note A list in cmake is a `;` separated group of strings. To create a list the set command can be used. For example, `set(var a b c d e)` creates a list with `a;b;c;d;e`, and `set(var \"a b c d e\")` creates a string or a list with one item in it. (Note macro arguments are not variables, and therefore cannot be used in LIST commands.)\n\n列表不应该用于复杂的数据处理任务，常常用来保存源文件列表。\n\n大多数构造列表的命令不会转义; 列表元素中的字符，因此将嵌套列表展开:\n\n```\nset(srcs a.c b.c c.c) # sets \"srcs\" to \"a.c;b.c;c.c\"\nset(x a \"b;c\") # sets \"x\" to \"a;b;c\", not \"a;b\\;c\"\nset(var \"a b c d e\") # sets var to \"a b c d e\"\n```\n\n[list](https://cmake.org/cmake/help/latest/command/list.html)操作，就是一些增删查改\n\n```\nReading\n  list(LENGTH <list> <out-var>)\n  list(GET <list> <element index> [<index> ...] <out-var>)\n  list(JOIN <list> <glue> <out-var>)\n  list(SUBLIST <list> <begin> <length> <out-var>)\n\nSearch\n  list(FIND <list> <value> <out-var>)\n\nModification\n  list(APPEND <list> [<element>...])\n  list(FILTER <list> {INCLUDE | EXCLUDE} REGEX <regex>)\n  list(INSERT <list> <index> [<element>...])\n  list(POP_BACK <list> [<out-var>...])\n  list(POP_FRONT <list> [<out-var>...])\n  list(PREPEND <list> [<element>...])\n  list(REMOVE_ITEM <list> <value>...)\n  list(REMOVE_AT <list> <index>...)\n  list(REMOVE_DUPLICATES <list>)\n  list(TRANSFORM <list> <ACTION> [...])\n\nOrdering\n  list(REVERSE <list>)\n  list(SORT <list> [...])\n```\n\n# [file 命令](https://cmake.org/cmake/help/latest/command/file.html)\n\n```\nReading\n  file(READ <filename> <out-var> [...])\n  file(STRINGS <filename> <out-var> [...])\n  file(<HASH> <filename> <out-var>)\n  file(TIMESTAMP <filename> <out-var> [...])\n  file(GET_RUNTIME_DEPENDENCIES [...])\n\nWriting\n  file({WRITE | APPEND} <filename> <content>...)\n  file({TOUCH | TOUCH_NOCREATE} [<file>...])\n  file(GENERATE OUTPUT <output-file> [...])\n  file(CONFIGURE OUTPUT <output-file> CONTENT <content> [...])\n\nFilesystem\n  file({GLOB | GLOB_RECURSE} <out-var> [...] [<globbing-expr>...])\n  file(MAKE_DIRECTORY [<dir>...])\n  file({REMOVE | REMOVE_RECURSE } [<files>...])\n  file(RENAME <oldname> <newname> [...])\n  file(COPY_FILE <oldname> <newname> [...])\n  file({COPY | INSTALL} <file>... DESTINATION <dir> [...])\n  file(SIZE <filename> <out-var>)\n  file(READ_SYMLINK <linkname> <out-var>)\n  file(CREATE_LINK <original> <linkname> [...])\n  file(CHMOD <files>... <directories>... PERMISSIONS <permissions>... [...])\n  file(CHMOD_RECURSE <files>... <directories>... PERMISSIONS <permissions>... [...])\n\nPath Conversion\n  file(REAL_PATH <path> <out-var> [BASE_DIRECTORY <dir>] [EXPAND_TILDE])\n  file(RELATIVE_PATH <out-var> <directory> <file>)\n  file({TO_CMAKE_PATH | TO_NATIVE_PATH} <path> <out-var>)\n\nTransfer\n  file(DOWNLOAD <url> [<file>] [...])\n  file(UPLOAD <file> <url> [...])\n\nLocking\n  file(LOCK <path> [...])\n\nArchiving\n  file(ARCHIVE_CREATE OUTPUT <archive> PATHS <paths>... [...])\n  file(ARCHIVE_EXTRACT INPUT <archive> [...])\n```\n\n## Filesystem\n\n```\nfile(GLOB <variable>\n     [LIST_DIRECTORIES true|false] [RELATIVE <path>] [CONFIGURE_DEPENDS]\n     [<globbing-expressions>...])\nfile(GLOB_RECURSE <variable> [FOLLOW_SYMLINKS]\n     [LIST_DIRECTORIES true|false] [RELATIVE <path>] [CONFIGURE_DEPENDS]\n     [<globbing-expressions>...])\n```\n\n> Generate a list of files that match the `<globbing-expressions>` and store it into the `<variable>`. Globbing expressions are similar to regular expressions, but much simpler. If `RELATIVE` flag is specified, the results will be returned as relative paths to the given path.\n> \n> On Windows and macOS, globbing is case-insensitive even if the underlying filesystem is case-sensitive (both filenames and globbing expressions are converted to lowercase before matching). On other platforms, globbing is case-sensitive\n> \n> By default `GLOB` lists directories - directories are omitted in result if `LIST_DIRECTORIES` is set to false.\n\nExamples of globbing expressions include:\n\n```\n*.cxx      - match all files with extension cxx\n*.vt?      - match all files with extension vta,...,vtz\nf[3-5].txt - match files f3.txt, f4.txt, f5.txt\n```\n\n> The `GLOB_RECURSE` mode will traverse all the subdirectories of the matched directory and match the files.\n\n# cmake 执行shell命令\n\n通过 execute_process  可以执行调用shell 命令\n\n```\nexecute_process(COMMAND <cmd1> [<arguments>]\n                [COMMAND <cmd2> [<arguments>]]...\n                [WORKING_DIRECTORY <directory>]\n                [TIMEOUT <seconds>]\n                [RESULT_VARIABLE <variable>]\n                [RESULTS_VARIABLE <variable>]\n                [OUTPUT_VARIABLE <variable>]\n                [ERROR_VARIABLE <variable>]\n                [INPUT_FILE <file>]\n                [OUTPUT_FILE <file>]\n                [ERROR_FILE <file>]\n                [OUTPUT_QUIET]\n                [ERROR_QUIET]\n                [COMMAND_ECHO <where>]\n                [OUTPUT_STRIP_TRAILING_WHITESPACE]\n                [ERROR_STRIP_TRAILING_WHITESPACE]\n                [ENCODING <name>]\n                [ECHO_OUTPUT_VARIABLE]\n                [ECHO_ERROR_VARIABLE]\n                [COMMAND_ERROR_IS_FATAL <ANY|LAST>])\n```\n","source":"_posts/cmake/2022-03-17-cmake 入门.md","raw":"---\nlayout: post\ntitle: \"cmake 语言初识\"\ndate: 2022-03-17\ntag: cmake\n\n---\n\n# 文件组织\n\nCMake源文件用cmake语言编写，共三种组织形式\n\n- [Directories](https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#directories) (`CMakeLists.txt`) 目录\n\n- [Scripts](https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#scripts) (`<script>.cmake`) 脚本\n\n- [Modules](https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#modules) (`<module>.cmake`) 模块\n\n### Directories 目录\n\n用cmake 去编译项目时候，入口是项目顶级目录的`CMakeLists.txt`文件，`CMakeLists.txt`描述了当前项目构建规则。当遇到`add _ subdirectory ()`命令，cmake会去命令指定的子目录中搜索`CMakeLists.txt`，将其添加到构建过程，这是一个递归解析的过程。子目录中的`CMakeLists.txt`描述了子项目的构建规则。\n\n### Scripts 脚本\n\n一个单独的`<script>.cmake`文件可以被当做脚本来处理，可以理解为shell脚本，通过cmake来解析和执行脚本定义的操作。脚本中不允许出现定义构建目标和构建行为的命令，\n\ncmake 脚本不参与构建过程。\n\n```\ncmake [{-D <var>=<value>}...] -P <cmake-script-file> [-- <unparsed-options>...]\n```\n\n> Process the given cmake file as a script written in the CMake language. No configure or generate step is performed and the cache is not modified. If variables are defined using `-D`, this must be done before the `-P` argument.\n\n> Any options after `--` are not parsed by CMake, but they are still included in the set of [`CMAKE_ARGV<n>`](https://cmake.org/cmake/help/latest/variable/CMAKE_ARGV0.html#variable:CMAKE_ARGV0 \"CMAKE_ARGV0\") variables passed to the script (including the `--` itself).\n\n### Modules 模块\n\n就是一个cmake的源文件，形式`<module>.cmake`。可以在当前`CMakeLists.txt`或cmake源文件中，通过`include()`命令，引入其他cmake文件中定义的内容。类似于c语言的\n\n`#include<>`。\n\ncmake 内置了很多的模块，可以通过[cmake-modules](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#manual:cmake-modules(7))查看。项目可以定义自己cmake modules，通过[CMAKE_MODULE_PATH](https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html#variable:CMAKE_MODULE_PATH)来指定他们的路径。\n\n# cmake 变量\n\n1. cmake 变量的值是字符串类型\n\n2. Set ()和 unset ()命令显式地设置或取消设置变量\n\n3. 变量名是区分大小写的,建议只使用由字母数字字符加上 `_ `和`-`组成的名称\n\n4. 根据作用于范围, 变量的类型有normal, cache, or environment variable\n\n### 变量作用范围\n\n参考这篇文章[cmake cache变量_反复研究好几遍，我才发现关于 CMake 变量还可以这样理解！_weixin_39732534的博客-CSDN博客](https://blog.csdn.net/weixin_39732534/article/details/110658282) 可以更好的理解cmake 变量及其作用域范围。\n\n#### 函数作用域\n\ncmake  通过 [`function()`](https://cmake.org/cmake/help/latest/command/function.html#command:function \"function\")命令来定义函数。在函数作用域通过`set`定义的变量，只在函数作用域内有效，函数返回后，该变量失效。\n\n但是通过`set`命令指定 `PARENT_SCOPE`,可以设置函数上级作用域内的变量。\n\n#### CMake 文件中\n\n每个CMakeLists.txt 和 `xx.cmake`文件中都定义一个作用域。上级CMakeLists.txt文件中定义的变量，会传递给下级的CMakeLists.txt文件中。\n\n不在函数用通过`set`和`unset`命令设置的变量，作用范围在当前的文件中。\n\n修改当前CMakeLists.txt文件中定义的变量，在上级CMakeLists.txt文件中不生效，但是通过`set`命令指定 `PARENT_SCOPE`,可以修改上级作用域内的变量。\n\n#### cache 中\n\ncache 变量存被保存在`CMakeCache.txt`文件中。全局变量，多个构建构建中持续生效。\n\n只能通过set命令，指定`CACHE`选项来显示修改。\n\n#### 环境变量\n\n类似于普通变量，但是作用范围是全局，不会被缓存。\n\n变量引用的格式为 $ENV { < Variable > }\n\nCMake 环境变量的初始值是调用进程的初始值。可以使用 set ()和 unset ()命令更改值。这些命令只影响正在运行的 CMake 进程，而不影响整个系统环境。更改后的值不会写回调用进程，后续的构建或测试进程也不会看到它们。\n\n### 变量求值的顺序：\n\n1. 当前函数内查找\n\n2. 当前文件中查找\n\n3. 缓存中查找\n\n4. 最后没找到，计为空字符串。\n\n5. 可以通过`$CACHE{VAR}`跳过前面的过程，直接从缓存中查找。\n\n### set 给变量赋值\n\n#### normal 变量\n\n```\nset(<variable> <value>... [PARENT_SCOPE])\n```\n\n如果指定了PARENT_SCOPE，修改会在上级作用域内生效。\n\n#### Set Cache Entry\n\n```\nset(<variable> <value>... CACHE <type> <docstring> [FORCE])\n```\n\n不加FORCE，修改不会覆盖之前cache中的值。 FORCE 选项覆盖现有条目。\n\ntype的类型必须指定为以下一种：\n\n1. BOOL\n\n2. FILEPATH\n\n3. PATH\n\n4. STRING\n\n5. INTERNAL\n\n> 也可以通过cmake命令，通过`-D<var>=<value>`添加缓存条目。\n\n#### 环境变量\n\n```\nset(ENV{<variable>} [<value>])\n```\n\n设置给定值的环境变量，`$ENV{<variable>}`的后续调用将返回这个新值。\n\n此命令只影响当前的 CMake 进程，而不影响调用 CMake 的进程，也不影响整个系统环境，也不影响后续构建或测试流程的环境。\n\n如果在 `ENV { < variable > }`之后没有给出参数，或者如果 `< value >` 是一个空字符串，那么这个命令将清除任何已存在的环境变量\n\n## list 变量\n\n> Note A list in cmake is a `;` separated group of strings. To create a list the set command can be used. For example, `set(var a b c d e)` creates a list with `a;b;c;d;e`, and `set(var \"a b c d e\")` creates a string or a list with one item in it. (Note macro arguments are not variables, and therefore cannot be used in LIST commands.)\n\n列表不应该用于复杂的数据处理任务，常常用来保存源文件列表。\n\n大多数构造列表的命令不会转义; 列表元素中的字符，因此将嵌套列表展开:\n\n```\nset(srcs a.c b.c c.c) # sets \"srcs\" to \"a.c;b.c;c.c\"\nset(x a \"b;c\") # sets \"x\" to \"a;b;c\", not \"a;b\\;c\"\nset(var \"a b c d e\") # sets var to \"a b c d e\"\n```\n\n[list](https://cmake.org/cmake/help/latest/command/list.html)操作，就是一些增删查改\n\n```\nReading\n  list(LENGTH <list> <out-var>)\n  list(GET <list> <element index> [<index> ...] <out-var>)\n  list(JOIN <list> <glue> <out-var>)\n  list(SUBLIST <list> <begin> <length> <out-var>)\n\nSearch\n  list(FIND <list> <value> <out-var>)\n\nModification\n  list(APPEND <list> [<element>...])\n  list(FILTER <list> {INCLUDE | EXCLUDE} REGEX <regex>)\n  list(INSERT <list> <index> [<element>...])\n  list(POP_BACK <list> [<out-var>...])\n  list(POP_FRONT <list> [<out-var>...])\n  list(PREPEND <list> [<element>...])\n  list(REMOVE_ITEM <list> <value>...)\n  list(REMOVE_AT <list> <index>...)\n  list(REMOVE_DUPLICATES <list>)\n  list(TRANSFORM <list> <ACTION> [...])\n\nOrdering\n  list(REVERSE <list>)\n  list(SORT <list> [...])\n```\n\n# [file 命令](https://cmake.org/cmake/help/latest/command/file.html)\n\n```\nReading\n  file(READ <filename> <out-var> [...])\n  file(STRINGS <filename> <out-var> [...])\n  file(<HASH> <filename> <out-var>)\n  file(TIMESTAMP <filename> <out-var> [...])\n  file(GET_RUNTIME_DEPENDENCIES [...])\n\nWriting\n  file({WRITE | APPEND} <filename> <content>...)\n  file({TOUCH | TOUCH_NOCREATE} [<file>...])\n  file(GENERATE OUTPUT <output-file> [...])\n  file(CONFIGURE OUTPUT <output-file> CONTENT <content> [...])\n\nFilesystem\n  file({GLOB | GLOB_RECURSE} <out-var> [...] [<globbing-expr>...])\n  file(MAKE_DIRECTORY [<dir>...])\n  file({REMOVE | REMOVE_RECURSE } [<files>...])\n  file(RENAME <oldname> <newname> [...])\n  file(COPY_FILE <oldname> <newname> [...])\n  file({COPY | INSTALL} <file>... DESTINATION <dir> [...])\n  file(SIZE <filename> <out-var>)\n  file(READ_SYMLINK <linkname> <out-var>)\n  file(CREATE_LINK <original> <linkname> [...])\n  file(CHMOD <files>... <directories>... PERMISSIONS <permissions>... [...])\n  file(CHMOD_RECURSE <files>... <directories>... PERMISSIONS <permissions>... [...])\n\nPath Conversion\n  file(REAL_PATH <path> <out-var> [BASE_DIRECTORY <dir>] [EXPAND_TILDE])\n  file(RELATIVE_PATH <out-var> <directory> <file>)\n  file({TO_CMAKE_PATH | TO_NATIVE_PATH} <path> <out-var>)\n\nTransfer\n  file(DOWNLOAD <url> [<file>] [...])\n  file(UPLOAD <file> <url> [...])\n\nLocking\n  file(LOCK <path> [...])\n\nArchiving\n  file(ARCHIVE_CREATE OUTPUT <archive> PATHS <paths>... [...])\n  file(ARCHIVE_EXTRACT INPUT <archive> [...])\n```\n\n## Filesystem\n\n```\nfile(GLOB <variable>\n     [LIST_DIRECTORIES true|false] [RELATIVE <path>] [CONFIGURE_DEPENDS]\n     [<globbing-expressions>...])\nfile(GLOB_RECURSE <variable> [FOLLOW_SYMLINKS]\n     [LIST_DIRECTORIES true|false] [RELATIVE <path>] [CONFIGURE_DEPENDS]\n     [<globbing-expressions>...])\n```\n\n> Generate a list of files that match the `<globbing-expressions>` and store it into the `<variable>`. Globbing expressions are similar to regular expressions, but much simpler. If `RELATIVE` flag is specified, the results will be returned as relative paths to the given path.\n> \n> On Windows and macOS, globbing is case-insensitive even if the underlying filesystem is case-sensitive (both filenames and globbing expressions are converted to lowercase before matching). On other platforms, globbing is case-sensitive\n> \n> By default `GLOB` lists directories - directories are omitted in result if `LIST_DIRECTORIES` is set to false.\n\nExamples of globbing expressions include:\n\n```\n*.cxx      - match all files with extension cxx\n*.vt?      - match all files with extension vta,...,vtz\nf[3-5].txt - match files f3.txt, f4.txt, f5.txt\n```\n\n> The `GLOB_RECURSE` mode will traverse all the subdirectories of the matched directory and match the files.\n\n# cmake 执行shell命令\n\n通过 execute_process  可以执行调用shell 命令\n\n```\nexecute_process(COMMAND <cmd1> [<arguments>]\n                [COMMAND <cmd2> [<arguments>]]...\n                [WORKING_DIRECTORY <directory>]\n                [TIMEOUT <seconds>]\n                [RESULT_VARIABLE <variable>]\n                [RESULTS_VARIABLE <variable>]\n                [OUTPUT_VARIABLE <variable>]\n                [ERROR_VARIABLE <variable>]\n                [INPUT_FILE <file>]\n                [OUTPUT_FILE <file>]\n                [ERROR_FILE <file>]\n                [OUTPUT_QUIET]\n                [ERROR_QUIET]\n                [COMMAND_ECHO <where>]\n                [OUTPUT_STRIP_TRAILING_WHITESPACE]\n                [ERROR_STRIP_TRAILING_WHITESPACE]\n                [ENCODING <name>]\n                [ECHO_OUTPUT_VARIABLE]\n                [ECHO_ERROR_VARIABLE]\n                [COMMAND_ERROR_IS_FATAL <ANY|LAST>])\n```\n","slug":"cmake/2022-03-17-cmake 入门","published":1,"updated":"2024-03-06T11:53:13.564Z","comments":1,"photos":[],"_id":"cltgopena0018qywh1g9301qu","content":"<h1 id=\"文件组织\"><a href=\"#文件组织\" class=\"headerlink\" title=\"文件组织\"></a>文件组织</h1><p>CMake源文件用cmake语言编写，共三种组织形式</p>\n<ul>\n<li><p><a href=\"https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#directories\">Directories</a> (<code>CMakeLists.txt</code>) 目录</p>\n</li>\n<li><p><a href=\"https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#scripts\">Scripts</a> (<code>&lt;script&gt;.cmake</code>) 脚本</p>\n</li>\n<li><p><a href=\"https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#modules\">Modules</a> (<code>&lt;module&gt;.cmake</code>) 模块</p>\n</li>\n</ul>\n<h3 id=\"Directories-目录\"><a href=\"#Directories-目录\" class=\"headerlink\" title=\"Directories 目录\"></a>Directories 目录</h3><p>用cmake 去编译项目时候，入口是项目顶级目录的<code>CMakeLists.txt</code>文件，<code>CMakeLists.txt</code>描述了当前项目构建规则。当遇到<code>add _ subdirectory ()</code>命令，cmake会去命令指定的子目录中搜索<code>CMakeLists.txt</code>，将其添加到构建过程，这是一个递归解析的过程。子目录中的<code>CMakeLists.txt</code>描述了子项目的构建规则。</p>\n<h3 id=\"Scripts-脚本\"><a href=\"#Scripts-脚本\" class=\"headerlink\" title=\"Scripts 脚本\"></a>Scripts 脚本</h3><p>一个单独的<code>&lt;script&gt;.cmake</code>文件可以被当做脚本来处理，可以理解为shell脚本，通过cmake来解析和执行脚本定义的操作。脚本中不允许出现定义构建目标和构建行为的命令，</p>\n<p>cmake 脚本不参与构建过程。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">cmake [&#123;-D <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">var</span>&gt;</span>=<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">value</span>&gt;</span>&#125;...] -P <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">cmake-script-file</span>&gt;</span> [-- <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">unparsed-options</span>&gt;</span>...]<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Process the given cmake file as a script written in the CMake language. No configure or generate step is performed and the cache is not modified. If variables are defined using <code>-D</code>, this must be done before the <code>-P</code> argument.</p>\n</blockquote>\n<blockquote>\n<p>Any options after <code>--</code> are not parsed by CMake, but they are still included in the set of <a href=\"https://cmake.org/cmake/help/latest/variable/CMAKE_ARGV0.html#variable:CMAKE_ARGV0\" title=\"CMAKE_ARGV0\"><code>CMAKE_ARGV&lt;n&gt;</code></a> variables passed to the script (including the <code>--</code> itself).</p>\n</blockquote>\n<h3 id=\"Modules-模块\"><a href=\"#Modules-模块\" class=\"headerlink\" title=\"Modules 模块\"></a>Modules 模块</h3><p>就是一个cmake的源文件，形式<code>&lt;module&gt;.cmake</code>。可以在当前<code>CMakeLists.txt</code>或cmake源文件中，通过<code>include()</code>命令，引入其他cmake文件中定义的内容。类似于c语言的</p>\n<p><code>#include&lt;&gt;</code>。</p>\n<p>cmake 内置了很多的模块，可以通过<a href=\"https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#manual:cmake-modules(7)\">cmake-modules</a>查看。项目可以定义自己cmake modules，通过<a href=\"https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html#variable:CMAKE_MODULE_PATH\">CMAKE_MODULE_PATH</a>来指定他们的路径。</p>\n<h1 id=\"cmake-变量\"><a href=\"#cmake-变量\" class=\"headerlink\" title=\"cmake 变量\"></a>cmake 变量</h1><ol>\n<li><p>cmake 变量的值是字符串类型</p>\n</li>\n<li><p>Set ()和 unset ()命令显式地设置或取消设置变量</p>\n</li>\n<li><p>变量名是区分大小写的,建议只使用由字母数字字符加上 <code>_ </code>和<code>-</code>组成的名称</p>\n</li>\n<li><p>根据作用于范围, 变量的类型有normal, cache, or environment variable</p>\n</li>\n</ol>\n<h3 id=\"变量作用范围\"><a href=\"#变量作用范围\" class=\"headerlink\" title=\"变量作用范围\"></a>变量作用范围</h3><p>参考这篇文章<a href=\"https://blog.csdn.net/weixin_39732534/article/details/110658282\">cmake cache变量_反复研究好几遍，我才发现关于 CMake 变量还可以这样理解！_weixin_39732534的博客-CSDN博客</a> 可以更好的理解cmake 变量及其作用域范围。</p>\n<h4 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h4><p>cmake  通过 <a href=\"https://cmake.org/cmake/help/latest/command/function.html#command:function\" title=\"function\"><code>function()</code></a>命令来定义函数。在函数作用域通过<code>set</code>定义的变量，只在函数作用域内有效，函数返回后，该变量失效。</p>\n<p>但是通过<code>set</code>命令指定 <code>PARENT_SCOPE</code>,可以设置函数上级作用域内的变量。</p>\n<h4 id=\"CMake-文件中\"><a href=\"#CMake-文件中\" class=\"headerlink\" title=\"CMake 文件中\"></a>CMake 文件中</h4><p>每个CMakeLists.txt 和 <code>xx.cmake</code>文件中都定义一个作用域。上级CMakeLists.txt文件中定义的变量，会传递给下级的CMakeLists.txt文件中。</p>\n<p>不在函数用通过<code>set</code>和<code>unset</code>命令设置的变量，作用范围在当前的文件中。</p>\n<p>修改当前CMakeLists.txt文件中定义的变量，在上级CMakeLists.txt文件中不生效，但是通过<code>set</code>命令指定 <code>PARENT_SCOPE</code>,可以修改上级作用域内的变量。</p>\n<h4 id=\"cache-中\"><a href=\"#cache-中\" class=\"headerlink\" title=\"cache 中\"></a>cache 中</h4><p>cache 变量存被保存在<code>CMakeCache.txt</code>文件中。全局变量，多个构建构建中持续生效。</p>\n<p>只能通过set命令，指定<code>CACHE</code>选项来显示修改。</p>\n<h4 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h4><p>类似于普通变量，但是作用范围是全局，不会被缓存。</p>\n<p>变量引用的格式为 $ENV { &lt; Variable &gt; }</p>\n<p>CMake 环境变量的初始值是调用进程的初始值。可以使用 set ()和 unset ()命令更改值。这些命令只影响正在运行的 CMake 进程，而不影响整个系统环境。更改后的值不会写回调用进程，后续的构建或测试进程也不会看到它们。</p>\n<h3 id=\"变量求值的顺序：\"><a href=\"#变量求值的顺序：\" class=\"headerlink\" title=\"变量求值的顺序：\"></a>变量求值的顺序：</h3><ol>\n<li><p>当前函数内查找</p>\n</li>\n<li><p>当前文件中查找</p>\n</li>\n<li><p>缓存中查找</p>\n</li>\n<li><p>最后没找到，计为空字符串。</p>\n</li>\n<li><p>可以通过<code>$CACHE&#123;VAR&#125;</code>跳过前面的过程，直接从缓存中查找。</p>\n</li>\n</ol>\n<h3 id=\"set-给变量赋值\"><a href=\"#set-给变量赋值\" class=\"headerlink\" title=\"set 给变量赋值\"></a>set 给变量赋值</h3><h4 id=\"normal-变量\"><a href=\"#normal-变量\" class=\"headerlink\" title=\"normal 变量\"></a>normal 变量</h4><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\"><span class=\"hljs-built_in\">set</span>(&lt;<span class=\"hljs-built_in\">variable</span>&gt; &lt;value&gt;<span class=\"hljs-params\">...</span> <span class=\"hljs-meta\">[</span>PARENT_SCOPE<span class=\"hljs-meta\">]</span>)<br></code></pre></td></tr></table></figure>\n\n<p>如果指定了PARENT_SCOPE，修改会在上级作用域内生效。</p>\n<h4 id=\"Set-Cache-Entry\"><a href=\"#Set-Cache-Entry\" class=\"headerlink\" title=\"Set Cache Entry\"></a>Set Cache Entry</h4><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\"><span class=\"hljs-built_in\">set</span>(&lt;<span class=\"hljs-built_in\">variable</span>&gt; &lt;value&gt;<span class=\"hljs-params\">...</span> <span class=\"hljs-keyword\">CACHE</span> &lt;<span class=\"hljs-keyword\">type</span>&gt; &lt;docstring&gt; <span class=\"hljs-meta\">[</span>FORCE<span class=\"hljs-meta\">]</span>)<br></code></pre></td></tr></table></figure>\n\n<p>不加FORCE，修改不会覆盖之前cache中的值。 FORCE 选项覆盖现有条目。</p>\n<p>type的类型必须指定为以下一种：</p>\n<ol>\n<li><p>BOOL</p>\n</li>\n<li><p>FILEPATH</p>\n</li>\n<li><p>PATH</p>\n</li>\n<li><p>STRING</p>\n</li>\n<li><p>INTERNAL</p>\n</li>\n</ol>\n<blockquote>\n<p>也可以通过cmake命令，通过<code>-D&lt;var&gt;=&lt;value&gt;</code>添加缓存条目。</p>\n</blockquote>\n<h4 id=\"环境变量-1\"><a href=\"#环境变量-1\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h4><figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-built_in\">set</span>(ENV&#123;<span class=\"hljs-operator\">&lt;</span>variable<span class=\"hljs-operator\">&gt;</span>&#125; <span class=\"hljs-meta\">[&lt;value&gt;]</span>)<br></code></pre></td></tr></table></figure>\n\n<p>设置给定值的环境变量，<code>$ENV&#123;&lt;variable&gt;&#125;</code>的后续调用将返回这个新值。</p>\n<p>此命令只影响当前的 CMake 进程，而不影响调用 CMake 的进程，也不影响整个系统环境，也不影响后续构建或测试流程的环境。</p>\n<p>如果在 <code>ENV &#123; &lt; variable &gt; &#125;</code>之后没有给出参数，或者如果 <code>&lt; value &gt;</code> 是一个空字符串，那么这个命令将清除任何已存在的环境变量</p>\n<h2 id=\"list-变量\"><a href=\"#list-变量\" class=\"headerlink\" title=\"list 变量\"></a>list 变量</h2><blockquote>\n<p>Note A list in cmake is a <code>;</code> separated group of strings. To create a list the set command can be used. For example, <code>set(var a b c d e)</code> creates a list with <code>a;b;c;d;e</code>, and <code>set(var &quot;a b c d e&quot;)</code> creates a string or a list with one item in it. (Note macro arguments are not variables, and therefore cannot be used in LIST commands.)</p>\n</blockquote>\n<p>列表不应该用于复杂的数据处理任务，常常用来保存源文件列表。</p>\n<p>大多数构造列表的命令不会转义; 列表元素中的字符，因此将嵌套列表展开:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">set(srcs <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.c</span> <span class=\"hljs-selector-tag\">b</span><span class=\"hljs-selector-class\">.c</span> c<span class=\"hljs-selector-class\">.c</span>) # sets &quot;srcs&quot; <span class=\"hljs-selector-tag\">to</span> &quot;<span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.c</span>;<span class=\"hljs-selector-tag\">b</span><span class=\"hljs-selector-class\">.c</span>;c<span class=\"hljs-selector-class\">.c</span>&quot;<br>set(x <span class=\"hljs-selector-tag\">a</span> &quot;<span class=\"hljs-selector-tag\">b</span>;c&quot;) # sets &quot;x&quot; <span class=\"hljs-selector-tag\">to</span> &quot;<span class=\"hljs-selector-tag\">a</span>;<span class=\"hljs-selector-tag\">b</span>;c&quot;, not &quot;<span class=\"hljs-selector-tag\">a</span>;<span class=\"hljs-selector-tag\">b</span>\\;c&quot;<br>set(<span class=\"hljs-selector-tag\">var</span> &quot;<span class=\"hljs-selector-tag\">a</span> <span class=\"hljs-selector-tag\">b</span> c d e&quot;) # sets <span class=\"hljs-selector-tag\">var</span> <span class=\"hljs-selector-tag\">to</span> &quot;<span class=\"hljs-selector-tag\">a</span> <span class=\"hljs-selector-tag\">b</span> c d e&quot;<br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://cmake.org/cmake/help/latest/command/list.html\">list</a>操作，就是一些增删查改</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"language-xml\">Reading</span><br><span class=\"language-xml\">  list(LENGTH <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">out-var</span>&gt;</span>)</span><br><span class=\"language-xml\">  list(GET <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">element</span> <span class=\"hljs-attr\">index</span>&gt;</span> [<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">index</span>&gt;</span> ...] <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">out-var</span>&gt;</span>)</span><br><span class=\"language-xml\">  list(JOIN <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">glue</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">out-var</span>&gt;</span>)</span><br><span class=\"language-xml\">  list(SUBLIST <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">begin</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">length</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">out-var</span>&gt;</span>)</span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">Search</span><br><span class=\"language-xml\">  list(FIND <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">value</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">out-var</span>&gt;</span>)</span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">Modification</span><br><span class=\"language-xml\">  list(APPEND <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> [<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">element</span>&gt;</span>...])</span><br><span class=\"language-xml\">  list(FILTER <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> </span><span class=\"hljs-template-variable\">&#123;INCLUDE | EXCLUDE&#125;</span><span class=\"language-xml\"> REGEX <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">regex</span>&gt;</span>)</span><br><span class=\"language-xml\">  list(INSERT <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">index</span>&gt;</span> [<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">element</span>&gt;</span>...])</span><br><span class=\"language-xml\">  list(POP_BACK <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> [<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">out-var</span>&gt;</span>...])</span><br><span class=\"language-xml\">  list(POP_FRONT <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> [<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">out-var</span>&gt;</span>...])</span><br><span class=\"language-xml\">  list(PREPEND <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> [<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">element</span>&gt;</span>...])</span><br><span class=\"language-xml\">  list(REMOVE_ITEM <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">value</span>&gt;</span>...)</span><br><span class=\"language-xml\">  list(REMOVE_AT <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">index</span>&gt;</span>...)</span><br><span class=\"language-xml\">  list(REMOVE_DUPLICATES <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span>)</span><br><span class=\"language-xml\">  list(TRANSFORM <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ACTION</span>&gt;</span> [...])</span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">Ordering</span><br><span class=\"language-xml\">  list(REVERSE <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span>)</span><br><span class=\"language-xml\">  list(SORT <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> [...])</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"file-命令\"><a href=\"#file-命令\" class=\"headerlink\" title=\"file 命令\"></a><a href=\"https://cmake.org/cmake/help/latest/command/file.html\">file 命令</a></h1><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">Reading<br>  <span class=\"hljs-keyword\">file</span>(READ <span class=\"hljs-symbol\">&lt;filename&gt;</span> <span class=\"hljs-symbol\">&lt;out-var&gt;</span> [...])<br>  <span class=\"hljs-keyword\">file</span>(STRINGS <span class=\"hljs-symbol\">&lt;filename&gt;</span> <span class=\"hljs-symbol\">&lt;out-var&gt;</span> [...])<br>  <span class=\"hljs-keyword\">file</span>(<span class=\"hljs-symbol\">&lt;HASH&gt;</span> <span class=\"hljs-symbol\">&lt;filename&gt;</span> <span class=\"hljs-symbol\">&lt;out-var&gt;</span>)<br>  <span class=\"hljs-keyword\">file</span>(TIMESTAMP <span class=\"hljs-symbol\">&lt;filename&gt;</span> <span class=\"hljs-symbol\">&lt;out-var&gt;</span> [...])<br>  <span class=\"hljs-keyword\">file</span>(GET_RUNTIME_DEPENDENCIES [...])<br><br>Writing<br>  <span class=\"hljs-keyword\">file</span>(&#123;WRITE | APPEND&#125; <span class=\"hljs-symbol\">&lt;filename&gt;</span> <span class=\"hljs-symbol\">&lt;content&gt;</span>...)<br>  <span class=\"hljs-keyword\">file</span>(&#123;TOUCH | TOUCH_NOCREATE&#125; [<span class=\"hljs-symbol\">&lt;file&gt;</span>...])<br>  <span class=\"hljs-keyword\">file</span>(GENERATE OUTPUT <span class=\"hljs-symbol\">&lt;output-file&gt;</span> [...])<br>  <span class=\"hljs-keyword\">file</span>(CONFIGURE OUTPUT <span class=\"hljs-symbol\">&lt;output-file&gt;</span> CONTENT <span class=\"hljs-symbol\">&lt;content&gt;</span> [...])<br><br>Filesystem<br>  <span class=\"hljs-keyword\">file</span>(&#123;GLOB | GLOB_RECURSE&#125; <span class=\"hljs-symbol\">&lt;out-var&gt;</span> [...] [<span class=\"hljs-symbol\">&lt;globbing-expr&gt;</span>...])<br>  <span class=\"hljs-keyword\">file</span>(MAKE_DIRECTORY [<span class=\"hljs-symbol\">&lt;dir&gt;</span>...])<br>  <span class=\"hljs-keyword\">file</span>(&#123;REMOVE | REMOVE_RECURSE &#125; [<span class=\"hljs-symbol\">&lt;files&gt;</span>...])<br>  <span class=\"hljs-keyword\">file</span>(RENAME <span class=\"hljs-symbol\">&lt;oldname&gt;</span> <span class=\"hljs-symbol\">&lt;newname&gt;</span> [...])<br>  <span class=\"hljs-keyword\">file</span>(COPY_FILE <span class=\"hljs-symbol\">&lt;oldname&gt;</span> <span class=\"hljs-symbol\">&lt;newname&gt;</span> [...])<br>  <span class=\"hljs-keyword\">file</span>(&#123;COPY | INSTALL&#125; <span class=\"hljs-symbol\">&lt;file&gt;</span>... DESTINATION <span class=\"hljs-symbol\">&lt;dir&gt;</span> [...])<br>  <span class=\"hljs-keyword\">file</span>(SIZE <span class=\"hljs-symbol\">&lt;filename&gt;</span> <span class=\"hljs-symbol\">&lt;out-var&gt;</span>)<br>  <span class=\"hljs-keyword\">file</span>(READ_SYMLINK <span class=\"hljs-symbol\">&lt;linkname&gt;</span> <span class=\"hljs-symbol\">&lt;out-var&gt;</span>)<br>  <span class=\"hljs-keyword\">file</span>(CREATE_LINK <span class=\"hljs-symbol\">&lt;original&gt;</span> <span class=\"hljs-symbol\">&lt;linkname&gt;</span> [...])<br>  <span class=\"hljs-keyword\">file</span>(CHMOD <span class=\"hljs-symbol\">&lt;files&gt;</span>... <span class=\"hljs-symbol\">&lt;directories&gt;</span>... PERMISSIONS <span class=\"hljs-symbol\">&lt;permissions&gt;</span>... [...])<br>  <span class=\"hljs-keyword\">file</span>(CHMOD_RECURSE <span class=\"hljs-symbol\">&lt;files&gt;</span>... <span class=\"hljs-symbol\">&lt;directories&gt;</span>... PERMISSIONS <span class=\"hljs-symbol\">&lt;permissions&gt;</span>... [...])<br><br>Path Conversion<br>  <span class=\"hljs-keyword\">file</span>(REAL_PATH <span class=\"hljs-symbol\">&lt;path&gt;</span> <span class=\"hljs-symbol\">&lt;out-var&gt;</span> [BASE_DIRECTORY <span class=\"hljs-symbol\">&lt;dir&gt;</span>] [EXPAND_TILDE])<br>  <span class=\"hljs-keyword\">file</span>(RELATIVE_PATH <span class=\"hljs-symbol\">&lt;out-var&gt;</span> <span class=\"hljs-symbol\">&lt;directory&gt;</span> <span class=\"hljs-symbol\">&lt;file&gt;</span>)<br>  <span class=\"hljs-keyword\">file</span>(&#123;TO_CMAKE_PATH | TO_NATIVE_PATH&#125; <span class=\"hljs-symbol\">&lt;path&gt;</span> <span class=\"hljs-symbol\">&lt;out-var&gt;</span>)<br><br>Transfer<br>  <span class=\"hljs-keyword\">file</span>(DOWNLOAD <span class=\"hljs-symbol\">&lt;url&gt;</span> [<span class=\"hljs-symbol\">&lt;file&gt;</span>] [...])<br>  <span class=\"hljs-keyword\">file</span>(UPLOAD <span class=\"hljs-symbol\">&lt;file&gt;</span> <span class=\"hljs-symbol\">&lt;url&gt;</span> [...])<br><br>Locking<br>  <span class=\"hljs-keyword\">file</span>(LOCK <span class=\"hljs-symbol\">&lt;path&gt;</span> [...])<br><br>Archiving<br>  <span class=\"hljs-keyword\">file</span>(ARCHIVE_CREATE OUTPUT <span class=\"hljs-symbol\">&lt;archive&gt;</span> PATHS <span class=\"hljs-symbol\">&lt;paths&gt;</span>... [...])<br>  <span class=\"hljs-keyword\">file</span>(ARCHIVE_EXTRACT INPUT <span class=\"hljs-symbol\">&lt;archive&gt;</span> [...])<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Filesystem\"><a href=\"#Filesystem\" class=\"headerlink\" title=\"Filesystem\"></a>Filesystem</h2><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-built_in\">file</span>(GLOB &lt;variable&gt;<br>     <span class=\"hljs-selector-attr\">[LIST_DIRECTORIES true|false]</span> <span class=\"hljs-selector-attr\">[RELATIVE &lt;path&gt;]</span> <span class=\"hljs-selector-attr\">[CONFIGURE_DEPENDS]</span><br>     <span class=\"hljs-selector-attr\">[&lt;globbing-expressions&gt;...]</span>)<br><span class=\"hljs-built_in\">file</span>(GLOB_RECURSE &lt;variable&gt; <span class=\"hljs-selector-attr\">[FOLLOW_SYMLINKS]</span><br>     <span class=\"hljs-selector-attr\">[LIST_DIRECTORIES true|false]</span> <span class=\"hljs-selector-attr\">[RELATIVE &lt;path&gt;]</span> <span class=\"hljs-selector-attr\">[CONFIGURE_DEPENDS]</span><br>     <span class=\"hljs-selector-attr\">[&lt;globbing-expressions&gt;...]</span>)<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Generate a list of files that match the <code>&lt;globbing-expressions&gt;</code> and store it into the <code>&lt;variable&gt;</code>. Globbing expressions are similar to regular expressions, but much simpler. If <code>RELATIVE</code> flag is specified, the results will be returned as relative paths to the given path.</p>\n<p>On Windows and macOS, globbing is case-insensitive even if the underlying filesystem is case-sensitive (both filenames and globbing expressions are converted to lowercase before matching). On other platforms, globbing is case-sensitive</p>\n<p>By default <code>GLOB</code> lists directories - directories are omitted in result if <code>LIST_DIRECTORIES</code> is set to false.</p>\n</blockquote>\n<p>Examples of globbing expressions include:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">*.cxx      - <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">all</span> <span class=\"hljs-keyword\">files</span> with extension cxx<br>*.vt?      - <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">all</span> <span class=\"hljs-keyword\">files</span> with extension vta,...,vtz<br><span class=\"hljs-keyword\">f</span>[<span class=\"hljs-number\">3</span>-<span class=\"hljs-number\">5</span>].txt - <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">files</span> f3.txt, f4.txt, f5.txt<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>The <code>GLOB_RECURSE</code> mode will traverse all the subdirectories of the matched directory and match the files.</p>\n</blockquote>\n<h1 id=\"cmake-执行shell命令\"><a href=\"#cmake-执行shell命令\" class=\"headerlink\" title=\"cmake 执行shell命令\"></a>cmake 执行shell命令</h1><p>通过 execute_process  可以执行调用shell 命令</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">execute_process(COMMAND &lt;cmd1&gt; <span class=\"hljs-comment\">[&lt;arguments&gt;]</span><br>                <span class=\"hljs-comment\">[COMMAND &lt;cmd2&gt; <span class=\"hljs-comment\">[&lt;arguments&gt;]</span>]</span>...<br>                <span class=\"hljs-comment\">[WORKING_DIRECTORY &lt;directory&gt;]</span><br>                <span class=\"hljs-comment\">[TIMEOUT &lt;seconds&gt;]</span><br>                <span class=\"hljs-comment\">[RESULT_VARIABLE &lt;variable&gt;]</span><br>                <span class=\"hljs-comment\">[RESULTS_VARIABLE &lt;variable&gt;]</span><br>                <span class=\"hljs-comment\">[OUTPUT_VARIABLE &lt;variable&gt;]</span><br>                <span class=\"hljs-comment\">[ERROR_VARIABLE &lt;variable&gt;]</span><br>                <span class=\"hljs-comment\">[INPUT_FILE &lt;file&gt;]</span><br>                <span class=\"hljs-comment\">[OUTPUT_FILE &lt;file&gt;]</span><br>                <span class=\"hljs-comment\">[ERROR_FILE &lt;file&gt;]</span><br>                <span class=\"hljs-comment\">[OUTPUT_QUIET]</span><br>                <span class=\"hljs-comment\">[ERROR_QUIET]</span><br>                <span class=\"hljs-comment\">[COMMAND_ECHO &lt;where&gt;]</span><br>                <span class=\"hljs-comment\">[OUTPUT_STRIP_TRAILING_WHITESPACE]</span><br>                <span class=\"hljs-comment\">[ERROR_STRIP_TRAILING_WHITESPACE]</span><br>                <span class=\"hljs-comment\">[ENCODING &lt;name&gt;]</span><br>                <span class=\"hljs-comment\">[ECHO_OUTPUT_VARIABLE]</span><br>                <span class=\"hljs-comment\">[ECHO_ERROR_VARIABLE]</span><br>                <span class=\"hljs-comment\">[COMMAND_ERROR_IS_FATAL &lt;ANY|LAST&gt;]</span>)<br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"文件组织\"><a href=\"#文件组织\" class=\"headerlink\" title=\"文件组织\"></a>文件组织</h1><p>CMake源文件用cmake语言编写，共三种组织形式</p>\n<ul>\n<li><p><a href=\"https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#directories\">Directories</a> (<code>CMakeLists.txt</code>) 目录</p>\n</li>\n<li><p><a href=\"https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#scripts\">Scripts</a> (<code>&lt;script&gt;.cmake</code>) 脚本</p>\n</li>\n<li><p><a href=\"https://cmake.org/cmake/help/latest/manual/cmake-language.7.html#modules\">Modules</a> (<code>&lt;module&gt;.cmake</code>) 模块</p>\n</li>\n</ul>\n<h3 id=\"Directories-目录\"><a href=\"#Directories-目录\" class=\"headerlink\" title=\"Directories 目录\"></a>Directories 目录</h3><p>用cmake 去编译项目时候，入口是项目顶级目录的<code>CMakeLists.txt</code>文件，<code>CMakeLists.txt</code>描述了当前项目构建规则。当遇到<code>add _ subdirectory ()</code>命令，cmake会去命令指定的子目录中搜索<code>CMakeLists.txt</code>，将其添加到构建过程，这是一个递归解析的过程。子目录中的<code>CMakeLists.txt</code>描述了子项目的构建规则。</p>\n<h3 id=\"Scripts-脚本\"><a href=\"#Scripts-脚本\" class=\"headerlink\" title=\"Scripts 脚本\"></a>Scripts 脚本</h3><p>一个单独的<code>&lt;script&gt;.cmake</code>文件可以被当做脚本来处理，可以理解为shell脚本，通过cmake来解析和执行脚本定义的操作。脚本中不允许出现定义构建目标和构建行为的命令，</p>\n<p>cmake 脚本不参与构建过程。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">cmake [&#123;-D <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">var</span>&gt;</span>=<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">value</span>&gt;</span>&#125;...] -P <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">cmake-script-file</span>&gt;</span> [-- <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">unparsed-options</span>&gt;</span>...]<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Process the given cmake file as a script written in the CMake language. No configure or generate step is performed and the cache is not modified. If variables are defined using <code>-D</code>, this must be done before the <code>-P</code> argument.</p>\n</blockquote>\n<blockquote>\n<p>Any options after <code>--</code> are not parsed by CMake, but they are still included in the set of <a href=\"https://cmake.org/cmake/help/latest/variable/CMAKE_ARGV0.html#variable:CMAKE_ARGV0\" title=\"CMAKE_ARGV0\"><code>CMAKE_ARGV&lt;n&gt;</code></a> variables passed to the script (including the <code>--</code> itself).</p>\n</blockquote>\n<h3 id=\"Modules-模块\"><a href=\"#Modules-模块\" class=\"headerlink\" title=\"Modules 模块\"></a>Modules 模块</h3><p>就是一个cmake的源文件，形式<code>&lt;module&gt;.cmake</code>。可以在当前<code>CMakeLists.txt</code>或cmake源文件中，通过<code>include()</code>命令，引入其他cmake文件中定义的内容。类似于c语言的</p>\n<p><code>#include&lt;&gt;</code>。</p>\n<p>cmake 内置了很多的模块，可以通过<a href=\"https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#manual:cmake-modules(7)\">cmake-modules</a>查看。项目可以定义自己cmake modules，通过<a href=\"https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html#variable:CMAKE_MODULE_PATH\">CMAKE_MODULE_PATH</a>来指定他们的路径。</p>\n<h1 id=\"cmake-变量\"><a href=\"#cmake-变量\" class=\"headerlink\" title=\"cmake 变量\"></a>cmake 变量</h1><ol>\n<li><p>cmake 变量的值是字符串类型</p>\n</li>\n<li><p>Set ()和 unset ()命令显式地设置或取消设置变量</p>\n</li>\n<li><p>变量名是区分大小写的,建议只使用由字母数字字符加上 <code>_ </code>和<code>-</code>组成的名称</p>\n</li>\n<li><p>根据作用于范围, 变量的类型有normal, cache, or environment variable</p>\n</li>\n</ol>\n<h3 id=\"变量作用范围\"><a href=\"#变量作用范围\" class=\"headerlink\" title=\"变量作用范围\"></a>变量作用范围</h3><p>参考这篇文章<a href=\"https://blog.csdn.net/weixin_39732534/article/details/110658282\">cmake cache变量_反复研究好几遍，我才发现关于 CMake 变量还可以这样理解！_weixin_39732534的博客-CSDN博客</a> 可以更好的理解cmake 变量及其作用域范围。</p>\n<h4 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h4><p>cmake  通过 <a href=\"https://cmake.org/cmake/help/latest/command/function.html#command:function\" title=\"function\"><code>function()</code></a>命令来定义函数。在函数作用域通过<code>set</code>定义的变量，只在函数作用域内有效，函数返回后，该变量失效。</p>\n<p>但是通过<code>set</code>命令指定 <code>PARENT_SCOPE</code>,可以设置函数上级作用域内的变量。</p>\n<h4 id=\"CMake-文件中\"><a href=\"#CMake-文件中\" class=\"headerlink\" title=\"CMake 文件中\"></a>CMake 文件中</h4><p>每个CMakeLists.txt 和 <code>xx.cmake</code>文件中都定义一个作用域。上级CMakeLists.txt文件中定义的变量，会传递给下级的CMakeLists.txt文件中。</p>\n<p>不在函数用通过<code>set</code>和<code>unset</code>命令设置的变量，作用范围在当前的文件中。</p>\n<p>修改当前CMakeLists.txt文件中定义的变量，在上级CMakeLists.txt文件中不生效，但是通过<code>set</code>命令指定 <code>PARENT_SCOPE</code>,可以修改上级作用域内的变量。</p>\n<h4 id=\"cache-中\"><a href=\"#cache-中\" class=\"headerlink\" title=\"cache 中\"></a>cache 中</h4><p>cache 变量存被保存在<code>CMakeCache.txt</code>文件中。全局变量，多个构建构建中持续生效。</p>\n<p>只能通过set命令，指定<code>CACHE</code>选项来显示修改。</p>\n<h4 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h4><p>类似于普通变量，但是作用范围是全局，不会被缓存。</p>\n<p>变量引用的格式为 $ENV { &lt; Variable &gt; }</p>\n<p>CMake 环境变量的初始值是调用进程的初始值。可以使用 set ()和 unset ()命令更改值。这些命令只影响正在运行的 CMake 进程，而不影响整个系统环境。更改后的值不会写回调用进程，后续的构建或测试进程也不会看到它们。</p>\n<h3 id=\"变量求值的顺序：\"><a href=\"#变量求值的顺序：\" class=\"headerlink\" title=\"变量求值的顺序：\"></a>变量求值的顺序：</h3><ol>\n<li><p>当前函数内查找</p>\n</li>\n<li><p>当前文件中查找</p>\n</li>\n<li><p>缓存中查找</p>\n</li>\n<li><p>最后没找到，计为空字符串。</p>\n</li>\n<li><p>可以通过<code>$CACHE&#123;VAR&#125;</code>跳过前面的过程，直接从缓存中查找。</p>\n</li>\n</ol>\n<h3 id=\"set-给变量赋值\"><a href=\"#set-给变量赋值\" class=\"headerlink\" title=\"set 给变量赋值\"></a>set 给变量赋值</h3><h4 id=\"normal-变量\"><a href=\"#normal-变量\" class=\"headerlink\" title=\"normal 变量\"></a>normal 变量</h4><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\"><span class=\"hljs-built_in\">set</span>(&lt;<span class=\"hljs-built_in\">variable</span>&gt; &lt;value&gt;<span class=\"hljs-params\">...</span> <span class=\"hljs-meta\">[</span>PARENT_SCOPE<span class=\"hljs-meta\">]</span>)<br></code></pre></td></tr></table></figure>\n\n<p>如果指定了PARENT_SCOPE，修改会在上级作用域内生效。</p>\n<h4 id=\"Set-Cache-Entry\"><a href=\"#Set-Cache-Entry\" class=\"headerlink\" title=\"Set Cache Entry\"></a>Set Cache Entry</h4><figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\"><span class=\"hljs-built_in\">set</span>(&lt;<span class=\"hljs-built_in\">variable</span>&gt; &lt;value&gt;<span class=\"hljs-params\">...</span> <span class=\"hljs-keyword\">CACHE</span> &lt;<span class=\"hljs-keyword\">type</span>&gt; &lt;docstring&gt; <span class=\"hljs-meta\">[</span>FORCE<span class=\"hljs-meta\">]</span>)<br></code></pre></td></tr></table></figure>\n\n<p>不加FORCE，修改不会覆盖之前cache中的值。 FORCE 选项覆盖现有条目。</p>\n<p>type的类型必须指定为以下一种：</p>\n<ol>\n<li><p>BOOL</p>\n</li>\n<li><p>FILEPATH</p>\n</li>\n<li><p>PATH</p>\n</li>\n<li><p>STRING</p>\n</li>\n<li><p>INTERNAL</p>\n</li>\n</ol>\n<blockquote>\n<p>也可以通过cmake命令，通过<code>-D&lt;var&gt;=&lt;value&gt;</code>添加缓存条目。</p>\n</blockquote>\n<h4 id=\"环境变量-1\"><a href=\"#环境变量-1\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h4><figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\"><span class=\"hljs-built_in\">set</span>(ENV&#123;<span class=\"hljs-operator\">&lt;</span>variable<span class=\"hljs-operator\">&gt;</span>&#125; <span class=\"hljs-meta\">[&lt;value&gt;]</span>)<br></code></pre></td></tr></table></figure>\n\n<p>设置给定值的环境变量，<code>$ENV&#123;&lt;variable&gt;&#125;</code>的后续调用将返回这个新值。</p>\n<p>此命令只影响当前的 CMake 进程，而不影响调用 CMake 的进程，也不影响整个系统环境，也不影响后续构建或测试流程的环境。</p>\n<p>如果在 <code>ENV &#123; &lt; variable &gt; &#125;</code>之后没有给出参数，或者如果 <code>&lt; value &gt;</code> 是一个空字符串，那么这个命令将清除任何已存在的环境变量</p>\n<h2 id=\"list-变量\"><a href=\"#list-变量\" class=\"headerlink\" title=\"list 变量\"></a>list 变量</h2><blockquote>\n<p>Note A list in cmake is a <code>;</code> separated group of strings. To create a list the set command can be used. For example, <code>set(var a b c d e)</code> creates a list with <code>a;b;c;d;e</code>, and <code>set(var &quot;a b c d e&quot;)</code> creates a string or a list with one item in it. (Note macro arguments are not variables, and therefore cannot be used in LIST commands.)</p>\n</blockquote>\n<p>列表不应该用于复杂的数据处理任务，常常用来保存源文件列表。</p>\n<p>大多数构造列表的命令不会转义; 列表元素中的字符，因此将嵌套列表展开:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">set(srcs <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.c</span> <span class=\"hljs-selector-tag\">b</span><span class=\"hljs-selector-class\">.c</span> c<span class=\"hljs-selector-class\">.c</span>) # sets &quot;srcs&quot; <span class=\"hljs-selector-tag\">to</span> &quot;<span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-class\">.c</span>;<span class=\"hljs-selector-tag\">b</span><span class=\"hljs-selector-class\">.c</span>;c<span class=\"hljs-selector-class\">.c</span>&quot;<br>set(x <span class=\"hljs-selector-tag\">a</span> &quot;<span class=\"hljs-selector-tag\">b</span>;c&quot;) # sets &quot;x&quot; <span class=\"hljs-selector-tag\">to</span> &quot;<span class=\"hljs-selector-tag\">a</span>;<span class=\"hljs-selector-tag\">b</span>;c&quot;, not &quot;<span class=\"hljs-selector-tag\">a</span>;<span class=\"hljs-selector-tag\">b</span>\\;c&quot;<br>set(<span class=\"hljs-selector-tag\">var</span> &quot;<span class=\"hljs-selector-tag\">a</span> <span class=\"hljs-selector-tag\">b</span> c d e&quot;) # sets <span class=\"hljs-selector-tag\">var</span> <span class=\"hljs-selector-tag\">to</span> &quot;<span class=\"hljs-selector-tag\">a</span> <span class=\"hljs-selector-tag\">b</span> c d e&quot;<br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://cmake.org/cmake/help/latest/command/list.html\">list</a>操作，就是一些增删查改</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dust\"><span class=\"language-xml\">Reading</span><br><span class=\"language-xml\">  list(LENGTH <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">out-var</span>&gt;</span>)</span><br><span class=\"language-xml\">  list(GET <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">element</span> <span class=\"hljs-attr\">index</span>&gt;</span> [<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">index</span>&gt;</span> ...] <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">out-var</span>&gt;</span>)</span><br><span class=\"language-xml\">  list(JOIN <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">glue</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">out-var</span>&gt;</span>)</span><br><span class=\"language-xml\">  list(SUBLIST <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">begin</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">length</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">out-var</span>&gt;</span>)</span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">Search</span><br><span class=\"language-xml\">  list(FIND <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">value</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">out-var</span>&gt;</span>)</span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">Modification</span><br><span class=\"language-xml\">  list(APPEND <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> [<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">element</span>&gt;</span>...])</span><br><span class=\"language-xml\">  list(FILTER <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> </span><span class=\"hljs-template-variable\">&#123;INCLUDE | EXCLUDE&#125;</span><span class=\"language-xml\"> REGEX <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">regex</span>&gt;</span>)</span><br><span class=\"language-xml\">  list(INSERT <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">index</span>&gt;</span> [<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">element</span>&gt;</span>...])</span><br><span class=\"language-xml\">  list(POP_BACK <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> [<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">out-var</span>&gt;</span>...])</span><br><span class=\"language-xml\">  list(POP_FRONT <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> [<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">out-var</span>&gt;</span>...])</span><br><span class=\"language-xml\">  list(PREPEND <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> [<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">element</span>&gt;</span>...])</span><br><span class=\"language-xml\">  list(REMOVE_ITEM <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">value</span>&gt;</span>...)</span><br><span class=\"language-xml\">  list(REMOVE_AT <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">index</span>&gt;</span>...)</span><br><span class=\"language-xml\">  list(REMOVE_DUPLICATES <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span>)</span><br><span class=\"language-xml\">  list(TRANSFORM <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ACTION</span>&gt;</span> [...])</span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">Ordering</span><br><span class=\"language-xml\">  list(REVERSE <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span>)</span><br><span class=\"language-xml\">  list(SORT <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">list</span>&gt;</span> [...])</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"file-命令\"><a href=\"#file-命令\" class=\"headerlink\" title=\"file 命令\"></a><a href=\"https://cmake.org/cmake/help/latest/command/file.html\">file 命令</a></h1><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">Reading<br>  <span class=\"hljs-keyword\">file</span>(READ <span class=\"hljs-symbol\">&lt;filename&gt;</span> <span class=\"hljs-symbol\">&lt;out-var&gt;</span> [...])<br>  <span class=\"hljs-keyword\">file</span>(STRINGS <span class=\"hljs-symbol\">&lt;filename&gt;</span> <span class=\"hljs-symbol\">&lt;out-var&gt;</span> [...])<br>  <span class=\"hljs-keyword\">file</span>(<span class=\"hljs-symbol\">&lt;HASH&gt;</span> <span class=\"hljs-symbol\">&lt;filename&gt;</span> <span class=\"hljs-symbol\">&lt;out-var&gt;</span>)<br>  <span class=\"hljs-keyword\">file</span>(TIMESTAMP <span class=\"hljs-symbol\">&lt;filename&gt;</span> <span class=\"hljs-symbol\">&lt;out-var&gt;</span> [...])<br>  <span class=\"hljs-keyword\">file</span>(GET_RUNTIME_DEPENDENCIES [...])<br><br>Writing<br>  <span class=\"hljs-keyword\">file</span>(&#123;WRITE | APPEND&#125; <span class=\"hljs-symbol\">&lt;filename&gt;</span> <span class=\"hljs-symbol\">&lt;content&gt;</span>...)<br>  <span class=\"hljs-keyword\">file</span>(&#123;TOUCH | TOUCH_NOCREATE&#125; [<span class=\"hljs-symbol\">&lt;file&gt;</span>...])<br>  <span class=\"hljs-keyword\">file</span>(GENERATE OUTPUT <span class=\"hljs-symbol\">&lt;output-file&gt;</span> [...])<br>  <span class=\"hljs-keyword\">file</span>(CONFIGURE OUTPUT <span class=\"hljs-symbol\">&lt;output-file&gt;</span> CONTENT <span class=\"hljs-symbol\">&lt;content&gt;</span> [...])<br><br>Filesystem<br>  <span class=\"hljs-keyword\">file</span>(&#123;GLOB | GLOB_RECURSE&#125; <span class=\"hljs-symbol\">&lt;out-var&gt;</span> [...] [<span class=\"hljs-symbol\">&lt;globbing-expr&gt;</span>...])<br>  <span class=\"hljs-keyword\">file</span>(MAKE_DIRECTORY [<span class=\"hljs-symbol\">&lt;dir&gt;</span>...])<br>  <span class=\"hljs-keyword\">file</span>(&#123;REMOVE | REMOVE_RECURSE &#125; [<span class=\"hljs-symbol\">&lt;files&gt;</span>...])<br>  <span class=\"hljs-keyword\">file</span>(RENAME <span class=\"hljs-symbol\">&lt;oldname&gt;</span> <span class=\"hljs-symbol\">&lt;newname&gt;</span> [...])<br>  <span class=\"hljs-keyword\">file</span>(COPY_FILE <span class=\"hljs-symbol\">&lt;oldname&gt;</span> <span class=\"hljs-symbol\">&lt;newname&gt;</span> [...])<br>  <span class=\"hljs-keyword\">file</span>(&#123;COPY | INSTALL&#125; <span class=\"hljs-symbol\">&lt;file&gt;</span>... DESTINATION <span class=\"hljs-symbol\">&lt;dir&gt;</span> [...])<br>  <span class=\"hljs-keyword\">file</span>(SIZE <span class=\"hljs-symbol\">&lt;filename&gt;</span> <span class=\"hljs-symbol\">&lt;out-var&gt;</span>)<br>  <span class=\"hljs-keyword\">file</span>(READ_SYMLINK <span class=\"hljs-symbol\">&lt;linkname&gt;</span> <span class=\"hljs-symbol\">&lt;out-var&gt;</span>)<br>  <span class=\"hljs-keyword\">file</span>(CREATE_LINK <span class=\"hljs-symbol\">&lt;original&gt;</span> <span class=\"hljs-symbol\">&lt;linkname&gt;</span> [...])<br>  <span class=\"hljs-keyword\">file</span>(CHMOD <span class=\"hljs-symbol\">&lt;files&gt;</span>... <span class=\"hljs-symbol\">&lt;directories&gt;</span>... PERMISSIONS <span class=\"hljs-symbol\">&lt;permissions&gt;</span>... [...])<br>  <span class=\"hljs-keyword\">file</span>(CHMOD_RECURSE <span class=\"hljs-symbol\">&lt;files&gt;</span>... <span class=\"hljs-symbol\">&lt;directories&gt;</span>... PERMISSIONS <span class=\"hljs-symbol\">&lt;permissions&gt;</span>... [...])<br><br>Path Conversion<br>  <span class=\"hljs-keyword\">file</span>(REAL_PATH <span class=\"hljs-symbol\">&lt;path&gt;</span> <span class=\"hljs-symbol\">&lt;out-var&gt;</span> [BASE_DIRECTORY <span class=\"hljs-symbol\">&lt;dir&gt;</span>] [EXPAND_TILDE])<br>  <span class=\"hljs-keyword\">file</span>(RELATIVE_PATH <span class=\"hljs-symbol\">&lt;out-var&gt;</span> <span class=\"hljs-symbol\">&lt;directory&gt;</span> <span class=\"hljs-symbol\">&lt;file&gt;</span>)<br>  <span class=\"hljs-keyword\">file</span>(&#123;TO_CMAKE_PATH | TO_NATIVE_PATH&#125; <span class=\"hljs-symbol\">&lt;path&gt;</span> <span class=\"hljs-symbol\">&lt;out-var&gt;</span>)<br><br>Transfer<br>  <span class=\"hljs-keyword\">file</span>(DOWNLOAD <span class=\"hljs-symbol\">&lt;url&gt;</span> [<span class=\"hljs-symbol\">&lt;file&gt;</span>] [...])<br>  <span class=\"hljs-keyword\">file</span>(UPLOAD <span class=\"hljs-symbol\">&lt;file&gt;</span> <span class=\"hljs-symbol\">&lt;url&gt;</span> [...])<br><br>Locking<br>  <span class=\"hljs-keyword\">file</span>(LOCK <span class=\"hljs-symbol\">&lt;path&gt;</span> [...])<br><br>Archiving<br>  <span class=\"hljs-keyword\">file</span>(ARCHIVE_CREATE OUTPUT <span class=\"hljs-symbol\">&lt;archive&gt;</span> PATHS <span class=\"hljs-symbol\">&lt;paths&gt;</span>... [...])<br>  <span class=\"hljs-keyword\">file</span>(ARCHIVE_EXTRACT INPUT <span class=\"hljs-symbol\">&lt;archive&gt;</span> [...])<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Filesystem\"><a href=\"#Filesystem\" class=\"headerlink\" title=\"Filesystem\"></a>Filesystem</h2><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-built_in\">file</span>(GLOB &lt;variable&gt;<br>     <span class=\"hljs-selector-attr\">[LIST_DIRECTORIES true|false]</span> <span class=\"hljs-selector-attr\">[RELATIVE &lt;path&gt;]</span> <span class=\"hljs-selector-attr\">[CONFIGURE_DEPENDS]</span><br>     <span class=\"hljs-selector-attr\">[&lt;globbing-expressions&gt;...]</span>)<br><span class=\"hljs-built_in\">file</span>(GLOB_RECURSE &lt;variable&gt; <span class=\"hljs-selector-attr\">[FOLLOW_SYMLINKS]</span><br>     <span class=\"hljs-selector-attr\">[LIST_DIRECTORIES true|false]</span> <span class=\"hljs-selector-attr\">[RELATIVE &lt;path&gt;]</span> <span class=\"hljs-selector-attr\">[CONFIGURE_DEPENDS]</span><br>     <span class=\"hljs-selector-attr\">[&lt;globbing-expressions&gt;...]</span>)<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Generate a list of files that match the <code>&lt;globbing-expressions&gt;</code> and store it into the <code>&lt;variable&gt;</code>. Globbing expressions are similar to regular expressions, but much simpler. If <code>RELATIVE</code> flag is specified, the results will be returned as relative paths to the given path.</p>\n<p>On Windows and macOS, globbing is case-insensitive even if the underlying filesystem is case-sensitive (both filenames and globbing expressions are converted to lowercase before matching). On other platforms, globbing is case-sensitive</p>\n<p>By default <code>GLOB</code> lists directories - directories are omitted in result if <code>LIST_DIRECTORIES</code> is set to false.</p>\n</blockquote>\n<p>Examples of globbing expressions include:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">*.cxx      - <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">all</span> <span class=\"hljs-keyword\">files</span> with extension cxx<br>*.vt?      - <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">all</span> <span class=\"hljs-keyword\">files</span> with extension vta,...,vtz<br><span class=\"hljs-keyword\">f</span>[<span class=\"hljs-number\">3</span>-<span class=\"hljs-number\">5</span>].txt - <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">files</span> f3.txt, f4.txt, f5.txt<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>The <code>GLOB_RECURSE</code> mode will traverse all the subdirectories of the matched directory and match the files.</p>\n</blockquote>\n<h1 id=\"cmake-执行shell命令\"><a href=\"#cmake-执行shell命令\" class=\"headerlink\" title=\"cmake 执行shell命令\"></a>cmake 执行shell命令</h1><p>通过 execute_process  可以执行调用shell 命令</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">execute_process(COMMAND &lt;cmd1&gt; <span class=\"hljs-comment\">[&lt;arguments&gt;]</span><br>                <span class=\"hljs-comment\">[COMMAND &lt;cmd2&gt; <span class=\"hljs-comment\">[&lt;arguments&gt;]</span>]</span>...<br>                <span class=\"hljs-comment\">[WORKING_DIRECTORY &lt;directory&gt;]</span><br>                <span class=\"hljs-comment\">[TIMEOUT &lt;seconds&gt;]</span><br>                <span class=\"hljs-comment\">[RESULT_VARIABLE &lt;variable&gt;]</span><br>                <span class=\"hljs-comment\">[RESULTS_VARIABLE &lt;variable&gt;]</span><br>                <span class=\"hljs-comment\">[OUTPUT_VARIABLE &lt;variable&gt;]</span><br>                <span class=\"hljs-comment\">[ERROR_VARIABLE &lt;variable&gt;]</span><br>                <span class=\"hljs-comment\">[INPUT_FILE &lt;file&gt;]</span><br>                <span class=\"hljs-comment\">[OUTPUT_FILE &lt;file&gt;]</span><br>                <span class=\"hljs-comment\">[ERROR_FILE &lt;file&gt;]</span><br>                <span class=\"hljs-comment\">[OUTPUT_QUIET]</span><br>                <span class=\"hljs-comment\">[ERROR_QUIET]</span><br>                <span class=\"hljs-comment\">[COMMAND_ECHO &lt;where&gt;]</span><br>                <span class=\"hljs-comment\">[OUTPUT_STRIP_TRAILING_WHITESPACE]</span><br>                <span class=\"hljs-comment\">[ERROR_STRIP_TRAILING_WHITESPACE]</span><br>                <span class=\"hljs-comment\">[ENCODING &lt;name&gt;]</span><br>                <span class=\"hljs-comment\">[ECHO_OUTPUT_VARIABLE]</span><br>                <span class=\"hljs-comment\">[ECHO_ERROR_VARIABLE]</span><br>                <span class=\"hljs-comment\">[COMMAND_ERROR_IS_FATAL &lt;ANY|LAST&gt;]</span>)<br></code></pre></td></tr></table></figure>\n"},{"layout":"post","title":"cmake add_custom_command","date":"2022-10-22T16:00:00.000Z","_content":"\n目的： 添加自定义的构建规则到生成的构建系统中。\n\n有两种用法：\n1. 使用外部命令来产生一个输出, 例如生成文件\n2. 监听一个target的构建事件，在target构建前或者构建后，执行命令\n\n\n# Examples: Generating Files\n\n添加命令，执行后生成源文件\n\n```\nadd_custom_command(\n  OUTPUT out.c\n  COMMAND someTool -i ${CMAKE_CURRENT_SOURCE_DIR}/in.txt\n                   -o out.c\n  DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/in.txt\n  VERBATIM)\nadd_library(myLib out.c)\n```\n\n通过生成器表达式，为每个config指定不同的输出\n```\nadd_custom_command(\n  OUTPUT \"out-$<CONFIG>.c\"\n  COMMAND someTool -i ${CMAKE_CURRENT_SOURCE_DIR}/in.txt\n                   -o \"out-$<CONFIG>.c\"\n                   -c \"$<CONFIG>\"\n  DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/in.txt\n  VERBATIM)\nadd_library(myLib \"out-$<CONFIG>.c\")\n```\n\n# Examples: Build Events\n\n在target被构建，链接之后，执行自定义命令\n\n```\nadd_executable(myExe myExe.c)\nadd_custom_command(\n  TARGET myExe POST_BUILD\n  COMMAND someHasher -i \"$<TARGET_FILE:myExe>\"\n                     -o \"$<TARGET_FILE:myExe>.hash\"\n  VERBATIM)\n```\n\n目前支持两种\n- PRE_LINK 编译后，连接前执行命令\n- POST_BUILD 构建后，成功链接后执行命令\n\n","source":"_posts/cmake/2022-10-23-cmake add_custom_command.md","raw":"---\nlayout: post\ntitle: \"cmake add_custom_command\"\ndate: 2022-10-23\ntag: cmake\n---\n\n目的： 添加自定义的构建规则到生成的构建系统中。\n\n有两种用法：\n1. 使用外部命令来产生一个输出, 例如生成文件\n2. 监听一个target的构建事件，在target构建前或者构建后，执行命令\n\n\n# Examples: Generating Files\n\n添加命令，执行后生成源文件\n\n```\nadd_custom_command(\n  OUTPUT out.c\n  COMMAND someTool -i ${CMAKE_CURRENT_SOURCE_DIR}/in.txt\n                   -o out.c\n  DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/in.txt\n  VERBATIM)\nadd_library(myLib out.c)\n```\n\n通过生成器表达式，为每个config指定不同的输出\n```\nadd_custom_command(\n  OUTPUT \"out-$<CONFIG>.c\"\n  COMMAND someTool -i ${CMAKE_CURRENT_SOURCE_DIR}/in.txt\n                   -o \"out-$<CONFIG>.c\"\n                   -c \"$<CONFIG>\"\n  DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/in.txt\n  VERBATIM)\nadd_library(myLib \"out-$<CONFIG>.c\")\n```\n\n# Examples: Build Events\n\n在target被构建，链接之后，执行自定义命令\n\n```\nadd_executable(myExe myExe.c)\nadd_custom_command(\n  TARGET myExe POST_BUILD\n  COMMAND someHasher -i \"$<TARGET_FILE:myExe>\"\n                     -o \"$<TARGET_FILE:myExe>.hash\"\n  VERBATIM)\n```\n\n目前支持两种\n- PRE_LINK 编译后，连接前执行命令\n- POST_BUILD 构建后，成功链接后执行命令\n\n","slug":"cmake/2022-10-23-cmake add_custom_command","published":1,"updated":"2024-03-06T11:53:13.564Z","comments":1,"photos":[],"_id":"cltgopena0019qywhgnhc54sv","content":"<p>目的： 添加自定义的构建规则到生成的构建系统中。</p>\n<p>有两种用法：</p>\n<ol>\n<li>使用外部命令来产生一个输出, 例如生成文件</li>\n<li>监听一个target的构建事件，在target构建前或者构建后，执行命令</li>\n</ol>\n<h1 id=\"Examples-Generating-Files\"><a href=\"#Examples-Generating-Files\" class=\"headerlink\" title=\"Examples: Generating Files\"></a>Examples: Generating Files</h1><p>添加命令，执行后生成源文件</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-built_in\">add_custom_command</span>(<br>  OUTPUT out<span class=\"hljs-selector-class\">.c</span><br>  COMMAND someTool -<span class=\"hljs-selector-tag\">i</span> $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/<span class=\"hljs-keyword\">in</span><span class=\"hljs-selector-class\">.txt</span><br>                   -o out<span class=\"hljs-selector-class\">.c</span><br>  DEPENDS $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/<span class=\"hljs-keyword\">in</span><span class=\"hljs-selector-class\">.txt</span><br>  VERBATIM)<br><span class=\"hljs-function\"><span class=\"hljs-title\">add_library</span><span class=\"hljs-params\">(myLib out.c)</span></span><br></code></pre></td></tr></table></figure>\n\n<p>通过生成器表达式，为每个config指定不同的输出</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-built_in\">add_custom_command</span>(<br>  OUTPUT <span class=\"hljs-string\">&quot;out-$&lt;CONFIG&gt;.c&quot;</span><br>  COMMAND someTool -<span class=\"hljs-selector-tag\">i</span> $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/<span class=\"hljs-keyword\">in</span><span class=\"hljs-selector-class\">.txt</span><br>                   -o <span class=\"hljs-string\">&quot;out-$&lt;CONFIG&gt;.c&quot;</span><br>                   -c <span class=\"hljs-string\">&quot;$&lt;CONFIG&gt;&quot;</span><br>  DEPENDS $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/<span class=\"hljs-keyword\">in</span><span class=\"hljs-selector-class\">.txt</span><br>  VERBATIM)<br><span class=\"hljs-function\"><span class=\"hljs-title\">add_library</span><span class=\"hljs-params\">(myLib <span class=\"hljs-string\">&quot;out-$&lt;CONFIG&gt;.c&quot;</span>)</span></span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Examples-Build-Events\"><a href=\"#Examples-Build-Events\" class=\"headerlink\" title=\"Examples: Build Events\"></a>Examples: Build Events</h1><p>在target被构建，链接之后，执行自定义命令</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">add_executable</span><span class=\"hljs-params\">(myExe myExe.c)</span></span><br><span class=\"hljs-built_in\">add_custom_command</span>(<br>  TARGET myExe POST_BUILD<br>  COMMAND someHasher -<span class=\"hljs-selector-tag\">i</span> <span class=\"hljs-string\">&quot;$&lt;TARGET_FILE:myExe&gt;&quot;</span><br>                     -o <span class=\"hljs-string\">&quot;$&lt;TARGET_FILE:myExe&gt;.hash&quot;</span><br>  VERBATIM)<br></code></pre></td></tr></table></figure>\n\n<p>目前支持两种</p>\n<ul>\n<li>PRE_LINK 编译后，连接前执行命令</li>\n<li>POST_BUILD 构建后，成功链接后执行命令</li>\n</ul>\n","excerpt":"","more":"<p>目的： 添加自定义的构建规则到生成的构建系统中。</p>\n<p>有两种用法：</p>\n<ol>\n<li>使用外部命令来产生一个输出, 例如生成文件</li>\n<li>监听一个target的构建事件，在target构建前或者构建后，执行命令</li>\n</ol>\n<h1 id=\"Examples-Generating-Files\"><a href=\"#Examples-Generating-Files\" class=\"headerlink\" title=\"Examples: Generating Files\"></a>Examples: Generating Files</h1><p>添加命令，执行后生成源文件</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-built_in\">add_custom_command</span>(<br>  OUTPUT out<span class=\"hljs-selector-class\">.c</span><br>  COMMAND someTool -<span class=\"hljs-selector-tag\">i</span> $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/<span class=\"hljs-keyword\">in</span><span class=\"hljs-selector-class\">.txt</span><br>                   -o out<span class=\"hljs-selector-class\">.c</span><br>  DEPENDS $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/<span class=\"hljs-keyword\">in</span><span class=\"hljs-selector-class\">.txt</span><br>  VERBATIM)<br><span class=\"hljs-function\"><span class=\"hljs-title\">add_library</span><span class=\"hljs-params\">(myLib out.c)</span></span><br></code></pre></td></tr></table></figure>\n\n<p>通过生成器表达式，为每个config指定不同的输出</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-built_in\">add_custom_command</span>(<br>  OUTPUT <span class=\"hljs-string\">&quot;out-$&lt;CONFIG&gt;.c&quot;</span><br>  COMMAND someTool -<span class=\"hljs-selector-tag\">i</span> $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/<span class=\"hljs-keyword\">in</span><span class=\"hljs-selector-class\">.txt</span><br>                   -o <span class=\"hljs-string\">&quot;out-$&lt;CONFIG&gt;.c&quot;</span><br>                   -c <span class=\"hljs-string\">&quot;$&lt;CONFIG&gt;&quot;</span><br>  DEPENDS $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/<span class=\"hljs-keyword\">in</span><span class=\"hljs-selector-class\">.txt</span><br>  VERBATIM)<br><span class=\"hljs-function\"><span class=\"hljs-title\">add_library</span><span class=\"hljs-params\">(myLib <span class=\"hljs-string\">&quot;out-$&lt;CONFIG&gt;.c&quot;</span>)</span></span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Examples-Build-Events\"><a href=\"#Examples-Build-Events\" class=\"headerlink\" title=\"Examples: Build Events\"></a>Examples: Build Events</h1><p>在target被构建，链接之后，执行自定义命令</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">add_executable</span><span class=\"hljs-params\">(myExe myExe.c)</span></span><br><span class=\"hljs-built_in\">add_custom_command</span>(<br>  TARGET myExe POST_BUILD<br>  COMMAND someHasher -<span class=\"hljs-selector-tag\">i</span> <span class=\"hljs-string\">&quot;$&lt;TARGET_FILE:myExe&gt;&quot;</span><br>                     -o <span class=\"hljs-string\">&quot;$&lt;TARGET_FILE:myExe&gt;.hash&quot;</span><br>  VERBATIM)<br></code></pre></td></tr></table></figure>\n\n<p>目前支持两种</p>\n<ul>\n<li>PRE_LINK 编译后，连接前执行命令</li>\n<li>POST_BUILD 构建后，成功链接后执行命令</li>\n</ul>\n"},{"layout":"post","title":"cmake Importing and Exporting Guide","date":"2022-10-23T16:00:00.000Z","_content":"\n参考：https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html \n\n# Importing\n\nIMPORTED targets 将cmake工程外部的库，可执行文件引入到当前的cmake工程中，被引入的内容会关联到一个cmake 中一个\n逻辑上的target。\n\n创建方式，调用`add_executable()`,`add_library()`命令创建target， 但是要添加`IMPORTED`参数。\n\n这个IMPORTED target不产生任何构建文件，因为他们引入的都是现成的库或者可执行文件。\n\n一旦IMPORTED target 被创建好了，就可以像工程中的其他target一样被引用了。 通过这种方式，就可以方便，灵活引用外部可执行文件和库了。\n\n## Importing Executables\n\n使用磁盘上的可执行文件。\n\n```\nadd_executable(myexe IMPORTED)\nset_property(TARGET myexe PROPERTY\n             IMPORTED_LOCATION \"../InstallMyExe/bin/myexe\")\nadd_custom_command(OUTPUT main.cc COMMAND myexe)\nadd_executable(mynewexe main.cc)\n```\n\n1. 创建一个IMPORTED target\n2. 设置target相关属性，这里指定其关联的可执行文件路径\n3. 添加了一个custom command， 用target myexe指定的可执行文件来生成文件`main.cc`\n4. 创建一个正常的可执行target, 使用上一步生成的`main.cc`作为源文件\n\n## Importing Libraries\n\n导入已经构建好的库作为一个target来使用。\n```\nadd_library(foo STATIC IMPORTED)\nset_property(TARGET foo PROPERTY\n             IMPORTED_LOCATION \"/path/to/libfoo.a\")\nadd_executable(myexe src1.c src2.c)\ntarget_link_libraries(myexe PRIVATE foo)\n```\n\n1. 创建一个IMPORTED target\n2. 设置target相关属性，这里指定其关联的静态库路径\n3. 创建一个正常的可执行target myexe，链接上面创建的target foo\n\n考虑到可能会有debug，release 等不同配置，引入具有不同配置的同一个库，可以使用下面的形式\n```\nfind_library(math_REL NAMES m)\nfind_library(math_DBG NAMES md)\nadd_library(math STATIC IMPORTED GLOBAL)\nset_target_properties(math PROPERTIES\n  IMPORTED_LOCATION \"${math_REL}\"\n  IMPORTED_LOCATION_DEBUG \"${math_DBG}\"\n  IMPORTED_CONFIGURATIONS \"RELEASE;DEBUG\"\n)\nadd_executable(myexe src1.c src2.c)\ntarget_link_libraries(myexe PRIVATE math)\n```\n# Exporting Targets\n> While IMPORTED targets on their own are useful, they still require that the project that imports them knows the locations of the target files on disk. The real power of IMPORTED targets is when the project providing the target files also provides a CMake file to help import them. A project can be setup to produce the necessary information so that it can easily be used by other CMake projects be it from a build directory, a local install or when packaged.\n\n1. IMPORTED targets 要求使用这些target的工程，知道相关文件在磁盘上的位置。\n2. 要想屏蔽这些细节，库的提供方，同时提供一个导入这个库的帮助文件 `xxxTargets.cmake`\n3. 要想生成的库，可以通过`find_package()`命令来索引使用的话，可以在cmake工程中配置，在构建工程的时候，同时生成对应的帮助文件\n    - `xxxTargets.cmake`\n    - `xxxConfig.cmake`\n    - `xxxConfigVersion.cmake`\n\n## `xxxTargets.cmake`\n\n```\ncmake_minimum_required(VERSION 3.15)\nproject(MathFunctions)\n\n# make cache variables for install destinations\ninclude(GNUInstallDirs)\n\n# specify the C++ standard\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\n\n# create library\nadd_library(MathFunctions STATIC MathFunctions.cxx)\n\n# add include directories\ntarget_include_directories(MathFunctions\n                           PUBLIC\n                           \"$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\"\n                           \"$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\"\n)\n\n# install the target and create export-set\ninstall(TARGETS MathFunctions\n        EXPORT MathFunctionsTargets\n        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n        RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n        INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n)\n\n# install header file\ninstall(FILES MathFunctions.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n\n# generate and install export file\ninstall(EXPORT MathFunctionsTargets\n        FILE MathFunctionsTargets.cmake\n        NAMESPACE MathFunctions::\n        DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/MathFunctions\n)\n# create IMPORTED target, set target property\nadd_library(MathFunctions::MathFunctions STATIC IMPORTED)\nset_target_properties(MathFunctions::MathFunctions PROPERTIES\n  INTERFACE_INCLUDE_DIRECTORIES \"${_IMPORT_PREFIX}/include\"\n)\n```\n\n1. 创建一个正常的静态库\n2. 设置静态库头文件搜索路径，分别指定构建时和安装后的路径\n3. 创建一个install命令，指定生成二进制文件的安装路径。其中`EXPORT MathFunctionsTargets`,指定了导出target文件对应的文件名字是`MathFunctionsTargets.cmake`\n4. 指定头文件如何安装\n5. 指定`MathFunctionsTargets.cmake`文件如何安装，`NAMESPACE MathFunctions::` 给导出的target添加前缀命名空间，一般带有命名空间的target，都是`IMPORTED target`\n6. 创建一个`IMPORTED target`,名字是`MathFunctions::MathFunctions`\n7. 设置`MathFunctions::MathFunctions`的属性，此处是头文件路径\n\n\n如何使用导出的target文件, 在`CMakeLists.txt`文件中\n```\n include(${INSTALL_PREFIX}/lib/cmake/MathFunctionTargets.cmake)\n add_executable(myexe src1.c src2.c )\n target_link_libraries(myexe PRIVATE MathFunctions::MathFunctions)\n```\n1. 首先包含`/MathFunctionTargets.cmake`文件\n2. 创建一个可执行目标myexe\n3. 链接MathFunctions::MathFunctions到myexe\n\n## 支持`find_package()`\n\n使用示例：\n\n```\nfind_package(Stats 2.6.4 REQUIRED)\ntarget_link_libraries(MathFunctions PUBLIC Stats::Types)\n```\n\nfind_package() 支持两种搜索模式\n- module mode， 针对非cmake构建的库，搜索`Find<PackageName>.cmake`文件\n- config mode， 针对cmake构建的库，相关文件为\n    - target相关： `<lowercasePackageName>-config.cmake`或者`<PackageName>Config.cmake`\n    - 版本相关： `<lowercasePackageName>-config-version.cmake` 或 `<PackageName>ConfigVersion.cmake`\n\n因此，cmake构建的库，想要支持`find_package()`的config模式，需要提供\n- `xxxConfig.cmake`\n- `xxConfigVersion.cmake`\n\n\n首先包含`CMakePackageConfigHelpers`模块\n```\ninclude(CMakePackageConfigHelpers)\n```\n\n### Creating a Package Configuration File\n\n使用`CMakePackageConfigHelpers`模块中的`configure_package_config_file`命令来生成`MathFunctionsConfig.cmake`文件，蓝本是`Config.cmake.in`,同时指定生成后的路径。\n\n```\nconfigure_package_config_file(${CMAKE_CURRENT_SOURCE_DIR}/Config.cmake.in\n  \"${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake\"\n  INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/MathFunctions\n)\n```\n\n通过`isntall`命令指定`xxxConfig.cmake`和`xxxConfigVersion.cmake`文件安装规则\n```\ninstall(FILES\n          \"${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake\"\n          \"${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake\"\n        DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/MathFunctions\n)\n```\n\n关于`Config.cmake.in`文件\n```\n@PACKAGE_INIT@\n\ninclude(\"${CMAKE_CURRENT_LIST_DIR}/MathFunctionsTargets.cmake\")\n\ncheck_required_components(MathFunctions)\n```\n\n`@PACKAGE_INIT@` 在配置的时候，会被替换和展开，展开后包含\n1. 以`PACKAGE_`为前缀的相对路径\n2. `set_and_check()` 和 `heck_required_components()`两个宏定义。\n\n\n`check_required_components` 针对所有的组件，给`<Package>_<Component>_FOUND`变量赋值， 找到为`TRUE`,找不到为`FALSE`。 同时给`<Package>_FOUND`变量赋值， 如果结果为`FALSE`,认为该package没有找到。\n\n`set_and_check`主要给对应的目录和文件路径赋值，如果引用的文件或路径没有找到，该宏执行失败。\n### Creating a Package Version File\n\n`CMakePackageConfigHelpers`模块，提供了`write_basic_package_version_file()`命令来生成`xxConfigVersion.cmake`文件。 当`find_package()`命令指定了版本号的时候， cmake 会读取该文件来获取版本号信息做匹配\n\n```\nset(version 3.4.1)\n\nset_property(TARGET MathFunctions PROPERTY VERSION ${version})\nset_property(TARGET MathFunctions PROPERTY SOVERSION 3)\nset_property(TARGET MathFunctions PROPERTY\n  INTERFACE_MathFunctions_MAJOR_VERSION 3)\nset_property(TARGET MathFunctions APPEND PROPERTY\n  COMPATIBLE_INTERFACE_STRING MathFunctions_MAJOR_VERSION\n)\n\n# generate the version file for the config file\nwrite_basic_package_version_file(\n  \"${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake\"\n  VERSION \"${version}\"\n  COMPATIBILITY AnyNewerVersion\n)\n```\n\n1. 设置target的版本号相关的变量\n2. 将版本号信息，写入`MathFunctionsConfigVersion.cmake`文件\n\n\n此时已经配置好如何生成`xxxConfig.cmake`和`xxxConfigVersion.cmake`文件.\n执行构建，安装\n```\nmkdir build \ncd build \ncmake ..\ncmake --build .\ncmake --install . --prefix `<prefix>`\n```\n\n观察输出, 对应的文件已经生成\n```\nMathFunctionsConfig.cmake\nMathFunctionsConfigVersion.cmake\nMathFunctionsTargets-noconfig.cmake\nMathFunctionsTargets.cmake\n```\n使用`find_package()`来使用生成config文件, 此时需要通过`CMAKE_PREFIX_PATH`来指定config文件的搜罗路径。\n\n```\ncmake_minimum_required(VERSION 3.15)\nproject(Downstream)\n\n# specify the C++ standard\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\n\nfind_package(MathFunctions 3.4.1 EXACT)\n\nadd_executable(myexe main.cc)\ntarget_link_libraries(myexe PRIVATE MathFunctions::MathFunctions)\n```\n\n注意：\n导出配置，不应该引用绝对路径，应当关联相对路径，这样，无论安装在哪里，都可以通过config文件正确索引到库。\n\n1. 不应当显示的依赖`CMAKE_INSTALL_PREFIX`\n\n```\ntarget_include_directories(tgt INTERFACE\n  # Wrong, not relocatable:\n  $<INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/include/TgtName>\n)\n\ntarget_include_directories(tgt INTERFACE\n  # Ok, relocatable:\n  $<INSTALL_INTERFACE:include/TgtName>\n)\n```\n\n2. 可以使用`$<INSTALL_PREFIX> generator expression`\n\n```\ntarget_include_directories(tgt INTERFACE\n  # Ok, relocatable:\n  $<INSTALL_INTERFACE:$<INSTALL_PREFIX>/include/TgtName>\n)\n```\n\n\n\n\n\n\n\n","source":"_posts/cmake/2022-10-24-cmake Importing and Exporting Guide.md","raw":"---\nlayout: post\ntitle: \"cmake Importing and Exporting Guide\"\ndate: 2022-10-24\ntag: cmake\n---\n\n参考：https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html \n\n# Importing\n\nIMPORTED targets 将cmake工程外部的库，可执行文件引入到当前的cmake工程中，被引入的内容会关联到一个cmake 中一个\n逻辑上的target。\n\n创建方式，调用`add_executable()`,`add_library()`命令创建target， 但是要添加`IMPORTED`参数。\n\n这个IMPORTED target不产生任何构建文件，因为他们引入的都是现成的库或者可执行文件。\n\n一旦IMPORTED target 被创建好了，就可以像工程中的其他target一样被引用了。 通过这种方式，就可以方便，灵活引用外部可执行文件和库了。\n\n## Importing Executables\n\n使用磁盘上的可执行文件。\n\n```\nadd_executable(myexe IMPORTED)\nset_property(TARGET myexe PROPERTY\n             IMPORTED_LOCATION \"../InstallMyExe/bin/myexe\")\nadd_custom_command(OUTPUT main.cc COMMAND myexe)\nadd_executable(mynewexe main.cc)\n```\n\n1. 创建一个IMPORTED target\n2. 设置target相关属性，这里指定其关联的可执行文件路径\n3. 添加了一个custom command， 用target myexe指定的可执行文件来生成文件`main.cc`\n4. 创建一个正常的可执行target, 使用上一步生成的`main.cc`作为源文件\n\n## Importing Libraries\n\n导入已经构建好的库作为一个target来使用。\n```\nadd_library(foo STATIC IMPORTED)\nset_property(TARGET foo PROPERTY\n             IMPORTED_LOCATION \"/path/to/libfoo.a\")\nadd_executable(myexe src1.c src2.c)\ntarget_link_libraries(myexe PRIVATE foo)\n```\n\n1. 创建一个IMPORTED target\n2. 设置target相关属性，这里指定其关联的静态库路径\n3. 创建一个正常的可执行target myexe，链接上面创建的target foo\n\n考虑到可能会有debug，release 等不同配置，引入具有不同配置的同一个库，可以使用下面的形式\n```\nfind_library(math_REL NAMES m)\nfind_library(math_DBG NAMES md)\nadd_library(math STATIC IMPORTED GLOBAL)\nset_target_properties(math PROPERTIES\n  IMPORTED_LOCATION \"${math_REL}\"\n  IMPORTED_LOCATION_DEBUG \"${math_DBG}\"\n  IMPORTED_CONFIGURATIONS \"RELEASE;DEBUG\"\n)\nadd_executable(myexe src1.c src2.c)\ntarget_link_libraries(myexe PRIVATE math)\n```\n# Exporting Targets\n> While IMPORTED targets on their own are useful, they still require that the project that imports them knows the locations of the target files on disk. The real power of IMPORTED targets is when the project providing the target files also provides a CMake file to help import them. A project can be setup to produce the necessary information so that it can easily be used by other CMake projects be it from a build directory, a local install or when packaged.\n\n1. IMPORTED targets 要求使用这些target的工程，知道相关文件在磁盘上的位置。\n2. 要想屏蔽这些细节，库的提供方，同时提供一个导入这个库的帮助文件 `xxxTargets.cmake`\n3. 要想生成的库，可以通过`find_package()`命令来索引使用的话，可以在cmake工程中配置，在构建工程的时候，同时生成对应的帮助文件\n    - `xxxTargets.cmake`\n    - `xxxConfig.cmake`\n    - `xxxConfigVersion.cmake`\n\n## `xxxTargets.cmake`\n\n```\ncmake_minimum_required(VERSION 3.15)\nproject(MathFunctions)\n\n# make cache variables for install destinations\ninclude(GNUInstallDirs)\n\n# specify the C++ standard\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\n\n# create library\nadd_library(MathFunctions STATIC MathFunctions.cxx)\n\n# add include directories\ntarget_include_directories(MathFunctions\n                           PUBLIC\n                           \"$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\"\n                           \"$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\"\n)\n\n# install the target and create export-set\ninstall(TARGETS MathFunctions\n        EXPORT MathFunctionsTargets\n        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n        RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n        INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n)\n\n# install header file\ninstall(FILES MathFunctions.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n\n# generate and install export file\ninstall(EXPORT MathFunctionsTargets\n        FILE MathFunctionsTargets.cmake\n        NAMESPACE MathFunctions::\n        DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/MathFunctions\n)\n# create IMPORTED target, set target property\nadd_library(MathFunctions::MathFunctions STATIC IMPORTED)\nset_target_properties(MathFunctions::MathFunctions PROPERTIES\n  INTERFACE_INCLUDE_DIRECTORIES \"${_IMPORT_PREFIX}/include\"\n)\n```\n\n1. 创建一个正常的静态库\n2. 设置静态库头文件搜索路径，分别指定构建时和安装后的路径\n3. 创建一个install命令，指定生成二进制文件的安装路径。其中`EXPORT MathFunctionsTargets`,指定了导出target文件对应的文件名字是`MathFunctionsTargets.cmake`\n4. 指定头文件如何安装\n5. 指定`MathFunctionsTargets.cmake`文件如何安装，`NAMESPACE MathFunctions::` 给导出的target添加前缀命名空间，一般带有命名空间的target，都是`IMPORTED target`\n6. 创建一个`IMPORTED target`,名字是`MathFunctions::MathFunctions`\n7. 设置`MathFunctions::MathFunctions`的属性，此处是头文件路径\n\n\n如何使用导出的target文件, 在`CMakeLists.txt`文件中\n```\n include(${INSTALL_PREFIX}/lib/cmake/MathFunctionTargets.cmake)\n add_executable(myexe src1.c src2.c )\n target_link_libraries(myexe PRIVATE MathFunctions::MathFunctions)\n```\n1. 首先包含`/MathFunctionTargets.cmake`文件\n2. 创建一个可执行目标myexe\n3. 链接MathFunctions::MathFunctions到myexe\n\n## 支持`find_package()`\n\n使用示例：\n\n```\nfind_package(Stats 2.6.4 REQUIRED)\ntarget_link_libraries(MathFunctions PUBLIC Stats::Types)\n```\n\nfind_package() 支持两种搜索模式\n- module mode， 针对非cmake构建的库，搜索`Find<PackageName>.cmake`文件\n- config mode， 针对cmake构建的库，相关文件为\n    - target相关： `<lowercasePackageName>-config.cmake`或者`<PackageName>Config.cmake`\n    - 版本相关： `<lowercasePackageName>-config-version.cmake` 或 `<PackageName>ConfigVersion.cmake`\n\n因此，cmake构建的库，想要支持`find_package()`的config模式，需要提供\n- `xxxConfig.cmake`\n- `xxConfigVersion.cmake`\n\n\n首先包含`CMakePackageConfigHelpers`模块\n```\ninclude(CMakePackageConfigHelpers)\n```\n\n### Creating a Package Configuration File\n\n使用`CMakePackageConfigHelpers`模块中的`configure_package_config_file`命令来生成`MathFunctionsConfig.cmake`文件，蓝本是`Config.cmake.in`,同时指定生成后的路径。\n\n```\nconfigure_package_config_file(${CMAKE_CURRENT_SOURCE_DIR}/Config.cmake.in\n  \"${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake\"\n  INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/MathFunctions\n)\n```\n\n通过`isntall`命令指定`xxxConfig.cmake`和`xxxConfigVersion.cmake`文件安装规则\n```\ninstall(FILES\n          \"${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake\"\n          \"${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake\"\n        DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/MathFunctions\n)\n```\n\n关于`Config.cmake.in`文件\n```\n@PACKAGE_INIT@\n\ninclude(\"${CMAKE_CURRENT_LIST_DIR}/MathFunctionsTargets.cmake\")\n\ncheck_required_components(MathFunctions)\n```\n\n`@PACKAGE_INIT@` 在配置的时候，会被替换和展开，展开后包含\n1. 以`PACKAGE_`为前缀的相对路径\n2. `set_and_check()` 和 `heck_required_components()`两个宏定义。\n\n\n`check_required_components` 针对所有的组件，给`<Package>_<Component>_FOUND`变量赋值， 找到为`TRUE`,找不到为`FALSE`。 同时给`<Package>_FOUND`变量赋值， 如果结果为`FALSE`,认为该package没有找到。\n\n`set_and_check`主要给对应的目录和文件路径赋值，如果引用的文件或路径没有找到，该宏执行失败。\n### Creating a Package Version File\n\n`CMakePackageConfigHelpers`模块，提供了`write_basic_package_version_file()`命令来生成`xxConfigVersion.cmake`文件。 当`find_package()`命令指定了版本号的时候， cmake 会读取该文件来获取版本号信息做匹配\n\n```\nset(version 3.4.1)\n\nset_property(TARGET MathFunctions PROPERTY VERSION ${version})\nset_property(TARGET MathFunctions PROPERTY SOVERSION 3)\nset_property(TARGET MathFunctions PROPERTY\n  INTERFACE_MathFunctions_MAJOR_VERSION 3)\nset_property(TARGET MathFunctions APPEND PROPERTY\n  COMPATIBLE_INTERFACE_STRING MathFunctions_MAJOR_VERSION\n)\n\n# generate the version file for the config file\nwrite_basic_package_version_file(\n  \"${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake\"\n  VERSION \"${version}\"\n  COMPATIBILITY AnyNewerVersion\n)\n```\n\n1. 设置target的版本号相关的变量\n2. 将版本号信息，写入`MathFunctionsConfigVersion.cmake`文件\n\n\n此时已经配置好如何生成`xxxConfig.cmake`和`xxxConfigVersion.cmake`文件.\n执行构建，安装\n```\nmkdir build \ncd build \ncmake ..\ncmake --build .\ncmake --install . --prefix `<prefix>`\n```\n\n观察输出, 对应的文件已经生成\n```\nMathFunctionsConfig.cmake\nMathFunctionsConfigVersion.cmake\nMathFunctionsTargets-noconfig.cmake\nMathFunctionsTargets.cmake\n```\n使用`find_package()`来使用生成config文件, 此时需要通过`CMAKE_PREFIX_PATH`来指定config文件的搜罗路径。\n\n```\ncmake_minimum_required(VERSION 3.15)\nproject(Downstream)\n\n# specify the C++ standard\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_STANDARD_REQUIRED True)\n\nfind_package(MathFunctions 3.4.1 EXACT)\n\nadd_executable(myexe main.cc)\ntarget_link_libraries(myexe PRIVATE MathFunctions::MathFunctions)\n```\n\n注意：\n导出配置，不应该引用绝对路径，应当关联相对路径，这样，无论安装在哪里，都可以通过config文件正确索引到库。\n\n1. 不应当显示的依赖`CMAKE_INSTALL_PREFIX`\n\n```\ntarget_include_directories(tgt INTERFACE\n  # Wrong, not relocatable:\n  $<INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/include/TgtName>\n)\n\ntarget_include_directories(tgt INTERFACE\n  # Ok, relocatable:\n  $<INSTALL_INTERFACE:include/TgtName>\n)\n```\n\n2. 可以使用`$<INSTALL_PREFIX> generator expression`\n\n```\ntarget_include_directories(tgt INTERFACE\n  # Ok, relocatable:\n  $<INSTALL_INTERFACE:$<INSTALL_PREFIX>/include/TgtName>\n)\n```\n\n\n\n\n\n\n\n","slug":"cmake/2022-10-24-cmake Importing and Exporting Guide","published":1,"updated":"2024-03-06T11:53:13.564Z","comments":1,"photos":[],"_id":"cltgopenb001bqywhex4bfz2a","content":"<p>参考：<a href=\"https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html\">https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html</a> </p>\n<h1 id=\"Importing\"><a href=\"#Importing\" class=\"headerlink\" title=\"Importing\"></a>Importing</h1><p>IMPORTED targets 将cmake工程外部的库，可执行文件引入到当前的cmake工程中，被引入的内容会关联到一个cmake 中一个<br>逻辑上的target。</p>\n<p>创建方式，调用<code>add_executable()</code>,<code>add_library()</code>命令创建target， 但是要添加<code>IMPORTED</code>参数。</p>\n<p>这个IMPORTED target不产生任何构建文件，因为他们引入的都是现成的库或者可执行文件。</p>\n<p>一旦IMPORTED target 被创建好了，就可以像工程中的其他target一样被引用了。 通过这种方式，就可以方便，灵活引用外部可执行文件和库了。</p>\n<h2 id=\"Importing-Executables\"><a href=\"#Importing-Executables\" class=\"headerlink\" title=\"Importing Executables\"></a>Importing Executables</h2><p>使用磁盘上的可执行文件。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">add_executable</span><span class=\"hljs-params\">(myexe IMPORTED)</span></span><br><span class=\"hljs-built_in\">set_property</span>(TARGET myexe PROPERTY<br>             IMPORTED_LOCATION <span class=\"hljs-string\">&quot;../InstallMyExe/bin/myexe&quot;</span>)<br><span class=\"hljs-function\"><span class=\"hljs-title\">add_custom_command</span><span class=\"hljs-params\">(OUTPUT main.cc COMMAND myexe)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">add_executable</span><span class=\"hljs-params\">(mynewexe main.cc)</span></span><br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>创建一个IMPORTED target</li>\n<li>设置target相关属性，这里指定其关联的可执行文件路径</li>\n<li>添加了一个custom command， 用target myexe指定的可执行文件来生成文件<code>main.cc</code></li>\n<li>创建一个正常的可执行target, 使用上一步生成的<code>main.cc</code>作为源文件</li>\n</ol>\n<h2 id=\"Importing-Libraries\"><a href=\"#Importing-Libraries\" class=\"headerlink\" title=\"Importing Libraries\"></a>Importing Libraries</h2><p>导入已经构建好的库作为一个target来使用。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">add_library</span><span class=\"hljs-params\">(foo STATIC IMPORTED)</span></span><br><span class=\"hljs-built_in\">set_property</span>(TARGET foo PROPERTY<br>             IMPORTED_LOCATION <span class=\"hljs-string\">&quot;/path/to/libfoo.a&quot;</span>)<br><span class=\"hljs-function\"><span class=\"hljs-title\">add_executable</span><span class=\"hljs-params\">(myexe src1.c src2.c)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">target_link_libraries</span><span class=\"hljs-params\">(myexe PRIVATE foo)</span></span><br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>创建一个IMPORTED target</li>\n<li>设置target相关属性，这里指定其关联的静态库路径</li>\n<li>创建一个正常的可执行target myexe，链接上面创建的target foo</li>\n</ol>\n<p>考虑到可能会有debug，release 等不同配置，引入具有不同配置的同一个库，可以使用下面的形式</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">find_library</span><span class=\"hljs-params\">(math_REL NAMES m)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">find_library</span><span class=\"hljs-params\">(math_DBG NAMES md)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">add_library</span><span class=\"hljs-params\">(math STATIC IMPORTED GLOBAL)</span></span><br><span class=\"hljs-built_in\">set_target_properties</span>(math PROPERTIES<br>  IMPORTED_LOCATION <span class=\"hljs-string\">&quot;$&#123;math_REL&#125;&quot;</span><br>  IMPORTED_LOCATION_DEBUG <span class=\"hljs-string\">&quot;$&#123;math_DBG&#125;&quot;</span><br>  IMPORTED_CONFIGURATIONS <span class=\"hljs-string\">&quot;RELEASE;DEBUG&quot;</span><br>)<br><span class=\"hljs-function\"><span class=\"hljs-title\">add_executable</span><span class=\"hljs-params\">(myexe src1.c src2.c)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">target_link_libraries</span><span class=\"hljs-params\">(myexe PRIVATE math)</span></span><br></code></pre></td></tr></table></figure>\n<h1 id=\"Exporting-Targets\"><a href=\"#Exporting-Targets\" class=\"headerlink\" title=\"Exporting Targets\"></a>Exporting Targets</h1><blockquote>\n<p>While IMPORTED targets on their own are useful, they still require that the project that imports them knows the locations of the target files on disk. The real power of IMPORTED targets is when the project providing the target files also provides a CMake file to help import them. A project can be setup to produce the necessary information so that it can easily be used by other CMake projects be it from a build directory, a local install or when packaged.</p>\n</blockquote>\n<ol>\n<li>IMPORTED targets 要求使用这些target的工程，知道相关文件在磁盘上的位置。</li>\n<li>要想屏蔽这些细节，库的提供方，同时提供一个导入这个库的帮助文件 <code>xxxTargets.cmake</code></li>\n<li>要想生成的库，可以通过<code>find_package()</code>命令来索引使用的话，可以在cmake工程中配置，在构建工程的时候，同时生成对应的帮助文件<ul>\n<li><code>xxxTargets.cmake</code></li>\n<li><code>xxxConfig.cmake</code></li>\n<li><code>xxxConfigVersion.cmake</code></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"xxxTargets-cmake\"><a href=\"#xxxTargets-cmake\" class=\"headerlink\" title=\"xxxTargets.cmake\"></a><code>xxxTargets.cmake</code></h2><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><span class=\"hljs-keyword\">project</span>(MathFunctions)<br><br><span class=\"hljs-comment\"># make cache variables for install destinations</span><br><span class=\"hljs-keyword\">include</span>(GNUInstallDirs)<br><br><span class=\"hljs-comment\"># specify the C++ standard</span><br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD <span class=\"hljs-number\">11</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class=\"hljs-keyword\">True</span>)<br><br><span class=\"hljs-comment\"># create library</span><br><span class=\"hljs-keyword\">add_library</span>(MathFunctions STATIC MathFunctions.cxx)<br><br><span class=\"hljs-comment\"># add include directories</span><br><span class=\"hljs-keyword\">target_include_directories</span>(MathFunctions<br>                           PUBLIC<br>                           <span class=\"hljs-string\">&quot;$&lt;BUILD_INTERFACE:$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&gt;&quot;</span><br>                           <span class=\"hljs-string\">&quot;$&lt;INSTALL_INTERFACE:$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;&gt;&quot;</span><br>)<br><br><span class=\"hljs-comment\"># install the target and create export-set</span><br><span class=\"hljs-keyword\">install</span>(TARGETS MathFunctions<br>        <span class=\"hljs-keyword\">EXPORT</span> MathFunctionsTargets<br>        LIBRARY DESTINATION <span class=\"hljs-variable\">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span><br>        ARCHIVE DESTINATION <span class=\"hljs-variable\">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span><br>        RUNTIME DESTINATION <span class=\"hljs-variable\">$&#123;CMAKE_INSTALL_BINDIR&#125;</span><br>        INCLUDES DESTINATION <span class=\"hljs-variable\">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span><br>)<br><br><span class=\"hljs-comment\"># install header file</span><br><span class=\"hljs-keyword\">install</span>(FILES MathFunctions.h DESTINATION <span class=\"hljs-variable\">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span>)<br><br><span class=\"hljs-comment\"># generate and install export file</span><br><span class=\"hljs-keyword\">install</span>(<span class=\"hljs-keyword\">EXPORT</span> MathFunctionsTargets<br>        <span class=\"hljs-keyword\">FILE</span> MathFunctionsTargets.cmake<br>        NAMESPACE MathFunctions::<br>        DESTINATION <span class=\"hljs-variable\">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>/cmake/MathFunctions<br>)<br><span class=\"hljs-comment\"># create IMPORTED target, set target property</span><br><span class=\"hljs-keyword\">add_library</span>(MathFunctions::MathFunctions STATIC IMPORTED)<br><span class=\"hljs-keyword\">set_target_properties</span>(MathFunctions::MathFunctions PROPERTIES<br>  INTERFACE_INCLUDE_DIRECTORIES <span class=\"hljs-string\">&quot;$&#123;_IMPORT_PREFIX&#125;/include&quot;</span><br>)<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>创建一个正常的静态库</li>\n<li>设置静态库头文件搜索路径，分别指定构建时和安装后的路径</li>\n<li>创建一个install命令，指定生成二进制文件的安装路径。其中<code>EXPORT MathFunctionsTargets</code>,指定了导出target文件对应的文件名字是<code>MathFunctionsTargets.cmake</code></li>\n<li>指定头文件如何安装</li>\n<li>指定<code>MathFunctionsTargets.cmake</code>文件如何安装，<code>NAMESPACE MathFunctions::</code> 给导出的target添加前缀命名空间，一般带有命名空间的target，都是<code>IMPORTED target</code></li>\n<li>创建一个<code>IMPORTED target</code>,名字是<code>MathFunctions::MathFunctions</code></li>\n<li>设置<code>MathFunctions::MathFunctions</code>的属性，此处是头文件路径</li>\n</ol>\n<p>如何使用导出的target文件, 在<code>CMakeLists.txt</code>文件中</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">include</span><span class=\"hljs-params\">($&#123;INSTALL_PREFIX&#125;/lib/cmake/MathFunctionTargets.cmake)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">add_executable</span><span class=\"hljs-params\">(myexe src1.c src2.c )</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">target_link_libraries</span><span class=\"hljs-params\">(myexe PRIVATE MathFunctions::MathFunctions)</span></span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>首先包含<code>/MathFunctionTargets.cmake</code>文件</li>\n<li>创建一个可执行目标myexe</li>\n<li>链接MathFunctions::MathFunctions到myexe</li>\n</ol>\n<h2 id=\"支持find-package\"><a href=\"#支持find-package\" class=\"headerlink\" title=\"支持find_package()\"></a>支持<code>find_package()</code></h2><p>使用示例：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">find_package</span><span class=\"hljs-params\">(Stats <span class=\"hljs-number\">2.6</span>.<span class=\"hljs-number\">4</span> REQUIRED)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">target_link_libraries</span><span class=\"hljs-params\">(MathFunctions PUBLIC Stats::Types)</span></span><br></code></pre></td></tr></table></figure>\n\n<p>find_package() 支持两种搜索模式</p>\n<ul>\n<li>module mode， 针对非cmake构建的库，搜索<code>Find&lt;PackageName&gt;.cmake</code>文件</li>\n<li>config mode， 针对cmake构建的库，相关文件为<ul>\n<li>target相关： <code>&lt;lowercasePackageName&gt;-config.cmake</code>或者<code>&lt;PackageName&gt;Config.cmake</code></li>\n<li>版本相关： <code>&lt;lowercasePackageName&gt;-config-version.cmake</code> 或 <code>&lt;PackageName&gt;ConfigVersion.cmake</code></li>\n</ul>\n</li>\n</ul>\n<p>因此，cmake构建的库，想要支持<code>find_package()</code>的config模式，需要提供</p>\n<ul>\n<li><code>xxxConfig.cmake</code></li>\n<li><code>xxConfigVersion.cmake</code></li>\n</ul>\n<p>首先包含<code>CMakePackageConfigHelpers</code>模块</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">include</span><span class=\"hljs-params\">(CMakePackageConfigHelpers)</span></span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Creating-a-Package-Configuration-File\"><a href=\"#Creating-a-Package-Configuration-File\" class=\"headerlink\" title=\"Creating a Package Configuration File\"></a>Creating a Package Configuration File</h3><p>使用<code>CMakePackageConfigHelpers</code>模块中的<code>configure_package_config_file</code>命令来生成<code>MathFunctionsConfig.cmake</code>文件，蓝本是<code>Config.cmake.in</code>,同时指定生成后的路径。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">configure_package_config_file(<span class=\"hljs-variable\">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/Config.cmake.in<br>  <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/MathFunctionsConfig.cmake&quot;</span><br>  INSTALL_DESTINATION <span class=\"hljs-variable\">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>/cmake/MathFunctions<br>)<br></code></pre></td></tr></table></figure>\n\n<p>通过<code>isntall</code>命令指定<code>xxxConfig.cmake</code>和<code>xxxConfigVersion.cmake</code>文件安装规则</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">install(FILES<br>          <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/MathFunctionsConfig.cmake&quot;</span><br>          <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/MathFunctionsConfigVersion.cmake&quot;</span><br>        DESTINATION <span class=\"hljs-variable\">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>/cmake/MathFunctions<br>)<br></code></pre></td></tr></table></figure>\n\n<p>关于<code>Config.cmake.in</code>文件</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">@PACKAGE_INIT@<br><br><span class=\"hljs-function\"><span class=\"hljs-title\">include</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/MathFunctionsTargets.cmake&quot;</span>)</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-title\">check_required_components</span><span class=\"hljs-params\">(MathFunctions)</span></span><br></code></pre></td></tr></table></figure>\n\n<p><code>@PACKAGE_INIT@</code> 在配置的时候，会被替换和展开，展开后包含</p>\n<ol>\n<li>以<code>PACKAGE_</code>为前缀的相对路径</li>\n<li><code>set_and_check()</code> 和 <code>heck_required_components()</code>两个宏定义。</li>\n</ol>\n<p><code>check_required_components</code> 针对所有的组件，给<code>&lt;Package&gt;_&lt;Component&gt;_FOUND</code>变量赋值， 找到为<code>TRUE</code>,找不到为<code>FALSE</code>。 同时给<code>&lt;Package&gt;_FOUND</code>变量赋值， 如果结果为<code>FALSE</code>,认为该package没有找到。</p>\n<p><code>set_and_check</code>主要给对应的目录和文件路径赋值，如果引用的文件或路径没有找到，该宏执行失败。</p>\n<h3 id=\"Creating-a-Package-Version-File\"><a href=\"#Creating-a-Package-Version-File\" class=\"headerlink\" title=\"Creating a Package Version File\"></a>Creating a Package Version File</h3><p><code>CMakePackageConfigHelpers</code>模块，提供了<code>write_basic_package_version_file()</code>命令来生成<code>xxConfigVersion.cmake</code>文件。 当<code>find_package()</code>命令指定了版本号的时候， cmake 会读取该文件来获取版本号信息做匹配</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">set(<span class=\"hljs-keyword\">version</span> <span class=\"hljs-number\">3.4</span>.<span class=\"hljs-number\">1</span>)<br><br>set_property(TARGET MathFunctions <span class=\"hljs-keyword\">PROPERTY</span><span class=\"hljs-title\"> </span><span class=\"hljs-keyword\">VERSION</span> $&#123;<span class=\"hljs-keyword\">version</span>&#125;)<br>set_property(TARGET MathFunctions <span class=\"hljs-keyword\">PROPERTY</span><span class=\"hljs-title\"> </span>SOVERSION <span class=\"hljs-number\">3</span>)<br>set_property(TARGET MathFunctions <span class=\"hljs-keyword\">PROPERTY</span><span class=\"hljs-title\"></span><br><span class=\"hljs-title\">  </span>INTERFACE_MathFunctions_MAJOR_VERSION <span class=\"hljs-number\">3</span>)<br>set_property(TARGET MathFunctions APPEND <span class=\"hljs-keyword\">PROPERTY</span><span class=\"hljs-title\"></span><br><span class=\"hljs-title\">  </span>COMPATIBLE_INTERFACE_STRING MathFunctions_MAJOR_VERSION<br>)<br><br><span class=\"hljs-comment\"># generate the version file for the config file</span><br>write_basic_package_version_file(<br>  <span class=\"hljs-string\">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MathFunctionsConfigVersion.cmake&quot;</span><br>  <span class=\"hljs-keyword\">VERSION</span> <span class=\"hljs-string\">&quot;$&#123;version&#125;&quot;</span><br>  COMPATIBILITY AnyNewerVersion<br>)<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>设置target的版本号相关的变量</li>\n<li>将版本号信息，写入<code>MathFunctionsConfigVersion.cmake</code>文件</li>\n</ol>\n<p>此时已经配置好如何生成<code>xxxConfig.cmake</code>和<code>xxxConfigVersion.cmake</code>文件.<br>执行构建，安装</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\">mkdir build <br><span class=\"hljs-keyword\">cd</span> build <br>cmake <span class=\"hljs-string\">..</span><br>cmake <span class=\"hljs-params\">--build</span> .<br>cmake <span class=\"hljs-params\">--install</span> . <span class=\"hljs-params\">--prefix</span> `&lt;prefix&gt;`<br></code></pre></td></tr></table></figure>\n\n<p>观察输出, 对应的文件已经生成</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">MathFunctionsConfig<span class=\"hljs-selector-class\">.cmake</span><br>MathFunctionsConfigVersion<span class=\"hljs-selector-class\">.cmake</span><br>MathFunctionsTargets-noconfig<span class=\"hljs-selector-class\">.cmake</span><br>MathFunctionsTargets.cmake<br></code></pre></td></tr></table></figure>\n<p>使用<code>find_package()</code>来使用生成config文件, 此时需要通过<code>CMAKE_PREFIX_PATH</code>来指定config文件的搜罗路径。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><span class=\"hljs-built_in\">project</span>(Downstream)<br><br># specify the C++ standard<br><span class=\"hljs-built_in\">set</span>(CMAKE_CXX_STANDARD <span class=\"hljs-number\">11</span>)<br><span class=\"hljs-built_in\">set</span>(CMAKE_CXX_STANDARD_REQUIRED True)<br><br><span class=\"hljs-built_in\">find_package</span>(MathFunctions <span class=\"hljs-number\">3.4</span>.<span class=\"hljs-number\">1</span> EXACT)<br><br><span class=\"hljs-built_in\">add_executable</span>(myexe main.cc)<br><span class=\"hljs-built_in\">target_link_libraries</span>(myexe PRIVATE MathFunctions::MathFunctions)<br></code></pre></td></tr></table></figure>\n\n<p>注意：<br>导出配置，不应该引用绝对路径，应当关联相对路径，这样，无论安装在哪里，都可以通过config文件正确索引到库。</p>\n<ol>\n<li>不应当显示的依赖<code>CMAKE_INSTALL_PREFIX</code></li>\n</ol>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\">target_include_directories(tgt <span class=\"hljs-variable constant_\">INTERFACE</span><br>  <span class=\"hljs-comment\"># Wrong, not relocatable:</span><br>  <span class=\"hljs-variable\">$&lt;</span><span class=\"hljs-variable constant_\">INSTALL_INTERFACE</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-variable\">$&#123;</span><span class=\"hljs-variable constant_\">CMAKE_INSTALL_PREFIX</span>&#125;/<span class=\"hljs-keyword\">include</span>/<span class=\"hljs-title class_\">TgtName</span>&gt;<br>)<br><br>target_include_directories(tgt <span class=\"hljs-variable constant_\">INTERFACE</span><br>  <span class=\"hljs-comment\"># Ok, relocatable:</span><br>  <span class=\"hljs-variable\">$&lt;</span><span class=\"hljs-variable constant_\">INSTALL_INTERFACE</span><span class=\"hljs-symbol\">:include/TgtName&gt;</span><br>)<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>可以使用<code>$&lt;INSTALL_PREFIX&gt; generator expression</code></li>\n</ol>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\">target_include_directories(tgt INTERFACE<br>  <span class=\"hljs-comment\"># Ok, relocatable:</span><br>  <span class=\"hljs-variable\">$&lt;</span><span class=\"hljs-symbol\">INSTALL_INTERFACE:</span><span class=\"hljs-variable\">$&lt;</span>INSTALL_PREFIX&gt;<span class=\"hljs-regexp\">/include/</span>TgtName&gt;<br>)<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n","excerpt":"","more":"<p>参考：<a href=\"https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html\">https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html</a> </p>\n<h1 id=\"Importing\"><a href=\"#Importing\" class=\"headerlink\" title=\"Importing\"></a>Importing</h1><p>IMPORTED targets 将cmake工程外部的库，可执行文件引入到当前的cmake工程中，被引入的内容会关联到一个cmake 中一个<br>逻辑上的target。</p>\n<p>创建方式，调用<code>add_executable()</code>,<code>add_library()</code>命令创建target， 但是要添加<code>IMPORTED</code>参数。</p>\n<p>这个IMPORTED target不产生任何构建文件，因为他们引入的都是现成的库或者可执行文件。</p>\n<p>一旦IMPORTED target 被创建好了，就可以像工程中的其他target一样被引用了。 通过这种方式，就可以方便，灵活引用外部可执行文件和库了。</p>\n<h2 id=\"Importing-Executables\"><a href=\"#Importing-Executables\" class=\"headerlink\" title=\"Importing Executables\"></a>Importing Executables</h2><p>使用磁盘上的可执行文件。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">add_executable</span><span class=\"hljs-params\">(myexe IMPORTED)</span></span><br><span class=\"hljs-built_in\">set_property</span>(TARGET myexe PROPERTY<br>             IMPORTED_LOCATION <span class=\"hljs-string\">&quot;../InstallMyExe/bin/myexe&quot;</span>)<br><span class=\"hljs-function\"><span class=\"hljs-title\">add_custom_command</span><span class=\"hljs-params\">(OUTPUT main.cc COMMAND myexe)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">add_executable</span><span class=\"hljs-params\">(mynewexe main.cc)</span></span><br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>创建一个IMPORTED target</li>\n<li>设置target相关属性，这里指定其关联的可执行文件路径</li>\n<li>添加了一个custom command， 用target myexe指定的可执行文件来生成文件<code>main.cc</code></li>\n<li>创建一个正常的可执行target, 使用上一步生成的<code>main.cc</code>作为源文件</li>\n</ol>\n<h2 id=\"Importing-Libraries\"><a href=\"#Importing-Libraries\" class=\"headerlink\" title=\"Importing Libraries\"></a>Importing Libraries</h2><p>导入已经构建好的库作为一个target来使用。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">add_library</span><span class=\"hljs-params\">(foo STATIC IMPORTED)</span></span><br><span class=\"hljs-built_in\">set_property</span>(TARGET foo PROPERTY<br>             IMPORTED_LOCATION <span class=\"hljs-string\">&quot;/path/to/libfoo.a&quot;</span>)<br><span class=\"hljs-function\"><span class=\"hljs-title\">add_executable</span><span class=\"hljs-params\">(myexe src1.c src2.c)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">target_link_libraries</span><span class=\"hljs-params\">(myexe PRIVATE foo)</span></span><br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>创建一个IMPORTED target</li>\n<li>设置target相关属性，这里指定其关联的静态库路径</li>\n<li>创建一个正常的可执行target myexe，链接上面创建的target foo</li>\n</ol>\n<p>考虑到可能会有debug，release 等不同配置，引入具有不同配置的同一个库，可以使用下面的形式</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">find_library</span><span class=\"hljs-params\">(math_REL NAMES m)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">find_library</span><span class=\"hljs-params\">(math_DBG NAMES md)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">add_library</span><span class=\"hljs-params\">(math STATIC IMPORTED GLOBAL)</span></span><br><span class=\"hljs-built_in\">set_target_properties</span>(math PROPERTIES<br>  IMPORTED_LOCATION <span class=\"hljs-string\">&quot;$&#123;math_REL&#125;&quot;</span><br>  IMPORTED_LOCATION_DEBUG <span class=\"hljs-string\">&quot;$&#123;math_DBG&#125;&quot;</span><br>  IMPORTED_CONFIGURATIONS <span class=\"hljs-string\">&quot;RELEASE;DEBUG&quot;</span><br>)<br><span class=\"hljs-function\"><span class=\"hljs-title\">add_executable</span><span class=\"hljs-params\">(myexe src1.c src2.c)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">target_link_libraries</span><span class=\"hljs-params\">(myexe PRIVATE math)</span></span><br></code></pre></td></tr></table></figure>\n<h1 id=\"Exporting-Targets\"><a href=\"#Exporting-Targets\" class=\"headerlink\" title=\"Exporting Targets\"></a>Exporting Targets</h1><blockquote>\n<p>While IMPORTED targets on their own are useful, they still require that the project that imports them knows the locations of the target files on disk. The real power of IMPORTED targets is when the project providing the target files also provides a CMake file to help import them. A project can be setup to produce the necessary information so that it can easily be used by other CMake projects be it from a build directory, a local install or when packaged.</p>\n</blockquote>\n<ol>\n<li>IMPORTED targets 要求使用这些target的工程，知道相关文件在磁盘上的位置。</li>\n<li>要想屏蔽这些细节，库的提供方，同时提供一个导入这个库的帮助文件 <code>xxxTargets.cmake</code></li>\n<li>要想生成的库，可以通过<code>find_package()</code>命令来索引使用的话，可以在cmake工程中配置，在构建工程的时候，同时生成对应的帮助文件<ul>\n<li><code>xxxTargets.cmake</code></li>\n<li><code>xxxConfig.cmake</code></li>\n<li><code>xxxConfigVersion.cmake</code></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"xxxTargets-cmake\"><a href=\"#xxxTargets-cmake\" class=\"headerlink\" title=\"xxxTargets.cmake\"></a><code>xxxTargets.cmake</code></h2><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><span class=\"hljs-keyword\">project</span>(MathFunctions)<br><br><span class=\"hljs-comment\"># make cache variables for install destinations</span><br><span class=\"hljs-keyword\">include</span>(GNUInstallDirs)<br><br><span class=\"hljs-comment\"># specify the C++ standard</span><br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD <span class=\"hljs-number\">11</span>)<br><span class=\"hljs-keyword\">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class=\"hljs-keyword\">True</span>)<br><br><span class=\"hljs-comment\"># create library</span><br><span class=\"hljs-keyword\">add_library</span>(MathFunctions STATIC MathFunctions.cxx)<br><br><span class=\"hljs-comment\"># add include directories</span><br><span class=\"hljs-keyword\">target_include_directories</span>(MathFunctions<br>                           PUBLIC<br>                           <span class=\"hljs-string\">&quot;$&lt;BUILD_INTERFACE:$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&gt;&quot;</span><br>                           <span class=\"hljs-string\">&quot;$&lt;INSTALL_INTERFACE:$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;&gt;&quot;</span><br>)<br><br><span class=\"hljs-comment\"># install the target and create export-set</span><br><span class=\"hljs-keyword\">install</span>(TARGETS MathFunctions<br>        <span class=\"hljs-keyword\">EXPORT</span> MathFunctionsTargets<br>        LIBRARY DESTINATION <span class=\"hljs-variable\">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span><br>        ARCHIVE DESTINATION <span class=\"hljs-variable\">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span><br>        RUNTIME DESTINATION <span class=\"hljs-variable\">$&#123;CMAKE_INSTALL_BINDIR&#125;</span><br>        INCLUDES DESTINATION <span class=\"hljs-variable\">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span><br>)<br><br><span class=\"hljs-comment\"># install header file</span><br><span class=\"hljs-keyword\">install</span>(FILES MathFunctions.h DESTINATION <span class=\"hljs-variable\">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span>)<br><br><span class=\"hljs-comment\"># generate and install export file</span><br><span class=\"hljs-keyword\">install</span>(<span class=\"hljs-keyword\">EXPORT</span> MathFunctionsTargets<br>        <span class=\"hljs-keyword\">FILE</span> MathFunctionsTargets.cmake<br>        NAMESPACE MathFunctions::<br>        DESTINATION <span class=\"hljs-variable\">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>/cmake/MathFunctions<br>)<br><span class=\"hljs-comment\"># create IMPORTED target, set target property</span><br><span class=\"hljs-keyword\">add_library</span>(MathFunctions::MathFunctions STATIC IMPORTED)<br><span class=\"hljs-keyword\">set_target_properties</span>(MathFunctions::MathFunctions PROPERTIES<br>  INTERFACE_INCLUDE_DIRECTORIES <span class=\"hljs-string\">&quot;$&#123;_IMPORT_PREFIX&#125;/include&quot;</span><br>)<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>创建一个正常的静态库</li>\n<li>设置静态库头文件搜索路径，分别指定构建时和安装后的路径</li>\n<li>创建一个install命令，指定生成二进制文件的安装路径。其中<code>EXPORT MathFunctionsTargets</code>,指定了导出target文件对应的文件名字是<code>MathFunctionsTargets.cmake</code></li>\n<li>指定头文件如何安装</li>\n<li>指定<code>MathFunctionsTargets.cmake</code>文件如何安装，<code>NAMESPACE MathFunctions::</code> 给导出的target添加前缀命名空间，一般带有命名空间的target，都是<code>IMPORTED target</code></li>\n<li>创建一个<code>IMPORTED target</code>,名字是<code>MathFunctions::MathFunctions</code></li>\n<li>设置<code>MathFunctions::MathFunctions</code>的属性，此处是头文件路径</li>\n</ol>\n<p>如何使用导出的target文件, 在<code>CMakeLists.txt</code>文件中</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">include</span><span class=\"hljs-params\">($&#123;INSTALL_PREFIX&#125;/lib/cmake/MathFunctionTargets.cmake)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">add_executable</span><span class=\"hljs-params\">(myexe src1.c src2.c )</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">target_link_libraries</span><span class=\"hljs-params\">(myexe PRIVATE MathFunctions::MathFunctions)</span></span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>首先包含<code>/MathFunctionTargets.cmake</code>文件</li>\n<li>创建一个可执行目标myexe</li>\n<li>链接MathFunctions::MathFunctions到myexe</li>\n</ol>\n<h2 id=\"支持find-package\"><a href=\"#支持find-package\" class=\"headerlink\" title=\"支持find_package()\"></a>支持<code>find_package()</code></h2><p>使用示例：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">find_package</span><span class=\"hljs-params\">(Stats <span class=\"hljs-number\">2.6</span>.<span class=\"hljs-number\">4</span> REQUIRED)</span></span><br><span class=\"hljs-function\"><span class=\"hljs-title\">target_link_libraries</span><span class=\"hljs-params\">(MathFunctions PUBLIC Stats::Types)</span></span><br></code></pre></td></tr></table></figure>\n\n<p>find_package() 支持两种搜索模式</p>\n<ul>\n<li>module mode， 针对非cmake构建的库，搜索<code>Find&lt;PackageName&gt;.cmake</code>文件</li>\n<li>config mode， 针对cmake构建的库，相关文件为<ul>\n<li>target相关： <code>&lt;lowercasePackageName&gt;-config.cmake</code>或者<code>&lt;PackageName&gt;Config.cmake</code></li>\n<li>版本相关： <code>&lt;lowercasePackageName&gt;-config-version.cmake</code> 或 <code>&lt;PackageName&gt;ConfigVersion.cmake</code></li>\n</ul>\n</li>\n</ul>\n<p>因此，cmake构建的库，想要支持<code>find_package()</code>的config模式，需要提供</p>\n<ul>\n<li><code>xxxConfig.cmake</code></li>\n<li><code>xxConfigVersion.cmake</code></li>\n</ul>\n<p>首先包含<code>CMakePackageConfigHelpers</code>模块</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">include</span><span class=\"hljs-params\">(CMakePackageConfigHelpers)</span></span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Creating-a-Package-Configuration-File\"><a href=\"#Creating-a-Package-Configuration-File\" class=\"headerlink\" title=\"Creating a Package Configuration File\"></a>Creating a Package Configuration File</h3><p>使用<code>CMakePackageConfigHelpers</code>模块中的<code>configure_package_config_file</code>命令来生成<code>MathFunctionsConfig.cmake</code>文件，蓝本是<code>Config.cmake.in</code>,同时指定生成后的路径。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">configure_package_config_file(<span class=\"hljs-variable\">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/Config.cmake.in<br>  <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/MathFunctionsConfig.cmake&quot;</span><br>  INSTALL_DESTINATION <span class=\"hljs-variable\">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>/cmake/MathFunctions<br>)<br></code></pre></td></tr></table></figure>\n\n<p>通过<code>isntall</code>命令指定<code>xxxConfig.cmake</code>和<code>xxxConfigVersion.cmake</code>文件安装规则</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">install(FILES<br>          <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/MathFunctionsConfig.cmake&quot;</span><br>          <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/MathFunctionsConfigVersion.cmake&quot;</span><br>        DESTINATION <span class=\"hljs-variable\">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>/cmake/MathFunctions<br>)<br></code></pre></td></tr></table></figure>\n\n<p>关于<code>Config.cmake.in</code>文件</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">@PACKAGE_INIT@<br><br><span class=\"hljs-function\"><span class=\"hljs-title\">include</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/MathFunctionsTargets.cmake&quot;</span>)</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-title\">check_required_components</span><span class=\"hljs-params\">(MathFunctions)</span></span><br></code></pre></td></tr></table></figure>\n\n<p><code>@PACKAGE_INIT@</code> 在配置的时候，会被替换和展开，展开后包含</p>\n<ol>\n<li>以<code>PACKAGE_</code>为前缀的相对路径</li>\n<li><code>set_and_check()</code> 和 <code>heck_required_components()</code>两个宏定义。</li>\n</ol>\n<p><code>check_required_components</code> 针对所有的组件，给<code>&lt;Package&gt;_&lt;Component&gt;_FOUND</code>变量赋值， 找到为<code>TRUE</code>,找不到为<code>FALSE</code>。 同时给<code>&lt;Package&gt;_FOUND</code>变量赋值， 如果结果为<code>FALSE</code>,认为该package没有找到。</p>\n<p><code>set_and_check</code>主要给对应的目录和文件路径赋值，如果引用的文件或路径没有找到，该宏执行失败。</p>\n<h3 id=\"Creating-a-Package-Version-File\"><a href=\"#Creating-a-Package-Version-File\" class=\"headerlink\" title=\"Creating a Package Version File\"></a>Creating a Package Version File</h3><p><code>CMakePackageConfigHelpers</code>模块，提供了<code>write_basic_package_version_file()</code>命令来生成<code>xxConfigVersion.cmake</code>文件。 当<code>find_package()</code>命令指定了版本号的时候， cmake 会读取该文件来获取版本号信息做匹配</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">set(<span class=\"hljs-keyword\">version</span> <span class=\"hljs-number\">3.4</span>.<span class=\"hljs-number\">1</span>)<br><br>set_property(TARGET MathFunctions <span class=\"hljs-keyword\">PROPERTY</span><span class=\"hljs-title\"> </span><span class=\"hljs-keyword\">VERSION</span> $&#123;<span class=\"hljs-keyword\">version</span>&#125;)<br>set_property(TARGET MathFunctions <span class=\"hljs-keyword\">PROPERTY</span><span class=\"hljs-title\"> </span>SOVERSION <span class=\"hljs-number\">3</span>)<br>set_property(TARGET MathFunctions <span class=\"hljs-keyword\">PROPERTY</span><span class=\"hljs-title\"></span><br><span class=\"hljs-title\">  </span>INTERFACE_MathFunctions_MAJOR_VERSION <span class=\"hljs-number\">3</span>)<br>set_property(TARGET MathFunctions APPEND <span class=\"hljs-keyword\">PROPERTY</span><span class=\"hljs-title\"></span><br><span class=\"hljs-title\">  </span>COMPATIBLE_INTERFACE_STRING MathFunctions_MAJOR_VERSION<br>)<br><br><span class=\"hljs-comment\"># generate the version file for the config file</span><br>write_basic_package_version_file(<br>  <span class=\"hljs-string\">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MathFunctionsConfigVersion.cmake&quot;</span><br>  <span class=\"hljs-keyword\">VERSION</span> <span class=\"hljs-string\">&quot;$&#123;version&#125;&quot;</span><br>  COMPATIBILITY AnyNewerVersion<br>)<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>设置target的版本号相关的变量</li>\n<li>将版本号信息，写入<code>MathFunctionsConfigVersion.cmake</code>文件</li>\n</ol>\n<p>此时已经配置好如何生成<code>xxxConfig.cmake</code>和<code>xxxConfigVersion.cmake</code>文件.<br>执行构建，安装</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\">mkdir build <br><span class=\"hljs-keyword\">cd</span> build <br>cmake <span class=\"hljs-string\">..</span><br>cmake <span class=\"hljs-params\">--build</span> .<br>cmake <span class=\"hljs-params\">--install</span> . <span class=\"hljs-params\">--prefix</span> `&lt;prefix&gt;`<br></code></pre></td></tr></table></figure>\n\n<p>观察输出, 对应的文件已经生成</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">MathFunctionsConfig<span class=\"hljs-selector-class\">.cmake</span><br>MathFunctionsConfigVersion<span class=\"hljs-selector-class\">.cmake</span><br>MathFunctionsTargets-noconfig<span class=\"hljs-selector-class\">.cmake</span><br>MathFunctionsTargets.cmake<br></code></pre></td></tr></table></figure>\n<p>使用<code>find_package()</code>来使用生成config文件, 此时需要通过<code>CMAKE_PREFIX_PATH</code>来指定config文件的搜罗路径。</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.15</span>)<br><span class=\"hljs-built_in\">project</span>(Downstream)<br><br># specify the C++ standard<br><span class=\"hljs-built_in\">set</span>(CMAKE_CXX_STANDARD <span class=\"hljs-number\">11</span>)<br><span class=\"hljs-built_in\">set</span>(CMAKE_CXX_STANDARD_REQUIRED True)<br><br><span class=\"hljs-built_in\">find_package</span>(MathFunctions <span class=\"hljs-number\">3.4</span>.<span class=\"hljs-number\">1</span> EXACT)<br><br><span class=\"hljs-built_in\">add_executable</span>(myexe main.cc)<br><span class=\"hljs-built_in\">target_link_libraries</span>(myexe PRIVATE MathFunctions::MathFunctions)<br></code></pre></td></tr></table></figure>\n\n<p>注意：<br>导出配置，不应该引用绝对路径，应当关联相对路径，这样，无论安装在哪里，都可以通过config文件正确索引到库。</p>\n<ol>\n<li>不应当显示的依赖<code>CMAKE_INSTALL_PREFIX</code></li>\n</ol>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\">target_include_directories(tgt <span class=\"hljs-variable constant_\">INTERFACE</span><br>  <span class=\"hljs-comment\"># Wrong, not relocatable:</span><br>  <span class=\"hljs-variable\">$&lt;</span><span class=\"hljs-variable constant_\">INSTALL_INTERFACE</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-variable\">$&#123;</span><span class=\"hljs-variable constant_\">CMAKE_INSTALL_PREFIX</span>&#125;/<span class=\"hljs-keyword\">include</span>/<span class=\"hljs-title class_\">TgtName</span>&gt;<br>)<br><br>target_include_directories(tgt <span class=\"hljs-variable constant_\">INTERFACE</span><br>  <span class=\"hljs-comment\"># Ok, relocatable:</span><br>  <span class=\"hljs-variable\">$&lt;</span><span class=\"hljs-variable constant_\">INSTALL_INTERFACE</span><span class=\"hljs-symbol\">:include/TgtName&gt;</span><br>)<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>可以使用<code>$&lt;INSTALL_PREFIX&gt; generator expression</code></li>\n</ol>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\">target_include_directories(tgt INTERFACE<br>  <span class=\"hljs-comment\"># Ok, relocatable:</span><br>  <span class=\"hljs-variable\">$&lt;</span><span class=\"hljs-symbol\">INSTALL_INTERFACE:</span><span class=\"hljs-variable\">$&lt;</span>INSTALL_PREFIX&gt;<span class=\"hljs-regexp\">/include/</span>TgtName&gt;<br>)<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n"},{"layout":"post","title":"MPEG-TS 格式分析","date":"2022-10-11T16:00:00.000Z","_content":"\n参考： \n[MPEG-TS 格式解析](https://blog.csdn.net/Kayson12345/article/details/81266587)\n\n[An introduction to MPEG-TS](https://tsduck.io/download/docs/mpegts-introduction.pdf)\n\n\n# 背景介绍\n\nMPEG-TS一种标准数据容器格式，传输与存储音视频、节目与系统信息协议数据，应用于数字广播系统，譬如DVB,ATSC与IPTV。传输流在MPEG-2第1部分系统中规定，正式称为ISO / IEC标准13818-1或ITU-T建议书[1]。\n\nMPEG2/DVB是一种多媒体传输、复用技术，在数字电视广播中可提供数百个节目频道。复用的含义是，可以同时传输多层节目。\n\n注意，DVB全称为Digital Video Broadcasting，包括不同的系统，如卫星数字电视广播系统，有线数字电视广播系统，地面开路数字电视广播系统，交互式数字电视广播系统以及数字电视加扰系统。DVB系统标准是一种全球数字电视技术的标准。如何定义广播中的比特流语法与句法，以实现在比特流中复用数字音频与视频，欧洲的DVB采用数字视频压缩MPEG-2标准，该标准是定义比特流的语法与句法的一个ISO/IEC标准，即13818-1标准。DVB系统的核心技术是采用MPEG-2技术进行视频、音频的编码，使用统一的MPEG-2传输流（TS流）。\n\nMPEG-2标准中，有两种不同的码流输出到信道，一种是节目码流（PS: Program Stream），适用于没有传输误差的场景；一种是传送流（TS：Transport Stream)，适用于有信道噪声的传输场景。节目流设计用于合理可靠的媒体，如光盘（如DVD），而传输流设计用于不太可靠的传输，即地面或卫星广播。此外，传输流可以携带多个节目。\n\nMPEG-2 system（编号13818-1）是MPEG-2标准的其中一部分，该部分描述了多个视频，音频和数据多种基本流（ES）合成传输流（TS）和节目流（PS）的方式。\n\n# TS 介绍\n\n一路TS比特流通常由连续的固定字节的TS包组成，所包含的内容有：\n\n- 一路或多路视频流（多个PES包组成，每个PES包的PID是一致的，一个PES包可能由若干个TS包组成）\n\n- 一路或多路音频流（通常为杜比的音频格式）\n\n- 一路或多路字幕\n\n- PSI表格信息（Program Specific Information，包括PAT与PMT表，即节目关联表与节目映射表）\n\n- PES: Packetized Elementary Stream，一路基本码流（如MEPG2视频流）会在编码器端被打包成PES流，由多个PES包组成，打包的过程中主要加入了PTS/DTS信息。\n\n\n\nPAT(Program Association Table)描述有多少路节目，每路节目的PMT（Program Map Table）表的PID是多少，PMT则描述了本节目有多少流，每一路流的类型与PID是多少，举个例子，你找个一个TS包，它的PID是0，说明它的负载内容是PAT信息，解析PAT信息，你发现节目1的PMT表的PID是0x10，接着，你在比特流中寻找一个PID为0x10的TS包，它的负载内容是节目1的PMT表信息，解析该PMT信息，你可以发现第一路流是MPEG2音频流，PID号0x21，第二路流是MPEG2视频流，PID号是0x22，第三路流是DVB字幕流，PID号是0x23，解析完毕，凡是比特流中PID号为0x22的TS包，所负载的内容为MPEG2视频流，把这些包一个一个找出来，把其中的有效码流一部分一部分的拼接起来，然后送给解码器去解码。\n\n注意，就一般的视频流而言，只要拼接成一个完整的PES包，就可以送出去给解码器，然后再继续拼接下一个PES包。\n\n什么是ES流，PES流，TS流？\n\n- ES流：有三种，图像数据流，音频数据流，以及其他编码数据流。\n\n- PES流：PES流是ES流经过PES打包器处理后形成的数据流，在这个过程中完成了将ES流分组、打包、加入包头信息等操作（对ES流的第一次打包）。PES流的基本单位是PES包。\n\n- TS流：由定长的TS包组成（188字节），而TS包是对PES包的一个重新封装（到这里，ES经过了两层的封装） 。应用于相对有错环境下的传输与存储（如DVB中），其基本单位是TS包，长度固定188字节。日本的DVB-S广播系统采用192个字节的TS包，美国采用204个字节的TS包，多加了16个字节的前向纠错校验码（FEC）。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655696635121665569663420.png)\nFig. 1. ES流打包成PES流\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655697239811665569723213.png)\nFig. 2. PES流打包成TS流\n\n什么是PSI表？\n\nPSI(Program Specific Info)，节目特定信息，该表格信息用来描述传送流的组成结构。PSI信息由四种类型的表组成，包括节目关联表（PAT），节目映射表（PMT），条件接收表（CAT），网络信息表（NIT）。PAT与PMT两张表帮助我们找到该传送流中的所有节目与流，PAT告诉我们，该TS流由哪些节目组成，每个节目的节目映射表PMT的PID是什么，而PMT告诉我们，该节目由哪些流组成，每一路流的类型与PID是什么。CAT与NIT暂时不考虑。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655698149521665569814410.png)\n\nFig. 3. PSI表\n\n# TS解封装的原理\n\nTS流的形成过程：\n\n1. 将原始音视频数据压缩之后，压缩结果组成一个基本码流（ES）。\n2. 对ES（基本码流）进行打包形成PES。\n3. 在PES包中加入时间戳信息(PTS/DTS)。\n4. 将PES包内容分配到一系列固定长度的传输包（TS Packet）中。\n5. 在传输包中加入定时信息(PCR)。\n6. 在传输包中加入节目专用信息(PSI) 。\n7. 连续输出传输包形成具有恒定比特率的MPEG-TS流。\n\nTS流的解析过程，可以说是生成的逆过程：\n\n1. 从复用的MPEG-TS流中解析出TS包；\n2. 从TS包中获取PAT及对应的PMT（PSI中的表格）；\n3. 从而获取特定节目的音视频PID；\n4. 通过PID筛选出特定音视频相关的TS包，并解析出PES；\n5. 从PES中读取到PTS/DTS，并从PES中解析出基本码流ES；\n6. 将ES交给解码器，获得压缩前的原始音视频数据\n\n# TS格式详解\n\n## 1. TS包格式\nTS包主要由两部分组成，一是4个字节的包头信息，二是有效载荷，另外中间有可能插入自适应调整字段。有效载荷包括节目专用信息，打包后的流数据，以及业务信息。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655700779571665570077901.png)\n\nFig. 4. TS包的组成结构\n\nTS的语法结构如下：\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655701129401665570112830.png)\n\nFig. 5. TS的语法结构\n\n主要字段解析：\nSync byte:同步字节，值为0x47；\n\nTransport error indicator:传输错误指示位，置1时，表示传送包中至少有一个不可纠正的错误位。\n\nPayload unit start indicator:负载单元起始指标位，表示TS包的有效净荷以PES/PSI包的第一个字节开始，举个例子，一个PES包可能由多个TS包构成，第一个TS包的负载单元起始指标位才会被置位。\n\nTransport priority:传输优先级，表明该包比同个PID的但未置位的TS包有更高的优先级。\n\nPID:该TS包的ID号，如果净荷是PAT包，则PID固定为0x00。\n\nTransport scrambling control:传输加扰控制位\n\nAdaption field control:自适应调整域控制位，置位则表明该TS包存在自适应调整字段。\n\nContinuity counter:连续计数器，随着具有相同PID的TS包的增加而增加，达到最大时恢复为0，如果两个连续相同PID的TS包具有相同的计数，则表明这两个包是一样的，只取一个解析即可。\n\nPayload:负载内容，可能为PAT/PMT/PES。data_byte为1B长\n度的数据，为负载字节。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655826274671665582627092.png)\n\nFig. 6. TS的语法结构代码示意\n\n## 2. PAT 格式\n\nPAT的语法结构如下：\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655846904131665584689570.png)\nFig. 7. PAT的语法结构示意\n\n主要的字段解析如下：\n\ntable_id: 标识一个TS PSI 分段的内容是节目关联分段，条件访问分段还是节目映射分段。对于PAT，置为0x00。\n\nsection_syntax_indicator: 对于PAT，置为0x01。\n\nsection_length: 分段长度字段，其值为从section_length（不包括在内）到CRC_32字段的字节数，其值不超过1021。\n\ntransport_stream_id: 区别与其他复用流的标识。\n\nversion_number: PAT的版本号，如果PAT有变，则版本号加1。\n\ncurrent_next_indicator:置0时，表明该传送的表分段不能使用，下一个表分段才有效。\n\nsection_number: 表明该TS包属于该PAT的第几个分段，分段号从0开始。\n\nlast_section_number: 表明最后一个分段号，同时表明该PAT的最大分段数目。一般，一个PAT表由一个TS包传送。\n\nprogram_number: 节目的编号。\n\nnetwork_PID: NIT表的PID值。\n\nprogram_map_PID: PMT表的PID值。\n\nCRC_32: CRC校验。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655849004091665584900226.png)\nFig. 8. PAT语法结构代码示意\n## 3. PMT 格式\n\nPMT的语法结构如下：\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655849504061665584950270.png)\nFig. 9. PMT语法结构\n\n主要的字段解析如下：\n\ntable_id: 标识一个TS PSI 分段的内容是节目关联分段，条件访问分段还是节目映射分段。对于PMT，置为0x02。\n\nsection_syntax_indicator: 对于PMT，置为0x01。\n\nsection_length: 分段长度字段，其值为从section_length（包括在内）到CRC_32字段的字节数，其值不超过1021。\n\nprogram_number: 表明一共有多少个节目。\n\nversion_number: PMT的版本号，如果字段中有关信息有变，则版本号以32为模加1。版本号是对一个节目的定义。\n\ncurrent_next_indicator:置0时，表明该传送的表分段不能使用，下一个表分段才有效。\n\nsection_number: 总为0x00。\n\nlast_section_number: 总为0x00。\n\nPCR_PID: 指示含有该节目的PCR字段的TS包的PID。\n\nprogram_info_length: 表明跟随其后的对节目信息描述的字节数，也就是第一个N loop descriptors的字节数。\n\nstream_type: 表明PES流的类型。譬如，0x01表明是MPEG-1视频，0X03表明是MPEG-1音频。\n\nelementary_PID: 表明该负载有该PES流的TS包的PID值。\n\nES_info_length: 表明跟随其后的描述相关节目元素的字节数，也就是第二个N loop descriptors的字节数。\n\nCRC_32: 在CEDARX代码中仅对DVB的场景下作校验。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655851034681665585103423.png)\n\nFig. 10. PMT的语法结构代码示意\n\n## 4.PES格式\n\nPES的语法如图10所示，它携带的主要信息包括流的ID，PES包的长度，PTS以及流的数据，也就是音视频与字幕数据。\n\n主要的字段解析如下：\n\npacket_start_code_prefix: 固定0x000001\n\nstream_id: 指定基本流的类型与编号\n\nPES_packet_length: 表明在该字段后面还有多少个字节。0表明PES包的长度未指示也未限定，对于当前的PES包而言。\n\nPES_scrambling_control: PES包的有效载荷的加扰方式。\n\nPES_priority: 多路复用器可以通过该位最优化基本流内的数据。\n\ndata_alignment_indicator:\n\ncopyright: PES包中的有效载荷确定具有版权的话，就置位。\n\norginal_or_copy: 置位时，表明PES包的有效载荷的内容是原始的，非复制的。\n\nPTS_DTS_flags: 2比特字节，表明PTS/DTC的存在情况。\n\nES_rate_flag: 置位，表明后面存在ES_rate字段。\n\nPES_header_data_length: 表明该PES包头中由任选字段与填充字节所占据的字节总数。任选字段譬如ES_rate。\n\nmarker_bit: 为1的比特位。\n\nPTS: 对于音频而言，如果该PES包中存在PTS字段，则有效负载中肯定有新的音频存取单元（access unit），该PTS对应于该音频存取单元。新的音频存取单元指的是一帧新的音频帧。对于视频而言，一般情况下，跟音频一样。\n\nDTS: 解码时间标志，当前CEDARX解码器未用到DTS。\n\nES_rate: 基本流速率，指定系统目标解码器接收PES包字节的速率。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655853343991665585333549.png)\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655858313871061665585632_.jpg)\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655858713891665585871171.png)\nFig. 11. PES的语法结构代码\n# 参考资料\n\n[1] ISO / IEC标准13818-1或ITU-T建议书 http://www.itu.int/rec/T-REC-H.222.0\n\n[2] 《数字电视业务信息及其编码》，方涛，国防工业出版社\n\n[3] https://wenku.baidu.com/view/87f5439c2f60ddccdb38a066.html?rec_flag=default\n\n[4] TS码流结构分析PPT，网络资料\n\n————————————————\n\n版权声明：本文为CSDN博主「Kayson12345」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/Kayson12345/article/details/81266587\n\n\n\n\n\n\n# 个人理解\n\n从TS流中获取PAT，解析PAT得到节目列表，每个节目列表对应一个PMT， 从PMT中得该节目对应的音视频PID， 从TS流根据PID滤出音视频TS包，将TS包还原为PES包，进而还原为ES流（h264, aac）送给解码器解码。\n\n结合[An introduction to MPEG-TS](https://tsduck.io/download/docs/mpegts-introduction.pdf)看起来更易于理解。\n\n# 分析工具\n[easyice ](https://easyice.cn/archives/85)","source":"_posts/hls/2022-10-12-MPEG-TS 格式分析.md","raw":"---\nlayout: post\ntitle: \"MPEG-TS 格式分析\"\ndate: 2022-10-12\ntag: hls\n---\n\n参考： \n[MPEG-TS 格式解析](https://blog.csdn.net/Kayson12345/article/details/81266587)\n\n[An introduction to MPEG-TS](https://tsduck.io/download/docs/mpegts-introduction.pdf)\n\n\n# 背景介绍\n\nMPEG-TS一种标准数据容器格式，传输与存储音视频、节目与系统信息协议数据，应用于数字广播系统，譬如DVB,ATSC与IPTV。传输流在MPEG-2第1部分系统中规定，正式称为ISO / IEC标准13818-1或ITU-T建议书[1]。\n\nMPEG2/DVB是一种多媒体传输、复用技术，在数字电视广播中可提供数百个节目频道。复用的含义是，可以同时传输多层节目。\n\n注意，DVB全称为Digital Video Broadcasting，包括不同的系统，如卫星数字电视广播系统，有线数字电视广播系统，地面开路数字电视广播系统，交互式数字电视广播系统以及数字电视加扰系统。DVB系统标准是一种全球数字电视技术的标准。如何定义广播中的比特流语法与句法，以实现在比特流中复用数字音频与视频，欧洲的DVB采用数字视频压缩MPEG-2标准，该标准是定义比特流的语法与句法的一个ISO/IEC标准，即13818-1标准。DVB系统的核心技术是采用MPEG-2技术进行视频、音频的编码，使用统一的MPEG-2传输流（TS流）。\n\nMPEG-2标准中，有两种不同的码流输出到信道，一种是节目码流（PS: Program Stream），适用于没有传输误差的场景；一种是传送流（TS：Transport Stream)，适用于有信道噪声的传输场景。节目流设计用于合理可靠的媒体，如光盘（如DVD），而传输流设计用于不太可靠的传输，即地面或卫星广播。此外，传输流可以携带多个节目。\n\nMPEG-2 system（编号13818-1）是MPEG-2标准的其中一部分，该部分描述了多个视频，音频和数据多种基本流（ES）合成传输流（TS）和节目流（PS）的方式。\n\n# TS 介绍\n\n一路TS比特流通常由连续的固定字节的TS包组成，所包含的内容有：\n\n- 一路或多路视频流（多个PES包组成，每个PES包的PID是一致的，一个PES包可能由若干个TS包组成）\n\n- 一路或多路音频流（通常为杜比的音频格式）\n\n- 一路或多路字幕\n\n- PSI表格信息（Program Specific Information，包括PAT与PMT表，即节目关联表与节目映射表）\n\n- PES: Packetized Elementary Stream，一路基本码流（如MEPG2视频流）会在编码器端被打包成PES流，由多个PES包组成，打包的过程中主要加入了PTS/DTS信息。\n\n\n\nPAT(Program Association Table)描述有多少路节目，每路节目的PMT（Program Map Table）表的PID是多少，PMT则描述了本节目有多少流，每一路流的类型与PID是多少，举个例子，你找个一个TS包，它的PID是0，说明它的负载内容是PAT信息，解析PAT信息，你发现节目1的PMT表的PID是0x10，接着，你在比特流中寻找一个PID为0x10的TS包，它的负载内容是节目1的PMT表信息，解析该PMT信息，你可以发现第一路流是MPEG2音频流，PID号0x21，第二路流是MPEG2视频流，PID号是0x22，第三路流是DVB字幕流，PID号是0x23，解析完毕，凡是比特流中PID号为0x22的TS包，所负载的内容为MPEG2视频流，把这些包一个一个找出来，把其中的有效码流一部分一部分的拼接起来，然后送给解码器去解码。\n\n注意，就一般的视频流而言，只要拼接成一个完整的PES包，就可以送出去给解码器，然后再继续拼接下一个PES包。\n\n什么是ES流，PES流，TS流？\n\n- ES流：有三种，图像数据流，音频数据流，以及其他编码数据流。\n\n- PES流：PES流是ES流经过PES打包器处理后形成的数据流，在这个过程中完成了将ES流分组、打包、加入包头信息等操作（对ES流的第一次打包）。PES流的基本单位是PES包。\n\n- TS流：由定长的TS包组成（188字节），而TS包是对PES包的一个重新封装（到这里，ES经过了两层的封装） 。应用于相对有错环境下的传输与存储（如DVB中），其基本单位是TS包，长度固定188字节。日本的DVB-S广播系统采用192个字节的TS包，美国采用204个字节的TS包，多加了16个字节的前向纠错校验码（FEC）。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655696635121665569663420.png)\nFig. 1. ES流打包成PES流\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655697239811665569723213.png)\nFig. 2. PES流打包成TS流\n\n什么是PSI表？\n\nPSI(Program Specific Info)，节目特定信息，该表格信息用来描述传送流的组成结构。PSI信息由四种类型的表组成，包括节目关联表（PAT），节目映射表（PMT），条件接收表（CAT），网络信息表（NIT）。PAT与PMT两张表帮助我们找到该传送流中的所有节目与流，PAT告诉我们，该TS流由哪些节目组成，每个节目的节目映射表PMT的PID是什么，而PMT告诉我们，该节目由哪些流组成，每一路流的类型与PID是什么。CAT与NIT暂时不考虑。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655698149521665569814410.png)\n\nFig. 3. PSI表\n\n# TS解封装的原理\n\nTS流的形成过程：\n\n1. 将原始音视频数据压缩之后，压缩结果组成一个基本码流（ES）。\n2. 对ES（基本码流）进行打包形成PES。\n3. 在PES包中加入时间戳信息(PTS/DTS)。\n4. 将PES包内容分配到一系列固定长度的传输包（TS Packet）中。\n5. 在传输包中加入定时信息(PCR)。\n6. 在传输包中加入节目专用信息(PSI) 。\n7. 连续输出传输包形成具有恒定比特率的MPEG-TS流。\n\nTS流的解析过程，可以说是生成的逆过程：\n\n1. 从复用的MPEG-TS流中解析出TS包；\n2. 从TS包中获取PAT及对应的PMT（PSI中的表格）；\n3. 从而获取特定节目的音视频PID；\n4. 通过PID筛选出特定音视频相关的TS包，并解析出PES；\n5. 从PES中读取到PTS/DTS，并从PES中解析出基本码流ES；\n6. 将ES交给解码器，获得压缩前的原始音视频数据\n\n# TS格式详解\n\n## 1. TS包格式\nTS包主要由两部分组成，一是4个字节的包头信息，二是有效载荷，另外中间有可能插入自适应调整字段。有效载荷包括节目专用信息，打包后的流数据，以及业务信息。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655700779571665570077901.png)\n\nFig. 4. TS包的组成结构\n\nTS的语法结构如下：\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655701129401665570112830.png)\n\nFig. 5. TS的语法结构\n\n主要字段解析：\nSync byte:同步字节，值为0x47；\n\nTransport error indicator:传输错误指示位，置1时，表示传送包中至少有一个不可纠正的错误位。\n\nPayload unit start indicator:负载单元起始指标位，表示TS包的有效净荷以PES/PSI包的第一个字节开始，举个例子，一个PES包可能由多个TS包构成，第一个TS包的负载单元起始指标位才会被置位。\n\nTransport priority:传输优先级，表明该包比同个PID的但未置位的TS包有更高的优先级。\n\nPID:该TS包的ID号，如果净荷是PAT包，则PID固定为0x00。\n\nTransport scrambling control:传输加扰控制位\n\nAdaption field control:自适应调整域控制位，置位则表明该TS包存在自适应调整字段。\n\nContinuity counter:连续计数器，随着具有相同PID的TS包的增加而增加，达到最大时恢复为0，如果两个连续相同PID的TS包具有相同的计数，则表明这两个包是一样的，只取一个解析即可。\n\nPayload:负载内容，可能为PAT/PMT/PES。data_byte为1B长\n度的数据，为负载字节。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655826274671665582627092.png)\n\nFig. 6. TS的语法结构代码示意\n\n## 2. PAT 格式\n\nPAT的语法结构如下：\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655846904131665584689570.png)\nFig. 7. PAT的语法结构示意\n\n主要的字段解析如下：\n\ntable_id: 标识一个TS PSI 分段的内容是节目关联分段，条件访问分段还是节目映射分段。对于PAT，置为0x00。\n\nsection_syntax_indicator: 对于PAT，置为0x01。\n\nsection_length: 分段长度字段，其值为从section_length（不包括在内）到CRC_32字段的字节数，其值不超过1021。\n\ntransport_stream_id: 区别与其他复用流的标识。\n\nversion_number: PAT的版本号，如果PAT有变，则版本号加1。\n\ncurrent_next_indicator:置0时，表明该传送的表分段不能使用，下一个表分段才有效。\n\nsection_number: 表明该TS包属于该PAT的第几个分段，分段号从0开始。\n\nlast_section_number: 表明最后一个分段号，同时表明该PAT的最大分段数目。一般，一个PAT表由一个TS包传送。\n\nprogram_number: 节目的编号。\n\nnetwork_PID: NIT表的PID值。\n\nprogram_map_PID: PMT表的PID值。\n\nCRC_32: CRC校验。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655849004091665584900226.png)\nFig. 8. PAT语法结构代码示意\n## 3. PMT 格式\n\nPMT的语法结构如下：\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655849504061665584950270.png)\nFig. 9. PMT语法结构\n\n主要的字段解析如下：\n\ntable_id: 标识一个TS PSI 分段的内容是节目关联分段，条件访问分段还是节目映射分段。对于PMT，置为0x02。\n\nsection_syntax_indicator: 对于PMT，置为0x01。\n\nsection_length: 分段长度字段，其值为从section_length（包括在内）到CRC_32字段的字节数，其值不超过1021。\n\nprogram_number: 表明一共有多少个节目。\n\nversion_number: PMT的版本号，如果字段中有关信息有变，则版本号以32为模加1。版本号是对一个节目的定义。\n\ncurrent_next_indicator:置0时，表明该传送的表分段不能使用，下一个表分段才有效。\n\nsection_number: 总为0x00。\n\nlast_section_number: 总为0x00。\n\nPCR_PID: 指示含有该节目的PCR字段的TS包的PID。\n\nprogram_info_length: 表明跟随其后的对节目信息描述的字节数，也就是第一个N loop descriptors的字节数。\n\nstream_type: 表明PES流的类型。譬如，0x01表明是MPEG-1视频，0X03表明是MPEG-1音频。\n\nelementary_PID: 表明该负载有该PES流的TS包的PID值。\n\nES_info_length: 表明跟随其后的描述相关节目元素的字节数，也就是第二个N loop descriptors的字节数。\n\nCRC_32: 在CEDARX代码中仅对DVB的场景下作校验。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655851034681665585103423.png)\n\nFig. 10. PMT的语法结构代码示意\n\n## 4.PES格式\n\nPES的语法如图10所示，它携带的主要信息包括流的ID，PES包的长度，PTS以及流的数据，也就是音视频与字幕数据。\n\n主要的字段解析如下：\n\npacket_start_code_prefix: 固定0x000001\n\nstream_id: 指定基本流的类型与编号\n\nPES_packet_length: 表明在该字段后面还有多少个字节。0表明PES包的长度未指示也未限定，对于当前的PES包而言。\n\nPES_scrambling_control: PES包的有效载荷的加扰方式。\n\nPES_priority: 多路复用器可以通过该位最优化基本流内的数据。\n\ndata_alignment_indicator:\n\ncopyright: PES包中的有效载荷确定具有版权的话，就置位。\n\norginal_or_copy: 置位时，表明PES包的有效载荷的内容是原始的，非复制的。\n\nPTS_DTS_flags: 2比特字节，表明PTS/DTC的存在情况。\n\nES_rate_flag: 置位，表明后面存在ES_rate字段。\n\nPES_header_data_length: 表明该PES包头中由任选字段与填充字节所占据的字节总数。任选字段譬如ES_rate。\n\nmarker_bit: 为1的比特位。\n\nPTS: 对于音频而言，如果该PES包中存在PTS字段，则有效负载中肯定有新的音频存取单元（access unit），该PTS对应于该音频存取单元。新的音频存取单元指的是一帧新的音频帧。对于视频而言，一般情况下，跟音频一样。\n\nDTS: 解码时间标志，当前CEDARX解码器未用到DTS。\n\nES_rate: 基本流速率，指定系统目标解码器接收PES包字节的速率。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655853343991665585333549.png)\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655858313871061665585632_.jpg)\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655858713891665585871171.png)\nFig. 11. PES的语法结构代码\n# 参考资料\n\n[1] ISO / IEC标准13818-1或ITU-T建议书 http://www.itu.int/rec/T-REC-H.222.0\n\n[2] 《数字电视业务信息及其编码》，方涛，国防工业出版社\n\n[3] https://wenku.baidu.com/view/87f5439c2f60ddccdb38a066.html?rec_flag=default\n\n[4] TS码流结构分析PPT，网络资料\n\n————————————————\n\n版权声明：本文为CSDN博主「Kayson12345」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/Kayson12345/article/details/81266587\n\n\n\n\n\n\n# 个人理解\n\n从TS流中获取PAT，解析PAT得到节目列表，每个节目列表对应一个PMT， 从PMT中得该节目对应的音视频PID， 从TS流根据PID滤出音视频TS包，将TS包还原为PES包，进而还原为ES流（h264, aac）送给解码器解码。\n\n结合[An introduction to MPEG-TS](https://tsduck.io/download/docs/mpegts-introduction.pdf)看起来更易于理解。\n\n# 分析工具\n[easyice ](https://easyice.cn/archives/85)","slug":"hls/2022-10-12-MPEG-TS 格式分析","published":1,"updated":"2024-03-06T11:53:13.566Z","comments":1,"photos":[],"_id":"cltgopenb001dqywh53y4f3ml","content":"<p>参考：<br><a href=\"https://blog.csdn.net/Kayson12345/article/details/81266587\">MPEG-TS 格式解析</a></p>\n<p><a href=\"https://tsduck.io/download/docs/mpegts-introduction.pdf\">An introduction to MPEG-TS</a></p>\n<h1 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h1><p>MPEG-TS一种标准数据容器格式，传输与存储音视频、节目与系统信息协议数据，应用于数字广播系统，譬如DVB,ATSC与IPTV。传输流在MPEG-2第1部分系统中规定，正式称为ISO &#x2F; IEC标准13818-1或ITU-T建议书[1]。</p>\n<p>MPEG2&#x2F;DVB是一种多媒体传输、复用技术，在数字电视广播中可提供数百个节目频道。复用的含义是，可以同时传输多层节目。</p>\n<p>注意，DVB全称为Digital Video Broadcasting，包括不同的系统，如卫星数字电视广播系统，有线数字电视广播系统，地面开路数字电视广播系统，交互式数字电视广播系统以及数字电视加扰系统。DVB系统标准是一种全球数字电视技术的标准。如何定义广播中的比特流语法与句法，以实现在比特流中复用数字音频与视频，欧洲的DVB采用数字视频压缩MPEG-2标准，该标准是定义比特流的语法与句法的一个ISO&#x2F;IEC标准，即13818-1标准。DVB系统的核心技术是采用MPEG-2技术进行视频、音频的编码，使用统一的MPEG-2传输流（TS流）。</p>\n<p>MPEG-2标准中，有两种不同的码流输出到信道，一种是节目码流（PS: Program Stream），适用于没有传输误差的场景；一种是传送流（TS：Transport Stream)，适用于有信道噪声的传输场景。节目流设计用于合理可靠的媒体，如光盘（如DVD），而传输流设计用于不太可靠的传输，即地面或卫星广播。此外，传输流可以携带多个节目。</p>\n<p>MPEG-2 system（编号13818-1）是MPEG-2标准的其中一部分，该部分描述了多个视频，音频和数据多种基本流（ES）合成传输流（TS）和节目流（PS）的方式。</p>\n<h1 id=\"TS-介绍\"><a href=\"#TS-介绍\" class=\"headerlink\" title=\"TS 介绍\"></a>TS 介绍</h1><p>一路TS比特流通常由连续的固定字节的TS包组成，所包含的内容有：</p>\n<ul>\n<li><p>一路或多路视频流（多个PES包组成，每个PES包的PID是一致的，一个PES包可能由若干个TS包组成）</p>\n</li>\n<li><p>一路或多路音频流（通常为杜比的音频格式）</p>\n</li>\n<li><p>一路或多路字幕</p>\n</li>\n<li><p>PSI表格信息（Program Specific Information，包括PAT与PMT表，即节目关联表与节目映射表）</p>\n</li>\n<li><p>PES: Packetized Elementary Stream，一路基本码流（如MEPG2视频流）会在编码器端被打包成PES流，由多个PES包组成，打包的过程中主要加入了PTS&#x2F;DTS信息。</p>\n</li>\n</ul>\n<p>PAT(Program Association Table)描述有多少路节目，每路节目的PMT（Program Map Table）表的PID是多少，PMT则描述了本节目有多少流，每一路流的类型与PID是多少，举个例子，你找个一个TS包，它的PID是0，说明它的负载内容是PAT信息，解析PAT信息，你发现节目1的PMT表的PID是0x10，接着，你在比特流中寻找一个PID为0x10的TS包，它的负载内容是节目1的PMT表信息，解析该PMT信息，你可以发现第一路流是MPEG2音频流，PID号0x21，第二路流是MPEG2视频流，PID号是0x22，第三路流是DVB字幕流，PID号是0x23，解析完毕，凡是比特流中PID号为0x22的TS包，所负载的内容为MPEG2视频流，把这些包一个一个找出来，把其中的有效码流一部分一部分的拼接起来，然后送给解码器去解码。</p>\n<p>注意，就一般的视频流而言，只要拼接成一个完整的PES包，就可以送出去给解码器，然后再继续拼接下一个PES包。</p>\n<p>什么是ES流，PES流，TS流？</p>\n<ul>\n<li><p>ES流：有三种，图像数据流，音频数据流，以及其他编码数据流。</p>\n</li>\n<li><p>PES流：PES流是ES流经过PES打包器处理后形成的数据流，在这个过程中完成了将ES流分组、打包、加入包头信息等操作（对ES流的第一次打包）。PES流的基本单位是PES包。</p>\n</li>\n<li><p>TS流：由定长的TS包组成（188字节），而TS包是对PES包的一个重新封装（到这里，ES经过了两层的封装） 。应用于相对有错环境下的传输与存储（如DVB中），其基本单位是TS包，长度固定188字节。日本的DVB-S广播系统采用192个字节的TS包，美国采用204个字节的TS包，多加了16个字节的前向纠错校验码（FEC）。</p>\n</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655696635121665569663420.png\"><br>Fig. 1. ES流打包成PES流<br><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655697239811665569723213.png\"><br>Fig. 2. PES流打包成TS流</p>\n<p>什么是PSI表？</p>\n<p>PSI(Program Specific Info)，节目特定信息，该表格信息用来描述传送流的组成结构。PSI信息由四种类型的表组成，包括节目关联表（PAT），节目映射表（PMT），条件接收表（CAT），网络信息表（NIT）。PAT与PMT两张表帮助我们找到该传送流中的所有节目与流，PAT告诉我们，该TS流由哪些节目组成，每个节目的节目映射表PMT的PID是什么，而PMT告诉我们，该节目由哪些流组成，每一路流的类型与PID是什么。CAT与NIT暂时不考虑。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655698149521665569814410.png\"></p>\n<p>Fig. 3. PSI表</p>\n<h1 id=\"TS解封装的原理\"><a href=\"#TS解封装的原理\" class=\"headerlink\" title=\"TS解封装的原理\"></a>TS解封装的原理</h1><p>TS流的形成过程：</p>\n<ol>\n<li>将原始音视频数据压缩之后，压缩结果组成一个基本码流（ES）。</li>\n<li>对ES（基本码流）进行打包形成PES。</li>\n<li>在PES包中加入时间戳信息(PTS&#x2F;DTS)。</li>\n<li>将PES包内容分配到一系列固定长度的传输包（TS Packet）中。</li>\n<li>在传输包中加入定时信息(PCR)。</li>\n<li>在传输包中加入节目专用信息(PSI) 。</li>\n<li>连续输出传输包形成具有恒定比特率的MPEG-TS流。</li>\n</ol>\n<p>TS流的解析过程，可以说是生成的逆过程：</p>\n<ol>\n<li>从复用的MPEG-TS流中解析出TS包；</li>\n<li>从TS包中获取PAT及对应的PMT（PSI中的表格）；</li>\n<li>从而获取特定节目的音视频PID；</li>\n<li>通过PID筛选出特定音视频相关的TS包，并解析出PES；</li>\n<li>从PES中读取到PTS&#x2F;DTS，并从PES中解析出基本码流ES；</li>\n<li>将ES交给解码器，获得压缩前的原始音视频数据</li>\n</ol>\n<h1 id=\"TS格式详解\"><a href=\"#TS格式详解\" class=\"headerlink\" title=\"TS格式详解\"></a>TS格式详解</h1><h2 id=\"1-TS包格式\"><a href=\"#1-TS包格式\" class=\"headerlink\" title=\"1. TS包格式\"></a>1. TS包格式</h2><p>TS包主要由两部分组成，一是4个字节的包头信息，二是有效载荷，另外中间有可能插入自适应调整字段。有效载荷包括节目专用信息，打包后的流数据，以及业务信息。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655700779571665570077901.png\"></p>\n<p>Fig. 4. TS包的组成结构</p>\n<p>TS的语法结构如下：</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655701129401665570112830.png\"></p>\n<p>Fig. 5. TS的语法结构</p>\n<p>主要字段解析：<br>Sync byte:同步字节，值为0x47；</p>\n<p>Transport error indicator:传输错误指示位，置1时，表示传送包中至少有一个不可纠正的错误位。</p>\n<p>Payload unit start indicator:负载单元起始指标位，表示TS包的有效净荷以PES&#x2F;PSI包的第一个字节开始，举个例子，一个PES包可能由多个TS包构成，第一个TS包的负载单元起始指标位才会被置位。</p>\n<p>Transport priority:传输优先级，表明该包比同个PID的但未置位的TS包有更高的优先级。</p>\n<p>PID:该TS包的ID号，如果净荷是PAT包，则PID固定为0x00。</p>\n<p>Transport scrambling control:传输加扰控制位</p>\n<p>Adaption field control:自适应调整域控制位，置位则表明该TS包存在自适应调整字段。</p>\n<p>Continuity counter:连续计数器，随着具有相同PID的TS包的增加而增加，达到最大时恢复为0，如果两个连续相同PID的TS包具有相同的计数，则表明这两个包是一样的，只取一个解析即可。</p>\n<p>Payload:负载内容，可能为PAT&#x2F;PMT&#x2F;PES。data_byte为1B长<br>度的数据，为负载字节。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655826274671665582627092.png\"></p>\n<p>Fig. 6. TS的语法结构代码示意</p>\n<h2 id=\"2-PAT-格式\"><a href=\"#2-PAT-格式\" class=\"headerlink\" title=\"2. PAT 格式\"></a>2. PAT 格式</h2><p>PAT的语法结构如下：</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655846904131665584689570.png\"><br>Fig. 7. PAT的语法结构示意</p>\n<p>主要的字段解析如下：</p>\n<p>table_id: 标识一个TS PSI 分段的内容是节目关联分段，条件访问分段还是节目映射分段。对于PAT，置为0x00。</p>\n<p>section_syntax_indicator: 对于PAT，置为0x01。</p>\n<p>section_length: 分段长度字段，其值为从section_length（不包括在内）到CRC_32字段的字节数，其值不超过1021。</p>\n<p>transport_stream_id: 区别与其他复用流的标识。</p>\n<p>version_number: PAT的版本号，如果PAT有变，则版本号加1。</p>\n<p>current_next_indicator:置0时，表明该传送的表分段不能使用，下一个表分段才有效。</p>\n<p>section_number: 表明该TS包属于该PAT的第几个分段，分段号从0开始。</p>\n<p>last_section_number: 表明最后一个分段号，同时表明该PAT的最大分段数目。一般，一个PAT表由一个TS包传送。</p>\n<p>program_number: 节目的编号。</p>\n<p>network_PID: NIT表的PID值。</p>\n<p>program_map_PID: PMT表的PID值。</p>\n<p>CRC_32: CRC校验。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655849004091665584900226.png\"><br>Fig. 8. PAT语法结构代码示意</p>\n<h2 id=\"3-PMT-格式\"><a href=\"#3-PMT-格式\" class=\"headerlink\" title=\"3. PMT 格式\"></a>3. PMT 格式</h2><p>PMT的语法结构如下：<br><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655849504061665584950270.png\"><br>Fig. 9. PMT语法结构</p>\n<p>主要的字段解析如下：</p>\n<p>table_id: 标识一个TS PSI 分段的内容是节目关联分段，条件访问分段还是节目映射分段。对于PMT，置为0x02。</p>\n<p>section_syntax_indicator: 对于PMT，置为0x01。</p>\n<p>section_length: 分段长度字段，其值为从section_length（包括在内）到CRC_32字段的字节数，其值不超过1021。</p>\n<p>program_number: 表明一共有多少个节目。</p>\n<p>version_number: PMT的版本号，如果字段中有关信息有变，则版本号以32为模加1。版本号是对一个节目的定义。</p>\n<p>current_next_indicator:置0时，表明该传送的表分段不能使用，下一个表分段才有效。</p>\n<p>section_number: 总为0x00。</p>\n<p>last_section_number: 总为0x00。</p>\n<p>PCR_PID: 指示含有该节目的PCR字段的TS包的PID。</p>\n<p>program_info_length: 表明跟随其后的对节目信息描述的字节数，也就是第一个N loop descriptors的字节数。</p>\n<p>stream_type: 表明PES流的类型。譬如，0x01表明是MPEG-1视频，0X03表明是MPEG-1音频。</p>\n<p>elementary_PID: 表明该负载有该PES流的TS包的PID值。</p>\n<p>ES_info_length: 表明跟随其后的描述相关节目元素的字节数，也就是第二个N loop descriptors的字节数。</p>\n<p>CRC_32: 在CEDARX代码中仅对DVB的场景下作校验。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655851034681665585103423.png\"></p>\n<p>Fig. 10. PMT的语法结构代码示意</p>\n<h2 id=\"4-PES格式\"><a href=\"#4-PES格式\" class=\"headerlink\" title=\"4.PES格式\"></a>4.PES格式</h2><p>PES的语法如图10所示，它携带的主要信息包括流的ID，PES包的长度，PTS以及流的数据，也就是音视频与字幕数据。</p>\n<p>主要的字段解析如下：</p>\n<p>packet_start_code_prefix: 固定0x000001</p>\n<p>stream_id: 指定基本流的类型与编号</p>\n<p>PES_packet_length: 表明在该字段后面还有多少个字节。0表明PES包的长度未指示也未限定，对于当前的PES包而言。</p>\n<p>PES_scrambling_control: PES包的有效载荷的加扰方式。</p>\n<p>PES_priority: 多路复用器可以通过该位最优化基本流内的数据。</p>\n<p>data_alignment_indicator:</p>\n<p>copyright: PES包中的有效载荷确定具有版权的话，就置位。</p>\n<p>orginal_or_copy: 置位时，表明PES包的有效载荷的内容是原始的，非复制的。</p>\n<p>PTS_DTS_flags: 2比特字节，表明PTS&#x2F;DTC的存在情况。</p>\n<p>ES_rate_flag: 置位，表明后面存在ES_rate字段。</p>\n<p>PES_header_data_length: 表明该PES包头中由任选字段与填充字节所占据的字节总数。任选字段譬如ES_rate。</p>\n<p>marker_bit: 为1的比特位。</p>\n<p>PTS: 对于音频而言，如果该PES包中存在PTS字段，则有效负载中肯定有新的音频存取单元（access unit），该PTS对应于该音频存取单元。新的音频存取单元指的是一帧新的音频帧。对于视频而言，一般情况下，跟音频一样。</p>\n<p>DTS: 解码时间标志，当前CEDARX解码器未用到DTS。</p>\n<p>ES_rate: 基本流速率，指定系统目标解码器接收PES包字节的速率。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655853343991665585333549.png\"><br><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655858313871061665585632_.jpg\"><br><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655858713891665585871171.png\"><br>Fig. 11. PES的语法结构代码</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[1] ISO &#x2F; IEC标准13818-1或ITU-T建议书 <a href=\"http://www.itu.int/rec/T-REC-H.222.0\">http://www.itu.int/rec/T-REC-H.222.0</a></p>\n<p>[2] 《数字电视业务信息及其编码》，方涛，国防工业出版社</p>\n<p>[3] <a href=\"https://wenku.baidu.com/view/87f5439c2f60ddccdb38a066.html?rec_flag=default\">https://wenku.baidu.com/view/87f5439c2f60ddccdb38a066.html?rec_flag=default</a></p>\n<p>[4] TS码流结构分析PPT，网络资料</p>\n<p>————————————————</p>\n<p>版权声明：本文为CSDN博主「Kayson12345」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/Kayson12345/article/details/81266587\">https://blog.csdn.net/Kayson12345/article/details/81266587</a></p>\n<h1 id=\"个人理解\"><a href=\"#个人理解\" class=\"headerlink\" title=\"个人理解\"></a>个人理解</h1><p>从TS流中获取PAT，解析PAT得到节目列表，每个节目列表对应一个PMT， 从PMT中得该节目对应的音视频PID， 从TS流根据PID滤出音视频TS包，将TS包还原为PES包，进而还原为ES流（h264, aac）送给解码器解码。</p>\n<p>结合<a href=\"https://tsduck.io/download/docs/mpegts-introduction.pdf\">An introduction to MPEG-TS</a>看起来更易于理解。</p>\n<h1 id=\"分析工具\"><a href=\"#分析工具\" class=\"headerlink\" title=\"分析工具\"></a>分析工具</h1><p><a href=\"https://easyice.cn/archives/85\">easyice </a></p>\n","excerpt":"","more":"<p>参考：<br><a href=\"https://blog.csdn.net/Kayson12345/article/details/81266587\">MPEG-TS 格式解析</a></p>\n<p><a href=\"https://tsduck.io/download/docs/mpegts-introduction.pdf\">An introduction to MPEG-TS</a></p>\n<h1 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h1><p>MPEG-TS一种标准数据容器格式，传输与存储音视频、节目与系统信息协议数据，应用于数字广播系统，譬如DVB,ATSC与IPTV。传输流在MPEG-2第1部分系统中规定，正式称为ISO &#x2F; IEC标准13818-1或ITU-T建议书[1]。</p>\n<p>MPEG2&#x2F;DVB是一种多媒体传输、复用技术，在数字电视广播中可提供数百个节目频道。复用的含义是，可以同时传输多层节目。</p>\n<p>注意，DVB全称为Digital Video Broadcasting，包括不同的系统，如卫星数字电视广播系统，有线数字电视广播系统，地面开路数字电视广播系统，交互式数字电视广播系统以及数字电视加扰系统。DVB系统标准是一种全球数字电视技术的标准。如何定义广播中的比特流语法与句法，以实现在比特流中复用数字音频与视频，欧洲的DVB采用数字视频压缩MPEG-2标准，该标准是定义比特流的语法与句法的一个ISO&#x2F;IEC标准，即13818-1标准。DVB系统的核心技术是采用MPEG-2技术进行视频、音频的编码，使用统一的MPEG-2传输流（TS流）。</p>\n<p>MPEG-2标准中，有两种不同的码流输出到信道，一种是节目码流（PS: Program Stream），适用于没有传输误差的场景；一种是传送流（TS：Transport Stream)，适用于有信道噪声的传输场景。节目流设计用于合理可靠的媒体，如光盘（如DVD），而传输流设计用于不太可靠的传输，即地面或卫星广播。此外，传输流可以携带多个节目。</p>\n<p>MPEG-2 system（编号13818-1）是MPEG-2标准的其中一部分，该部分描述了多个视频，音频和数据多种基本流（ES）合成传输流（TS）和节目流（PS）的方式。</p>\n<h1 id=\"TS-介绍\"><a href=\"#TS-介绍\" class=\"headerlink\" title=\"TS 介绍\"></a>TS 介绍</h1><p>一路TS比特流通常由连续的固定字节的TS包组成，所包含的内容有：</p>\n<ul>\n<li><p>一路或多路视频流（多个PES包组成，每个PES包的PID是一致的，一个PES包可能由若干个TS包组成）</p>\n</li>\n<li><p>一路或多路音频流（通常为杜比的音频格式）</p>\n</li>\n<li><p>一路或多路字幕</p>\n</li>\n<li><p>PSI表格信息（Program Specific Information，包括PAT与PMT表，即节目关联表与节目映射表）</p>\n</li>\n<li><p>PES: Packetized Elementary Stream，一路基本码流（如MEPG2视频流）会在编码器端被打包成PES流，由多个PES包组成，打包的过程中主要加入了PTS&#x2F;DTS信息。</p>\n</li>\n</ul>\n<p>PAT(Program Association Table)描述有多少路节目，每路节目的PMT（Program Map Table）表的PID是多少，PMT则描述了本节目有多少流，每一路流的类型与PID是多少，举个例子，你找个一个TS包，它的PID是0，说明它的负载内容是PAT信息，解析PAT信息，你发现节目1的PMT表的PID是0x10，接着，你在比特流中寻找一个PID为0x10的TS包，它的负载内容是节目1的PMT表信息，解析该PMT信息，你可以发现第一路流是MPEG2音频流，PID号0x21，第二路流是MPEG2视频流，PID号是0x22，第三路流是DVB字幕流，PID号是0x23，解析完毕，凡是比特流中PID号为0x22的TS包，所负载的内容为MPEG2视频流，把这些包一个一个找出来，把其中的有效码流一部分一部分的拼接起来，然后送给解码器去解码。</p>\n<p>注意，就一般的视频流而言，只要拼接成一个完整的PES包，就可以送出去给解码器，然后再继续拼接下一个PES包。</p>\n<p>什么是ES流，PES流，TS流？</p>\n<ul>\n<li><p>ES流：有三种，图像数据流，音频数据流，以及其他编码数据流。</p>\n</li>\n<li><p>PES流：PES流是ES流经过PES打包器处理后形成的数据流，在这个过程中完成了将ES流分组、打包、加入包头信息等操作（对ES流的第一次打包）。PES流的基本单位是PES包。</p>\n</li>\n<li><p>TS流：由定长的TS包组成（188字节），而TS包是对PES包的一个重新封装（到这里，ES经过了两层的封装） 。应用于相对有错环境下的传输与存储（如DVB中），其基本单位是TS包，长度固定188字节。日本的DVB-S广播系统采用192个字节的TS包，美国采用204个字节的TS包，多加了16个字节的前向纠错校验码（FEC）。</p>\n</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655696635121665569663420.png\"><br>Fig. 1. ES流打包成PES流<br><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655697239811665569723213.png\"><br>Fig. 2. PES流打包成TS流</p>\n<p>什么是PSI表？</p>\n<p>PSI(Program Specific Info)，节目特定信息，该表格信息用来描述传送流的组成结构。PSI信息由四种类型的表组成，包括节目关联表（PAT），节目映射表（PMT），条件接收表（CAT），网络信息表（NIT）。PAT与PMT两张表帮助我们找到该传送流中的所有节目与流，PAT告诉我们，该TS流由哪些节目组成，每个节目的节目映射表PMT的PID是什么，而PMT告诉我们，该节目由哪些流组成，每一路流的类型与PID是什么。CAT与NIT暂时不考虑。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655698149521665569814410.png\"></p>\n<p>Fig. 3. PSI表</p>\n<h1 id=\"TS解封装的原理\"><a href=\"#TS解封装的原理\" class=\"headerlink\" title=\"TS解封装的原理\"></a>TS解封装的原理</h1><p>TS流的形成过程：</p>\n<ol>\n<li>将原始音视频数据压缩之后，压缩结果组成一个基本码流（ES）。</li>\n<li>对ES（基本码流）进行打包形成PES。</li>\n<li>在PES包中加入时间戳信息(PTS&#x2F;DTS)。</li>\n<li>将PES包内容分配到一系列固定长度的传输包（TS Packet）中。</li>\n<li>在传输包中加入定时信息(PCR)。</li>\n<li>在传输包中加入节目专用信息(PSI) 。</li>\n<li>连续输出传输包形成具有恒定比特率的MPEG-TS流。</li>\n</ol>\n<p>TS流的解析过程，可以说是生成的逆过程：</p>\n<ol>\n<li>从复用的MPEG-TS流中解析出TS包；</li>\n<li>从TS包中获取PAT及对应的PMT（PSI中的表格）；</li>\n<li>从而获取特定节目的音视频PID；</li>\n<li>通过PID筛选出特定音视频相关的TS包，并解析出PES；</li>\n<li>从PES中读取到PTS&#x2F;DTS，并从PES中解析出基本码流ES；</li>\n<li>将ES交给解码器，获得压缩前的原始音视频数据</li>\n</ol>\n<h1 id=\"TS格式详解\"><a href=\"#TS格式详解\" class=\"headerlink\" title=\"TS格式详解\"></a>TS格式详解</h1><h2 id=\"1-TS包格式\"><a href=\"#1-TS包格式\" class=\"headerlink\" title=\"1. TS包格式\"></a>1. TS包格式</h2><p>TS包主要由两部分组成，一是4个字节的包头信息，二是有效载荷，另外中间有可能插入自适应调整字段。有效载荷包括节目专用信息，打包后的流数据，以及业务信息。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655700779571665570077901.png\"></p>\n<p>Fig. 4. TS包的组成结构</p>\n<p>TS的语法结构如下：</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655701129401665570112830.png\"></p>\n<p>Fig. 5. TS的语法结构</p>\n<p>主要字段解析：<br>Sync byte:同步字节，值为0x47；</p>\n<p>Transport error indicator:传输错误指示位，置1时，表示传送包中至少有一个不可纠正的错误位。</p>\n<p>Payload unit start indicator:负载单元起始指标位，表示TS包的有效净荷以PES&#x2F;PSI包的第一个字节开始，举个例子，一个PES包可能由多个TS包构成，第一个TS包的负载单元起始指标位才会被置位。</p>\n<p>Transport priority:传输优先级，表明该包比同个PID的但未置位的TS包有更高的优先级。</p>\n<p>PID:该TS包的ID号，如果净荷是PAT包，则PID固定为0x00。</p>\n<p>Transport scrambling control:传输加扰控制位</p>\n<p>Adaption field control:自适应调整域控制位，置位则表明该TS包存在自适应调整字段。</p>\n<p>Continuity counter:连续计数器，随着具有相同PID的TS包的增加而增加，达到最大时恢复为0，如果两个连续相同PID的TS包具有相同的计数，则表明这两个包是一样的，只取一个解析即可。</p>\n<p>Payload:负载内容，可能为PAT&#x2F;PMT&#x2F;PES。data_byte为1B长<br>度的数据，为负载字节。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655826274671665582627092.png\"></p>\n<p>Fig. 6. TS的语法结构代码示意</p>\n<h2 id=\"2-PAT-格式\"><a href=\"#2-PAT-格式\" class=\"headerlink\" title=\"2. PAT 格式\"></a>2. PAT 格式</h2><p>PAT的语法结构如下：</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655846904131665584689570.png\"><br>Fig. 7. PAT的语法结构示意</p>\n<p>主要的字段解析如下：</p>\n<p>table_id: 标识一个TS PSI 分段的内容是节目关联分段，条件访问分段还是节目映射分段。对于PAT，置为0x00。</p>\n<p>section_syntax_indicator: 对于PAT，置为0x01。</p>\n<p>section_length: 分段长度字段，其值为从section_length（不包括在内）到CRC_32字段的字节数，其值不超过1021。</p>\n<p>transport_stream_id: 区别与其他复用流的标识。</p>\n<p>version_number: PAT的版本号，如果PAT有变，则版本号加1。</p>\n<p>current_next_indicator:置0时，表明该传送的表分段不能使用，下一个表分段才有效。</p>\n<p>section_number: 表明该TS包属于该PAT的第几个分段，分段号从0开始。</p>\n<p>last_section_number: 表明最后一个分段号，同时表明该PAT的最大分段数目。一般，一个PAT表由一个TS包传送。</p>\n<p>program_number: 节目的编号。</p>\n<p>network_PID: NIT表的PID值。</p>\n<p>program_map_PID: PMT表的PID值。</p>\n<p>CRC_32: CRC校验。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655849004091665584900226.png\"><br>Fig. 8. PAT语法结构代码示意</p>\n<h2 id=\"3-PMT-格式\"><a href=\"#3-PMT-格式\" class=\"headerlink\" title=\"3. PMT 格式\"></a>3. PMT 格式</h2><p>PMT的语法结构如下：<br><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655849504061665584950270.png\"><br>Fig. 9. PMT语法结构</p>\n<p>主要的字段解析如下：</p>\n<p>table_id: 标识一个TS PSI 分段的内容是节目关联分段，条件访问分段还是节目映射分段。对于PMT，置为0x02。</p>\n<p>section_syntax_indicator: 对于PMT，置为0x01。</p>\n<p>section_length: 分段长度字段，其值为从section_length（包括在内）到CRC_32字段的字节数，其值不超过1021。</p>\n<p>program_number: 表明一共有多少个节目。</p>\n<p>version_number: PMT的版本号，如果字段中有关信息有变，则版本号以32为模加1。版本号是对一个节目的定义。</p>\n<p>current_next_indicator:置0时，表明该传送的表分段不能使用，下一个表分段才有效。</p>\n<p>section_number: 总为0x00。</p>\n<p>last_section_number: 总为0x00。</p>\n<p>PCR_PID: 指示含有该节目的PCR字段的TS包的PID。</p>\n<p>program_info_length: 表明跟随其后的对节目信息描述的字节数，也就是第一个N loop descriptors的字节数。</p>\n<p>stream_type: 表明PES流的类型。譬如，0x01表明是MPEG-1视频，0X03表明是MPEG-1音频。</p>\n<p>elementary_PID: 表明该负载有该PES流的TS包的PID值。</p>\n<p>ES_info_length: 表明跟随其后的描述相关节目元素的字节数，也就是第二个N loop descriptors的字节数。</p>\n<p>CRC_32: 在CEDARX代码中仅对DVB的场景下作校验。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655851034681665585103423.png\"></p>\n<p>Fig. 10. PMT的语法结构代码示意</p>\n<h2 id=\"4-PES格式\"><a href=\"#4-PES格式\" class=\"headerlink\" title=\"4.PES格式\"></a>4.PES格式</h2><p>PES的语法如图10所示，它携带的主要信息包括流的ID，PES包的长度，PTS以及流的数据，也就是音视频与字幕数据。</p>\n<p>主要的字段解析如下：</p>\n<p>packet_start_code_prefix: 固定0x000001</p>\n<p>stream_id: 指定基本流的类型与编号</p>\n<p>PES_packet_length: 表明在该字段后面还有多少个字节。0表明PES包的长度未指示也未限定，对于当前的PES包而言。</p>\n<p>PES_scrambling_control: PES包的有效载荷的加扰方式。</p>\n<p>PES_priority: 多路复用器可以通过该位最优化基本流内的数据。</p>\n<p>data_alignment_indicator:</p>\n<p>copyright: PES包中的有效载荷确定具有版权的话，就置位。</p>\n<p>orginal_or_copy: 置位时，表明PES包的有效载荷的内容是原始的，非复制的。</p>\n<p>PTS_DTS_flags: 2比特字节，表明PTS&#x2F;DTC的存在情况。</p>\n<p>ES_rate_flag: 置位，表明后面存在ES_rate字段。</p>\n<p>PES_header_data_length: 表明该PES包头中由任选字段与填充字节所占据的字节总数。任选字段譬如ES_rate。</p>\n<p>marker_bit: 为1的比特位。</p>\n<p>PTS: 对于音频而言，如果该PES包中存在PTS字段，则有效负载中肯定有新的音频存取单元（access unit），该PTS对应于该音频存取单元。新的音频存取单元指的是一帧新的音频帧。对于视频而言，一般情况下，跟音频一样。</p>\n<p>DTS: 解码时间标志，当前CEDARX解码器未用到DTS。</p>\n<p>ES_rate: 基本流速率，指定系统目标解码器接收PES包字节的速率。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655853343991665585333549.png\"><br><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655858313871061665585632_.jpg\"><br><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16655858713891665585871171.png\"><br>Fig. 11. PES的语法结构代码</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>[1] ISO &#x2F; IEC标准13818-1或ITU-T建议书 <a href=\"http://www.itu.int/rec/T-REC-H.222.0\">http://www.itu.int/rec/T-REC-H.222.0</a></p>\n<p>[2] 《数字电视业务信息及其编码》，方涛，国防工业出版社</p>\n<p>[3] <a href=\"https://wenku.baidu.com/view/87f5439c2f60ddccdb38a066.html?rec_flag=default\">https://wenku.baidu.com/view/87f5439c2f60ddccdb38a066.html?rec_flag=default</a></p>\n<p>[4] TS码流结构分析PPT，网络资料</p>\n<p>————————————————</p>\n<p>版权声明：本文为CSDN博主「Kayson12345」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/Kayson12345/article/details/81266587\">https://blog.csdn.net/Kayson12345/article/details/81266587</a></p>\n<h1 id=\"个人理解\"><a href=\"#个人理解\" class=\"headerlink\" title=\"个人理解\"></a>个人理解</h1><p>从TS流中获取PAT，解析PAT得到节目列表，每个节目列表对应一个PMT， 从PMT中得该节目对应的音视频PID， 从TS流根据PID滤出音视频TS包，将TS包还原为PES包，进而还原为ES流（h264, aac）送给解码器解码。</p>\n<p>结合<a href=\"https://tsduck.io/download/docs/mpegts-introduction.pdf\">An introduction to MPEG-TS</a>看起来更易于理解。</p>\n<h1 id=\"分析工具\"><a href=\"#分析工具\" class=\"headerlink\" title=\"分析工具\"></a>分析工具</h1><p><a href=\"https://easyice.cn/archives/85\">easyice </a></p>\n"},{"layout":"post","title":"HLS 介绍，M3U8 格式分析","date":"2022-10-12T16:00:00.000Z","_content":"\n# HLS 是什么\n\n维基百科的介绍：\n\nHTTP Live Streaming，缩写为HLS，是由苹果公司提出基于HTTP的流媒体网络传输协议。是苹果公司QuickTime X和iPhone软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的扩充 M3U (m3u8) 播放列表文件，用于寻找可用的媒体流。\n\nHLS只请求基本的HTTP报文，与实时传输协议（RTP）不同，HLS可以穿过任何允许HTTP数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。\n\n苹果公司把HLS协议作为一个互联网草案（逐步提交），在第一阶段中已作为一个非正式的标准提交到IETF。2017年8月，RFC 8216发布，描述了HLS协议第7版的定义。\n\n苹果自己的介绍：\n\n> Send live and on‐demand audio and video to iPhone, iPad, Mac, Apple Watch, Apple TV, and PC with HTTP Live Streaming (HLS) technology from Apple. Using the same protocol that powers the web, HLS lets you deploy content using ordinary web servers and content delivery networks. HLS is designed for reliability and dynamically adapts to network conditions by optimizing playback for the available speed of wired and wireless connections.\n\n总结一下：\n1. 基于HTTP的流媒体网络传输协议，支持安全通信（通过https, 媒体数据加密等）\n2. 工作原理是把整个流分成一个个小的基于HTTP的文件来下载, 使用m3u8描述播放列表。\n3. 支持直播和点播（VOD， video on demand）\n4. 当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率\n\n\n## HLS 流媒体架构\n\n> Conceptually, HTTP Live Streaming consists of three parts: the server component, the distribution component, and the client software.\n>\n>In a typical configuration, a hardware encoder takes audio-video input, encodes it as HEVC video and AC-3 audio, and outputs a fragmented MPEG-4 file or an MPEG-2 transport stream. A software stream segmenter then breaks the stream into a series of short media files, which are placed on a web server. The segmenter also creates and maintains an index file containing a list of the media files. The URL of the index file is published on the web server. Client software reads the index, then requests the listed media files in order and displays them without any pauses or gaps between segments.\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656504345291665650434432.png)\n\n\n概念上，HLS 包含\n- 服务端组件\n- 分发组件\n- 客户端软件\n\n\n步骤：\n1. 服务端硬件编码器，将音视频输入编码(视频编码成HEVC，H264, 音频编码成AAC，AC-3)， 输出ts流（也可以生成分段的mp4文件， 很少用）\n2. 分段软件会将ts流分割，打包成ts文件，同时生成索引文件（m3u8）,索引文件保存了媒体文件的信息。\n3. 客户端读取m3u8索引文件，下载对应的ts文件，将内容播放给用户\n\n\n苹果提供了一套用于HLS的工具集，参考：\n\n[Using Apple's HTTP Live Streaming (HLS) Tools](https://developer.apple.com/documentation/http_live_streaming/using_apple_s_http_live_streaming_hls_tools)\n\n- Media File Segmenter (mediafilesegmenter), 媒体文件分割器\n- Media Subtitle Segmenter (mediasubtitlesegmenter)， 字幕分割器\n- Media Stream Segmenter (mediastreamsegmenter) 媒体流分割器\n- Variant Playlist Creator (variantplaylistcreator) 可变播放列表生成器\n- ...\n\n# M3U8\n\n> The Unicode version of M3U is M3U8, which uses UTF-8-encoded characters. M3U8 files are the basis for the HTTP Live Streaming (HLS) format originally developed by Apple to stream video and radio to iOS devices, and which is now a popular format for adaptive streaming in general.\n\n> M3U (MP3 URL or Moving Picture Experts Group Audio Layer 3 Uniform Resource Locator in full) is a computer file format for a multimedia playlist. One common use of the M3U file format is creating a single-entry playlist file pointing to a stream on the Internet.\n\n> Although originally designed for audio files, such as MP3, it is commonly used to point media players to audio and video sources, including online sources.\n\n\n总结一下：\n\n1. M3U8 是M3U的Unicode版本，使用 UTF-8 编码， 是 HLS 的基础\n2. M3U 最初是为音频文件设计的，例如MP3， 现在不再局限于音频文件，可以用来索引音频和视频资源，网络资源\n3. 下面分析M3U 文件格式\n\n\n**M3U**\n\n> An M3U file is a plain text file that specifies the locations of one or more media files. The file is saved with the \"m3u\" filename extension if the text is encoded in the local system's default non-Unicode encoding (e.g., a Windows codepage), or with the \"m3u8\" extension if the text is UTF-8 encoded.\n\n总结一下：\n1. M3U 文件是纯文本文件，指定了资源文件的位置\n2. 以`.m3u`为文件后缀\n3. 使用 UTF-8 编码的版本，以 `.m3u8`为后缀\n\n\n## Extended M3U\n\n看一个例子：\n\n```\n#EXTM3U\n#EXT-X-PLAYLIST-TYPE:VOD\n#EXT-X-TARGETDURATION:10\n#EXT-X-VERSION:4\n#EXT-X-MEDIA-SEQUENCE:0\n#EXTINF:10.0,\nhttp://example.com/movie1/fileSequenceA.ts\n#EXTINF:10.0,\nhttp://example.com/movie1/fileSequenceB.ts\n#EXTINF:10.0,\nhttp://example.com/movie1/fileSequenceC.ts\n#EXTINF:9.0,\nhttp://example.com/movie1/fileSequenceD.ts\n#EXT-X-ENDLIST\n```\n\n语法：\n- Tags: begin with '#EXT'\n- Comments: only begin with '#'\n- 标签后面可以有参数，例如`#EXTINF:10.0`\n- 标签内容可以是：\n    1. an absolute local pathname\n    2. a local pathname relative to the M3U file location; e.g. Heavysets.mp3\n    3. a URL\n\n\n表格参考：[https://en.wikipedia.org/wiki/M3U](https://en.wikipedia.org/wiki/M3U)\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656557421391665655741667.png)\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656557911381665655790476.png)\n\n## 例子分析\n\n```\n#EXTM3U\n#EXT-X-PLAYLIST-TYPE:VOD\n#EXT-X-TARGETDURATION:10\n#EXT-X-VERSION:4\n#EXT-X-MEDIA-SEQUENCE:0\n#EXTINF:10.0,\nhttp://example.com/movie1/fileSequenceA.ts\n#EXTINF:10.0,\nhttp://example.com/movie1/fileSequenceB.ts\n#EXTINF:10.0,\nhttp://example.com/movie1/fileSequenceC.ts\n#EXTINF:9.0,\nhttp://example.com/movie1/fileSequenceD.ts\n#EXT-X-ENDLIST\n```\n\n**EXTM3U**\n\n表明是`extended M3U`文件， 区别于基本的`M3U`文件。m3u8文件必须以该标签开始。\n\n\n**EXT-X-PLAYLIST-TYPE**\n\n类型可以是：\n\n- VOD， 代表点播， 结尾包含`#EXT-X-ENDLIST`\n- EVENT， 代表直播, 结尾不包含`#EXT-X-ENDLIST`\n\n**EXT-X-TARGETDURATION**\n\n单个媒体文件的最大时长。每一个`#EXTINF:10.0`标签指定的时长`<=`EXT-X-TARGETDURATION\n\n**EXT-X-MEDIA-SEQUENCE**\n\n> Indicates the sequence number of the first URL that appears in a playlist file. Each media file URL in a playlist has a unique integer sequence number. The sequence number of a URL is higher by 1 than the sequence number of the URL that preceded it. The media sequence numbers have no relation to the names of the files.\n\nm3u8文件中第一个URL文件的编号，与文件名字无关，每次比前面的+1。\n\n**EXT-X-VERSION**\n\n> The EXT-X-VERSION tag indicates the compatibility version of the Playlist file. This file, its associated media, and its server must comply with all provisions of the IETF Internet-Draft of \"HTTP Live Streaming 2nd Edition\" (or earlier specifications) describing the protocol version indicated by the tag value. A Playlist file that doesn't contain an EXT-X-VERSION tag must comply with version 1 of this protocol.\n\n表明该m3u8文件的版本兼容性。该m3u8文件，关联的媒体，服务器必须服从于该版本特性。如果不包含该字段，必须服从与版本1的规定。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656577590671665657758695.png)\n\n参考： [About the EXT-X-VERSION tag](https://developer.apple.com/documentation/http_live_streaming/about_the_ext-x-version_tag)\n\n\n**EXTINF**\n\n- 描述资源文件时长，URL\n- 时长： 版本小于3是int， 版本大于等于3是float, 单位秒\n\n**EXT-X-ENDLIST**\n\n结束标志，表明没有更多资源了。vod有，event可能没有。\n\n\n### VOD Playlist 点播\n\n```\n#EXTM3U\n#EXT-X-PLAYLIST-TYPE:VOD\n#EXT-X-TARGETDURATION:10\n#EXT-X-VERSION:4\n#EXT-X-MEDIA-SEQUENCE:0\n#EXTINF:10.0,\nhttp://example.com/movie1/fileSequenceA.ts\n#EXTINF:10.0,\nhttp://example.com/movie1/fileSequenceB.ts\n#EXTINF:10.0,\nhttp://example.com/movie1/fileSequenceC.ts\n#EXTINF:9.0,\nhttp://example.com/movie1/fileSequenceD.ts\n#EXT-X-ENDLIST\n```\n### live Playlist(Sliding Window) 直播滑动窗口\n\n> In live sessions, the index file is updated by removing media URIs from the file as new media files are created and made available. The EXT-X-ENDLIST tag isn't present in the live playlist, indicating that new media files will be added to the index file as they become available.\n\n直播流，m3u8文件会更新，前面的资源会被移除，后面的资源会被追加。\n没有`EXT-X-ENDLIST`标签，表示还会有新的资源被添加。\n\n看一个例子，开始时文件内容\n```\n#EXTM3U\n#EXT-X-TARGETDURATION:10\n#EXT-X-VERSION:4\n#EXT-X-MEDIA-SEQUENCE:1\n#EXTINF:10.0,\nfileSequence1.ts\n#EXTINF:10.0,\nfileSequence2.ts\n#EXTINF:10.0,\nfileSequence3.ts\n#EXTINF:10.0,\nfileSequence4.ts\n#EXTINF:10.0,\nfileSequence5.ts\n```\n\n旧资源被删除，新资被添加，看到`EXT-X-MEDIA-SEQUENCE`也发生了变化\n```\n#EXTM3U\n#EXT-X-TARGETDURATION:10\n#EXT-X-VERSION:4\n#EXT-X-MEDIA-SEQUENCE:2\n#EXTINF:10.0,\nfileSequence2.ts\n#EXTINF:10.0,\nfileSequence3.ts\n#EXTINF:10.00,\nfileSequence4.ts\n#EXTINF:10.00,\nfileSequence5.ts\n#EXTINF:10.0,\nfileSequence6.ts\n```\n\n再次更新\n```\n#EXTM3U\n#EXT-X-TARGETDURATION:10\n#EXT-X-VERSION:4\n#EXT-X-MEDIA-SEQUENCE:4\n#EXTINF:10.00,\nfileSequence4.ts\n#EXTINF:10.00,\nfileSequence5.ts\n#EXTINF:10.0,\nfileSequence6.ts,\n#EXTINF:10.0,\nfileSequence7.ts,\n#EXTINF:10.0,\nfileSequence8.ts,\n#EXTINF:10.0,\nfileSequence9.ts\n```\n\n### Event Playlist\n\n> An event playlist is specified by the EXT-X-PLAYLIST-TYPE tag with a value of EVENT. It doesn't initially have an EXT-X-ENDLIST tag, indicating that new media files will be added to the playlist as they become available.\n\n\n\n\n```\n#EXTM3U\n#EXT-X-PLAYLIST-TYPE:EVENT\n#EXT-X-TARGETDURATION:10\n#EXT-X-VERSION:4\n#EXT-X-MEDIA-SEQUENCE:0\n#EXTINF:10.00,\nfileSequence0.ts\n#EXTINF:10.0,\nfileSequence1.ts\n#EXTINF:10.0,\nfileSequence2.ts\n#EXTINF:10.0,\nfileSequence3.ts\n#EXTINF:10.0,\nfileSequence4.ts\n```\n\n观察到`#EXT-X-PLAYLIST-TYPE:EVENT`\n\n> If the tag is present and has a value of EVENT, the server must not change or delete any part of the playlist file (although it may append lines to it). If the tag is present and has a value of VOD, the playlist file must not change.\n\n> You can't remove anything from the playlist when using the EVENT tag; you may only append new segments to the end of the file. New segments are added to the end of the file until the event has concluded, at which time the EXT-X-ENDLIST tag is appended.\n\n如果类型为EVENT，更新m3u8文件，只能追加，不能删除。\n如果类型为VOD，不能更改m3u8播放列表。\n\n更新后\n```\n#EXTM3U\n#EXT-X-PLAYLIST-TYPE:EVENT\n#EXT-X-TARGETDURATION:10\n#EXT-X-VERSION:4\n#EXT-X-MEDIA-SEQUENCE:0\n#EXTINF:10.0,\nfileSequence0.ts\n#EXTINF:10.0,\nfileSequence1.ts\n#EXTINF:10.0,\nfileSequence2.ts\n#EXTINF:10.0,\nfileSequence3.ts\n#EXTINF:10.0,\nfileSequence4.ts\n\n// List of files between 4 and 120 go here.\n\n#EXTINF:10.0,\nfileSequence120.ts\n#EXTINF:10.0,\nfileSequence121.ts\n#EXT-X-ENDLIST\n```\n\n\n### Creating a Multivariant Playlist\n\n> Offer multiple playlist files to provide different encodings of the same content.\n\n为同一份内容，提供多个m3u8索引，每个m3u8采用不同的编码参数。\n\n\n> The Multivariant Playlist describes all of the available variants for your content. Each variant is a version of the stream at a particular bit rate and is contained in a separate playlist. The client switches to the most appropriate variant based on the measured network bit rate. The client’s player is tuned to minimize stalling of playback, to give the user the best possible streaming experience.\n\n为同一份内容，提供多个码率的m3u8,方便客户端播放器选择适应自身网络状况的最佳码率资源。\n\n结构图：\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656676568981665667656356.png)\n\n\n文件示例\n\n```\n#EXTM3U\n#EXT-X-STREAM-INF:BANDWIDTH=150000,RESOLUTION=416x234,CODECS=\"avc1.42e00a,mp4a.40.2\"\nhttp://example.com/low/index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=240000,RESOLUTION=416x234,CODECS=\"avc1.42e00a,mp4a.40.2\"\nhttp://example.com/lo_mid/index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=440000,RESOLUTION=416x234,CODECS=\"avc1.42e00a,mp4a.40.2\"\nhttp://example.com/hi_mid/index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=640000,RESOLUTION=640x360,CODECS=\"avc1.42e00a,mp4a.40.2\"\nhttp://example.com/high/index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=64000,CODECS=\"mp4a.40.5\"\nhttp://example.com/audio/index.m3u8\n```\n\n**EXT-X-STREAM-INF**\nIndicates that the next URL in the playlist file identifies another playlist file.\n\n表明它的URL内容是一个m3u8文件。\n\nThe EXT-X-STREAM-INF tag has the following parameters:\n\n**AVERAGE-BANDWIDTH**\n\n(Optional, but recommended) An integer that represents the average bit rate for the variant stream.\n\n平均码率，可选。\n\n\n**BANDWIDTH**\n\n(Required) An integer that is the upper bound of the overall bit rate for each media file, in bits per second. The upper bound value is calculated to include any container overhead that appears or will appear in the playlist.\n\n带宽。\n\n**FRAME-RATE**\n\n(Optional, but recommended) A floating-point value that describes the maximum frame rate in a variant stream.\n\n帧率，可选， 表示该流的最大帧率。\n\n**HDCP-LEVEL**\n\n(Optional) Indicates the type of encryption used. Valid values are TYPE-0 and NONE. Use TYPE-0 if the stream may not play unless the output is protected by HDCP.\n\n加密方式，可选。\n\n**RESOLUTION**\n\n(Optional, but recommended) The optional display size, in pixels, at which to display the video in the playlist. This parameter should be included for any stream that includes video.\n\n视频分辨率。\n\n\n**VIDEO-RANGE**\n\n(Required depending on encoding) A string with valid values of SDR or PQ. If transfer characteristic codes 1, 16, or 18 aren’t specified, then this parameter must be omitted.\n\n**CODECS**\n\n(Optional, but recommended) A quoted string containing a comma-separated list of formats, where each format specifies a media sample type that’s present in a media segment in the playlist file. Valid format identifiers are those in the ISO file format name space defined by RFC 6381.\n\n编码器相关参数。\n\n### Adding Alternate Media to a Playlist\n\n> Specify Rendition Playlists that can override the main presentation.\n\n> Adding alternate media to a Multivariant Playlist allows a provider to specify one of a set of variant playlists as an override of the main presentation. The client plays only the override media (audio or video), and suppresses any media of the same type from the main presentation, if present. This allows a presentation to offer multiple versions of the media without requiring the provider to store duplicate media, or requiring the client to download all variants when it only needs one. It also allows additional media to be offered subsequently without remastering the original content.\n\n在主音频视频资源外，提供多路备选资源。\n选择备选的音视频，客户端只会播放备选音视频资源。\n\n\n下面的例子，提供备选的多语言音频播放列表\n\n```\n#EXTM3U\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio\",LANGUAGE=\"eng\",NAME=\"English\",AUTOSELECT=YES, DEFAULT=YES,URI=\"eng/prog_index.m3u8\"\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio\",LANGUAGE=\"fre\",NAME=\"Français\",AUTOSELECT=YES, DEFAULT=NO,URI=\"fre/prog_index.m3u8\"\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio\",LANGUAGE=\"sp\",NAME=\"Espanol\",AUTOSELECT=YES, DEFAULT=NO,URI=\"sp/prog_index.m3u8\"\n\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=195023,CODECS=\"avc1.42e00a,mp4a.40.2\",AUDIO=\"audio\"\nlo/prog_index.m3u8\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=591680,CODECS=\"avc1.42e01e,mp4a.40.2\",AUDIO=\"audio\"\nhi/prog_index.m3u8\n```\n\nThe tags used in this Multivariant Playlist example include:\n\n**EXT-X-MEDIA**\nIdentifies an element of a media selection group. All the elements of a media selection group must have similar characteristics, for example, the same codecs and the same maximum bandwidth.\n\n表示媒体选项分组中的一个元素，同一个分组中的媒体具有相同的特征，如相同的编解码或带宽。\n\nEXT-X-STREAM-INF\nindicates that the next URL in the Multivariant Playlist identifies a Rendition Playlist. See Creating a Multivariant Playlist for the basic parameters.\n\n表明它的内容是一个索引， 指向一个m3u8文件\n\nThe EXT-X-MEDIA tag has the following parameters:\n\nTYPE\n(Required) A string indicating the type of media. Valid values are AUDIO, VIDEO, SUBTITLES, and CLOSED-CAPTIONS.\n\n媒体类型\n- AUDIO\n- VIDEO\n- SUBTITLES\n- CLOSED-CAPTIONS\n\n\nGROUP-ID\n(Required) A string specifying the group that the media selection belongs to.\n\n分组标识，字符串，必须有。\n\nLANGUAGE\n(Optional) A string that identifies the primary language used in the media selection.\n\n该选项中媒体文件对应的语言，可选。\n\nNAME\n(Required) A string that describes the primary language used in the media selection.\n\n该选项中媒体文件对应的语言的字符串标识，必须。\n\nAUTOSELECT\n(Optional) A string that indicates that the client may play the media selection in the absence of explicit user preference. Valid values are YES and NO. If the value of DEFAULT is YES, this value must also be YES.\n\n是否自动选择，可选。在用户偏好缺省的时候，指示客户端是否应该自动选择该选项。合法的值是YES和NO，\n如果`DEFAULT`是YES， 该字段的值必须也是YES.\n\nDEFAULT\n(Optional) A string indicating that the media selection should be played if the user hasn’t selected another option. Valid values are YES and NO.\n\n是否默认播放该选项，可选。用户没有选择其他选项的时候，是否默认播放该选项。\n\nINSTREAM-ID\n(Required for closed captions) A string that specifies a rendition within the segments in the media playlist. When the TYPE attribute is CLOSED-CAPTIONS, the INSTREAM-ID must have one of the following values: CC1, CC3, CC3, CC4, or SERVICEn, where n is between 1 and 63.\n\n\nASSOC-LANGUAGE\n(Optional) A string containing a language tag for the rendition. An associated language is often different from the language specified in the LANGUAGE attribute.\n\n关联的语言，可选。\n\nCHANNELS\n(Required when two renditions have the same codec but a different number of channels) An ordered string that indicates the maximum number of independent, simultaneous audio channels present in a media segment.\n\n表明该音频文件有几个声道\n\nURI\n(Optional) A string containing a URI that identifies the media playlist file. If the TYPE is CLOSED-CAPTIONS, this attribute must be omitted. When this attribute is omitted, the media content is in the original variant.\n\n媒体文件地址，可选。\n\nWhen its URI attribute is omitted, the EXT-X-MEDIA tag can indicate that the media described is included in the URI of the EXT-X-STREAM-INF tag.\n\n如果URI字段不存在，`EXT-X-MEDIA`描述的的媒体文件存在于`EXT-X-STREAM-INF`标签中。\n\nThe EXT-X-STREAM-INF tag has the following parameters:\n\nAUDIO\n(Optional) A quoted string that indicates the set of audio streams that may be used when playing the presentation. This value must match the value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the Multivariant Playlist whose TYPE attribute is AUDIO.\n\n\nVIDEO\n(Optional) A quoted string that indicates the set of video streams that may be used when playing the presentation. This value must match the value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the Multivariant Playlist whose TYPE attribute is VIDEO.\n\nSUBTITLES\n(Optional) A quoted string that indicates the set of subtitle renditions that can be used. This value must match the value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the Multivariant Playlist whose TYPE attribute is SUBTITLE.\n\nCLOSED-CAPTIONS\n(Optional) Either a quoted string that indicates the set of closed captions that can be used or an enumerated string with the value of NONE. When this value is a quoted string, it must match the value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the Multivariant Playlist whose TYPE attribute is CLOSED-CAPTIONS. If the enumerated value is NONE, all EXT-X-STREAM-INF tags must have this attribute with a value of NONE.\n\n\n总结一下：\n\n通过`EXT-X-MEDIA`可以定义资源组，可以有多个组，用GROUP-ID来区分， 有四种组类型\n- AUDIO\n- VIDEO\n- SUBTITLES\n- CLOSED-CAPTIONS\n\n每个分组中流属性是相同，其参数可以通过关联的`EXT-X-STREAM-INF`指定\n通过`EXT-X-STREAM-INF`定义资源组的流参数，带宽，编解码器信息。 它关联一个组ID，这个组内的所有备选媒体都具有相同的性质。\n\n\nYou can have multiple audio groups to allow changes in codes or bit rate. However, each audio group in a variant must have the same alternates in it. For example, you can’t have English in one audio group and leave it out of the other group. The following example defines two audio groups, one for low bit rates and one for high bit rates. Both audio groups define the same set of languages but are called based on the available bandwidth.\n\n每个组可以提供多个码率的媒体文件，其码率可以通过`EXT-X-STREAM-INF`指定，虽然`GROUP-ID`相同，但是码率是不同的。\n\n```\n#EXTM3U\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio-lo\",LANGUAGE=\"eng\",NAME=\"English\",AUTOSELECT=YES, DEFAULT=YES,URI=\"englo/prog_index.m3u8\"\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio-lo\",LANGUAGE=\"fre\",NAME=\"Français\",AUTOSELECT=YES, DEFAULT=NO,URI=\"frelo/prog_index.m3u8\"\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio-lo\",LANGUAGE=\"es\",NAME=\"Espanol\",AUTOSELECT=YES, DEFAULT=NO,URI=\"splo/prog_index.m3u8\"\n \n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio-hi\",LANGUAGE=\"eng\",NAME=\"English\",AUTOSELECT=YES, DEFAULT=YES,URI=\"eng/prog_index.m3u8\"\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio-hi\",LANGUAGE=\"fre\",NAME=\"Français\",AUTOSELECT=YES, DEFAULT=NO,URI=\"fre/prog_index.m3u8\"\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio-hi\",LANGUAGE=\"es\",NAME=\"Espanol\",AUTOSELECT=YES, DEFAULT=NO,URI=\"sp/prog_index.m3u8\"\n \n#EXT-X-STREAM-INF:BANDWIDTH=195023,CODECS=\"mp4a.40.5\", AUDIO=\"audio-lo\"\nlo/prog_index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=260000,CODECS=\"avc1.42e01e,mp4a.40.2\", AUDIO=\"audio-lo\"\nhi/prog_index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=591680,CODECS=\"mp4a.40.2, avc1.64001e\", AUDIO=\"audio-hi\"\nlo/prog_index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=650000,CODECS=\"avc1.42e01e,mp4a.40.2\", AUDIO=\"audio-hi\"\nhi/prog_index.m3u8\n\n```\n\nYou can have both a group and a single stream in a playlist. This is often done when you have multiple camera angles that all use the same audio. Create a group for the video streams and then declare the single audio stream. The following example shows a playlist with three camera angles and a single audio stream:\n\n一个视频组关联单个音频的情况。\n\n```\n#EXTM3U\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"500kbs\",NAME=\"Angle1\",AUTOSELECT=YES,DEFAULT=YES\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"500kbs\",NAME=\"Angle2\",AUTOSELECT=YES,DEFAULT=NO, URI=\"Angle2/500kbs/prog_index.m3u8\"\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"500kbs\",NAME=\"Angle3\",AUTOSELECT=YES,DEFAULT=NO, URI=\"Angle3/500kbs/prog_index.m3u8\"\n\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"aac\",LANGUAGE=\"en\",NAME=\"English\",AUTOSELECT=YES, DEFAULT=YES,URI=\"eng/prog_index.m3u8\"\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=754857,CODECS=\"mp4a.40.2,avc1.4d401e\", VIDEO=\"500kbs\",AUDIO=\"aac\"\nAngle1/500kbs/prog_index.m3u8\n```\n\nTo provide different streams for different bit rates, a different video group ID is needed for each bit rate.\n\n```\n#EXTM3U\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"200kbs\",NAME=\"Angle1\",AUTOSELECT=YES,DEFAULT=YES\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"200kbs\",NAME=\"Angle2\",AUTOSELECT=YES,DEFAULT=NO, URI=\"Angle2/200kbs/prog_index.m3u8\"\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"200kbs\",NAME=\"Angle3\",AUTOSELECT=YES,DEFAULT=NO, URI=\"Angle3/200kbs/prog_index.m3u8\"\n\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"500kbs\",NAME=\"Angle1\",AUTOSELECT=YES,DEFAULT=YES\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"500kbs\",NAME=\"Angle2\",AUTOSELECT=YES,DEFAULT=NO, URI=\"Angle2/500kbs/prog_index.m3u8\"\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"500kbs\",NAME=\"Angle3\",AUTOSELECT=YES,DEFAULT=NO, URI=\"Angle3/500kbs/prog_index.m3u8\"\n\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"aac\",LANGUAGE=\"en\",NAME=\"English\",AUTOSELECT=YES, DEFAULT=YES,URI=\"eng/prog_index.m3u8\"\n\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=300000,CODECS=\"mp4a.40.2,avc1.4d401e\", VIDEO=\"200kbs\",AUDIO=\"aac\"\nAngle1/200kbs/prog_index.m3u\n\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=754857,CODECS=\"mp4a.40.2,avc1.4d401e\", VIDEO=\"500kbs\",AUDIO=\"aac\"\nAngle1/500kbs/prog_index.m3u8\n```\n\n参考：\nhttps://developer.apple.com/documentation/http_live_streaming\nhttps://aleen42.gitbooks.io/wiki/content/summary/m3u8/m3u8.html","source":"_posts/hls/2022-10-13-HLS-介绍.md","raw":"---\nlayout: post\ntitle: \"HLS 介绍，M3U8 格式分析\"\ndate: 2022-10-13\ntag: hls,m3u8\n---\n\n# HLS 是什么\n\n维基百科的介绍：\n\nHTTP Live Streaming，缩写为HLS，是由苹果公司提出基于HTTP的流媒体网络传输协议。是苹果公司QuickTime X和iPhone软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的扩充 M3U (m3u8) 播放列表文件，用于寻找可用的媒体流。\n\nHLS只请求基本的HTTP报文，与实时传输协议（RTP）不同，HLS可以穿过任何允许HTTP数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。\n\n苹果公司把HLS协议作为一个互联网草案（逐步提交），在第一阶段中已作为一个非正式的标准提交到IETF。2017年8月，RFC 8216发布，描述了HLS协议第7版的定义。\n\n苹果自己的介绍：\n\n> Send live and on‐demand audio and video to iPhone, iPad, Mac, Apple Watch, Apple TV, and PC with HTTP Live Streaming (HLS) technology from Apple. Using the same protocol that powers the web, HLS lets you deploy content using ordinary web servers and content delivery networks. HLS is designed for reliability and dynamically adapts to network conditions by optimizing playback for the available speed of wired and wireless connections.\n\n总结一下：\n1. 基于HTTP的流媒体网络传输协议，支持安全通信（通过https, 媒体数据加密等）\n2. 工作原理是把整个流分成一个个小的基于HTTP的文件来下载, 使用m3u8描述播放列表。\n3. 支持直播和点播（VOD， video on demand）\n4. 当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率\n\n\n## HLS 流媒体架构\n\n> Conceptually, HTTP Live Streaming consists of three parts: the server component, the distribution component, and the client software.\n>\n>In a typical configuration, a hardware encoder takes audio-video input, encodes it as HEVC video and AC-3 audio, and outputs a fragmented MPEG-4 file or an MPEG-2 transport stream. A software stream segmenter then breaks the stream into a series of short media files, which are placed on a web server. The segmenter also creates and maintains an index file containing a list of the media files. The URL of the index file is published on the web server. Client software reads the index, then requests the listed media files in order and displays them without any pauses or gaps between segments.\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656504345291665650434432.png)\n\n\n概念上，HLS 包含\n- 服务端组件\n- 分发组件\n- 客户端软件\n\n\n步骤：\n1. 服务端硬件编码器，将音视频输入编码(视频编码成HEVC，H264, 音频编码成AAC，AC-3)， 输出ts流（也可以生成分段的mp4文件， 很少用）\n2. 分段软件会将ts流分割，打包成ts文件，同时生成索引文件（m3u8）,索引文件保存了媒体文件的信息。\n3. 客户端读取m3u8索引文件，下载对应的ts文件，将内容播放给用户\n\n\n苹果提供了一套用于HLS的工具集，参考：\n\n[Using Apple's HTTP Live Streaming (HLS) Tools](https://developer.apple.com/documentation/http_live_streaming/using_apple_s_http_live_streaming_hls_tools)\n\n- Media File Segmenter (mediafilesegmenter), 媒体文件分割器\n- Media Subtitle Segmenter (mediasubtitlesegmenter)， 字幕分割器\n- Media Stream Segmenter (mediastreamsegmenter) 媒体流分割器\n- Variant Playlist Creator (variantplaylistcreator) 可变播放列表生成器\n- ...\n\n# M3U8\n\n> The Unicode version of M3U is M3U8, which uses UTF-8-encoded characters. M3U8 files are the basis for the HTTP Live Streaming (HLS) format originally developed by Apple to stream video and radio to iOS devices, and which is now a popular format for adaptive streaming in general.\n\n> M3U (MP3 URL or Moving Picture Experts Group Audio Layer 3 Uniform Resource Locator in full) is a computer file format for a multimedia playlist. One common use of the M3U file format is creating a single-entry playlist file pointing to a stream on the Internet.\n\n> Although originally designed for audio files, such as MP3, it is commonly used to point media players to audio and video sources, including online sources.\n\n\n总结一下：\n\n1. M3U8 是M3U的Unicode版本，使用 UTF-8 编码， 是 HLS 的基础\n2. M3U 最初是为音频文件设计的，例如MP3， 现在不再局限于音频文件，可以用来索引音频和视频资源，网络资源\n3. 下面分析M3U 文件格式\n\n\n**M3U**\n\n> An M3U file is a plain text file that specifies the locations of one or more media files. The file is saved with the \"m3u\" filename extension if the text is encoded in the local system's default non-Unicode encoding (e.g., a Windows codepage), or with the \"m3u8\" extension if the text is UTF-8 encoded.\n\n总结一下：\n1. M3U 文件是纯文本文件，指定了资源文件的位置\n2. 以`.m3u`为文件后缀\n3. 使用 UTF-8 编码的版本，以 `.m3u8`为后缀\n\n\n## Extended M3U\n\n看一个例子：\n\n```\n#EXTM3U\n#EXT-X-PLAYLIST-TYPE:VOD\n#EXT-X-TARGETDURATION:10\n#EXT-X-VERSION:4\n#EXT-X-MEDIA-SEQUENCE:0\n#EXTINF:10.0,\nhttp://example.com/movie1/fileSequenceA.ts\n#EXTINF:10.0,\nhttp://example.com/movie1/fileSequenceB.ts\n#EXTINF:10.0,\nhttp://example.com/movie1/fileSequenceC.ts\n#EXTINF:9.0,\nhttp://example.com/movie1/fileSequenceD.ts\n#EXT-X-ENDLIST\n```\n\n语法：\n- Tags: begin with '#EXT'\n- Comments: only begin with '#'\n- 标签后面可以有参数，例如`#EXTINF:10.0`\n- 标签内容可以是：\n    1. an absolute local pathname\n    2. a local pathname relative to the M3U file location; e.g. Heavysets.mp3\n    3. a URL\n\n\n表格参考：[https://en.wikipedia.org/wiki/M3U](https://en.wikipedia.org/wiki/M3U)\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656557421391665655741667.png)\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656557911381665655790476.png)\n\n## 例子分析\n\n```\n#EXTM3U\n#EXT-X-PLAYLIST-TYPE:VOD\n#EXT-X-TARGETDURATION:10\n#EXT-X-VERSION:4\n#EXT-X-MEDIA-SEQUENCE:0\n#EXTINF:10.0,\nhttp://example.com/movie1/fileSequenceA.ts\n#EXTINF:10.0,\nhttp://example.com/movie1/fileSequenceB.ts\n#EXTINF:10.0,\nhttp://example.com/movie1/fileSequenceC.ts\n#EXTINF:9.0,\nhttp://example.com/movie1/fileSequenceD.ts\n#EXT-X-ENDLIST\n```\n\n**EXTM3U**\n\n表明是`extended M3U`文件， 区别于基本的`M3U`文件。m3u8文件必须以该标签开始。\n\n\n**EXT-X-PLAYLIST-TYPE**\n\n类型可以是：\n\n- VOD， 代表点播， 结尾包含`#EXT-X-ENDLIST`\n- EVENT， 代表直播, 结尾不包含`#EXT-X-ENDLIST`\n\n**EXT-X-TARGETDURATION**\n\n单个媒体文件的最大时长。每一个`#EXTINF:10.0`标签指定的时长`<=`EXT-X-TARGETDURATION\n\n**EXT-X-MEDIA-SEQUENCE**\n\n> Indicates the sequence number of the first URL that appears in a playlist file. Each media file URL in a playlist has a unique integer sequence number. The sequence number of a URL is higher by 1 than the sequence number of the URL that preceded it. The media sequence numbers have no relation to the names of the files.\n\nm3u8文件中第一个URL文件的编号，与文件名字无关，每次比前面的+1。\n\n**EXT-X-VERSION**\n\n> The EXT-X-VERSION tag indicates the compatibility version of the Playlist file. This file, its associated media, and its server must comply with all provisions of the IETF Internet-Draft of \"HTTP Live Streaming 2nd Edition\" (or earlier specifications) describing the protocol version indicated by the tag value. A Playlist file that doesn't contain an EXT-X-VERSION tag must comply with version 1 of this protocol.\n\n表明该m3u8文件的版本兼容性。该m3u8文件，关联的媒体，服务器必须服从于该版本特性。如果不包含该字段，必须服从与版本1的规定。\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656577590671665657758695.png)\n\n参考： [About the EXT-X-VERSION tag](https://developer.apple.com/documentation/http_live_streaming/about_the_ext-x-version_tag)\n\n\n**EXTINF**\n\n- 描述资源文件时长，URL\n- 时长： 版本小于3是int， 版本大于等于3是float, 单位秒\n\n**EXT-X-ENDLIST**\n\n结束标志，表明没有更多资源了。vod有，event可能没有。\n\n\n### VOD Playlist 点播\n\n```\n#EXTM3U\n#EXT-X-PLAYLIST-TYPE:VOD\n#EXT-X-TARGETDURATION:10\n#EXT-X-VERSION:4\n#EXT-X-MEDIA-SEQUENCE:0\n#EXTINF:10.0,\nhttp://example.com/movie1/fileSequenceA.ts\n#EXTINF:10.0,\nhttp://example.com/movie1/fileSequenceB.ts\n#EXTINF:10.0,\nhttp://example.com/movie1/fileSequenceC.ts\n#EXTINF:9.0,\nhttp://example.com/movie1/fileSequenceD.ts\n#EXT-X-ENDLIST\n```\n### live Playlist(Sliding Window) 直播滑动窗口\n\n> In live sessions, the index file is updated by removing media URIs from the file as new media files are created and made available. The EXT-X-ENDLIST tag isn't present in the live playlist, indicating that new media files will be added to the index file as they become available.\n\n直播流，m3u8文件会更新，前面的资源会被移除，后面的资源会被追加。\n没有`EXT-X-ENDLIST`标签，表示还会有新的资源被添加。\n\n看一个例子，开始时文件内容\n```\n#EXTM3U\n#EXT-X-TARGETDURATION:10\n#EXT-X-VERSION:4\n#EXT-X-MEDIA-SEQUENCE:1\n#EXTINF:10.0,\nfileSequence1.ts\n#EXTINF:10.0,\nfileSequence2.ts\n#EXTINF:10.0,\nfileSequence3.ts\n#EXTINF:10.0,\nfileSequence4.ts\n#EXTINF:10.0,\nfileSequence5.ts\n```\n\n旧资源被删除，新资被添加，看到`EXT-X-MEDIA-SEQUENCE`也发生了变化\n```\n#EXTM3U\n#EXT-X-TARGETDURATION:10\n#EXT-X-VERSION:4\n#EXT-X-MEDIA-SEQUENCE:2\n#EXTINF:10.0,\nfileSequence2.ts\n#EXTINF:10.0,\nfileSequence3.ts\n#EXTINF:10.00,\nfileSequence4.ts\n#EXTINF:10.00,\nfileSequence5.ts\n#EXTINF:10.0,\nfileSequence6.ts\n```\n\n再次更新\n```\n#EXTM3U\n#EXT-X-TARGETDURATION:10\n#EXT-X-VERSION:4\n#EXT-X-MEDIA-SEQUENCE:4\n#EXTINF:10.00,\nfileSequence4.ts\n#EXTINF:10.00,\nfileSequence5.ts\n#EXTINF:10.0,\nfileSequence6.ts,\n#EXTINF:10.0,\nfileSequence7.ts,\n#EXTINF:10.0,\nfileSequence8.ts,\n#EXTINF:10.0,\nfileSequence9.ts\n```\n\n### Event Playlist\n\n> An event playlist is specified by the EXT-X-PLAYLIST-TYPE tag with a value of EVENT. It doesn't initially have an EXT-X-ENDLIST tag, indicating that new media files will be added to the playlist as they become available.\n\n\n\n\n```\n#EXTM3U\n#EXT-X-PLAYLIST-TYPE:EVENT\n#EXT-X-TARGETDURATION:10\n#EXT-X-VERSION:4\n#EXT-X-MEDIA-SEQUENCE:0\n#EXTINF:10.00,\nfileSequence0.ts\n#EXTINF:10.0,\nfileSequence1.ts\n#EXTINF:10.0,\nfileSequence2.ts\n#EXTINF:10.0,\nfileSequence3.ts\n#EXTINF:10.0,\nfileSequence4.ts\n```\n\n观察到`#EXT-X-PLAYLIST-TYPE:EVENT`\n\n> If the tag is present and has a value of EVENT, the server must not change or delete any part of the playlist file (although it may append lines to it). If the tag is present and has a value of VOD, the playlist file must not change.\n\n> You can't remove anything from the playlist when using the EVENT tag; you may only append new segments to the end of the file. New segments are added to the end of the file until the event has concluded, at which time the EXT-X-ENDLIST tag is appended.\n\n如果类型为EVENT，更新m3u8文件，只能追加，不能删除。\n如果类型为VOD，不能更改m3u8播放列表。\n\n更新后\n```\n#EXTM3U\n#EXT-X-PLAYLIST-TYPE:EVENT\n#EXT-X-TARGETDURATION:10\n#EXT-X-VERSION:4\n#EXT-X-MEDIA-SEQUENCE:0\n#EXTINF:10.0,\nfileSequence0.ts\n#EXTINF:10.0,\nfileSequence1.ts\n#EXTINF:10.0,\nfileSequence2.ts\n#EXTINF:10.0,\nfileSequence3.ts\n#EXTINF:10.0,\nfileSequence4.ts\n\n// List of files between 4 and 120 go here.\n\n#EXTINF:10.0,\nfileSequence120.ts\n#EXTINF:10.0,\nfileSequence121.ts\n#EXT-X-ENDLIST\n```\n\n\n### Creating a Multivariant Playlist\n\n> Offer multiple playlist files to provide different encodings of the same content.\n\n为同一份内容，提供多个m3u8索引，每个m3u8采用不同的编码参数。\n\n\n> The Multivariant Playlist describes all of the available variants for your content. Each variant is a version of the stream at a particular bit rate and is contained in a separate playlist. The client switches to the most appropriate variant based on the measured network bit rate. The client’s player is tuned to minimize stalling of playback, to give the user the best possible streaming experience.\n\n为同一份内容，提供多个码率的m3u8,方便客户端播放器选择适应自身网络状况的最佳码率资源。\n\n结构图：\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656676568981665667656356.png)\n\n\n文件示例\n\n```\n#EXTM3U\n#EXT-X-STREAM-INF:BANDWIDTH=150000,RESOLUTION=416x234,CODECS=\"avc1.42e00a,mp4a.40.2\"\nhttp://example.com/low/index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=240000,RESOLUTION=416x234,CODECS=\"avc1.42e00a,mp4a.40.2\"\nhttp://example.com/lo_mid/index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=440000,RESOLUTION=416x234,CODECS=\"avc1.42e00a,mp4a.40.2\"\nhttp://example.com/hi_mid/index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=640000,RESOLUTION=640x360,CODECS=\"avc1.42e00a,mp4a.40.2\"\nhttp://example.com/high/index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=64000,CODECS=\"mp4a.40.5\"\nhttp://example.com/audio/index.m3u8\n```\n\n**EXT-X-STREAM-INF**\nIndicates that the next URL in the playlist file identifies another playlist file.\n\n表明它的URL内容是一个m3u8文件。\n\nThe EXT-X-STREAM-INF tag has the following parameters:\n\n**AVERAGE-BANDWIDTH**\n\n(Optional, but recommended) An integer that represents the average bit rate for the variant stream.\n\n平均码率，可选。\n\n\n**BANDWIDTH**\n\n(Required) An integer that is the upper bound of the overall bit rate for each media file, in bits per second. The upper bound value is calculated to include any container overhead that appears or will appear in the playlist.\n\n带宽。\n\n**FRAME-RATE**\n\n(Optional, but recommended) A floating-point value that describes the maximum frame rate in a variant stream.\n\n帧率，可选， 表示该流的最大帧率。\n\n**HDCP-LEVEL**\n\n(Optional) Indicates the type of encryption used. Valid values are TYPE-0 and NONE. Use TYPE-0 if the stream may not play unless the output is protected by HDCP.\n\n加密方式，可选。\n\n**RESOLUTION**\n\n(Optional, but recommended) The optional display size, in pixels, at which to display the video in the playlist. This parameter should be included for any stream that includes video.\n\n视频分辨率。\n\n\n**VIDEO-RANGE**\n\n(Required depending on encoding) A string with valid values of SDR or PQ. If transfer characteristic codes 1, 16, or 18 aren’t specified, then this parameter must be omitted.\n\n**CODECS**\n\n(Optional, but recommended) A quoted string containing a comma-separated list of formats, where each format specifies a media sample type that’s present in a media segment in the playlist file. Valid format identifiers are those in the ISO file format name space defined by RFC 6381.\n\n编码器相关参数。\n\n### Adding Alternate Media to a Playlist\n\n> Specify Rendition Playlists that can override the main presentation.\n\n> Adding alternate media to a Multivariant Playlist allows a provider to specify one of a set of variant playlists as an override of the main presentation. The client plays only the override media (audio or video), and suppresses any media of the same type from the main presentation, if present. This allows a presentation to offer multiple versions of the media without requiring the provider to store duplicate media, or requiring the client to download all variants when it only needs one. It also allows additional media to be offered subsequently without remastering the original content.\n\n在主音频视频资源外，提供多路备选资源。\n选择备选的音视频，客户端只会播放备选音视频资源。\n\n\n下面的例子，提供备选的多语言音频播放列表\n\n```\n#EXTM3U\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio\",LANGUAGE=\"eng\",NAME=\"English\",AUTOSELECT=YES, DEFAULT=YES,URI=\"eng/prog_index.m3u8\"\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio\",LANGUAGE=\"fre\",NAME=\"Français\",AUTOSELECT=YES, DEFAULT=NO,URI=\"fre/prog_index.m3u8\"\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio\",LANGUAGE=\"sp\",NAME=\"Espanol\",AUTOSELECT=YES, DEFAULT=NO,URI=\"sp/prog_index.m3u8\"\n\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=195023,CODECS=\"avc1.42e00a,mp4a.40.2\",AUDIO=\"audio\"\nlo/prog_index.m3u8\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=591680,CODECS=\"avc1.42e01e,mp4a.40.2\",AUDIO=\"audio\"\nhi/prog_index.m3u8\n```\n\nThe tags used in this Multivariant Playlist example include:\n\n**EXT-X-MEDIA**\nIdentifies an element of a media selection group. All the elements of a media selection group must have similar characteristics, for example, the same codecs and the same maximum bandwidth.\n\n表示媒体选项分组中的一个元素，同一个分组中的媒体具有相同的特征，如相同的编解码或带宽。\n\nEXT-X-STREAM-INF\nindicates that the next URL in the Multivariant Playlist identifies a Rendition Playlist. See Creating a Multivariant Playlist for the basic parameters.\n\n表明它的内容是一个索引， 指向一个m3u8文件\n\nThe EXT-X-MEDIA tag has the following parameters:\n\nTYPE\n(Required) A string indicating the type of media. Valid values are AUDIO, VIDEO, SUBTITLES, and CLOSED-CAPTIONS.\n\n媒体类型\n- AUDIO\n- VIDEO\n- SUBTITLES\n- CLOSED-CAPTIONS\n\n\nGROUP-ID\n(Required) A string specifying the group that the media selection belongs to.\n\n分组标识，字符串，必须有。\n\nLANGUAGE\n(Optional) A string that identifies the primary language used in the media selection.\n\n该选项中媒体文件对应的语言，可选。\n\nNAME\n(Required) A string that describes the primary language used in the media selection.\n\n该选项中媒体文件对应的语言的字符串标识，必须。\n\nAUTOSELECT\n(Optional) A string that indicates that the client may play the media selection in the absence of explicit user preference. Valid values are YES and NO. If the value of DEFAULT is YES, this value must also be YES.\n\n是否自动选择，可选。在用户偏好缺省的时候，指示客户端是否应该自动选择该选项。合法的值是YES和NO，\n如果`DEFAULT`是YES， 该字段的值必须也是YES.\n\nDEFAULT\n(Optional) A string indicating that the media selection should be played if the user hasn’t selected another option. Valid values are YES and NO.\n\n是否默认播放该选项，可选。用户没有选择其他选项的时候，是否默认播放该选项。\n\nINSTREAM-ID\n(Required for closed captions) A string that specifies a rendition within the segments in the media playlist. When the TYPE attribute is CLOSED-CAPTIONS, the INSTREAM-ID must have one of the following values: CC1, CC3, CC3, CC4, or SERVICEn, where n is between 1 and 63.\n\n\nASSOC-LANGUAGE\n(Optional) A string containing a language tag for the rendition. An associated language is often different from the language specified in the LANGUAGE attribute.\n\n关联的语言，可选。\n\nCHANNELS\n(Required when two renditions have the same codec but a different number of channels) An ordered string that indicates the maximum number of independent, simultaneous audio channels present in a media segment.\n\n表明该音频文件有几个声道\n\nURI\n(Optional) A string containing a URI that identifies the media playlist file. If the TYPE is CLOSED-CAPTIONS, this attribute must be omitted. When this attribute is omitted, the media content is in the original variant.\n\n媒体文件地址，可选。\n\nWhen its URI attribute is omitted, the EXT-X-MEDIA tag can indicate that the media described is included in the URI of the EXT-X-STREAM-INF tag.\n\n如果URI字段不存在，`EXT-X-MEDIA`描述的的媒体文件存在于`EXT-X-STREAM-INF`标签中。\n\nThe EXT-X-STREAM-INF tag has the following parameters:\n\nAUDIO\n(Optional) A quoted string that indicates the set of audio streams that may be used when playing the presentation. This value must match the value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the Multivariant Playlist whose TYPE attribute is AUDIO.\n\n\nVIDEO\n(Optional) A quoted string that indicates the set of video streams that may be used when playing the presentation. This value must match the value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the Multivariant Playlist whose TYPE attribute is VIDEO.\n\nSUBTITLES\n(Optional) A quoted string that indicates the set of subtitle renditions that can be used. This value must match the value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the Multivariant Playlist whose TYPE attribute is SUBTITLE.\n\nCLOSED-CAPTIONS\n(Optional) Either a quoted string that indicates the set of closed captions that can be used or an enumerated string with the value of NONE. When this value is a quoted string, it must match the value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the Multivariant Playlist whose TYPE attribute is CLOSED-CAPTIONS. If the enumerated value is NONE, all EXT-X-STREAM-INF tags must have this attribute with a value of NONE.\n\n\n总结一下：\n\n通过`EXT-X-MEDIA`可以定义资源组，可以有多个组，用GROUP-ID来区分， 有四种组类型\n- AUDIO\n- VIDEO\n- SUBTITLES\n- CLOSED-CAPTIONS\n\n每个分组中流属性是相同，其参数可以通过关联的`EXT-X-STREAM-INF`指定\n通过`EXT-X-STREAM-INF`定义资源组的流参数，带宽，编解码器信息。 它关联一个组ID，这个组内的所有备选媒体都具有相同的性质。\n\n\nYou can have multiple audio groups to allow changes in codes or bit rate. However, each audio group in a variant must have the same alternates in it. For example, you can’t have English in one audio group and leave it out of the other group. The following example defines two audio groups, one for low bit rates and one for high bit rates. Both audio groups define the same set of languages but are called based on the available bandwidth.\n\n每个组可以提供多个码率的媒体文件，其码率可以通过`EXT-X-STREAM-INF`指定，虽然`GROUP-ID`相同，但是码率是不同的。\n\n```\n#EXTM3U\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio-lo\",LANGUAGE=\"eng\",NAME=\"English\",AUTOSELECT=YES, DEFAULT=YES,URI=\"englo/prog_index.m3u8\"\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio-lo\",LANGUAGE=\"fre\",NAME=\"Français\",AUTOSELECT=YES, DEFAULT=NO,URI=\"frelo/prog_index.m3u8\"\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio-lo\",LANGUAGE=\"es\",NAME=\"Espanol\",AUTOSELECT=YES, DEFAULT=NO,URI=\"splo/prog_index.m3u8\"\n \n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio-hi\",LANGUAGE=\"eng\",NAME=\"English\",AUTOSELECT=YES, DEFAULT=YES,URI=\"eng/prog_index.m3u8\"\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio-hi\",LANGUAGE=\"fre\",NAME=\"Français\",AUTOSELECT=YES, DEFAULT=NO,URI=\"fre/prog_index.m3u8\"\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio-hi\",LANGUAGE=\"es\",NAME=\"Espanol\",AUTOSELECT=YES, DEFAULT=NO,URI=\"sp/prog_index.m3u8\"\n \n#EXT-X-STREAM-INF:BANDWIDTH=195023,CODECS=\"mp4a.40.5\", AUDIO=\"audio-lo\"\nlo/prog_index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=260000,CODECS=\"avc1.42e01e,mp4a.40.2\", AUDIO=\"audio-lo\"\nhi/prog_index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=591680,CODECS=\"mp4a.40.2, avc1.64001e\", AUDIO=\"audio-hi\"\nlo/prog_index.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=650000,CODECS=\"avc1.42e01e,mp4a.40.2\", AUDIO=\"audio-hi\"\nhi/prog_index.m3u8\n\n```\n\nYou can have both a group and a single stream in a playlist. This is often done when you have multiple camera angles that all use the same audio. Create a group for the video streams and then declare the single audio stream. The following example shows a playlist with three camera angles and a single audio stream:\n\n一个视频组关联单个音频的情况。\n\n```\n#EXTM3U\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"500kbs\",NAME=\"Angle1\",AUTOSELECT=YES,DEFAULT=YES\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"500kbs\",NAME=\"Angle2\",AUTOSELECT=YES,DEFAULT=NO, URI=\"Angle2/500kbs/prog_index.m3u8\"\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"500kbs\",NAME=\"Angle3\",AUTOSELECT=YES,DEFAULT=NO, URI=\"Angle3/500kbs/prog_index.m3u8\"\n\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"aac\",LANGUAGE=\"en\",NAME=\"English\",AUTOSELECT=YES, DEFAULT=YES,URI=\"eng/prog_index.m3u8\"\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=754857,CODECS=\"mp4a.40.2,avc1.4d401e\", VIDEO=\"500kbs\",AUDIO=\"aac\"\nAngle1/500kbs/prog_index.m3u8\n```\n\nTo provide different streams for different bit rates, a different video group ID is needed for each bit rate.\n\n```\n#EXTM3U\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"200kbs\",NAME=\"Angle1\",AUTOSELECT=YES,DEFAULT=YES\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"200kbs\",NAME=\"Angle2\",AUTOSELECT=YES,DEFAULT=NO, URI=\"Angle2/200kbs/prog_index.m3u8\"\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"200kbs\",NAME=\"Angle3\",AUTOSELECT=YES,DEFAULT=NO, URI=\"Angle3/200kbs/prog_index.m3u8\"\n\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"500kbs\",NAME=\"Angle1\",AUTOSELECT=YES,DEFAULT=YES\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"500kbs\",NAME=\"Angle2\",AUTOSELECT=YES,DEFAULT=NO, URI=\"Angle2/500kbs/prog_index.m3u8\"\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"500kbs\",NAME=\"Angle3\",AUTOSELECT=YES,DEFAULT=NO, URI=\"Angle3/500kbs/prog_index.m3u8\"\n\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"aac\",LANGUAGE=\"en\",NAME=\"English\",AUTOSELECT=YES, DEFAULT=YES,URI=\"eng/prog_index.m3u8\"\n\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=300000,CODECS=\"mp4a.40.2,avc1.4d401e\", VIDEO=\"200kbs\",AUDIO=\"aac\"\nAngle1/200kbs/prog_index.m3u\n\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=754857,CODECS=\"mp4a.40.2,avc1.4d401e\", VIDEO=\"500kbs\",AUDIO=\"aac\"\nAngle1/500kbs/prog_index.m3u8\n```\n\n参考：\nhttps://developer.apple.com/documentation/http_live_streaming\nhttps://aleen42.gitbooks.io/wiki/content/summary/m3u8/m3u8.html","slug":"hls/2022-10-13-HLS-介绍","published":1,"updated":"2024-03-06T11:53:13.567Z","comments":1,"photos":[],"_id":"cltgopenb001fqywhex55ebdo","content":"<h1 id=\"HLS-是什么\"><a href=\"#HLS-是什么\" class=\"headerlink\" title=\"HLS 是什么\"></a>HLS 是什么</h1><p>维基百科的介绍：</p>\n<p>HTTP Live Streaming，缩写为HLS，是由苹果公司提出基于HTTP的流媒体网络传输协议。是苹果公司QuickTime X和iPhone软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的扩充 M3U (m3u8) 播放列表文件，用于寻找可用的媒体流。</p>\n<p>HLS只请求基本的HTTP报文，与实时传输协议（RTP）不同，HLS可以穿过任何允许HTTP数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。</p>\n<p>苹果公司把HLS协议作为一个互联网草案（逐步提交），在第一阶段中已作为一个非正式的标准提交到IETF。2017年8月，RFC 8216发布，描述了HLS协议第7版的定义。</p>\n<p>苹果自己的介绍：</p>\n<blockquote>\n<p>Send live and on‐demand audio and video to iPhone, iPad, Mac, Apple Watch, Apple TV, and PC with HTTP Live Streaming (HLS) technology from Apple. Using the same protocol that powers the web, HLS lets you deploy content using ordinary web servers and content delivery networks. HLS is designed for reliability and dynamically adapts to network conditions by optimizing playback for the available speed of wired and wireless connections.</p>\n</blockquote>\n<p>总结一下：</p>\n<ol>\n<li>基于HTTP的流媒体网络传输协议，支持安全通信（通过https, 媒体数据加密等）</li>\n<li>工作原理是把整个流分成一个个小的基于HTTP的文件来下载, 使用m3u8描述播放列表。</li>\n<li>支持直播和点播（VOD， video on demand）</li>\n<li>当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率</li>\n</ol>\n<h2 id=\"HLS-流媒体架构\"><a href=\"#HLS-流媒体架构\" class=\"headerlink\" title=\"HLS 流媒体架构\"></a>HLS 流媒体架构</h2><blockquote>\n<p>Conceptually, HTTP Live Streaming consists of three parts: the server component, the distribution component, and the client software.</p>\n<p>In a typical configuration, a hardware encoder takes audio-video input, encodes it as HEVC video and AC-3 audio, and outputs a fragmented MPEG-4 file or an MPEG-2 transport stream. A software stream segmenter then breaks the stream into a series of short media files, which are placed on a web server. The segmenter also creates and maintains an index file containing a list of the media files. The URL of the index file is published on the web server. Client software reads the index, then requests the listed media files in order and displays them without any pauses or gaps between segments.</p>\n</blockquote>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656504345291665650434432.png\"></p>\n<p>概念上，HLS 包含</p>\n<ul>\n<li>服务端组件</li>\n<li>分发组件</li>\n<li>客户端软件</li>\n</ul>\n<p>步骤：</p>\n<ol>\n<li>服务端硬件编码器，将音视频输入编码(视频编码成HEVC，H264, 音频编码成AAC，AC-3)， 输出ts流（也可以生成分段的mp4文件， 很少用）</li>\n<li>分段软件会将ts流分割，打包成ts文件，同时生成索引文件（m3u8）,索引文件保存了媒体文件的信息。</li>\n<li>客户端读取m3u8索引文件，下载对应的ts文件，将内容播放给用户</li>\n</ol>\n<p>苹果提供了一套用于HLS的工具集，参考：</p>\n<p><a href=\"https://developer.apple.com/documentation/http_live_streaming/using_apple_s_http_live_streaming_hls_tools\">Using Apple’s HTTP Live Streaming (HLS) Tools</a></p>\n<ul>\n<li>Media File Segmenter (mediafilesegmenter), 媒体文件分割器</li>\n<li>Media Subtitle Segmenter (mediasubtitlesegmenter)， 字幕分割器</li>\n<li>Media Stream Segmenter (mediastreamsegmenter) 媒体流分割器</li>\n<li>Variant Playlist Creator (variantplaylistcreator) 可变播放列表生成器</li>\n<li>…</li>\n</ul>\n<h1 id=\"M3U8\"><a href=\"#M3U8\" class=\"headerlink\" title=\"M3U8\"></a>M3U8</h1><blockquote>\n<p>The Unicode version of M3U is M3U8, which uses UTF-8-encoded characters. M3U8 files are the basis for the HTTP Live Streaming (HLS) format originally developed by Apple to stream video and radio to iOS devices, and which is now a popular format for adaptive streaming in general.</p>\n</blockquote>\n<blockquote>\n<p>M3U (MP3 URL or Moving Picture Experts Group Audio Layer 3 Uniform Resource Locator in full) is a computer file format for a multimedia playlist. One common use of the M3U file format is creating a single-entry playlist file pointing to a stream on the Internet.</p>\n</blockquote>\n<blockquote>\n<p>Although originally designed for audio files, such as MP3, it is commonly used to point media players to audio and video sources, including online sources.</p>\n</blockquote>\n<p>总结一下：</p>\n<ol>\n<li>M3U8 是M3U的Unicode版本，使用 UTF-8 编码， 是 HLS 的基础</li>\n<li>M3U 最初是为音频文件设计的，例如MP3， 现在不再局限于音频文件，可以用来索引音频和视频资源，网络资源</li>\n<li>下面分析M3U 文件格式</li>\n</ol>\n<p><strong>M3U</strong></p>\n<blockquote>\n<p>An M3U file is a plain text file that specifies the locations of one or more media files. The file is saved with the “m3u” filename extension if the text is encoded in the local system’s default non-Unicode encoding (e.g., a Windows codepage), or with the “m3u8” extension if the text is UTF-8 encoded.</p>\n</blockquote>\n<p>总结一下：</p>\n<ol>\n<li>M3U 文件是纯文本文件，指定了资源文件的位置</li>\n<li>以<code>.m3u</code>为文件后缀</li>\n<li>使用 UTF-8 编码的版本，以 <code>.m3u8</code>为后缀</li>\n</ol>\n<h2 id=\"Extended-M3U\"><a href=\"#Extended-M3U\" class=\"headerlink\" title=\"Extended M3U\"></a>Extended M3U</h2><p>看一个例子：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-comment\">#EXTM3U</span><br><span class=\"hljs-comment\">#EXT-X-PLAYLIST-TYPE:VOD</span><br><span class=\"hljs-comment\">#EXT-X-TARGETDURATION:10</span><br><span class=\"hljs-comment\">#EXT-X-VERSION:4</span><br><span class=\"hljs-comment\">#EXT-X-MEDIA-SEQUENCE:0</span><br><span class=\"hljs-comment\">#EXTINF:10.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceA.ts<br><span class=\"hljs-comment\">#EXTINF:10.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceB.ts<br><span class=\"hljs-comment\">#EXTINF:10.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceC.ts<br><span class=\"hljs-comment\">#EXTINF:9.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceD.ts<br><span class=\"hljs-comment\">#EXT-X-ENDLIST</span><br></code></pre></td></tr></table></figure>\n\n<p>语法：</p>\n<ul>\n<li>Tags: begin with ‘#EXT’</li>\n<li>Comments: only begin with ‘#’</li>\n<li>标签后面可以有参数，例如<code>#EXTINF:10.0</code></li>\n<li>标签内容可以是：<ol>\n<li>an absolute local pathname</li>\n<li>a local pathname relative to the M3U file location; e.g. Heavysets.mp3</li>\n<li>a URL</li>\n</ol>\n</li>\n</ul>\n<p>表格参考：<a href=\"https://en.wikipedia.org/wiki/M3U\">https://en.wikipedia.org/wiki/M3U</a></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656557421391665655741667.png\"></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656557911381665655790476.png\"></p>\n<h2 id=\"例子分析\"><a href=\"#例子分析\" class=\"headerlink\" title=\"例子分析\"></a>例子分析</h2><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-comment\">#EXTM3U</span><br><span class=\"hljs-comment\">#EXT-X-PLAYLIST-TYPE:VOD</span><br><span class=\"hljs-comment\">#EXT-X-TARGETDURATION:10</span><br><span class=\"hljs-comment\">#EXT-X-VERSION:4</span><br><span class=\"hljs-comment\">#EXT-X-MEDIA-SEQUENCE:0</span><br><span class=\"hljs-comment\">#EXTINF:10.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceA.ts<br><span class=\"hljs-comment\">#EXTINF:10.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceB.ts<br><span class=\"hljs-comment\">#EXTINF:10.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceC.ts<br><span class=\"hljs-comment\">#EXTINF:9.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceD.ts<br><span class=\"hljs-comment\">#EXT-X-ENDLIST</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>EXTM3U</strong></p>\n<p>表明是<code>extended M3U</code>文件， 区别于基本的<code>M3U</code>文件。m3u8文件必须以该标签开始。</p>\n<p><strong>EXT-X-PLAYLIST-TYPE</strong></p>\n<p>类型可以是：</p>\n<ul>\n<li>VOD， 代表点播， 结尾包含<code>#EXT-X-ENDLIST</code></li>\n<li>EVENT， 代表直播, 结尾不包含<code>#EXT-X-ENDLIST</code></li>\n</ul>\n<p><strong>EXT-X-TARGETDURATION</strong></p>\n<p>单个媒体文件的最大时长。每一个<code>#EXTINF:10.0</code>标签指定的时长<code>&lt;=</code>EXT-X-TARGETDURATION</p>\n<p><strong>EXT-X-MEDIA-SEQUENCE</strong></p>\n<blockquote>\n<p>Indicates the sequence number of the first URL that appears in a playlist file. Each media file URL in a playlist has a unique integer sequence number. The sequence number of a URL is higher by 1 than the sequence number of the URL that preceded it. The media sequence numbers have no relation to the names of the files.</p>\n</blockquote>\n<p>m3u8文件中第一个URL文件的编号，与文件名字无关，每次比前面的+1。</p>\n<p><strong>EXT-X-VERSION</strong></p>\n<blockquote>\n<p>The EXT-X-VERSION tag indicates the compatibility version of the Playlist file. This file, its associated media, and its server must comply with all provisions of the IETF Internet-Draft of “HTTP Live Streaming 2nd Edition” (or earlier specifications) describing the protocol version indicated by the tag value. A Playlist file that doesn’t contain an EXT-X-VERSION tag must comply with version 1 of this protocol.</p>\n</blockquote>\n<p>表明该m3u8文件的版本兼容性。该m3u8文件，关联的媒体，服务器必须服从于该版本特性。如果不包含该字段，必须服从与版本1的规定。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656577590671665657758695.png\"></p>\n<p>参考： <a href=\"https://developer.apple.com/documentation/http_live_streaming/about_the_ext-x-version_tag\">About the EXT-X-VERSION tag</a></p>\n<p><strong>EXTINF</strong></p>\n<ul>\n<li>描述资源文件时长，URL</li>\n<li>时长： 版本小于3是int， 版本大于等于3是float, 单位秒</li>\n</ul>\n<p><strong>EXT-X-ENDLIST</strong></p>\n<p>结束标志，表明没有更多资源了。vod有，event可能没有。</p>\n<h3 id=\"VOD-Playlist-点播\"><a href=\"#VOD-Playlist-点播\" class=\"headerlink\" title=\"VOD Playlist 点播\"></a>VOD Playlist 点播</h3><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-comment\">#EXTM3U</span><br><span class=\"hljs-comment\">#EXT-X-PLAYLIST-TYPE:VOD</span><br><span class=\"hljs-comment\">#EXT-X-TARGETDURATION:10</span><br><span class=\"hljs-comment\">#EXT-X-VERSION:4</span><br><span class=\"hljs-comment\">#EXT-X-MEDIA-SEQUENCE:0</span><br><span class=\"hljs-comment\">#EXTINF:10.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceA.ts<br><span class=\"hljs-comment\">#EXTINF:10.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceB.ts<br><span class=\"hljs-comment\">#EXTINF:10.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceC.ts<br><span class=\"hljs-comment\">#EXTINF:9.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceD.ts<br><span class=\"hljs-comment\">#EXT-X-ENDLIST</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"live-Playlist-Sliding-Window-直播滑动窗口\"><a href=\"#live-Playlist-Sliding-Window-直播滑动窗口\" class=\"headerlink\" title=\"live Playlist(Sliding Window) 直播滑动窗口\"></a>live Playlist(Sliding Window) 直播滑动窗口</h3><blockquote>\n<p>In live sessions, the index file is updated by removing media URIs from the file as new media files are created and made available. The EXT-X-ENDLIST tag isn’t present in the live playlist, indicating that new media files will be added to the index file as they become available.</p>\n</blockquote>\n<p>直播流，m3u8文件会更新，前面的资源会被移除，后面的资源会被追加。<br>没有<code>EXT-X-ENDLIST</code>标签，表示还会有新的资源被添加。</p>\n<p>看一个例子，开始时文件内容</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\"><span class=\"hljs-attr\">#EXTM3</span>U<br><span class=\"hljs-attr\">#EXT-X-TARGETDURATION:10</span><br><span class=\"hljs-attr\">#EXT-X-VERSION:4</span><br><span class=\"hljs-attr\">#EXT-X-MEDIA-SEQUENCE:1</span><br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce1</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce2</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce3</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce4</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce5</span>.ts<br></code></pre></td></tr></table></figure>\n\n<p>旧资源被删除，新资被添加，看到<code>EXT-X-MEDIA-SEQUENCE</code>也发生了变化</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\"><span class=\"hljs-attr\">#EXTM3</span>U<br><span class=\"hljs-attr\">#EXT-X-TARGETDURATION:10</span><br><span class=\"hljs-attr\">#EXT-X-VERSION:4</span><br><span class=\"hljs-attr\">#EXT-X-MEDIA-SEQUENCE:2</span><br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce2</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce3</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.00</span>,<br>fileSeque<span class=\"hljs-symbol\">nce4</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.00</span>,<br>fileSeque<span class=\"hljs-symbol\">nce5</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce6</span>.ts<br></code></pre></td></tr></table></figure>\n\n<p>再次更新</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\"><span class=\"hljs-attr\">#EXTM3</span>U<br><span class=\"hljs-attr\">#EXT-X-TARGETDURATION:10</span><br><span class=\"hljs-attr\">#EXT-X-VERSION:4</span><br><span class=\"hljs-attr\">#EXT-X-MEDIA-SEQUENCE:4</span><br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.00</span>,<br>fileSeque<span class=\"hljs-symbol\">nce4</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.00</span>,<br>fileSeque<span class=\"hljs-symbol\">nce5</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce6</span>.ts,<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce7</span>.ts,<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce8</span>.ts,<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce9</span>.ts<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Event-Playlist\"><a href=\"#Event-Playlist\" class=\"headerlink\" title=\"Event Playlist\"></a>Event Playlist</h3><blockquote>\n<p>An event playlist is specified by the EXT-X-PLAYLIST-TYPE tag with a value of EVENT. It doesn’t initially have an EXT-X-ENDLIST tag, indicating that new media files will be added to the playlist as they become available.</p>\n</blockquote>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\"><span class=\"hljs-attr\">#EXTM3</span>U<br><span class=\"hljs-attr\">#EXT-X-PLAYLIST-TYPE:EVENT</span><br><span class=\"hljs-attr\">#EXT-X-TARGETDURATION:10</span><br><span class=\"hljs-attr\">#EXT-X-VERSION:4</span><br><span class=\"hljs-attr\">#EXT-X-MEDIA-SEQUENCE:0</span><br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.00</span>,<br>fileSeque<span class=\"hljs-symbol\">nce0</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce1</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce2</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce3</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce4</span>.ts<br></code></pre></td></tr></table></figure>\n\n<p>观察到<code>#EXT-X-PLAYLIST-TYPE:EVENT</code></p>\n<blockquote>\n<p>If the tag is present and has a value of EVENT, the server must not change or delete any part of the playlist file (although it may append lines to it). If the tag is present and has a value of VOD, the playlist file must not change.</p>\n</blockquote>\n<blockquote>\n<p>You can’t remove anything from the playlist when using the EVENT tag; you may only append new segments to the end of the file. New segments are added to the end of the file until the event has concluded, at which time the EXT-X-ENDLIST tag is appended.</p>\n</blockquote>\n<p>如果类型为EVENT，更新m3u8文件，只能追加，不能删除。<br>如果类型为VOD，不能更改m3u8播放列表。</p>\n<p>更新后</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-selector-id\">#EXTM3U</span><br><span class=\"hljs-selector-id\">#EXT-X-PLAYLIST-TYPE</span>:EVENT<br><span class=\"hljs-selector-id\">#EXT-X-TARGETDURATION</span>:<span class=\"hljs-number\">10</span><br><span class=\"hljs-selector-id\">#EXT-X-VERSION</span>:<span class=\"hljs-number\">4</span><br><span class=\"hljs-selector-id\">#EXT-X-MEDIA-SEQUENCE</span>:<span class=\"hljs-number\">0</span><br><span class=\"hljs-selector-id\">#EXTINF</span>:<span class=\"hljs-number\">10.0</span>,<br>fileSequence0<span class=\"hljs-selector-class\">.ts</span><br><span class=\"hljs-selector-id\">#EXTINF</span>:<span class=\"hljs-number\">10.0</span>,<br>fileSequence1<span class=\"hljs-selector-class\">.ts</span><br><span class=\"hljs-selector-id\">#EXTINF</span>:<span class=\"hljs-number\">10.0</span>,<br>fileSequence2<span class=\"hljs-selector-class\">.ts</span><br><span class=\"hljs-selector-id\">#EXTINF</span>:<span class=\"hljs-number\">10.0</span>,<br>fileSequence3<span class=\"hljs-selector-class\">.ts</span><br><span class=\"hljs-selector-id\">#EXTINF</span>:<span class=\"hljs-number\">10.0</span>,<br>fileSequence4<span class=\"hljs-selector-class\">.ts</span><br><br><span class=\"hljs-comment\">// List of files between 4 and 120 go here.</span><br><br><span class=\"hljs-selector-id\">#EXTINF</span>:<span class=\"hljs-number\">10.0</span>,<br>fileSequence120<span class=\"hljs-selector-class\">.ts</span><br><span class=\"hljs-selector-id\">#EXTINF</span>:<span class=\"hljs-number\">10.0</span>,<br>fileSequence121<span class=\"hljs-selector-class\">.ts</span><br>#EXT-X-ENDLIST<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"Creating-a-Multivariant-Playlist\"><a href=\"#Creating-a-Multivariant-Playlist\" class=\"headerlink\" title=\"Creating a Multivariant Playlist\"></a>Creating a Multivariant Playlist</h3><blockquote>\n<p>Offer multiple playlist files to provide different encodings of the same content.</p>\n</blockquote>\n<p>为同一份内容，提供多个m3u8索引，每个m3u8采用不同的编码参数。</p>\n<blockquote>\n<p>The Multivariant Playlist describes all of the available variants for your content. Each variant is a version of the stream at a particular bit rate and is contained in a separate playlist. The client switches to the most appropriate variant based on the measured network bit rate. The client’s player is tuned to minimize stalling of playback, to give the user the best possible streaming experience.</p>\n</blockquote>\n<p>为同一份内容，提供多个码率的m3u8,方便客户端播放器选择适应自身网络状况的最佳码率资源。</p>\n<p>结构图：</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656676568981665667656356.png\"></p>\n<p>文件示例</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dts\"><span class=\"hljs-meta\">#EXTM3U</span><br><span class=\"hljs-meta\">#EXT-X-STREAM-INF:BANDWIDTH=150000,RESOLUTION=416x234,CODECS=<span class=\"hljs-string\">&quot;avc1.42e00a,mp4a.40.2&quot;</span></span><br><span class=\"hljs-symbol\">http:</span><span class=\"hljs-comment\">//example.com/low/index.m3u8</span><br><span class=\"hljs-meta\">#EXT-X-STREAM-INF:BANDWIDTH=240000,RESOLUTION=416x234,CODECS=<span class=\"hljs-string\">&quot;avc1.42e00a,mp4a.40.2&quot;</span></span><br><span class=\"hljs-symbol\">http:</span><span class=\"hljs-comment\">//example.com/lo_mid/index.m3u8</span><br><span class=\"hljs-meta\">#EXT-X-STREAM-INF:BANDWIDTH=440000,RESOLUTION=416x234,CODECS=<span class=\"hljs-string\">&quot;avc1.42e00a,mp4a.40.2&quot;</span></span><br><span class=\"hljs-symbol\">http:</span><span class=\"hljs-comment\">//example.com/hi_mid/index.m3u8</span><br><span class=\"hljs-meta\">#EXT-X-STREAM-INF:BANDWIDTH=640000,RESOLUTION=640x360,CODECS=<span class=\"hljs-string\">&quot;avc1.42e00a,mp4a.40.2&quot;</span></span><br><span class=\"hljs-symbol\">http:</span><span class=\"hljs-comment\">//example.com/high/index.m3u8</span><br><span class=\"hljs-meta\">#EXT-X-STREAM-INF:BANDWIDTH=64000,CODECS=<span class=\"hljs-string\">&quot;mp4a.40.5&quot;</span></span><br><span class=\"hljs-symbol\">http:</span><span class=\"hljs-comment\">//example.com/audio/index.m3u8</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>EXT-X-STREAM-INF</strong><br>Indicates that the next URL in the playlist file identifies another playlist file.</p>\n<p>表明它的URL内容是一个m3u8文件。</p>\n<p>The EXT-X-STREAM-INF tag has the following parameters:</p>\n<p><strong>AVERAGE-BANDWIDTH</strong></p>\n<p>(Optional, but recommended) An integer that represents the average bit rate for the variant stream.</p>\n<p>平均码率，可选。</p>\n<p><strong>BANDWIDTH</strong></p>\n<p>(Required) An integer that is the upper bound of the overall bit rate for each media file, in bits per second. The upper bound value is calculated to include any container overhead that appears or will appear in the playlist.</p>\n<p>带宽。</p>\n<p><strong>FRAME-RATE</strong></p>\n<p>(Optional, but recommended) A floating-point value that describes the maximum frame rate in a variant stream.</p>\n<p>帧率，可选， 表示该流的最大帧率。</p>\n<p><strong>HDCP-LEVEL</strong></p>\n<p>(Optional) Indicates the type of encryption used. Valid values are TYPE-0 and NONE. Use TYPE-0 if the stream may not play unless the output is protected by HDCP.</p>\n<p>加密方式，可选。</p>\n<p><strong>RESOLUTION</strong></p>\n<p>(Optional, but recommended) The optional display size, in pixels, at which to display the video in the playlist. This parameter should be included for any stream that includes video.</p>\n<p>视频分辨率。</p>\n<p><strong>VIDEO-RANGE</strong></p>\n<p>(Required depending on encoding) A string with valid values of SDR or PQ. If transfer characteristic codes 1, 16, or 18 aren’t specified, then this parameter must be omitted.</p>\n<p><strong>CODECS</strong></p>\n<p>(Optional, but recommended) A quoted string containing a comma-separated list of formats, where each format specifies a media sample type that’s present in a media segment in the playlist file. Valid format identifiers are those in the ISO file format name space defined by RFC 6381.</p>\n<p>编码器相关参数。</p>\n<h3 id=\"Adding-Alternate-Media-to-a-Playlist\"><a href=\"#Adding-Alternate-Media-to-a-Playlist\" class=\"headerlink\" title=\"Adding Alternate Media to a Playlist\"></a>Adding Alternate Media to a Playlist</h3><blockquote>\n<p>Specify Rendition Playlists that can override the main presentation.</p>\n</blockquote>\n<blockquote>\n<p>Adding alternate media to a Multivariant Playlist allows a provider to specify one of a set of variant playlists as an override of the main presentation. The client plays only the override media (audio or video), and suppresses any media of the same type from the main presentation, if present. This allows a presentation to offer multiple versions of the media without requiring the provider to store duplicate media, or requiring the client to download all variants when it only needs one. It also allows additional media to be offered subsequently without remastering the original content.</p>\n</blockquote>\n<p>在主音频视频资源外，提供多路备选资源。<br>选择备选的音视频，客户端只会播放备选音视频资源。</p>\n<p>下面的例子，提供备选的多语言音频播放列表</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\">#EXTM3U<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;audio&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;eng&quot;</span>,NAME=<span class=\"hljs-string\">&quot;English&quot;</span>,AUTOSELECT=YES, DEFAULT=YES,URI=<span class=\"hljs-string\">&quot;eng/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;audio&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;fre&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Français&quot;</span>,AUTOSELECT=YES, DEFAULT=NO,URI=<span class=\"hljs-string\">&quot;fre/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;audio&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;sp&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Espanol&quot;</span>,AUTOSELECT=YES, DEFAULT=NO,URI=<span class=\"hljs-string\">&quot;sp/prog_index.m3u8&quot;</span><br><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-STREAM</span><span class=\"hljs-params\">-INF</span>:PROGRAM<span class=\"hljs-params\">-ID</span>=<span class=\"hljs-number\">1</span>,BANDWIDTH=<span class=\"hljs-number\">195023</span>,CODECS=<span class=\"hljs-string\">&quot;avc1.42e00a,mp4a.40.2&quot;</span>,AUDIO=<span class=\"hljs-string\">&quot;audio&quot;</span><br>lo/prog_index.m3u8<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-STREAM</span><span class=\"hljs-params\">-INF</span>:PROGRAM<span class=\"hljs-params\">-ID</span>=<span class=\"hljs-number\">1</span>,BANDWIDTH=<span class=\"hljs-number\">591680</span>,CODECS=<span class=\"hljs-string\">&quot;avc1.42e01e,mp4a.40.2&quot;</span>,AUDIO=<span class=\"hljs-string\">&quot;audio&quot;</span><br>hi/prog_index.m3u8<br></code></pre></td></tr></table></figure>\n\n<p>The tags used in this Multivariant Playlist example include:</p>\n<p><strong>EXT-X-MEDIA</strong><br>Identifies an element of a media selection group. All the elements of a media selection group must have similar characteristics, for example, the same codecs and the same maximum bandwidth.</p>\n<p>表示媒体选项分组中的一个元素，同一个分组中的媒体具有相同的特征，如相同的编解码或带宽。</p>\n<p>EXT-X-STREAM-INF<br>indicates that the next URL in the Multivariant Playlist identifies a Rendition Playlist. See Creating a Multivariant Playlist for the basic parameters.</p>\n<p>表明它的内容是一个索引， 指向一个m3u8文件</p>\n<p>The EXT-X-MEDIA tag has the following parameters:</p>\n<p>TYPE<br>(Required) A string indicating the type of media. Valid values are AUDIO, VIDEO, SUBTITLES, and CLOSED-CAPTIONS.</p>\n<p>媒体类型</p>\n<ul>\n<li>AUDIO</li>\n<li>VIDEO</li>\n<li>SUBTITLES</li>\n<li>CLOSED-CAPTIONS</li>\n</ul>\n<p>GROUP-ID<br>(Required) A string specifying the group that the media selection belongs to.</p>\n<p>分组标识，字符串，必须有。</p>\n<p>LANGUAGE<br>(Optional) A string that identifies the primary language used in the media selection.</p>\n<p>该选项中媒体文件对应的语言，可选。</p>\n<p>NAME<br>(Required) A string that describes the primary language used in the media selection.</p>\n<p>该选项中媒体文件对应的语言的字符串标识，必须。</p>\n<p>AUTOSELECT<br>(Optional) A string that indicates that the client may play the media selection in the absence of explicit user preference. Valid values are YES and NO. If the value of DEFAULT is YES, this value must also be YES.</p>\n<p>是否自动选择，可选。在用户偏好缺省的时候，指示客户端是否应该自动选择该选项。合法的值是YES和NO，<br>如果<code>DEFAULT</code>是YES， 该字段的值必须也是YES.</p>\n<p>DEFAULT<br>(Optional) A string indicating that the media selection should be played if the user hasn’t selected another option. Valid values are YES and NO.</p>\n<p>是否默认播放该选项，可选。用户没有选择其他选项的时候，是否默认播放该选项。</p>\n<p>INSTREAM-ID<br>(Required for closed captions) A string that specifies a rendition within the segments in the media playlist. When the TYPE attribute is CLOSED-CAPTIONS, the INSTREAM-ID must have one of the following values: CC1, CC3, CC3, CC4, or SERVICEn, where n is between 1 and 63.</p>\n<p>ASSOC-LANGUAGE<br>(Optional) A string containing a language tag for the rendition. An associated language is often different from the language specified in the LANGUAGE attribute.</p>\n<p>关联的语言，可选。</p>\n<p>CHANNELS<br>(Required when two renditions have the same codec but a different number of channels) An ordered string that indicates the maximum number of independent, simultaneous audio channels present in a media segment.</p>\n<p>表明该音频文件有几个声道</p>\n<p>URI<br>(Optional) A string containing a URI that identifies the media playlist file. If the TYPE is CLOSED-CAPTIONS, this attribute must be omitted. When this attribute is omitted, the media content is in the original variant.</p>\n<p>媒体文件地址，可选。</p>\n<p>When its URI attribute is omitted, the EXT-X-MEDIA tag can indicate that the media described is included in the URI of the EXT-X-STREAM-INF tag.</p>\n<p>如果URI字段不存在，<code>EXT-X-MEDIA</code>描述的的媒体文件存在于<code>EXT-X-STREAM-INF</code>标签中。</p>\n<p>The EXT-X-STREAM-INF tag has the following parameters:</p>\n<p>AUDIO<br>(Optional) A quoted string that indicates the set of audio streams that may be used when playing the presentation. This value must match the value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the Multivariant Playlist whose TYPE attribute is AUDIO.</p>\n<p>VIDEO<br>(Optional) A quoted string that indicates the set of video streams that may be used when playing the presentation. This value must match the value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the Multivariant Playlist whose TYPE attribute is VIDEO.</p>\n<p>SUBTITLES<br>(Optional) A quoted string that indicates the set of subtitle renditions that can be used. This value must match the value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the Multivariant Playlist whose TYPE attribute is SUBTITLE.</p>\n<p>CLOSED-CAPTIONS<br>(Optional) Either a quoted string that indicates the set of closed captions that can be used or an enumerated string with the value of NONE. When this value is a quoted string, it must match the value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the Multivariant Playlist whose TYPE attribute is CLOSED-CAPTIONS. If the enumerated value is NONE, all EXT-X-STREAM-INF tags must have this attribute with a value of NONE.</p>\n<p>总结一下：</p>\n<p>通过<code>EXT-X-MEDIA</code>可以定义资源组，可以有多个组，用GROUP-ID来区分， 有四种组类型</p>\n<ul>\n<li>AUDIO</li>\n<li>VIDEO</li>\n<li>SUBTITLES</li>\n<li>CLOSED-CAPTIONS</li>\n</ul>\n<p>每个分组中流属性是相同，其参数可以通过关联的<code>EXT-X-STREAM-INF</code>指定<br>通过<code>EXT-X-STREAM-INF</code>定义资源组的流参数，带宽，编解码器信息。 它关联一个组ID，这个组内的所有备选媒体都具有相同的性质。</p>\n<p>You can have multiple audio groups to allow changes in codes or bit rate. However, each audio group in a variant must have the same alternates in it. For example, you can’t have English in one audio group and leave it out of the other group. The following example defines two audio groups, one for low bit rates and one for high bit rates. Both audio groups define the same set of languages but are called based on the available bandwidth.</p>\n<p>每个组可以提供多个码率的媒体文件，其码率可以通过<code>EXT-X-STREAM-INF</code>指定，虽然<code>GROUP-ID</code>相同，但是码率是不同的。</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\">#EXTM3U<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;audio-lo&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;eng&quot;</span>,NAME=<span class=\"hljs-string\">&quot;English&quot;</span>,AUTOSELECT=YES, DEFAULT=YES,URI=<span class=\"hljs-string\">&quot;englo/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;audio-lo&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;fre&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Français&quot;</span>,AUTOSELECT=YES, DEFAULT=NO,URI=<span class=\"hljs-string\">&quot;frelo/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;audio-lo&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;es&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Espanol&quot;</span>,AUTOSELECT=YES, DEFAULT=NO,URI=<span class=\"hljs-string\">&quot;splo/prog_index.m3u8&quot;</span><br> <br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;audio-hi&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;eng&quot;</span>,NAME=<span class=\"hljs-string\">&quot;English&quot;</span>,AUTOSELECT=YES, DEFAULT=YES,URI=<span class=\"hljs-string\">&quot;eng/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;audio-hi&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;fre&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Français&quot;</span>,AUTOSELECT=YES, DEFAULT=NO,URI=<span class=\"hljs-string\">&quot;fre/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;audio-hi&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;es&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Espanol&quot;</span>,AUTOSELECT=YES, DEFAULT=NO,URI=<span class=\"hljs-string\">&quot;sp/prog_index.m3u8&quot;</span><br> <br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-STREAM</span><span class=\"hljs-params\">-INF</span>:BANDWIDTH=<span class=\"hljs-number\">195023</span>,CODECS=<span class=\"hljs-string\">&quot;mp4a.40.5&quot;</span>, AUDIO=<span class=\"hljs-string\">&quot;audio-lo&quot;</span><br>lo/prog_index.m3u8<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-STREAM</span><span class=\"hljs-params\">-INF</span>:BANDWIDTH=<span class=\"hljs-number\">260000</span>,CODECS=<span class=\"hljs-string\">&quot;avc1.42e01e,mp4a.40.2&quot;</span>, AUDIO=<span class=\"hljs-string\">&quot;audio-lo&quot;</span><br>hi/prog_index.m3u8<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-STREAM</span><span class=\"hljs-params\">-INF</span>:BANDWIDTH=<span class=\"hljs-number\">591680</span>,CODECS=<span class=\"hljs-string\">&quot;mp4a.40.2, avc1.64001e&quot;</span>, AUDIO=<span class=\"hljs-string\">&quot;audio-hi&quot;</span><br>lo/prog_index.m3u8<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-STREAM</span><span class=\"hljs-params\">-INF</span>:BANDWIDTH=<span class=\"hljs-number\">650000</span>,CODECS=<span class=\"hljs-string\">&quot;avc1.42e01e,mp4a.40.2&quot;</span>, AUDIO=<span class=\"hljs-string\">&quot;audio-hi&quot;</span><br>hi/prog_index.m3u8<br><br></code></pre></td></tr></table></figure>\n\n<p>You can have both a group and a single stream in a playlist. This is often done when you have multiple camera angles that all use the same audio. Create a group for the video streams and then declare the single audio stream. The following example shows a playlist with three camera angles and a single audio stream:</p>\n<p>一个视频组关联单个音频的情况。</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\">#EXTM3U<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=VIDEO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;500kbs&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Angle1&quot;</span>,AUTOSELECT=YES,DEFAULT=YES<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=VIDEO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;500kbs&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Angle2&quot;</span>,AUTOSELECT=YES,DEFAULT=NO, URI=<span class=\"hljs-string\">&quot;Angle2/500kbs/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=VIDEO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;500kbs&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Angle3&quot;</span>,AUTOSELECT=YES,DEFAULT=NO, URI=<span class=\"hljs-string\">&quot;Angle3/500kbs/prog_index.m3u8&quot;</span><br><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;aac&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;en&quot;</span>,NAME=<span class=\"hljs-string\">&quot;English&quot;</span>,AUTOSELECT=YES, DEFAULT=YES,URI=<span class=\"hljs-string\">&quot;eng/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-STREAM</span><span class=\"hljs-params\">-INF</span>:PROGRAM<span class=\"hljs-params\">-ID</span>=<span class=\"hljs-number\">1</span>,BANDWIDTH=<span class=\"hljs-number\">754857</span>,CODECS=<span class=\"hljs-string\">&quot;mp4a.40.2,avc1.4d401e&quot;</span>, VIDEO=<span class=\"hljs-string\">&quot;500kbs&quot;</span>,AUDIO=<span class=\"hljs-string\">&quot;aac&quot;</span><br>Angle1/<span class=\"hljs-number\">500</span>kbs/prog_index.m3u8<br></code></pre></td></tr></table></figure>\n\n<p>To provide different streams for different bit rates, a different video group ID is needed for each bit rate.</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\">#EXTM3U<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=VIDEO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;200kbs&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Angle1&quot;</span>,AUTOSELECT=YES,DEFAULT=YES<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=VIDEO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;200kbs&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Angle2&quot;</span>,AUTOSELECT=YES,DEFAULT=NO, URI=<span class=\"hljs-string\">&quot;Angle2/200kbs/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=VIDEO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;200kbs&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Angle3&quot;</span>,AUTOSELECT=YES,DEFAULT=NO, URI=<span class=\"hljs-string\">&quot;Angle3/200kbs/prog_index.m3u8&quot;</span><br><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=VIDEO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;500kbs&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Angle1&quot;</span>,AUTOSELECT=YES,DEFAULT=YES<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=VIDEO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;500kbs&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Angle2&quot;</span>,AUTOSELECT=YES,DEFAULT=NO, URI=<span class=\"hljs-string\">&quot;Angle2/500kbs/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=VIDEO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;500kbs&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Angle3&quot;</span>,AUTOSELECT=YES,DEFAULT=NO, URI=<span class=\"hljs-string\">&quot;Angle3/500kbs/prog_index.m3u8&quot;</span><br><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;aac&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;en&quot;</span>,NAME=<span class=\"hljs-string\">&quot;English&quot;</span>,AUTOSELECT=YES, DEFAULT=YES,URI=<span class=\"hljs-string\">&quot;eng/prog_index.m3u8&quot;</span><br><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-STREAM</span><span class=\"hljs-params\">-INF</span>:PROGRAM<span class=\"hljs-params\">-ID</span>=<span class=\"hljs-number\">1</span>,BANDWIDTH=<span class=\"hljs-number\">300000</span>,CODECS=<span class=\"hljs-string\">&quot;mp4a.40.2,avc1.4d401e&quot;</span>, VIDEO=<span class=\"hljs-string\">&quot;200kbs&quot;</span>,AUDIO=<span class=\"hljs-string\">&quot;aac&quot;</span><br>Angle1/<span class=\"hljs-number\">200</span>kbs/prog_index.m3u<br><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-STREAM</span><span class=\"hljs-params\">-INF</span>:PROGRAM<span class=\"hljs-params\">-ID</span>=<span class=\"hljs-number\">1</span>,BANDWIDTH=<span class=\"hljs-number\">754857</span>,CODECS=<span class=\"hljs-string\">&quot;mp4a.40.2,avc1.4d401e&quot;</span>, VIDEO=<span class=\"hljs-string\">&quot;500kbs&quot;</span>,AUDIO=<span class=\"hljs-string\">&quot;aac&quot;</span><br>Angle1/<span class=\"hljs-number\">500</span>kbs/prog_index.m3u8<br></code></pre></td></tr></table></figure>\n\n<p>参考：<br><a href=\"https://developer.apple.com/documentation/http_live_streaming\">https://developer.apple.com/documentation/http_live_streaming</a><br><a href=\"https://aleen42.gitbooks.io/wiki/content/summary/m3u8/m3u8.html\">https://aleen42.gitbooks.io/wiki/content/summary/m3u8/m3u8.html</a></p>\n","excerpt":"","more":"<h1 id=\"HLS-是什么\"><a href=\"#HLS-是什么\" class=\"headerlink\" title=\"HLS 是什么\"></a>HLS 是什么</h1><p>维基百科的介绍：</p>\n<p>HTTP Live Streaming，缩写为HLS，是由苹果公司提出基于HTTP的流媒体网络传输协议。是苹果公司QuickTime X和iPhone软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的扩充 M3U (m3u8) 播放列表文件，用于寻找可用的媒体流。</p>\n<p>HLS只请求基本的HTTP报文，与实时传输协议（RTP）不同，HLS可以穿过任何允许HTTP数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。</p>\n<p>苹果公司把HLS协议作为一个互联网草案（逐步提交），在第一阶段中已作为一个非正式的标准提交到IETF。2017年8月，RFC 8216发布，描述了HLS协议第7版的定义。</p>\n<p>苹果自己的介绍：</p>\n<blockquote>\n<p>Send live and on‐demand audio and video to iPhone, iPad, Mac, Apple Watch, Apple TV, and PC with HTTP Live Streaming (HLS) technology from Apple. Using the same protocol that powers the web, HLS lets you deploy content using ordinary web servers and content delivery networks. HLS is designed for reliability and dynamically adapts to network conditions by optimizing playback for the available speed of wired and wireless connections.</p>\n</blockquote>\n<p>总结一下：</p>\n<ol>\n<li>基于HTTP的流媒体网络传输协议，支持安全通信（通过https, 媒体数据加密等）</li>\n<li>工作原理是把整个流分成一个个小的基于HTTP的文件来下载, 使用m3u8描述播放列表。</li>\n<li>支持直播和点播（VOD， video on demand）</li>\n<li>当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率</li>\n</ol>\n<h2 id=\"HLS-流媒体架构\"><a href=\"#HLS-流媒体架构\" class=\"headerlink\" title=\"HLS 流媒体架构\"></a>HLS 流媒体架构</h2><blockquote>\n<p>Conceptually, HTTP Live Streaming consists of three parts: the server component, the distribution component, and the client software.</p>\n<p>In a typical configuration, a hardware encoder takes audio-video input, encodes it as HEVC video and AC-3 audio, and outputs a fragmented MPEG-4 file or an MPEG-2 transport stream. A software stream segmenter then breaks the stream into a series of short media files, which are placed on a web server. The segmenter also creates and maintains an index file containing a list of the media files. The URL of the index file is published on the web server. Client software reads the index, then requests the listed media files in order and displays them without any pauses or gaps between segments.</p>\n</blockquote>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656504345291665650434432.png\"></p>\n<p>概念上，HLS 包含</p>\n<ul>\n<li>服务端组件</li>\n<li>分发组件</li>\n<li>客户端软件</li>\n</ul>\n<p>步骤：</p>\n<ol>\n<li>服务端硬件编码器，将音视频输入编码(视频编码成HEVC，H264, 音频编码成AAC，AC-3)， 输出ts流（也可以生成分段的mp4文件， 很少用）</li>\n<li>分段软件会将ts流分割，打包成ts文件，同时生成索引文件（m3u8）,索引文件保存了媒体文件的信息。</li>\n<li>客户端读取m3u8索引文件，下载对应的ts文件，将内容播放给用户</li>\n</ol>\n<p>苹果提供了一套用于HLS的工具集，参考：</p>\n<p><a href=\"https://developer.apple.com/documentation/http_live_streaming/using_apple_s_http_live_streaming_hls_tools\">Using Apple’s HTTP Live Streaming (HLS) Tools</a></p>\n<ul>\n<li>Media File Segmenter (mediafilesegmenter), 媒体文件分割器</li>\n<li>Media Subtitle Segmenter (mediasubtitlesegmenter)， 字幕分割器</li>\n<li>Media Stream Segmenter (mediastreamsegmenter) 媒体流分割器</li>\n<li>Variant Playlist Creator (variantplaylistcreator) 可变播放列表生成器</li>\n<li>…</li>\n</ul>\n<h1 id=\"M3U8\"><a href=\"#M3U8\" class=\"headerlink\" title=\"M3U8\"></a>M3U8</h1><blockquote>\n<p>The Unicode version of M3U is M3U8, which uses UTF-8-encoded characters. M3U8 files are the basis for the HTTP Live Streaming (HLS) format originally developed by Apple to stream video and radio to iOS devices, and which is now a popular format for adaptive streaming in general.</p>\n</blockquote>\n<blockquote>\n<p>M3U (MP3 URL or Moving Picture Experts Group Audio Layer 3 Uniform Resource Locator in full) is a computer file format for a multimedia playlist. One common use of the M3U file format is creating a single-entry playlist file pointing to a stream on the Internet.</p>\n</blockquote>\n<blockquote>\n<p>Although originally designed for audio files, such as MP3, it is commonly used to point media players to audio and video sources, including online sources.</p>\n</blockquote>\n<p>总结一下：</p>\n<ol>\n<li>M3U8 是M3U的Unicode版本，使用 UTF-8 编码， 是 HLS 的基础</li>\n<li>M3U 最初是为音频文件设计的，例如MP3， 现在不再局限于音频文件，可以用来索引音频和视频资源，网络资源</li>\n<li>下面分析M3U 文件格式</li>\n</ol>\n<p><strong>M3U</strong></p>\n<blockquote>\n<p>An M3U file is a plain text file that specifies the locations of one or more media files. The file is saved with the “m3u” filename extension if the text is encoded in the local system’s default non-Unicode encoding (e.g., a Windows codepage), or with the “m3u8” extension if the text is UTF-8 encoded.</p>\n</blockquote>\n<p>总结一下：</p>\n<ol>\n<li>M3U 文件是纯文本文件，指定了资源文件的位置</li>\n<li>以<code>.m3u</code>为文件后缀</li>\n<li>使用 UTF-8 编码的版本，以 <code>.m3u8</code>为后缀</li>\n</ol>\n<h2 id=\"Extended-M3U\"><a href=\"#Extended-M3U\" class=\"headerlink\" title=\"Extended M3U\"></a>Extended M3U</h2><p>看一个例子：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-comment\">#EXTM3U</span><br><span class=\"hljs-comment\">#EXT-X-PLAYLIST-TYPE:VOD</span><br><span class=\"hljs-comment\">#EXT-X-TARGETDURATION:10</span><br><span class=\"hljs-comment\">#EXT-X-VERSION:4</span><br><span class=\"hljs-comment\">#EXT-X-MEDIA-SEQUENCE:0</span><br><span class=\"hljs-comment\">#EXTINF:10.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceA.ts<br><span class=\"hljs-comment\">#EXTINF:10.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceB.ts<br><span class=\"hljs-comment\">#EXTINF:10.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceC.ts<br><span class=\"hljs-comment\">#EXTINF:9.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceD.ts<br><span class=\"hljs-comment\">#EXT-X-ENDLIST</span><br></code></pre></td></tr></table></figure>\n\n<p>语法：</p>\n<ul>\n<li>Tags: begin with ‘#EXT’</li>\n<li>Comments: only begin with ‘#’</li>\n<li>标签后面可以有参数，例如<code>#EXTINF:10.0</code></li>\n<li>标签内容可以是：<ol>\n<li>an absolute local pathname</li>\n<li>a local pathname relative to the M3U file location; e.g. Heavysets.mp3</li>\n<li>a URL</li>\n</ol>\n</li>\n</ul>\n<p>表格参考：<a href=\"https://en.wikipedia.org/wiki/M3U\">https://en.wikipedia.org/wiki/M3U</a></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656557421391665655741667.png\"></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656557911381665655790476.png\"></p>\n<h2 id=\"例子分析\"><a href=\"#例子分析\" class=\"headerlink\" title=\"例子分析\"></a>例子分析</h2><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-comment\">#EXTM3U</span><br><span class=\"hljs-comment\">#EXT-X-PLAYLIST-TYPE:VOD</span><br><span class=\"hljs-comment\">#EXT-X-TARGETDURATION:10</span><br><span class=\"hljs-comment\">#EXT-X-VERSION:4</span><br><span class=\"hljs-comment\">#EXT-X-MEDIA-SEQUENCE:0</span><br><span class=\"hljs-comment\">#EXTINF:10.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceA.ts<br><span class=\"hljs-comment\">#EXTINF:10.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceB.ts<br><span class=\"hljs-comment\">#EXTINF:10.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceC.ts<br><span class=\"hljs-comment\">#EXTINF:9.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceD.ts<br><span class=\"hljs-comment\">#EXT-X-ENDLIST</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>EXTM3U</strong></p>\n<p>表明是<code>extended M3U</code>文件， 区别于基本的<code>M3U</code>文件。m3u8文件必须以该标签开始。</p>\n<p><strong>EXT-X-PLAYLIST-TYPE</strong></p>\n<p>类型可以是：</p>\n<ul>\n<li>VOD， 代表点播， 结尾包含<code>#EXT-X-ENDLIST</code></li>\n<li>EVENT， 代表直播, 结尾不包含<code>#EXT-X-ENDLIST</code></li>\n</ul>\n<p><strong>EXT-X-TARGETDURATION</strong></p>\n<p>单个媒体文件的最大时长。每一个<code>#EXTINF:10.0</code>标签指定的时长<code>&lt;=</code>EXT-X-TARGETDURATION</p>\n<p><strong>EXT-X-MEDIA-SEQUENCE</strong></p>\n<blockquote>\n<p>Indicates the sequence number of the first URL that appears in a playlist file. Each media file URL in a playlist has a unique integer sequence number. The sequence number of a URL is higher by 1 than the sequence number of the URL that preceded it. The media sequence numbers have no relation to the names of the files.</p>\n</blockquote>\n<p>m3u8文件中第一个URL文件的编号，与文件名字无关，每次比前面的+1。</p>\n<p><strong>EXT-X-VERSION</strong></p>\n<blockquote>\n<p>The EXT-X-VERSION tag indicates the compatibility version of the Playlist file. This file, its associated media, and its server must comply with all provisions of the IETF Internet-Draft of “HTTP Live Streaming 2nd Edition” (or earlier specifications) describing the protocol version indicated by the tag value. A Playlist file that doesn’t contain an EXT-X-VERSION tag must comply with version 1 of this protocol.</p>\n</blockquote>\n<p>表明该m3u8文件的版本兼容性。该m3u8文件，关联的媒体，服务器必须服从于该版本特性。如果不包含该字段，必须服从与版本1的规定。</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656577590671665657758695.png\"></p>\n<p>参考： <a href=\"https://developer.apple.com/documentation/http_live_streaming/about_the_ext-x-version_tag\">About the EXT-X-VERSION tag</a></p>\n<p><strong>EXTINF</strong></p>\n<ul>\n<li>描述资源文件时长，URL</li>\n<li>时长： 版本小于3是int， 版本大于等于3是float, 单位秒</li>\n</ul>\n<p><strong>EXT-X-ENDLIST</strong></p>\n<p>结束标志，表明没有更多资源了。vod有，event可能没有。</p>\n<h3 id=\"VOD-Playlist-点播\"><a href=\"#VOD-Playlist-点播\" class=\"headerlink\" title=\"VOD Playlist 点播\"></a>VOD Playlist 点播</h3><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-comment\">#EXTM3U</span><br><span class=\"hljs-comment\">#EXT-X-PLAYLIST-TYPE:VOD</span><br><span class=\"hljs-comment\">#EXT-X-TARGETDURATION:10</span><br><span class=\"hljs-comment\">#EXT-X-VERSION:4</span><br><span class=\"hljs-comment\">#EXT-X-MEDIA-SEQUENCE:0</span><br><span class=\"hljs-comment\">#EXTINF:10.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceA.ts<br><span class=\"hljs-comment\">#EXTINF:10.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceB.ts<br><span class=\"hljs-comment\">#EXTINF:10.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceC.ts<br><span class=\"hljs-comment\">#EXTINF:9.0,</span><br>http:<span class=\"hljs-regexp\">//</span>example.com<span class=\"hljs-regexp\">/movie1/</span>fileSequenceD.ts<br><span class=\"hljs-comment\">#EXT-X-ENDLIST</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"live-Playlist-Sliding-Window-直播滑动窗口\"><a href=\"#live-Playlist-Sliding-Window-直播滑动窗口\" class=\"headerlink\" title=\"live Playlist(Sliding Window) 直播滑动窗口\"></a>live Playlist(Sliding Window) 直播滑动窗口</h3><blockquote>\n<p>In live sessions, the index file is updated by removing media URIs from the file as new media files are created and made available. The EXT-X-ENDLIST tag isn’t present in the live playlist, indicating that new media files will be added to the index file as they become available.</p>\n</blockquote>\n<p>直播流，m3u8文件会更新，前面的资源会被移除，后面的资源会被追加。<br>没有<code>EXT-X-ENDLIST</code>标签，表示还会有新的资源被添加。</p>\n<p>看一个例子，开始时文件内容</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\"><span class=\"hljs-attr\">#EXTM3</span>U<br><span class=\"hljs-attr\">#EXT-X-TARGETDURATION:10</span><br><span class=\"hljs-attr\">#EXT-X-VERSION:4</span><br><span class=\"hljs-attr\">#EXT-X-MEDIA-SEQUENCE:1</span><br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce1</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce2</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce3</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce4</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce5</span>.ts<br></code></pre></td></tr></table></figure>\n\n<p>旧资源被删除，新资被添加，看到<code>EXT-X-MEDIA-SEQUENCE</code>也发生了变化</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\"><span class=\"hljs-attr\">#EXTM3</span>U<br><span class=\"hljs-attr\">#EXT-X-TARGETDURATION:10</span><br><span class=\"hljs-attr\">#EXT-X-VERSION:4</span><br><span class=\"hljs-attr\">#EXT-X-MEDIA-SEQUENCE:2</span><br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce2</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce3</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.00</span>,<br>fileSeque<span class=\"hljs-symbol\">nce4</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.00</span>,<br>fileSeque<span class=\"hljs-symbol\">nce5</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce6</span>.ts<br></code></pre></td></tr></table></figure>\n\n<p>再次更新</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\"><span class=\"hljs-attr\">#EXTM3</span>U<br><span class=\"hljs-attr\">#EXT-X-TARGETDURATION:10</span><br><span class=\"hljs-attr\">#EXT-X-VERSION:4</span><br><span class=\"hljs-attr\">#EXT-X-MEDIA-SEQUENCE:4</span><br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.00</span>,<br>fileSeque<span class=\"hljs-symbol\">nce4</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.00</span>,<br>fileSeque<span class=\"hljs-symbol\">nce5</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce6</span>.ts,<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce7</span>.ts,<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce8</span>.ts,<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce9</span>.ts<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Event-Playlist\"><a href=\"#Event-Playlist\" class=\"headerlink\" title=\"Event Playlist\"></a>Event Playlist</h3><blockquote>\n<p>An event playlist is specified by the EXT-X-PLAYLIST-TYPE tag with a value of EVENT. It doesn’t initially have an EXT-X-ENDLIST tag, indicating that new media files will be added to the playlist as they become available.</p>\n</blockquote>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\"><span class=\"hljs-attr\">#EXTM3</span>U<br><span class=\"hljs-attr\">#EXT-X-PLAYLIST-TYPE:EVENT</span><br><span class=\"hljs-attr\">#EXT-X-TARGETDURATION:10</span><br><span class=\"hljs-attr\">#EXT-X-VERSION:4</span><br><span class=\"hljs-attr\">#EXT-X-MEDIA-SEQUENCE:0</span><br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.00</span>,<br>fileSeque<span class=\"hljs-symbol\">nce0</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce1</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce2</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce3</span>.ts<br><span class=\"hljs-attr\">#EXTINF:10</span><span class=\"hljs-number\">.0</span>,<br>fileSeque<span class=\"hljs-symbol\">nce4</span>.ts<br></code></pre></td></tr></table></figure>\n\n<p>观察到<code>#EXT-X-PLAYLIST-TYPE:EVENT</code></p>\n<blockquote>\n<p>If the tag is present and has a value of EVENT, the server must not change or delete any part of the playlist file (although it may append lines to it). If the tag is present and has a value of VOD, the playlist file must not change.</p>\n</blockquote>\n<blockquote>\n<p>You can’t remove anything from the playlist when using the EVENT tag; you may only append new segments to the end of the file. New segments are added to the end of the file until the event has concluded, at which time the EXT-X-ENDLIST tag is appended.</p>\n</blockquote>\n<p>如果类型为EVENT，更新m3u8文件，只能追加，不能删除。<br>如果类型为VOD，不能更改m3u8播放列表。</p>\n<p>更新后</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-selector-id\">#EXTM3U</span><br><span class=\"hljs-selector-id\">#EXT-X-PLAYLIST-TYPE</span>:EVENT<br><span class=\"hljs-selector-id\">#EXT-X-TARGETDURATION</span>:<span class=\"hljs-number\">10</span><br><span class=\"hljs-selector-id\">#EXT-X-VERSION</span>:<span class=\"hljs-number\">4</span><br><span class=\"hljs-selector-id\">#EXT-X-MEDIA-SEQUENCE</span>:<span class=\"hljs-number\">0</span><br><span class=\"hljs-selector-id\">#EXTINF</span>:<span class=\"hljs-number\">10.0</span>,<br>fileSequence0<span class=\"hljs-selector-class\">.ts</span><br><span class=\"hljs-selector-id\">#EXTINF</span>:<span class=\"hljs-number\">10.0</span>,<br>fileSequence1<span class=\"hljs-selector-class\">.ts</span><br><span class=\"hljs-selector-id\">#EXTINF</span>:<span class=\"hljs-number\">10.0</span>,<br>fileSequence2<span class=\"hljs-selector-class\">.ts</span><br><span class=\"hljs-selector-id\">#EXTINF</span>:<span class=\"hljs-number\">10.0</span>,<br>fileSequence3<span class=\"hljs-selector-class\">.ts</span><br><span class=\"hljs-selector-id\">#EXTINF</span>:<span class=\"hljs-number\">10.0</span>,<br>fileSequence4<span class=\"hljs-selector-class\">.ts</span><br><br><span class=\"hljs-comment\">// List of files between 4 and 120 go here.</span><br><br><span class=\"hljs-selector-id\">#EXTINF</span>:<span class=\"hljs-number\">10.0</span>,<br>fileSequence120<span class=\"hljs-selector-class\">.ts</span><br><span class=\"hljs-selector-id\">#EXTINF</span>:<span class=\"hljs-number\">10.0</span>,<br>fileSequence121<span class=\"hljs-selector-class\">.ts</span><br>#EXT-X-ENDLIST<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"Creating-a-Multivariant-Playlist\"><a href=\"#Creating-a-Multivariant-Playlist\" class=\"headerlink\" title=\"Creating a Multivariant Playlist\"></a>Creating a Multivariant Playlist</h3><blockquote>\n<p>Offer multiple playlist files to provide different encodings of the same content.</p>\n</blockquote>\n<p>为同一份内容，提供多个m3u8索引，每个m3u8采用不同的编码参数。</p>\n<blockquote>\n<p>The Multivariant Playlist describes all of the available variants for your content. Each variant is a version of the stream at a particular bit rate and is contained in a separate playlist. The client switches to the most appropriate variant based on the measured network bit rate. The client’s player is tuned to minimize stalling of playback, to give the user the best possible streaming experience.</p>\n</blockquote>\n<p>为同一份内容，提供多个码率的m3u8,方便客户端播放器选择适应自身网络状况的最佳码率资源。</p>\n<p>结构图：</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16656676568981665667656356.png\"></p>\n<p>文件示例</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dts\"><span class=\"hljs-meta\">#EXTM3U</span><br><span class=\"hljs-meta\">#EXT-X-STREAM-INF:BANDWIDTH=150000,RESOLUTION=416x234,CODECS=<span class=\"hljs-string\">&quot;avc1.42e00a,mp4a.40.2&quot;</span></span><br><span class=\"hljs-symbol\">http:</span><span class=\"hljs-comment\">//example.com/low/index.m3u8</span><br><span class=\"hljs-meta\">#EXT-X-STREAM-INF:BANDWIDTH=240000,RESOLUTION=416x234,CODECS=<span class=\"hljs-string\">&quot;avc1.42e00a,mp4a.40.2&quot;</span></span><br><span class=\"hljs-symbol\">http:</span><span class=\"hljs-comment\">//example.com/lo_mid/index.m3u8</span><br><span class=\"hljs-meta\">#EXT-X-STREAM-INF:BANDWIDTH=440000,RESOLUTION=416x234,CODECS=<span class=\"hljs-string\">&quot;avc1.42e00a,mp4a.40.2&quot;</span></span><br><span class=\"hljs-symbol\">http:</span><span class=\"hljs-comment\">//example.com/hi_mid/index.m3u8</span><br><span class=\"hljs-meta\">#EXT-X-STREAM-INF:BANDWIDTH=640000,RESOLUTION=640x360,CODECS=<span class=\"hljs-string\">&quot;avc1.42e00a,mp4a.40.2&quot;</span></span><br><span class=\"hljs-symbol\">http:</span><span class=\"hljs-comment\">//example.com/high/index.m3u8</span><br><span class=\"hljs-meta\">#EXT-X-STREAM-INF:BANDWIDTH=64000,CODECS=<span class=\"hljs-string\">&quot;mp4a.40.5&quot;</span></span><br><span class=\"hljs-symbol\">http:</span><span class=\"hljs-comment\">//example.com/audio/index.m3u8</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>EXT-X-STREAM-INF</strong><br>Indicates that the next URL in the playlist file identifies another playlist file.</p>\n<p>表明它的URL内容是一个m3u8文件。</p>\n<p>The EXT-X-STREAM-INF tag has the following parameters:</p>\n<p><strong>AVERAGE-BANDWIDTH</strong></p>\n<p>(Optional, but recommended) An integer that represents the average bit rate for the variant stream.</p>\n<p>平均码率，可选。</p>\n<p><strong>BANDWIDTH</strong></p>\n<p>(Required) An integer that is the upper bound of the overall bit rate for each media file, in bits per second. The upper bound value is calculated to include any container overhead that appears or will appear in the playlist.</p>\n<p>带宽。</p>\n<p><strong>FRAME-RATE</strong></p>\n<p>(Optional, but recommended) A floating-point value that describes the maximum frame rate in a variant stream.</p>\n<p>帧率，可选， 表示该流的最大帧率。</p>\n<p><strong>HDCP-LEVEL</strong></p>\n<p>(Optional) Indicates the type of encryption used. Valid values are TYPE-0 and NONE. Use TYPE-0 if the stream may not play unless the output is protected by HDCP.</p>\n<p>加密方式，可选。</p>\n<p><strong>RESOLUTION</strong></p>\n<p>(Optional, but recommended) The optional display size, in pixels, at which to display the video in the playlist. This parameter should be included for any stream that includes video.</p>\n<p>视频分辨率。</p>\n<p><strong>VIDEO-RANGE</strong></p>\n<p>(Required depending on encoding) A string with valid values of SDR or PQ. If transfer characteristic codes 1, 16, or 18 aren’t specified, then this parameter must be omitted.</p>\n<p><strong>CODECS</strong></p>\n<p>(Optional, but recommended) A quoted string containing a comma-separated list of formats, where each format specifies a media sample type that’s present in a media segment in the playlist file. Valid format identifiers are those in the ISO file format name space defined by RFC 6381.</p>\n<p>编码器相关参数。</p>\n<h3 id=\"Adding-Alternate-Media-to-a-Playlist\"><a href=\"#Adding-Alternate-Media-to-a-Playlist\" class=\"headerlink\" title=\"Adding Alternate Media to a Playlist\"></a>Adding Alternate Media to a Playlist</h3><blockquote>\n<p>Specify Rendition Playlists that can override the main presentation.</p>\n</blockquote>\n<blockquote>\n<p>Adding alternate media to a Multivariant Playlist allows a provider to specify one of a set of variant playlists as an override of the main presentation. The client plays only the override media (audio or video), and suppresses any media of the same type from the main presentation, if present. This allows a presentation to offer multiple versions of the media without requiring the provider to store duplicate media, or requiring the client to download all variants when it only needs one. It also allows additional media to be offered subsequently without remastering the original content.</p>\n</blockquote>\n<p>在主音频视频资源外，提供多路备选资源。<br>选择备选的音视频，客户端只会播放备选音视频资源。</p>\n<p>下面的例子，提供备选的多语言音频播放列表</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\">#EXTM3U<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;audio&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;eng&quot;</span>,NAME=<span class=\"hljs-string\">&quot;English&quot;</span>,AUTOSELECT=YES, DEFAULT=YES,URI=<span class=\"hljs-string\">&quot;eng/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;audio&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;fre&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Français&quot;</span>,AUTOSELECT=YES, DEFAULT=NO,URI=<span class=\"hljs-string\">&quot;fre/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;audio&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;sp&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Espanol&quot;</span>,AUTOSELECT=YES, DEFAULT=NO,URI=<span class=\"hljs-string\">&quot;sp/prog_index.m3u8&quot;</span><br><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-STREAM</span><span class=\"hljs-params\">-INF</span>:PROGRAM<span class=\"hljs-params\">-ID</span>=<span class=\"hljs-number\">1</span>,BANDWIDTH=<span class=\"hljs-number\">195023</span>,CODECS=<span class=\"hljs-string\">&quot;avc1.42e00a,mp4a.40.2&quot;</span>,AUDIO=<span class=\"hljs-string\">&quot;audio&quot;</span><br>lo/prog_index.m3u8<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-STREAM</span><span class=\"hljs-params\">-INF</span>:PROGRAM<span class=\"hljs-params\">-ID</span>=<span class=\"hljs-number\">1</span>,BANDWIDTH=<span class=\"hljs-number\">591680</span>,CODECS=<span class=\"hljs-string\">&quot;avc1.42e01e,mp4a.40.2&quot;</span>,AUDIO=<span class=\"hljs-string\">&quot;audio&quot;</span><br>hi/prog_index.m3u8<br></code></pre></td></tr></table></figure>\n\n<p>The tags used in this Multivariant Playlist example include:</p>\n<p><strong>EXT-X-MEDIA</strong><br>Identifies an element of a media selection group. All the elements of a media selection group must have similar characteristics, for example, the same codecs and the same maximum bandwidth.</p>\n<p>表示媒体选项分组中的一个元素，同一个分组中的媒体具有相同的特征，如相同的编解码或带宽。</p>\n<p>EXT-X-STREAM-INF<br>indicates that the next URL in the Multivariant Playlist identifies a Rendition Playlist. See Creating a Multivariant Playlist for the basic parameters.</p>\n<p>表明它的内容是一个索引， 指向一个m3u8文件</p>\n<p>The EXT-X-MEDIA tag has the following parameters:</p>\n<p>TYPE<br>(Required) A string indicating the type of media. Valid values are AUDIO, VIDEO, SUBTITLES, and CLOSED-CAPTIONS.</p>\n<p>媒体类型</p>\n<ul>\n<li>AUDIO</li>\n<li>VIDEO</li>\n<li>SUBTITLES</li>\n<li>CLOSED-CAPTIONS</li>\n</ul>\n<p>GROUP-ID<br>(Required) A string specifying the group that the media selection belongs to.</p>\n<p>分组标识，字符串，必须有。</p>\n<p>LANGUAGE<br>(Optional) A string that identifies the primary language used in the media selection.</p>\n<p>该选项中媒体文件对应的语言，可选。</p>\n<p>NAME<br>(Required) A string that describes the primary language used in the media selection.</p>\n<p>该选项中媒体文件对应的语言的字符串标识，必须。</p>\n<p>AUTOSELECT<br>(Optional) A string that indicates that the client may play the media selection in the absence of explicit user preference. Valid values are YES and NO. If the value of DEFAULT is YES, this value must also be YES.</p>\n<p>是否自动选择，可选。在用户偏好缺省的时候，指示客户端是否应该自动选择该选项。合法的值是YES和NO，<br>如果<code>DEFAULT</code>是YES， 该字段的值必须也是YES.</p>\n<p>DEFAULT<br>(Optional) A string indicating that the media selection should be played if the user hasn’t selected another option. Valid values are YES and NO.</p>\n<p>是否默认播放该选项，可选。用户没有选择其他选项的时候，是否默认播放该选项。</p>\n<p>INSTREAM-ID<br>(Required for closed captions) A string that specifies a rendition within the segments in the media playlist. When the TYPE attribute is CLOSED-CAPTIONS, the INSTREAM-ID must have one of the following values: CC1, CC3, CC3, CC4, or SERVICEn, where n is between 1 and 63.</p>\n<p>ASSOC-LANGUAGE<br>(Optional) A string containing a language tag for the rendition. An associated language is often different from the language specified in the LANGUAGE attribute.</p>\n<p>关联的语言，可选。</p>\n<p>CHANNELS<br>(Required when two renditions have the same codec but a different number of channels) An ordered string that indicates the maximum number of independent, simultaneous audio channels present in a media segment.</p>\n<p>表明该音频文件有几个声道</p>\n<p>URI<br>(Optional) A string containing a URI that identifies the media playlist file. If the TYPE is CLOSED-CAPTIONS, this attribute must be omitted. When this attribute is omitted, the media content is in the original variant.</p>\n<p>媒体文件地址，可选。</p>\n<p>When its URI attribute is omitted, the EXT-X-MEDIA tag can indicate that the media described is included in the URI of the EXT-X-STREAM-INF tag.</p>\n<p>如果URI字段不存在，<code>EXT-X-MEDIA</code>描述的的媒体文件存在于<code>EXT-X-STREAM-INF</code>标签中。</p>\n<p>The EXT-X-STREAM-INF tag has the following parameters:</p>\n<p>AUDIO<br>(Optional) A quoted string that indicates the set of audio streams that may be used when playing the presentation. This value must match the value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the Multivariant Playlist whose TYPE attribute is AUDIO.</p>\n<p>VIDEO<br>(Optional) A quoted string that indicates the set of video streams that may be used when playing the presentation. This value must match the value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the Multivariant Playlist whose TYPE attribute is VIDEO.</p>\n<p>SUBTITLES<br>(Optional) A quoted string that indicates the set of subtitle renditions that can be used. This value must match the value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the Multivariant Playlist whose TYPE attribute is SUBTITLE.</p>\n<p>CLOSED-CAPTIONS<br>(Optional) Either a quoted string that indicates the set of closed captions that can be used or an enumerated string with the value of NONE. When this value is a quoted string, it must match the value of the GROUP-ID attribute of an EXT-X-MEDIA tag elsewhere in the Multivariant Playlist whose TYPE attribute is CLOSED-CAPTIONS. If the enumerated value is NONE, all EXT-X-STREAM-INF tags must have this attribute with a value of NONE.</p>\n<p>总结一下：</p>\n<p>通过<code>EXT-X-MEDIA</code>可以定义资源组，可以有多个组，用GROUP-ID来区分， 有四种组类型</p>\n<ul>\n<li>AUDIO</li>\n<li>VIDEO</li>\n<li>SUBTITLES</li>\n<li>CLOSED-CAPTIONS</li>\n</ul>\n<p>每个分组中流属性是相同，其参数可以通过关联的<code>EXT-X-STREAM-INF</code>指定<br>通过<code>EXT-X-STREAM-INF</code>定义资源组的流参数，带宽，编解码器信息。 它关联一个组ID，这个组内的所有备选媒体都具有相同的性质。</p>\n<p>You can have multiple audio groups to allow changes in codes or bit rate. However, each audio group in a variant must have the same alternates in it. For example, you can’t have English in one audio group and leave it out of the other group. The following example defines two audio groups, one for low bit rates and one for high bit rates. Both audio groups define the same set of languages but are called based on the available bandwidth.</p>\n<p>每个组可以提供多个码率的媒体文件，其码率可以通过<code>EXT-X-STREAM-INF</code>指定，虽然<code>GROUP-ID</code>相同，但是码率是不同的。</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\">#EXTM3U<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;audio-lo&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;eng&quot;</span>,NAME=<span class=\"hljs-string\">&quot;English&quot;</span>,AUTOSELECT=YES, DEFAULT=YES,URI=<span class=\"hljs-string\">&quot;englo/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;audio-lo&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;fre&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Français&quot;</span>,AUTOSELECT=YES, DEFAULT=NO,URI=<span class=\"hljs-string\">&quot;frelo/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;audio-lo&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;es&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Espanol&quot;</span>,AUTOSELECT=YES, DEFAULT=NO,URI=<span class=\"hljs-string\">&quot;splo/prog_index.m3u8&quot;</span><br> <br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;audio-hi&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;eng&quot;</span>,NAME=<span class=\"hljs-string\">&quot;English&quot;</span>,AUTOSELECT=YES, DEFAULT=YES,URI=<span class=\"hljs-string\">&quot;eng/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;audio-hi&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;fre&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Français&quot;</span>,AUTOSELECT=YES, DEFAULT=NO,URI=<span class=\"hljs-string\">&quot;fre/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;audio-hi&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;es&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Espanol&quot;</span>,AUTOSELECT=YES, DEFAULT=NO,URI=<span class=\"hljs-string\">&quot;sp/prog_index.m3u8&quot;</span><br> <br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-STREAM</span><span class=\"hljs-params\">-INF</span>:BANDWIDTH=<span class=\"hljs-number\">195023</span>,CODECS=<span class=\"hljs-string\">&quot;mp4a.40.5&quot;</span>, AUDIO=<span class=\"hljs-string\">&quot;audio-lo&quot;</span><br>lo/prog_index.m3u8<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-STREAM</span><span class=\"hljs-params\">-INF</span>:BANDWIDTH=<span class=\"hljs-number\">260000</span>,CODECS=<span class=\"hljs-string\">&quot;avc1.42e01e,mp4a.40.2&quot;</span>, AUDIO=<span class=\"hljs-string\">&quot;audio-lo&quot;</span><br>hi/prog_index.m3u8<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-STREAM</span><span class=\"hljs-params\">-INF</span>:BANDWIDTH=<span class=\"hljs-number\">591680</span>,CODECS=<span class=\"hljs-string\">&quot;mp4a.40.2, avc1.64001e&quot;</span>, AUDIO=<span class=\"hljs-string\">&quot;audio-hi&quot;</span><br>lo/prog_index.m3u8<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-STREAM</span><span class=\"hljs-params\">-INF</span>:BANDWIDTH=<span class=\"hljs-number\">650000</span>,CODECS=<span class=\"hljs-string\">&quot;avc1.42e01e,mp4a.40.2&quot;</span>, AUDIO=<span class=\"hljs-string\">&quot;audio-hi&quot;</span><br>hi/prog_index.m3u8<br><br></code></pre></td></tr></table></figure>\n\n<p>You can have both a group and a single stream in a playlist. This is often done when you have multiple camera angles that all use the same audio. Create a group for the video streams and then declare the single audio stream. The following example shows a playlist with three camera angles and a single audio stream:</p>\n<p>一个视频组关联单个音频的情况。</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\">#EXTM3U<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=VIDEO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;500kbs&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Angle1&quot;</span>,AUTOSELECT=YES,DEFAULT=YES<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=VIDEO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;500kbs&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Angle2&quot;</span>,AUTOSELECT=YES,DEFAULT=NO, URI=<span class=\"hljs-string\">&quot;Angle2/500kbs/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=VIDEO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;500kbs&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Angle3&quot;</span>,AUTOSELECT=YES,DEFAULT=NO, URI=<span class=\"hljs-string\">&quot;Angle3/500kbs/prog_index.m3u8&quot;</span><br><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;aac&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;en&quot;</span>,NAME=<span class=\"hljs-string\">&quot;English&quot;</span>,AUTOSELECT=YES, DEFAULT=YES,URI=<span class=\"hljs-string\">&quot;eng/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-STREAM</span><span class=\"hljs-params\">-INF</span>:PROGRAM<span class=\"hljs-params\">-ID</span>=<span class=\"hljs-number\">1</span>,BANDWIDTH=<span class=\"hljs-number\">754857</span>,CODECS=<span class=\"hljs-string\">&quot;mp4a.40.2,avc1.4d401e&quot;</span>, VIDEO=<span class=\"hljs-string\">&quot;500kbs&quot;</span>,AUDIO=<span class=\"hljs-string\">&quot;aac&quot;</span><br>Angle1/<span class=\"hljs-number\">500</span>kbs/prog_index.m3u8<br></code></pre></td></tr></table></figure>\n\n<p>To provide different streams for different bit rates, a different video group ID is needed for each bit rate.</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lasso\">#EXTM3U<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=VIDEO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;200kbs&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Angle1&quot;</span>,AUTOSELECT=YES,DEFAULT=YES<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=VIDEO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;200kbs&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Angle2&quot;</span>,AUTOSELECT=YES,DEFAULT=NO, URI=<span class=\"hljs-string\">&quot;Angle2/200kbs/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=VIDEO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;200kbs&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Angle3&quot;</span>,AUTOSELECT=YES,DEFAULT=NO, URI=<span class=\"hljs-string\">&quot;Angle3/200kbs/prog_index.m3u8&quot;</span><br><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=VIDEO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;500kbs&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Angle1&quot;</span>,AUTOSELECT=YES,DEFAULT=YES<br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=VIDEO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;500kbs&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Angle2&quot;</span>,AUTOSELECT=YES,DEFAULT=NO, URI=<span class=\"hljs-string\">&quot;Angle2/500kbs/prog_index.m3u8&quot;</span><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=VIDEO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;500kbs&quot;</span>,NAME=<span class=\"hljs-string\">&quot;Angle3&quot;</span>,AUTOSELECT=YES,DEFAULT=NO, URI=<span class=\"hljs-string\">&quot;Angle3/500kbs/prog_index.m3u8&quot;</span><br><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-MEDIA</span>:<span class=\"hljs-keyword\">TYPE</span>=AUDIO,<span class=\"hljs-keyword\">GROUP</span><span class=\"hljs-params\">-ID</span>=<span class=\"hljs-string\">&quot;aac&quot;</span>,LANGUAGE=<span class=\"hljs-string\">&quot;en&quot;</span>,NAME=<span class=\"hljs-string\">&quot;English&quot;</span>,AUTOSELECT=YES, DEFAULT=YES,URI=<span class=\"hljs-string\">&quot;eng/prog_index.m3u8&quot;</span><br><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-STREAM</span><span class=\"hljs-params\">-INF</span>:PROGRAM<span class=\"hljs-params\">-ID</span>=<span class=\"hljs-number\">1</span>,BANDWIDTH=<span class=\"hljs-number\">300000</span>,CODECS=<span class=\"hljs-string\">&quot;mp4a.40.2,avc1.4d401e&quot;</span>, VIDEO=<span class=\"hljs-string\">&quot;200kbs&quot;</span>,AUDIO=<span class=\"hljs-string\">&quot;aac&quot;</span><br>Angle1/<span class=\"hljs-number\">200</span>kbs/prog_index.m3u<br><br>#EXT<span class=\"hljs-params\">-X</span><span class=\"hljs-params\">-STREAM</span><span class=\"hljs-params\">-INF</span>:PROGRAM<span class=\"hljs-params\">-ID</span>=<span class=\"hljs-number\">1</span>,BANDWIDTH=<span class=\"hljs-number\">754857</span>,CODECS=<span class=\"hljs-string\">&quot;mp4a.40.2,avc1.4d401e&quot;</span>, VIDEO=<span class=\"hljs-string\">&quot;500kbs&quot;</span>,AUDIO=<span class=\"hljs-string\">&quot;aac&quot;</span><br>Angle1/<span class=\"hljs-number\">500</span>kbs/prog_index.m3u8<br></code></pre></td></tr></table></figure>\n\n<p>参考：<br><a href=\"https://developer.apple.com/documentation/http_live_streaming\">https://developer.apple.com/documentation/http_live_streaming</a><br><a href=\"https://aleen42.gitbooks.io/wiki/content/summary/m3u8/m3u8.html\">https://aleen42.gitbooks.io/wiki/content/summary/m3u8/m3u8.html</a></p>\n"},{"layout":"post","title":"使用Xcode调试ffmpeg","date":"2022-03-08T16:00:00.000Z","_content":"\nffmpeg 源码 https://github.com/FFmpeg/FFmpeg.git\n\n## ffmpeg 配置, 使其支持调试\n\n```bash\n./configure  --disable-optimizations --disable-stripping --enable-debug=3 --disable-doc\nmake -j `nproc`\n```\n\n![image20210422182014703png](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/1646798696028ceaddb1d1dd2473496faad4c1883ba1d.png) \n\n以`_g`结尾的就是可以调试的程序`ffmpeg_g, ffplay_g, ffprobe_g`\n\n## Xcode 配置\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468770121471646877011522.png)\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468770571461646877056550.png)\n\n把 ffmpeg 目录拖进工程，等待添加完成，可能时间较久\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468356217741646835620857.png)\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468772051421646877204301.png)等待加载完毕\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468780312171646878030941.png)\n\n\n\n添加target， 比如说调试`ffplay_g`\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468360299171646836029894.png)\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468360897771646836089376.png)\n\n修改对应的路径\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468361877781646836187409.png)\n\n修改scheme，选择`ffplay_g`为可执行目标\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468363477791646836347004.png)\n\n给`ffplay_g`传递参数\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468366427811646836642007.png)\n\n开始打断点调试吧\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468367127821646836712289.png)\n\n## 调试 ffmpeg官方的示例程序，示例位于`ffmpeg/doc/examples`路径下面\n\n```shell\ncd ffmpeg\nmake examples\n```\n\n后缀带`_g`的都是可以调试的\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468370517811646837051618.png)\n\n与调试ffplay_g一样，添加target，配置路径，配置可执行目标，添加参数，愉快地调试吧！\n\n---\n\n参考： [Xcode调试ffmpeg源码(十五) - 简书](https://www.jianshu.com/p/27a90b113413)\n","source":"_posts/ffmpeg/2022-03-09-使用Xcode调试ffmpeg.md","raw":"---\nlayout: post\ntitle: \"使用Xcode调试ffmpeg\"\ndate: 2022-03-09 \ntag: ffmpeg\n\n---\n\nffmpeg 源码 https://github.com/FFmpeg/FFmpeg.git\n\n## ffmpeg 配置, 使其支持调试\n\n```bash\n./configure  --disable-optimizations --disable-stripping --enable-debug=3 --disable-doc\nmake -j `nproc`\n```\n\n![image20210422182014703png](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/1646798696028ceaddb1d1dd2473496faad4c1883ba1d.png) \n\n以`_g`结尾的就是可以调试的程序`ffmpeg_g, ffplay_g, ffprobe_g`\n\n## Xcode 配置\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468770121471646877011522.png)\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468770571461646877056550.png)\n\n把 ffmpeg 目录拖进工程，等待添加完成，可能时间较久\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468356217741646835620857.png)\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468772051421646877204301.png)等待加载完毕\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468780312171646878030941.png)\n\n\n\n添加target， 比如说调试`ffplay_g`\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468360299171646836029894.png)\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468360897771646836089376.png)\n\n修改对应的路径\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468361877781646836187409.png)\n\n修改scheme，选择`ffplay_g`为可执行目标\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468363477791646836347004.png)\n\n给`ffplay_g`传递参数\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468366427811646836642007.png)\n\n开始打断点调试吧\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468367127821646836712289.png)\n\n## 调试 ffmpeg官方的示例程序，示例位于`ffmpeg/doc/examples`路径下面\n\n```shell\ncd ffmpeg\nmake examples\n```\n\n后缀带`_g`的都是可以调试的\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468370517811646837051618.png)\n\n与调试ffplay_g一样，添加target，配置路径，配置可执行目标，添加参数，愉快地调试吧！\n\n---\n\n参考： [Xcode调试ffmpeg源码(十五) - 简书](https://www.jianshu.com/p/27a90b113413)\n","slug":"ffmpeg/2022-03-09-使用Xcode调试ffmpeg","published":1,"updated":"2024-03-06T11:53:13.565Z","comments":1,"photos":[],"_id":"cltgopenb001hqywhhj525uwo","content":"<p>ffmpeg 源码 <a href=\"https://github.com/FFmpeg/FFmpeg.git\">https://github.com/FFmpeg/FFmpeg.git</a></p>\n<h2 id=\"ffmpeg-配置-使其支持调试\"><a href=\"#ffmpeg-配置-使其支持调试\" class=\"headerlink\" title=\"ffmpeg 配置, 使其支持调试\"></a>ffmpeg 配置, 使其支持调试</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">./configure  --disable-optimizations --disable-stripping --enable-debug=3 --disable-doc<br>make -j `<span class=\"hljs-built_in\">nproc</span>`<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/1646798696028ceaddb1d1dd2473496faad4c1883ba1d.png\" alt=\"image20210422182014703png\"> </p>\n<p>以<code>_g</code>结尾的就是可以调试的程序<code>ffmpeg_g, ffplay_g, ffprobe_g</code></p>\n<h2 id=\"Xcode-配置\"><a href=\"#Xcode-配置\" class=\"headerlink\" title=\"Xcode 配置\"></a>Xcode 配置</h2><p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468770121471646877011522.png\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468770571461646877056550.png\"></p>\n<p>把 ffmpeg 目录拖进工程，等待添加完成，可能时间较久</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468356217741646835620857.png\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468772051421646877204301.png\">等待加载完毕</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468780312171646878030941.png\"></p>\n<p>添加target， 比如说调试<code>ffplay_g</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468360299171646836029894.png\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468360897771646836089376.png\"></p>\n<p>修改对应的路径</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468361877781646836187409.png\"></p>\n<p>修改scheme，选择<code>ffplay_g</code>为可执行目标</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468363477791646836347004.png\"></p>\n<p>给<code>ffplay_g</code>传递参数</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468366427811646836642007.png\"></p>\n<p>开始打断点调试吧</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468367127821646836712289.png\"></p>\n<h2 id=\"调试-ffmpeg官方的示例程序，示例位于ffmpeg-doc-examples路径下面\"><a href=\"#调试-ffmpeg官方的示例程序，示例位于ffmpeg-doc-examples路径下面\" class=\"headerlink\" title=\"调试 ffmpeg官方的示例程序，示例位于ffmpeg/doc/examples路径下面\"></a>调试 ffmpeg官方的示例程序，示例位于<code>ffmpeg/doc/examples</code>路径下面</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">cd ffmpeg<br>make examples<br></code></pre></td></tr></table></figure>\n\n<p>后缀带<code>_g</code>的都是可以调试的</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468370517811646837051618.png\"></p>\n<p>与调试ffplay_g一样，添加target，配置路径，配置可执行目标，添加参数，愉快地调试吧！</p>\n<hr>\n<p>参考： <a href=\"https://www.jianshu.com/p/27a90b113413\">Xcode调试ffmpeg源码(十五) - 简书</a></p>\n","excerpt":"","more":"<p>ffmpeg 源码 <a href=\"https://github.com/FFmpeg/FFmpeg.git\">https://github.com/FFmpeg/FFmpeg.git</a></p>\n<h2 id=\"ffmpeg-配置-使其支持调试\"><a href=\"#ffmpeg-配置-使其支持调试\" class=\"headerlink\" title=\"ffmpeg 配置, 使其支持调试\"></a>ffmpeg 配置, 使其支持调试</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">./configure  --disable-optimizations --disable-stripping --enable-debug=3 --disable-doc<br>make -j `<span class=\"hljs-built_in\">nproc</span>`<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/1646798696028ceaddb1d1dd2473496faad4c1883ba1d.png\" alt=\"image20210422182014703png\"> </p>\n<p>以<code>_g</code>结尾的就是可以调试的程序<code>ffmpeg_g, ffplay_g, ffprobe_g</code></p>\n<h2 id=\"Xcode-配置\"><a href=\"#Xcode-配置\" class=\"headerlink\" title=\"Xcode 配置\"></a>Xcode 配置</h2><p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468770121471646877011522.png\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468770571461646877056550.png\"></p>\n<p>把 ffmpeg 目录拖进工程，等待添加完成，可能时间较久</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468356217741646835620857.png\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468772051421646877204301.png\">等待加载完毕</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468780312171646878030941.png\"></p>\n<p>添加target， 比如说调试<code>ffplay_g</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468360299171646836029894.png\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468360897771646836089376.png\"></p>\n<p>修改对应的路径</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468361877781646836187409.png\"></p>\n<p>修改scheme，选择<code>ffplay_g</code>为可执行目标</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468363477791646836347004.png\"></p>\n<p>给<code>ffplay_g</code>传递参数</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468366427811646836642007.png\"></p>\n<p>开始打断点调试吧</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468367127821646836712289.png\"></p>\n<h2 id=\"调试-ffmpeg官方的示例程序，示例位于ffmpeg-doc-examples路径下面\"><a href=\"#调试-ffmpeg官方的示例程序，示例位于ffmpeg-doc-examples路径下面\" class=\"headerlink\" title=\"调试 ffmpeg官方的示例程序，示例位于ffmpeg/doc/examples路径下面\"></a>调试 ffmpeg官方的示例程序，示例位于<code>ffmpeg/doc/examples</code>路径下面</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">cd ffmpeg<br>make examples<br></code></pre></td></tr></table></figure>\n\n<p>后缀带<code>_g</code>的都是可以调试的</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468370517811646837051618.png\"></p>\n<p>与调试ffplay_g一样，添加target，配置路径，配置可执行目标，添加参数，愉快地调试吧！</p>\n<hr>\n<p>参考： <a href=\"https://www.jianshu.com/p/27a90b113413\">Xcode调试ffmpeg源码(十五) - 简书</a></p>\n"},{"layout":"post","title":"如何使用vscode在macOS平台调试ffmpeg","date":"2022-03-08T16:00:00.000Z","_content":"\n# 使用vscode调试ffmpeg\n\n准备知识：[Debug C++ in Visual Studio Code](https://code.visualstudio.com/docs/cpp/cpp-debug)\n\nffmpeg 源码 https://github.com/FFmpeg/FFmpeg.git\n\n## ffmpeg 配置, 使其支持调试\n\n关于`-g3`相关知识[gcc-g-vs-g3-gdb-flag-what-is-the-difference](https://stackoverflow.com/questions/10475040/gcc-g-vs-g3-gdb-flag-what-is-the-difference)\n\n```bash\n./configure  --disable-optimizations --disable-stripping --enable-debug=3 --disable-doc\nmake -j `nproc`\n```\n\n![image-20210422182014703.png](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/1646798696028ceaddb1d1dd2473496faad4c1883ba1d.png)\n以`_g`结尾的就是可以调试的程序`ffmpeg_g, ffplay_g, ffprobe_g`\n\n## vscode配置\n\n![image-20210422181630503.png](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/1646798890870e47d61888a5e4095b6b1fd9c30246471.png)\n\n如下命令：\n\n```\n# macOS上列出所有的音视频设备\nffmpeg -f avfoundation -list_devices true -i \"\"\n```\n\n> launch.json 对应的配置\n\n```\n{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"(lldb) Launch\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceFolder}/ffmpeg_g\",\n            \"args\": [\"-f\", \"avfoundation\", \"-list_devices\", \"true\", \"-i\", \"\\\"\\\"\"],\n            \"stopAtEntry\": false,\n            \"cwd\": \"${workspaceFolder}\",\n            \"environment\": [],\n            \"externalConsole\": false,\n            \"MIMode\": \"lldb\"\n        }\n    ]\n}\n```\n\n打上断点，点击运行，就可以愉快的调试了\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/164679893487073e861799f104c449a57f809f7e7c1e1.png)\n\n附上链接：lldb 使用教程 [Tutorial](https://lldb.llvm.org/use/tutorial.html)\n\n# 调试ffmpeg/doc/example\n\n```shell\nmake examples \n```\n\n在ffmpeg/doc/example目录下, 以`_g`结尾的就是可以调试的\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468208261531646820825284.png)\n\n配置launch.json\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468210321531646821031535.png)\n\n开始调试吧\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468211571521646821156644.png)\n\n## 修改代码重新编译\n\n 例如你在调试的时候，修改了ffmpeg的源码，想调试一下更改后的代码，需要重新编译生成。\n\n```\ncd ffmpeg\nmake -j 16\nmake examples\n```\n\n你想自动化这个过程，在调试之前自动编译，如何实现呢？\n\n#### 配置 `prelaunchTask`\n\n1. 在tasks.json中添加一个task\n   \n   ```\n   {\n       // See https://go.microsoft.com/fwlink/?LinkId=733558\n       // for the documentation about the tasks.json format\n       \"version\": \"2.0.0\",\n       \"tasks\": [\n           {\n               \"label\": \"make\",\n               \"type\": \"shell\",\n               \"command\": \"make -j 16; make examples\",\n               \"problemMatcher\": [],\n               \"group\": {\n                   \"kind\": \"build\",\n                   \"isDefault\": true\n               },\n               \"options\": {\n                   \"cwd\": \"${workspaceFolder}\"\n               }\n           }\n       ]\n   }\n   ```\n\n2. 在launch.json中配置prelaunchTask\n   \n   ![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16472372959411647237295151.png)\n\n然后修改代码，点击调试， vscode 自动执行make，编译修改后的文件，重新生成可执行程序。然后就可以愉快地修改代码，调试，修改也会即时生效。\n\n## 备注：m1 芯片的mac 如果遇到调试问题\n\n[ ERROR: Unable to start debugging. Unexpected LLDB output from command \"-exec-run\". process exited with status -1 (attach failed ((os/kern) invalid argument)) ](https://github.com/microsoft/vscode-cpptools/issues/6779)\n\n解决办法：\n\n使用 `CodeLLDB debugger`插件，而不是vc code 原生的调试插件\n\n> I would suggest you to use CodeLLDB debugger (vadimcn.vscode-lldb). It's an extension in VSCode and works exactly like the native debugger in VSCode. For its setup, you just need to change the configuration of your launch.json file with the one provided by the extension. And that should do the trick.\n\n> Now if you would try to debug then, VSCode will make use of that extension and should be able to debug your programs as it was to be done by the native debugger.\n\n> I am personally using it on my M1 chip MacBook Air, and it works perfectly fine. According to me, It's much easier to implement than other workarounds present at the moment.\n","source":"_posts/ffmpeg/2022-03-09-如何使用vscode在macOS平台调试ffmpeg.md","raw":"---\nlayout: post\ntitle: \"如何使用vscode在macOS平台调试ffmpeg\"\ndate: 2022-03-09 \ntag: ffmpeg\n\n---\n\n# 使用vscode调试ffmpeg\n\n准备知识：[Debug C++ in Visual Studio Code](https://code.visualstudio.com/docs/cpp/cpp-debug)\n\nffmpeg 源码 https://github.com/FFmpeg/FFmpeg.git\n\n## ffmpeg 配置, 使其支持调试\n\n关于`-g3`相关知识[gcc-g-vs-g3-gdb-flag-what-is-the-difference](https://stackoverflow.com/questions/10475040/gcc-g-vs-g3-gdb-flag-what-is-the-difference)\n\n```bash\n./configure  --disable-optimizations --disable-stripping --enable-debug=3 --disable-doc\nmake -j `nproc`\n```\n\n![image-20210422182014703.png](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/1646798696028ceaddb1d1dd2473496faad4c1883ba1d.png)\n以`_g`结尾的就是可以调试的程序`ffmpeg_g, ffplay_g, ffprobe_g`\n\n## vscode配置\n\n![image-20210422181630503.png](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/1646798890870e47d61888a5e4095b6b1fd9c30246471.png)\n\n如下命令：\n\n```\n# macOS上列出所有的音视频设备\nffmpeg -f avfoundation -list_devices true -i \"\"\n```\n\n> launch.json 对应的配置\n\n```\n{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"(lldb) Launch\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceFolder}/ffmpeg_g\",\n            \"args\": [\"-f\", \"avfoundation\", \"-list_devices\", \"true\", \"-i\", \"\\\"\\\"\"],\n            \"stopAtEntry\": false,\n            \"cwd\": \"${workspaceFolder}\",\n            \"environment\": [],\n            \"externalConsole\": false,\n            \"MIMode\": \"lldb\"\n        }\n    ]\n}\n```\n\n打上断点，点击运行，就可以愉快的调试了\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/164679893487073e861799f104c449a57f809f7e7c1e1.png)\n\n附上链接：lldb 使用教程 [Tutorial](https://lldb.llvm.org/use/tutorial.html)\n\n# 调试ffmpeg/doc/example\n\n```shell\nmake examples \n```\n\n在ffmpeg/doc/example目录下, 以`_g`结尾的就是可以调试的\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468208261531646820825284.png)\n\n配置launch.json\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468210321531646821031535.png)\n\n开始调试吧\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468211571521646821156644.png)\n\n## 修改代码重新编译\n\n 例如你在调试的时候，修改了ffmpeg的源码，想调试一下更改后的代码，需要重新编译生成。\n\n```\ncd ffmpeg\nmake -j 16\nmake examples\n```\n\n你想自动化这个过程，在调试之前自动编译，如何实现呢？\n\n#### 配置 `prelaunchTask`\n\n1. 在tasks.json中添加一个task\n   \n   ```\n   {\n       // See https://go.microsoft.com/fwlink/?LinkId=733558\n       // for the documentation about the tasks.json format\n       \"version\": \"2.0.0\",\n       \"tasks\": [\n           {\n               \"label\": \"make\",\n               \"type\": \"shell\",\n               \"command\": \"make -j 16; make examples\",\n               \"problemMatcher\": [],\n               \"group\": {\n                   \"kind\": \"build\",\n                   \"isDefault\": true\n               },\n               \"options\": {\n                   \"cwd\": \"${workspaceFolder}\"\n               }\n           }\n       ]\n   }\n   ```\n\n2. 在launch.json中配置prelaunchTask\n   \n   ![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16472372959411647237295151.png)\n\n然后修改代码，点击调试， vscode 自动执行make，编译修改后的文件，重新生成可执行程序。然后就可以愉快地修改代码，调试，修改也会即时生效。\n\n## 备注：m1 芯片的mac 如果遇到调试问题\n\n[ ERROR: Unable to start debugging. Unexpected LLDB output from command \"-exec-run\". process exited with status -1 (attach failed ((os/kern) invalid argument)) ](https://github.com/microsoft/vscode-cpptools/issues/6779)\n\n解决办法：\n\n使用 `CodeLLDB debugger`插件，而不是vc code 原生的调试插件\n\n> I would suggest you to use CodeLLDB debugger (vadimcn.vscode-lldb). It's an extension in VSCode and works exactly like the native debugger in VSCode. For its setup, you just need to change the configuration of your launch.json file with the one provided by the extension. And that should do the trick.\n\n> Now if you would try to debug then, VSCode will make use of that extension and should be able to debug your programs as it was to be done by the native debugger.\n\n> I am personally using it on my M1 chip MacBook Air, and it works perfectly fine. According to me, It's much easier to implement than other workarounds present at the moment.\n","slug":"ffmpeg/2022-03-09-如何使用vscode在macOS平台调试ffmpeg","published":1,"updated":"2024-03-06T11:53:13.565Z","comments":1,"photos":[],"_id":"cltgopenc001jqywh42v31l6n","content":"<h1 id=\"使用vscode调试ffmpeg\"><a href=\"#使用vscode调试ffmpeg\" class=\"headerlink\" title=\"使用vscode调试ffmpeg\"></a>使用vscode调试ffmpeg</h1><p>准备知识：<a href=\"https://code.visualstudio.com/docs/cpp/cpp-debug\">Debug C++ in Visual Studio Code</a></p>\n<p>ffmpeg 源码 <a href=\"https://github.com/FFmpeg/FFmpeg.git\">https://github.com/FFmpeg/FFmpeg.git</a></p>\n<h2 id=\"ffmpeg-配置-使其支持调试\"><a href=\"#ffmpeg-配置-使其支持调试\" class=\"headerlink\" title=\"ffmpeg 配置, 使其支持调试\"></a>ffmpeg 配置, 使其支持调试</h2><p>关于<code>-g3</code>相关知识<a href=\"https://stackoverflow.com/questions/10475040/gcc-g-vs-g3-gdb-flag-what-is-the-difference\">gcc-g-vs-g3-gdb-flag-what-is-the-difference</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">./configure  --disable-optimizations --disable-stripping --enable-debug=3 --disable-doc<br>make -j `<span class=\"hljs-built_in\">nproc</span>`<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/1646798696028ceaddb1d1dd2473496faad4c1883ba1d.png\" alt=\"image-20210422182014703.png\"><br>以<code>_g</code>结尾的就是可以调试的程序<code>ffmpeg_g, ffplay_g, ffprobe_g</code></p>\n<h2 id=\"vscode配置\"><a href=\"#vscode配置\" class=\"headerlink\" title=\"vscode配置\"></a>vscode配置</h2><p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/1646798890870e47d61888a5e4095b6b1fd9c30246471.png\" alt=\"image-20210422181630503.png\"></p>\n<p>如下命令：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-comment\"># macOS上列出所有的音视频设备</span><br><span class=\"hljs-attribute\">ffmpeg</span> -f avfoundation -list_devices <span class=\"hljs-literal\">true</span> -i <span class=\"hljs-string\">&quot;&quot;</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>launch.json 对应的配置</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dart\">&#123;<br>    <span class=\"hljs-comment\">// Use IntelliSense to learn about possible attributes.</span><br>    <span class=\"hljs-comment\">// Hover to view descriptions of existing attributes.</span><br>    <span class=\"hljs-comment\">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br>    <span class=\"hljs-string\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;0.2.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;configurations&quot;</span>: [<br>        &#123;<br>            <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;(lldb) Launch&quot;</span>,<br>            <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;cppdbg&quot;</span>,<br>            <span class=\"hljs-string\">&quot;request&quot;</span>: <span class=\"hljs-string\">&quot;launch&quot;</span>,<br>            <span class=\"hljs-string\">&quot;program&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$&#123;workspaceFolder&#125;</span>/ffmpeg_g&quot;</span>,<br>            <span class=\"hljs-string\">&quot;args&quot;</span>: [<span class=\"hljs-string\">&quot;-f&quot;</span>, <span class=\"hljs-string\">&quot;avfoundation&quot;</span>, <span class=\"hljs-string\">&quot;-list_devices&quot;</span>, <span class=\"hljs-string\">&quot;true&quot;</span>, <span class=\"hljs-string\">&quot;-i&quot;</span>, <span class=\"hljs-string\">&quot;\\&quot;\\&quot;&quot;</span>],<br>            <span class=\"hljs-string\">&quot;stopAtEntry&quot;</span>: <span class=\"hljs-keyword\">false</span>,<br>            <span class=\"hljs-string\">&quot;cwd&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$&#123;workspaceFolder&#125;</span>&quot;</span>,<br>            <span class=\"hljs-string\">&quot;environment&quot;</span>: [],<br>            <span class=\"hljs-string\">&quot;externalConsole&quot;</span>: <span class=\"hljs-keyword\">false</span>,<br>            <span class=\"hljs-string\">&quot;MIMode&quot;</span>: <span class=\"hljs-string\">&quot;lldb&quot;</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>打上断点，点击运行，就可以愉快的调试了<br><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/164679893487073e861799f104c449a57f809f7e7c1e1.png\"></p>\n<p>附上链接：lldb 使用教程 <a href=\"https://lldb.llvm.org/use/tutorial.html\">Tutorial</a></p>\n<h1 id=\"调试ffmpeg-doc-example\"><a href=\"#调试ffmpeg-doc-example\" class=\"headerlink\" title=\"调试ffmpeg&#x2F;doc&#x2F;example\"></a>调试ffmpeg&#x2F;doc&#x2F;example</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">make examples <br></code></pre></td></tr></table></figure>\n\n<p>在ffmpeg&#x2F;doc&#x2F;example目录下, 以<code>_g</code>结尾的就是可以调试的</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468208261531646820825284.png\"></p>\n<p>配置launch.json</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468210321531646821031535.png\"></p>\n<p>开始调试吧</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468211571521646821156644.png\"></p>\n<h2 id=\"修改代码重新编译\"><a href=\"#修改代码重新编译\" class=\"headerlink\" title=\"修改代码重新编译\"></a>修改代码重新编译</h2><p> 例如你在调试的时候，修改了ffmpeg的源码，想调试一下更改后的代码，需要重新编译生成。</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">cd</span> ffmpeg<br><span class=\"hljs-keyword\">make</span> -<span class=\"hljs-keyword\">j</span> <span class=\"hljs-number\">16</span><br><span class=\"hljs-keyword\">make</span> examples<br></code></pre></td></tr></table></figure>\n\n<p>你想自动化这个过程，在调试之前自动编译，如何实现呢？</p>\n<h4 id=\"配置-prelaunchTask\"><a href=\"#配置-prelaunchTask\" class=\"headerlink\" title=\"配置 prelaunchTask\"></a>配置 <code>prelaunchTask</code></h4><ol>\n<li><p>在tasks.json中添加一个task</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dart\">&#123;<br>    <span class=\"hljs-comment\">// See https://go.microsoft.com/fwlink/?LinkId=733558</span><br>    <span class=\"hljs-comment\">// for the documentation about the tasks.json format</span><br>    <span class=\"hljs-string\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;2.0.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;tasks&quot;</span>: [<br>        &#123;<br>            <span class=\"hljs-string\">&quot;label&quot;</span>: <span class=\"hljs-string\">&quot;make&quot;</span>,<br>            <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;shell&quot;</span>,<br>            <span class=\"hljs-string\">&quot;command&quot;</span>: <span class=\"hljs-string\">&quot;make -j 16; make examples&quot;</span>,<br>            <span class=\"hljs-string\">&quot;problemMatcher&quot;</span>: [],<br>            <span class=\"hljs-string\">&quot;group&quot;</span>: &#123;<br>                <span class=\"hljs-string\">&quot;kind&quot;</span>: <span class=\"hljs-string\">&quot;build&quot;</span>,<br>                <span class=\"hljs-string\">&quot;isDefault&quot;</span>: <span class=\"hljs-keyword\">true</span><br>            &#125;,<br>            <span class=\"hljs-string\">&quot;options&quot;</span>: &#123;<br>                <span class=\"hljs-string\">&quot;cwd&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$&#123;workspaceFolder&#125;</span>&quot;</span><br>            &#125;<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>在launch.json中配置prelaunchTask</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16472372959411647237295151.png\"></p>\n</li>\n</ol>\n<p>然后修改代码，点击调试， vscode 自动执行make，编译修改后的文件，重新生成可执行程序。然后就可以愉快地修改代码，调试，修改也会即时生效。</p>\n<h2 id=\"备注：m1-芯片的mac-如果遇到调试问题\"><a href=\"#备注：m1-芯片的mac-如果遇到调试问题\" class=\"headerlink\" title=\"备注：m1 芯片的mac 如果遇到调试问题\"></a>备注：m1 芯片的mac 如果遇到调试问题</h2><p><a href=\"https://github.com/microsoft/vscode-cpptools/issues/6779\"> ERROR: Unable to start debugging. Unexpected LLDB output from command “-exec-run”. process exited with status -1 (attach failed ((os&#x2F;kern) invalid argument)) </a></p>\n<p>解决办法：</p>\n<p>使用 <code>CodeLLDB debugger</code>插件，而不是vc code 原生的调试插件</p>\n<blockquote>\n<p>I would suggest you to use CodeLLDB debugger (vadimcn.vscode-lldb). It’s an extension in VSCode and works exactly like the native debugger in VSCode. For its setup, you just need to change the configuration of your launch.json file with the one provided by the extension. And that should do the trick.</p>\n</blockquote>\n<blockquote>\n<p>Now if you would try to debug then, VSCode will make use of that extension and should be able to debug your programs as it was to be done by the native debugger.</p>\n</blockquote>\n<blockquote>\n<p>I am personally using it on my M1 chip MacBook Air, and it works perfectly fine. According to me, It’s much easier to implement than other workarounds present at the moment.</p>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"使用vscode调试ffmpeg\"><a href=\"#使用vscode调试ffmpeg\" class=\"headerlink\" title=\"使用vscode调试ffmpeg\"></a>使用vscode调试ffmpeg</h1><p>准备知识：<a href=\"https://code.visualstudio.com/docs/cpp/cpp-debug\">Debug C++ in Visual Studio Code</a></p>\n<p>ffmpeg 源码 <a href=\"https://github.com/FFmpeg/FFmpeg.git\">https://github.com/FFmpeg/FFmpeg.git</a></p>\n<h2 id=\"ffmpeg-配置-使其支持调试\"><a href=\"#ffmpeg-配置-使其支持调试\" class=\"headerlink\" title=\"ffmpeg 配置, 使其支持调试\"></a>ffmpeg 配置, 使其支持调试</h2><p>关于<code>-g3</code>相关知识<a href=\"https://stackoverflow.com/questions/10475040/gcc-g-vs-g3-gdb-flag-what-is-the-difference\">gcc-g-vs-g3-gdb-flag-what-is-the-difference</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">./configure  --disable-optimizations --disable-stripping --enable-debug=3 --disable-doc<br>make -j `<span class=\"hljs-built_in\">nproc</span>`<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/1646798696028ceaddb1d1dd2473496faad4c1883ba1d.png\" alt=\"image-20210422182014703.png\"><br>以<code>_g</code>结尾的就是可以调试的程序<code>ffmpeg_g, ffplay_g, ffprobe_g</code></p>\n<h2 id=\"vscode配置\"><a href=\"#vscode配置\" class=\"headerlink\" title=\"vscode配置\"></a>vscode配置</h2><p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/1646798890870e47d61888a5e4095b6b1fd9c30246471.png\" alt=\"image-20210422181630503.png\"></p>\n<p>如下命令：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-comment\"># macOS上列出所有的音视频设备</span><br><span class=\"hljs-attribute\">ffmpeg</span> -f avfoundation -list_devices <span class=\"hljs-literal\">true</span> -i <span class=\"hljs-string\">&quot;&quot;</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>launch.json 对应的配置</p>\n</blockquote>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dart\">&#123;<br>    <span class=\"hljs-comment\">// Use IntelliSense to learn about possible attributes.</span><br>    <span class=\"hljs-comment\">// Hover to view descriptions of existing attributes.</span><br>    <span class=\"hljs-comment\">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span><br>    <span class=\"hljs-string\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;0.2.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;configurations&quot;</span>: [<br>        &#123;<br>            <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;(lldb) Launch&quot;</span>,<br>            <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;cppdbg&quot;</span>,<br>            <span class=\"hljs-string\">&quot;request&quot;</span>: <span class=\"hljs-string\">&quot;launch&quot;</span>,<br>            <span class=\"hljs-string\">&quot;program&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$&#123;workspaceFolder&#125;</span>/ffmpeg_g&quot;</span>,<br>            <span class=\"hljs-string\">&quot;args&quot;</span>: [<span class=\"hljs-string\">&quot;-f&quot;</span>, <span class=\"hljs-string\">&quot;avfoundation&quot;</span>, <span class=\"hljs-string\">&quot;-list_devices&quot;</span>, <span class=\"hljs-string\">&quot;true&quot;</span>, <span class=\"hljs-string\">&quot;-i&quot;</span>, <span class=\"hljs-string\">&quot;\\&quot;\\&quot;&quot;</span>],<br>            <span class=\"hljs-string\">&quot;stopAtEntry&quot;</span>: <span class=\"hljs-keyword\">false</span>,<br>            <span class=\"hljs-string\">&quot;cwd&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$&#123;workspaceFolder&#125;</span>&quot;</span>,<br>            <span class=\"hljs-string\">&quot;environment&quot;</span>: [],<br>            <span class=\"hljs-string\">&quot;externalConsole&quot;</span>: <span class=\"hljs-keyword\">false</span>,<br>            <span class=\"hljs-string\">&quot;MIMode&quot;</span>: <span class=\"hljs-string\">&quot;lldb&quot;</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>打上断点，点击运行，就可以愉快的调试了<br><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/164679893487073e861799f104c449a57f809f7e7c1e1.png\"></p>\n<p>附上链接：lldb 使用教程 <a href=\"https://lldb.llvm.org/use/tutorial.html\">Tutorial</a></p>\n<h1 id=\"调试ffmpeg-doc-example\"><a href=\"#调试ffmpeg-doc-example\" class=\"headerlink\" title=\"调试ffmpeg&#x2F;doc&#x2F;example\"></a>调试ffmpeg&#x2F;doc&#x2F;example</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">make examples <br></code></pre></td></tr></table></figure>\n\n<p>在ffmpeg&#x2F;doc&#x2F;example目录下, 以<code>_g</code>结尾的就是可以调试的</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468208261531646820825284.png\"></p>\n<p>配置launch.json</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468210321531646821031535.png\"></p>\n<p>开始调试吧</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468211571521646821156644.png\"></p>\n<h2 id=\"修改代码重新编译\"><a href=\"#修改代码重新编译\" class=\"headerlink\" title=\"修改代码重新编译\"></a>修改代码重新编译</h2><p> 例如你在调试的时候，修改了ffmpeg的源码，想调试一下更改后的代码，需要重新编译生成。</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\"><span class=\"hljs-keyword\">cd</span> ffmpeg<br><span class=\"hljs-keyword\">make</span> -<span class=\"hljs-keyword\">j</span> <span class=\"hljs-number\">16</span><br><span class=\"hljs-keyword\">make</span> examples<br></code></pre></td></tr></table></figure>\n\n<p>你想自动化这个过程，在调试之前自动编译，如何实现呢？</p>\n<h4 id=\"配置-prelaunchTask\"><a href=\"#配置-prelaunchTask\" class=\"headerlink\" title=\"配置 prelaunchTask\"></a>配置 <code>prelaunchTask</code></h4><ol>\n<li><p>在tasks.json中添加一个task</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dart\">&#123;<br>    <span class=\"hljs-comment\">// See https://go.microsoft.com/fwlink/?LinkId=733558</span><br>    <span class=\"hljs-comment\">// for the documentation about the tasks.json format</span><br>    <span class=\"hljs-string\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;2.0.0&quot;</span>,<br>    <span class=\"hljs-string\">&quot;tasks&quot;</span>: [<br>        &#123;<br>            <span class=\"hljs-string\">&quot;label&quot;</span>: <span class=\"hljs-string\">&quot;make&quot;</span>,<br>            <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;shell&quot;</span>,<br>            <span class=\"hljs-string\">&quot;command&quot;</span>: <span class=\"hljs-string\">&quot;make -j 16; make examples&quot;</span>,<br>            <span class=\"hljs-string\">&quot;problemMatcher&quot;</span>: [],<br>            <span class=\"hljs-string\">&quot;group&quot;</span>: &#123;<br>                <span class=\"hljs-string\">&quot;kind&quot;</span>: <span class=\"hljs-string\">&quot;build&quot;</span>,<br>                <span class=\"hljs-string\">&quot;isDefault&quot;</span>: <span class=\"hljs-keyword\">true</span><br>            &#125;,<br>            <span class=\"hljs-string\">&quot;options&quot;</span>: &#123;<br>                <span class=\"hljs-string\">&quot;cwd&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$&#123;workspaceFolder&#125;</span>&quot;</span><br>            &#125;<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>在launch.json中配置prelaunchTask</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16472372959411647237295151.png\"></p>\n</li>\n</ol>\n<p>然后修改代码，点击调试， vscode 自动执行make，编译修改后的文件，重新生成可执行程序。然后就可以愉快地修改代码，调试，修改也会即时生效。</p>\n<h2 id=\"备注：m1-芯片的mac-如果遇到调试问题\"><a href=\"#备注：m1-芯片的mac-如果遇到调试问题\" class=\"headerlink\" title=\"备注：m1 芯片的mac 如果遇到调试问题\"></a>备注：m1 芯片的mac 如果遇到调试问题</h2><p><a href=\"https://github.com/microsoft/vscode-cpptools/issues/6779\"> ERROR: Unable to start debugging. Unexpected LLDB output from command “-exec-run”. process exited with status -1 (attach failed ((os&#x2F;kern) invalid argument)) </a></p>\n<p>解决办法：</p>\n<p>使用 <code>CodeLLDB debugger</code>插件，而不是vc code 原生的调试插件</p>\n<blockquote>\n<p>I would suggest you to use CodeLLDB debugger (vadimcn.vscode-lldb). It’s an extension in VSCode and works exactly like the native debugger in VSCode. For its setup, you just need to change the configuration of your launch.json file with the one provided by the extension. And that should do the trick.</p>\n</blockquote>\n<blockquote>\n<p>Now if you would try to debug then, VSCode will make use of that extension and should be able to debug your programs as it was to be done by the native debugger.</p>\n</blockquote>\n<blockquote>\n<p>I am personally using it on my M1 chip MacBook Air, and it works perfectly fine. According to me, It’s much easier to implement than other workarounds present at the moment.</p>\n</blockquote>\n"},{"layout":"post","title":"ffmpeg example 1.解封装，解码学习","date":"2022-03-09T16:00:00.000Z","_content":"\n\n\n## 背景\n\n学习ffmpeg，打算从源码入手，源码又太多太复杂。好在ffmpeg提供了示例代码，演示如何使用ffmpeg的api， 示例代码位于`ffmpeg/doc/examples`目录下，可以[通过vscode 来调试](https://yxibng.github.io/2022/03/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vscode%E5%9C%A8macOS%E5%B9%B3%E5%8F%B0%E8%B0%83%E8%AF%95ffmpeg/)这些示例代码，理解ffmpeg的调用方式。\n\n\n\n该目录下的示例代码如下\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468967433771646896743076.png)\n\n- decode_audio.c  演示如何解码音频\n\n- decode_video.c  演示如何解码视频\n\n- demuxing_decoding.c  演示如何解封装文件，和解码音视频\n\n今天来分析 `demuxing_decoding.c`\n\n\n\n## 流程\n\n\n\n\n使用的模块`libavutil`,`libavcodec`,`libavformat`\n\n- libavutil  包含一些公共的工具函数\n\n- libavcodec 用于各种类型声音/图像编解码\n\n- libavformat 用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能，包含demuxers和muxer库\n\n### 1.解封装\n\n1. 打开文件、获取封装信息上下文AVFormatContext（avformat_open_input）\n\n2. 获取媒体文件音视频信息，这一步会将AVFormatContext内部变量填充（avformat_find_stream_info）\n\n3. 获取音视频流ID。一般有两种方法：\n   \n   1. 遍历AVFormatContext内部所有的stream，如果stream的codec_type对应为audio/video，这记录当前stream的ID；\n   \n   2. FFmpeg提供av_find_best_stream接口，可以直接获取相应类型（audio or video）的流ID\n\n4. 获取流的每一帧数据（av_read_frame）  \n\n5. 关闭文件\n\n### 2.解码\n\n解码在解封装的基础上，将每一帧数据进行解码。步骤如下：\n\n1. 申请解码器上下文AVCodecContext（avcodec_alloc_context3）\n\n2. 初始化AVCodecContext参数，可以使用将解封装得到的流的解码器参数设置进来（avcodec_parameters_to_context）\n\n3. 打开解码器（avcodec_open2）\n\n4. 解码每一帧数据。只需要将解封装获取的帧传递给解码器（avcodec_send_packet），再接收即可（avcodec_receive_frame）\n\n5. 关闭文件和解码器\n   \n   \n   \n\n## 源码分析\n\n#### main 函数，简化版\n\n```c\nint main (int argc, char **argv)\n{\n    /*\n     打开输入文件，创建AVFormatContext\n    */\n    if (avformat_open_input(&fmt_ctx, src_filename, NULL, NULL) < 0) {\n        fprintf(stderr, \"Could not open source file %s\\n\", src_filename);\n        exit(1);\n    }\n\n    /* 获取封装格式中的音视频信息，填充在AVFormatContext中 */\n    if (avformat_find_stream_info(fmt_ctx, NULL) < 0) {\n        fprintf(stderr, \"Could not find stream information\\n\");\n        exit(1);\n    }\n    /*\n    1. 从 fmt_ctx 读取视频对应的AVStream\n    2. 从 AVStream 读取解码相关的 AVCodec\n    3. 根据 AVCodec 创建 AVCodecContext，根据 AVStream 给 AVCodecContext 填充解码参数\n    4. 打开解码器\n    */\n    if (open_codec_context(&video_stream_idx, &video_dec_ctx, fmt_ctx, AVMEDIA_TYPE_VIDEO) >= 0) {\n        video_stream = fmt_ctx->streams[video_stream_idx];\n    }\n    /*\n    1. 从 fmt_ctx 读取音频对应的AVStream\n    2. 从 AVStream 读取解码相关的 AVCodec\n    3. 根据 AVCodec 创建 AVCodecContext，根据 AVStream 给 AVCodecContext 填充解码参数\n    4. 打开解码器\n    */\n    if (open_codec_context(&audio_stream_idx, &audio_dec_ctx, fmt_ctx, AVMEDIA_TYPE_AUDIO) >= 0) {\n        audio_stream = fmt_ctx->streams[audio_stream_idx];\n    }\n\n    //创建frame, 用于存储解码后的数据\n    frame = av_frame_alloc();\n    //创建pkt，用于存储解封装后从文件中读取的音视频包\n    pkt = av_packet_alloc();\n    /*\n    从文件中循环读取音视频帧，存入pkt\n    根据类型区分音频帧还是视频帧，分别送给对应的解码器去解码\n    */\n    while (av_read_frame(fmt_ctx, pkt) >= 0) {\n        // check if the packet belongs to a stream we are interested in, otherwise\n        // skip it\n        if (pkt->stream_index == video_stream_idx)\n            ret = decode_packet(video_dec_ctx, pkt);\n        else if (pkt->stream_index == audio_stream_idx)\n            ret = decode_packet(audio_dec_ctx, pkt);\n        av_packet_unref(pkt);\n        if (ret < 0)\n            break;\n    }\n\n    /* 冲洗音视频解码器，将剩余的解码数据读出来 */\n    if (video_dec_ctx)\n        decode_packet(video_dec_ctx, NULL);\n    if (audio_dec_ctx)\n        decode_packet(audio_dec_ctx, NULL);\nend:\n    //资源释放和退出\n    avcodec_free_context(&video_dec_ctx);\n    avcodec_free_context(&audio_dec_ctx);\n    avformat_close_input(&fmt_ctx);\n    if (video_dst_file)\n        fclose(video_dst_file);\n    if (audio_dst_file)\n        fclose(audio_dst_file);\n    av_packet_free(&pkt);\n    av_frame_free(&frame);\n    av_free(video_dst_data[0]);\n\n    return ret < 0;\n}\n\n```\n\n1. 验证输入参数是否正确\n\n2. 打开文件，读取封装信息\n\n3. 根据封装信息，分别创建视频解码器和音频解码器\n\n4. 循环从文件中读取pkt\n   \n   1. 如果是视频数据，送到视频解码器，解码后写入视频文件\n   \n   2. 如果是音频数据，送到音频解码器，解码后写入音频文件\n\n5. 冲洗音频视频解码器，读取剩余数据\n\n6. 清理资源退出\n\n# \n\n#### open_codec_context\n\n```c\nstatic int open_codec_context(int *stream_idx,\n                              AVCodecContext **dec_ctx, AVFormatContext *fmt_ctx, enum AVMediaType type)\n{\n    int ret, stream_index;\n    AVStream *st;\n    const AVCodec *dec = NULL;\n    //找到音频/视频对应的stream_index\n    ret = av_find_best_stream(fmt_ctx, type, -1, -1, NULL, 0);\n    if (ret < 0) {\n        fprintf(stderr, \"Could not find %s stream in input file '%s'\\n\",\n                av_get_media_type_string(type), src_filename);\n        return ret;\n    } else {\n        stream_index = ret;\n        //获取音频/视频对应的AVStream\n        st = fmt_ctx->streams[stream_index];\n\n        /* 获取解码对应的AVCodec */\n        dec = avcodec_find_decoder(st->codecpar->codec_id);\n        if (!dec) {\n            fprintf(stderr, \"Failed to find %s codec\\n\",\n                    av_get_media_type_string(type));\n            return AVERROR(EINVAL);\n        }\n\n        /* 根据AVCodec 创建 AVCodecContext */\n        *dec_ctx = avcodec_alloc_context3(dec);\n        if (!*dec_ctx) {\n            fprintf(stderr, \"Failed to allocate the %s codec context\\n\",\n                    av_get_media_type_string(type));\n            return AVERROR(ENOMEM);\n        }\n        /* 将AVStream的codecpar中保存的解码相关的参数，填充到AVCodecContext中 */\n        if ((ret = avcodec_parameters_to_context(*dec_ctx, st->codecpar)) < 0) {\n            fprintf(stderr, \"Failed to copy %s codec parameters to decoder context\\n\",\n                    av_get_media_type_string(type));\n            return ret;\n        }\n\n        /* 打开解码器 */\n        if ((ret = avcodec_open2(*dec_ctx, dec, NULL)) < 0) {\n            fprintf(stderr, \"Failed to open %s codec\\n\",\n                    av_get_media_type_string(type));\n            return ret;\n        }\n        //stream_index回传\n        *stream_idx = stream_index;\n    }\n\n    return 0;\n}\n```\n\n1. 获取AVStream\n\n2. 从AVStream读取解码信息，创建AVCodecContext\n\n3. 给AVCodecContext配置参数\n\n4. 打开解码器\n\n#### decode_packet\n\n```c\nstatic int decode_packet(AVCodecContext *dec, const AVPacket *pkt)\n{\n    int ret = 0;\n\n    // submit the packet to the decoder\n    ret = avcodec_send_packet(dec, pkt);\n    if (ret < 0) {\n        fprintf(stderr, \"Error submitting a packet for decoding (%s)\\n\", av_err2str(ret));\n        return ret;\n    }\n\n    // get all the available frames from the decoder\n    while (ret >= 0) {\n        ret = avcodec_receive_frame(dec, frame);\n        if (ret < 0) {\n            // those two return values are special and mean there is no output\n            // frame available, but there were no errors during decoding\n            if (ret == AVERROR_EOF || ret == AVERROR(EAGAIN))\n                return 0;\n\n            fprintf(stderr, \"Error during decoding (%s)\\n\", av_err2str(ret));\n            return ret;\n        }\n\n        // write the frame data to output file\n        if (dec->codec->type == AVMEDIA_TYPE_VIDEO)\n            ret = output_video_frame(frame);\n        else\n            ret = output_audio_frame(frame);\n\n        av_frame_unref(frame);\n        if (ret < 0)\n            return ret;\n    }\n\n    return 0;\n}\n```\n\n1. 调用avcodec_send_packet给解码器送pkt\n\n2. 调用avcodec_receive_frame从解码器读frame\n\n3. 调用output_video_frame将解码后视频写文件，调用output_audio_frame将解码后音频写文件\n\n#### output_video_frame\n\n```c\nstatic int output_video_frame(AVFrame *frame)\n{\n    //解码中，发现宽高或者格式变了，报错\n    if (frame->width != width || frame->height != height ||\n        frame->format != pix_fmt) {\n        /* To handle this change, one could call av_image_alloc again and\n         * decode the following frames into another rawvideo file. */\n        fprintf(stderr, \"Error: Width, height and pixel format have to be \"\n                \"constant in a rawvideo file, but the width, height or \"\n                \"pixel format of the input video changed:\\n\"\n                \"old: width = %d, height = %d, format = %s\\n\"\n                \"new: width = %d, height = %d, format = %s\\n\",\n                width, height, av_get_pix_fmt_name(pix_fmt),\n                frame->width, frame->height,\n                av_get_pix_fmt_name(frame->format));\n        return -1;\n    }\n    printf(\"video_frame n:%d coded_n:%d\\n\",\n           video_frame_count++, frame->coded_picture_number);\n    /*\n     从frame中读取解码后的数据，拷贝到之前申请的buffer中\n     调用av_image_copy是为了去除frame中可能的字节对齐的数据\n     写入文件中的数据，要求不含有字节对齐的数据\n    */\n\n    av_image_copy(video_dst_data, video_dst_linesize,\n                  (const uint8_t **)(frame->data), frame->linesize,\n                  pix_fmt, width, height);\n\n    /* write to rawvideo file */\n    fwrite(video_dst_data[0], 1, video_dst_bufsize, video_dst_file);\n    return 0;\n}\n```\n\n1. 判断解码后的宽高，格式是否变更，写入文件的宽高，格式应该是一致的，如果变更就报错\n\n2. 将frame中的数据拷贝到之前申请的buffer中，拷贝的时候，去除字节对齐数据\n\n3. 将buffer中的数据写入文件\n\n#### output_audio_frame\n\n```c\nstatic int output_audio_frame(AVFrame *frame)\n{\n    size_t unpadded_linesize = frame->nb_samples * av_get_bytes_per_sample(frame->format);\n    printf(\"audio_frame n:%d nb_samples:%d pts:%s\\n\",\n           audio_frame_count++, frame->nb_samples,\n           av_ts2timestr(frame->pts, &audio_dec_ctx->time_base));\n\n    /* Write the raw audio data samples of the first plane. This works\n     * fine for packed formats (e.g. AV_SAMPLE_FMT_S16). However,\n     * most audio decoders output planar audio, which uses a separate\n     * plane of audio samples for each channel (e.g. AV_SAMPLE_FMT_S16P).\n     * In other words, this code will write only the first audio channel\n     * in these cases.\n     * You should use libswresample or libavfilter to convert the frame\n     * to packed data. */\n\n    /*\n    只写了第一个声道的数据，如果是平面多声道，使用libswresample或libavfilter将其转化为交错类型的音频再写入文件\n    */\n    fwrite(frame->extended_data[0], 1, unpadded_linesize, audio_dst_file);\n\n    return 0;\n}\n```\n\n1. 将frame中的音频的第一个声道数据写入文件\n\n2. 如果想写入多声道，需要通过libswresample或libavfilter转为交错型的再写入文件\n   \n   \n   \n   ---\n\n参考了： [FFmpeg 封装、解封装及解码的流程简介_myvest的专栏-CSDN博客_ffmpeg 封装流程](https://blog.csdn.net/myvest/article/details/89254452)\n\n\n","source":"_posts/ffmpeg/2022-03-10-ffmpeg example 学习 1.md","raw":"---\nlayout: post\ntitle: \"ffmpeg example 1.解封装，解码学习\"\ndate: 2022-03-10 \ntag: ffmpeg\n\n---\n\n\n\n## 背景\n\n学习ffmpeg，打算从源码入手，源码又太多太复杂。好在ffmpeg提供了示例代码，演示如何使用ffmpeg的api， 示例代码位于`ffmpeg/doc/examples`目录下，可以[通过vscode 来调试](https://yxibng.github.io/2022/03/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vscode%E5%9C%A8macOS%E5%B9%B3%E5%8F%B0%E8%B0%83%E8%AF%95ffmpeg/)这些示例代码，理解ffmpeg的调用方式。\n\n\n\n该目录下的示例代码如下\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468967433771646896743076.png)\n\n- decode_audio.c  演示如何解码音频\n\n- decode_video.c  演示如何解码视频\n\n- demuxing_decoding.c  演示如何解封装文件，和解码音视频\n\n今天来分析 `demuxing_decoding.c`\n\n\n\n## 流程\n\n\n\n\n使用的模块`libavutil`,`libavcodec`,`libavformat`\n\n- libavutil  包含一些公共的工具函数\n\n- libavcodec 用于各种类型声音/图像编解码\n\n- libavformat 用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能，包含demuxers和muxer库\n\n### 1.解封装\n\n1. 打开文件、获取封装信息上下文AVFormatContext（avformat_open_input）\n\n2. 获取媒体文件音视频信息，这一步会将AVFormatContext内部变量填充（avformat_find_stream_info）\n\n3. 获取音视频流ID。一般有两种方法：\n   \n   1. 遍历AVFormatContext内部所有的stream，如果stream的codec_type对应为audio/video，这记录当前stream的ID；\n   \n   2. FFmpeg提供av_find_best_stream接口，可以直接获取相应类型（audio or video）的流ID\n\n4. 获取流的每一帧数据（av_read_frame）  \n\n5. 关闭文件\n\n### 2.解码\n\n解码在解封装的基础上，将每一帧数据进行解码。步骤如下：\n\n1. 申请解码器上下文AVCodecContext（avcodec_alloc_context3）\n\n2. 初始化AVCodecContext参数，可以使用将解封装得到的流的解码器参数设置进来（avcodec_parameters_to_context）\n\n3. 打开解码器（avcodec_open2）\n\n4. 解码每一帧数据。只需要将解封装获取的帧传递给解码器（avcodec_send_packet），再接收即可（avcodec_receive_frame）\n\n5. 关闭文件和解码器\n   \n   \n   \n\n## 源码分析\n\n#### main 函数，简化版\n\n```c\nint main (int argc, char **argv)\n{\n    /*\n     打开输入文件，创建AVFormatContext\n    */\n    if (avformat_open_input(&fmt_ctx, src_filename, NULL, NULL) < 0) {\n        fprintf(stderr, \"Could not open source file %s\\n\", src_filename);\n        exit(1);\n    }\n\n    /* 获取封装格式中的音视频信息，填充在AVFormatContext中 */\n    if (avformat_find_stream_info(fmt_ctx, NULL) < 0) {\n        fprintf(stderr, \"Could not find stream information\\n\");\n        exit(1);\n    }\n    /*\n    1. 从 fmt_ctx 读取视频对应的AVStream\n    2. 从 AVStream 读取解码相关的 AVCodec\n    3. 根据 AVCodec 创建 AVCodecContext，根据 AVStream 给 AVCodecContext 填充解码参数\n    4. 打开解码器\n    */\n    if (open_codec_context(&video_stream_idx, &video_dec_ctx, fmt_ctx, AVMEDIA_TYPE_VIDEO) >= 0) {\n        video_stream = fmt_ctx->streams[video_stream_idx];\n    }\n    /*\n    1. 从 fmt_ctx 读取音频对应的AVStream\n    2. 从 AVStream 读取解码相关的 AVCodec\n    3. 根据 AVCodec 创建 AVCodecContext，根据 AVStream 给 AVCodecContext 填充解码参数\n    4. 打开解码器\n    */\n    if (open_codec_context(&audio_stream_idx, &audio_dec_ctx, fmt_ctx, AVMEDIA_TYPE_AUDIO) >= 0) {\n        audio_stream = fmt_ctx->streams[audio_stream_idx];\n    }\n\n    //创建frame, 用于存储解码后的数据\n    frame = av_frame_alloc();\n    //创建pkt，用于存储解封装后从文件中读取的音视频包\n    pkt = av_packet_alloc();\n    /*\n    从文件中循环读取音视频帧，存入pkt\n    根据类型区分音频帧还是视频帧，分别送给对应的解码器去解码\n    */\n    while (av_read_frame(fmt_ctx, pkt) >= 0) {\n        // check if the packet belongs to a stream we are interested in, otherwise\n        // skip it\n        if (pkt->stream_index == video_stream_idx)\n            ret = decode_packet(video_dec_ctx, pkt);\n        else if (pkt->stream_index == audio_stream_idx)\n            ret = decode_packet(audio_dec_ctx, pkt);\n        av_packet_unref(pkt);\n        if (ret < 0)\n            break;\n    }\n\n    /* 冲洗音视频解码器，将剩余的解码数据读出来 */\n    if (video_dec_ctx)\n        decode_packet(video_dec_ctx, NULL);\n    if (audio_dec_ctx)\n        decode_packet(audio_dec_ctx, NULL);\nend:\n    //资源释放和退出\n    avcodec_free_context(&video_dec_ctx);\n    avcodec_free_context(&audio_dec_ctx);\n    avformat_close_input(&fmt_ctx);\n    if (video_dst_file)\n        fclose(video_dst_file);\n    if (audio_dst_file)\n        fclose(audio_dst_file);\n    av_packet_free(&pkt);\n    av_frame_free(&frame);\n    av_free(video_dst_data[0]);\n\n    return ret < 0;\n}\n\n```\n\n1. 验证输入参数是否正确\n\n2. 打开文件，读取封装信息\n\n3. 根据封装信息，分别创建视频解码器和音频解码器\n\n4. 循环从文件中读取pkt\n   \n   1. 如果是视频数据，送到视频解码器，解码后写入视频文件\n   \n   2. 如果是音频数据，送到音频解码器，解码后写入音频文件\n\n5. 冲洗音频视频解码器，读取剩余数据\n\n6. 清理资源退出\n\n# \n\n#### open_codec_context\n\n```c\nstatic int open_codec_context(int *stream_idx,\n                              AVCodecContext **dec_ctx, AVFormatContext *fmt_ctx, enum AVMediaType type)\n{\n    int ret, stream_index;\n    AVStream *st;\n    const AVCodec *dec = NULL;\n    //找到音频/视频对应的stream_index\n    ret = av_find_best_stream(fmt_ctx, type, -1, -1, NULL, 0);\n    if (ret < 0) {\n        fprintf(stderr, \"Could not find %s stream in input file '%s'\\n\",\n                av_get_media_type_string(type), src_filename);\n        return ret;\n    } else {\n        stream_index = ret;\n        //获取音频/视频对应的AVStream\n        st = fmt_ctx->streams[stream_index];\n\n        /* 获取解码对应的AVCodec */\n        dec = avcodec_find_decoder(st->codecpar->codec_id);\n        if (!dec) {\n            fprintf(stderr, \"Failed to find %s codec\\n\",\n                    av_get_media_type_string(type));\n            return AVERROR(EINVAL);\n        }\n\n        /* 根据AVCodec 创建 AVCodecContext */\n        *dec_ctx = avcodec_alloc_context3(dec);\n        if (!*dec_ctx) {\n            fprintf(stderr, \"Failed to allocate the %s codec context\\n\",\n                    av_get_media_type_string(type));\n            return AVERROR(ENOMEM);\n        }\n        /* 将AVStream的codecpar中保存的解码相关的参数，填充到AVCodecContext中 */\n        if ((ret = avcodec_parameters_to_context(*dec_ctx, st->codecpar)) < 0) {\n            fprintf(stderr, \"Failed to copy %s codec parameters to decoder context\\n\",\n                    av_get_media_type_string(type));\n            return ret;\n        }\n\n        /* 打开解码器 */\n        if ((ret = avcodec_open2(*dec_ctx, dec, NULL)) < 0) {\n            fprintf(stderr, \"Failed to open %s codec\\n\",\n                    av_get_media_type_string(type));\n            return ret;\n        }\n        //stream_index回传\n        *stream_idx = stream_index;\n    }\n\n    return 0;\n}\n```\n\n1. 获取AVStream\n\n2. 从AVStream读取解码信息，创建AVCodecContext\n\n3. 给AVCodecContext配置参数\n\n4. 打开解码器\n\n#### decode_packet\n\n```c\nstatic int decode_packet(AVCodecContext *dec, const AVPacket *pkt)\n{\n    int ret = 0;\n\n    // submit the packet to the decoder\n    ret = avcodec_send_packet(dec, pkt);\n    if (ret < 0) {\n        fprintf(stderr, \"Error submitting a packet for decoding (%s)\\n\", av_err2str(ret));\n        return ret;\n    }\n\n    // get all the available frames from the decoder\n    while (ret >= 0) {\n        ret = avcodec_receive_frame(dec, frame);\n        if (ret < 0) {\n            // those two return values are special and mean there is no output\n            // frame available, but there were no errors during decoding\n            if (ret == AVERROR_EOF || ret == AVERROR(EAGAIN))\n                return 0;\n\n            fprintf(stderr, \"Error during decoding (%s)\\n\", av_err2str(ret));\n            return ret;\n        }\n\n        // write the frame data to output file\n        if (dec->codec->type == AVMEDIA_TYPE_VIDEO)\n            ret = output_video_frame(frame);\n        else\n            ret = output_audio_frame(frame);\n\n        av_frame_unref(frame);\n        if (ret < 0)\n            return ret;\n    }\n\n    return 0;\n}\n```\n\n1. 调用avcodec_send_packet给解码器送pkt\n\n2. 调用avcodec_receive_frame从解码器读frame\n\n3. 调用output_video_frame将解码后视频写文件，调用output_audio_frame将解码后音频写文件\n\n#### output_video_frame\n\n```c\nstatic int output_video_frame(AVFrame *frame)\n{\n    //解码中，发现宽高或者格式变了，报错\n    if (frame->width != width || frame->height != height ||\n        frame->format != pix_fmt) {\n        /* To handle this change, one could call av_image_alloc again and\n         * decode the following frames into another rawvideo file. */\n        fprintf(stderr, \"Error: Width, height and pixel format have to be \"\n                \"constant in a rawvideo file, but the width, height or \"\n                \"pixel format of the input video changed:\\n\"\n                \"old: width = %d, height = %d, format = %s\\n\"\n                \"new: width = %d, height = %d, format = %s\\n\",\n                width, height, av_get_pix_fmt_name(pix_fmt),\n                frame->width, frame->height,\n                av_get_pix_fmt_name(frame->format));\n        return -1;\n    }\n    printf(\"video_frame n:%d coded_n:%d\\n\",\n           video_frame_count++, frame->coded_picture_number);\n    /*\n     从frame中读取解码后的数据，拷贝到之前申请的buffer中\n     调用av_image_copy是为了去除frame中可能的字节对齐的数据\n     写入文件中的数据，要求不含有字节对齐的数据\n    */\n\n    av_image_copy(video_dst_data, video_dst_linesize,\n                  (const uint8_t **)(frame->data), frame->linesize,\n                  pix_fmt, width, height);\n\n    /* write to rawvideo file */\n    fwrite(video_dst_data[0], 1, video_dst_bufsize, video_dst_file);\n    return 0;\n}\n```\n\n1. 判断解码后的宽高，格式是否变更，写入文件的宽高，格式应该是一致的，如果变更就报错\n\n2. 将frame中的数据拷贝到之前申请的buffer中，拷贝的时候，去除字节对齐数据\n\n3. 将buffer中的数据写入文件\n\n#### output_audio_frame\n\n```c\nstatic int output_audio_frame(AVFrame *frame)\n{\n    size_t unpadded_linesize = frame->nb_samples * av_get_bytes_per_sample(frame->format);\n    printf(\"audio_frame n:%d nb_samples:%d pts:%s\\n\",\n           audio_frame_count++, frame->nb_samples,\n           av_ts2timestr(frame->pts, &audio_dec_ctx->time_base));\n\n    /* Write the raw audio data samples of the first plane. This works\n     * fine for packed formats (e.g. AV_SAMPLE_FMT_S16). However,\n     * most audio decoders output planar audio, which uses a separate\n     * plane of audio samples for each channel (e.g. AV_SAMPLE_FMT_S16P).\n     * In other words, this code will write only the first audio channel\n     * in these cases.\n     * You should use libswresample or libavfilter to convert the frame\n     * to packed data. */\n\n    /*\n    只写了第一个声道的数据，如果是平面多声道，使用libswresample或libavfilter将其转化为交错类型的音频再写入文件\n    */\n    fwrite(frame->extended_data[0], 1, unpadded_linesize, audio_dst_file);\n\n    return 0;\n}\n```\n\n1. 将frame中的音频的第一个声道数据写入文件\n\n2. 如果想写入多声道，需要通过libswresample或libavfilter转为交错型的再写入文件\n   \n   \n   \n   ---\n\n参考了： [FFmpeg 封装、解封装及解码的流程简介_myvest的专栏-CSDN博客_ffmpeg 封装流程](https://blog.csdn.net/myvest/article/details/89254452)\n\n\n","slug":"ffmpeg/2022-03-10-ffmpeg example 学习 1","published":1,"updated":"2024-03-06T11:53:13.565Z","comments":1,"photos":[],"_id":"cltgopenc001lqywh9hj2f57u","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>学习ffmpeg，打算从源码入手，源码又太多太复杂。好在ffmpeg提供了示例代码，演示如何使用ffmpeg的api， 示例代码位于<code>ffmpeg/doc/examples</code>目录下，可以<a href=\"https://yxibng.github.io/2022/03/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vscode%E5%9C%A8macOS%E5%B9%B3%E5%8F%B0%E8%B0%83%E8%AF%95ffmpeg/\">通过vscode 来调试</a>这些示例代码，理解ffmpeg的调用方式。</p>\n<p>该目录下的示例代码如下</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468967433771646896743076.png\"></p>\n<ul>\n<li><p>decode_audio.c  演示如何解码音频</p>\n</li>\n<li><p>decode_video.c  演示如何解码视频</p>\n</li>\n<li><p>demuxing_decoding.c  演示如何解封装文件，和解码音视频</p>\n</li>\n</ul>\n<p>今天来分析 <code>demuxing_decoding.c</code></p>\n<h2 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h2><p>使用的模块<code>libavutil</code>,<code>libavcodec</code>,<code>libavformat</code></p>\n<ul>\n<li><p>libavutil  包含一些公共的工具函数</p>\n</li>\n<li><p>libavcodec 用于各种类型声音&#x2F;图像编解码</p>\n</li>\n<li><p>libavformat 用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能，包含demuxers和muxer库</p>\n</li>\n</ul>\n<h3 id=\"1-解封装\"><a href=\"#1-解封装\" class=\"headerlink\" title=\"1.解封装\"></a>1.解封装</h3><ol>\n<li><p>打开文件、获取封装信息上下文AVFormatContext（avformat_open_input）</p>\n</li>\n<li><p>获取媒体文件音视频信息，这一步会将AVFormatContext内部变量填充（avformat_find_stream_info）</p>\n</li>\n<li><p>获取音视频流ID。一般有两种方法：</p>\n<ol>\n<li><p>遍历AVFormatContext内部所有的stream，如果stream的codec_type对应为audio&#x2F;video，这记录当前stream的ID；</p>\n</li>\n<li><p>FFmpeg提供av_find_best_stream接口，可以直接获取相应类型（audio or video）的流ID</p>\n</li>\n</ol>\n</li>\n<li><p>获取流的每一帧数据（av_read_frame）  </p>\n</li>\n<li><p>关闭文件</p>\n</li>\n</ol>\n<h3 id=\"2-解码\"><a href=\"#2-解码\" class=\"headerlink\" title=\"2.解码\"></a>2.解码</h3><p>解码在解封装的基础上，将每一帧数据进行解码。步骤如下：</p>\n<ol>\n<li><p>申请解码器上下文AVCodecContext（avcodec_alloc_context3）</p>\n</li>\n<li><p>初始化AVCodecContext参数，可以使用将解封装得到的流的解码器参数设置进来（avcodec_parameters_to_context）</p>\n</li>\n<li><p>打开解码器（avcodec_open2）</p>\n</li>\n<li><p>解码每一帧数据。只需要将解封装获取的帧传递给解码器（avcodec_send_packet），再接收即可（avcodec_receive_frame）</p>\n</li>\n<li><p>关闭文件和解码器</p>\n</li>\n</ol>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h4 id=\"main-函数，简化版\"><a href=\"#main-函数，简化版\" class=\"headerlink\" title=\"main 函数，简化版\"></a>main 函数，简化版</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span><br>&#123;<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">     打开输入文件，创建AVFormatContext</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-keyword\">if</span> (avformat_open_input(&amp;fmt_ctx, src_filename, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-literal\">NULL</span>) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not open source file %s\\n&quot;</span>, src_filename);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 获取封装格式中的音视频信息，填充在AVFormatContext中 */</span><br>    <span class=\"hljs-keyword\">if</span> (avformat_find_stream_info(fmt_ctx, <span class=\"hljs-literal\">NULL</span>) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not find stream information\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">    1. 从 fmt_ctx 读取视频对应的AVStream</span><br><span class=\"hljs-comment\">    2. 从 AVStream 读取解码相关的 AVCodec</span><br><span class=\"hljs-comment\">    3. 根据 AVCodec 创建 AVCodecContext，根据 AVStream 给 AVCodecContext 填充解码参数</span><br><span class=\"hljs-comment\">    4. 打开解码器</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-keyword\">if</span> (open_codec_context(&amp;video_stream_idx, &amp;video_dec_ctx, fmt_ctx, AVMEDIA_TYPE_VIDEO) &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>        video_stream = fmt_ctx-&gt;streams[video_stream_idx];<br>    &#125;<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">    1. 从 fmt_ctx 读取音频对应的AVStream</span><br><span class=\"hljs-comment\">    2. 从 AVStream 读取解码相关的 AVCodec</span><br><span class=\"hljs-comment\">    3. 根据 AVCodec 创建 AVCodecContext，根据 AVStream 给 AVCodecContext 填充解码参数</span><br><span class=\"hljs-comment\">    4. 打开解码器</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-keyword\">if</span> (open_codec_context(&amp;audio_stream_idx, &amp;audio_dec_ctx, fmt_ctx, AVMEDIA_TYPE_AUDIO) &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>        audio_stream = fmt_ctx-&gt;streams[audio_stream_idx];<br>    &#125;<br><br>    <span class=\"hljs-comment\">//创建frame, 用于存储解码后的数据</span><br>    frame = av_frame_alloc();<br>    <span class=\"hljs-comment\">//创建pkt，用于存储解封装后从文件中读取的音视频包</span><br>    pkt = av_packet_alloc();<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">    从文件中循环读取音视频帧，存入pkt</span><br><span class=\"hljs-comment\">    根据类型区分音频帧还是视频帧，分别送给对应的解码器去解码</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-keyword\">while</span> (av_read_frame(fmt_ctx, pkt) &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-comment\">// check if the packet belongs to a stream we are interested in, otherwise</span><br>        <span class=\"hljs-comment\">// skip it</span><br>        <span class=\"hljs-keyword\">if</span> (pkt-&gt;stream_index == video_stream_idx)<br>            ret = decode_packet(video_dec_ctx, pkt);<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pkt-&gt;stream_index == audio_stream_idx)<br>            ret = decode_packet(audio_dec_ctx, pkt);<br>        av_packet_unref(pkt);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 冲洗音视频解码器，将剩余的解码数据读出来 */</span><br>    <span class=\"hljs-keyword\">if</span> (video_dec_ctx)<br>        decode_packet(video_dec_ctx, <span class=\"hljs-literal\">NULL</span>);<br>    <span class=\"hljs-keyword\">if</span> (audio_dec_ctx)<br>        decode_packet(audio_dec_ctx, <span class=\"hljs-literal\">NULL</span>);<br>end:<br>    <span class=\"hljs-comment\">//资源释放和退出</span><br>    avcodec_free_context(&amp;video_dec_ctx);<br>    avcodec_free_context(&amp;audio_dec_ctx);<br>    avformat_close_input(&amp;fmt_ctx);<br>    <span class=\"hljs-keyword\">if</span> (video_dst_file)<br>        fclose(video_dst_file);<br>    <span class=\"hljs-keyword\">if</span> (audio_dst_file)<br>        fclose(audio_dst_file);<br>    av_packet_free(&amp;pkt);<br>    av_frame_free(&amp;frame);<br>    av_free(video_dst_data[<span class=\"hljs-number\">0</span>]);<br><br>    <span class=\"hljs-keyword\">return</span> ret &lt; <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>验证输入参数是否正确</p>\n</li>\n<li><p>打开文件，读取封装信息</p>\n</li>\n<li><p>根据封装信息，分别创建视频解码器和音频解码器</p>\n</li>\n<li><p>循环从文件中读取pkt</p>\n<ol>\n<li><p>如果是视频数据，送到视频解码器，解码后写入视频文件</p>\n</li>\n<li><p>如果是音频数据，送到音频解码器，解码后写入音频文件</p>\n</li>\n</ol>\n</li>\n<li><p>冲洗音频视频解码器，读取剩余数据</p>\n</li>\n<li><p>清理资源退出</p>\n</li>\n</ol>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h4 id=\"open-codec-context\"><a href=\"#open-codec-context\" class=\"headerlink\" title=\"open_codec_context\"></a>open_codec_context</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">open_codec_context</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> *stream_idx,</span><br><span class=\"hljs-params\">                              AVCodecContext **dec_ctx, AVFormatContext *fmt_ctx, <span class=\"hljs-keyword\">enum</span> AVMediaType type)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> ret, stream_index;<br>    AVStream *st;<br>    <span class=\"hljs-type\">const</span> AVCodec *dec = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-comment\">//找到音频/视频对应的stream_index</span><br>    ret = av_find_best_stream(fmt_ctx, type, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not find %s stream in input file &#x27;%s&#x27;\\n&quot;</span>,<br>                av_get_media_type_string(type), src_filename);<br>        <span class=\"hljs-keyword\">return</span> ret;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        stream_index = ret;<br>        <span class=\"hljs-comment\">//获取音频/视频对应的AVStream</span><br>        st = fmt_ctx-&gt;streams[stream_index];<br><br>        <span class=\"hljs-comment\">/* 获取解码对应的AVCodec */</span><br>        dec = avcodec_find_decoder(st-&gt;codecpar-&gt;codec_id);<br>        <span class=\"hljs-keyword\">if</span> (!dec) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed to find %s codec\\n&quot;</span>,<br>                    av_get_media_type_string(type));<br>            <span class=\"hljs-keyword\">return</span> AVERROR(EINVAL);<br>        &#125;<br><br>        <span class=\"hljs-comment\">/* 根据AVCodec 创建 AVCodecContext */</span><br>        *dec_ctx = avcodec_alloc_context3(dec);<br>        <span class=\"hljs-keyword\">if</span> (!*dec_ctx) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed to allocate the %s codec context\\n&quot;</span>,<br>                    av_get_media_type_string(type));<br>            <span class=\"hljs-keyword\">return</span> AVERROR(ENOMEM);<br>        &#125;<br>        <span class=\"hljs-comment\">/* 将AVStream的codecpar中保存的解码相关的参数，填充到AVCodecContext中 */</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = avcodec_parameters_to_context(*dec_ctx, st-&gt;codecpar)) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed to copy %s codec parameters to decoder context\\n&quot;</span>,<br>                    av_get_media_type_string(type));<br>            <span class=\"hljs-keyword\">return</span> ret;<br>        &#125;<br><br>        <span class=\"hljs-comment\">/* 打开解码器 */</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = avcodec_open2(*dec_ctx, dec, <span class=\"hljs-literal\">NULL</span>)) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed to open %s codec\\n&quot;</span>,<br>                    av_get_media_type_string(type));<br>            <span class=\"hljs-keyword\">return</span> ret;<br>        &#125;<br>        <span class=\"hljs-comment\">//stream_index回传</span><br>        *stream_idx = stream_index;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>获取AVStream</p>\n</li>\n<li><p>从AVStream读取解码信息，创建AVCodecContext</p>\n</li>\n<li><p>给AVCodecContext配置参数</p>\n</li>\n<li><p>打开解码器</p>\n</li>\n</ol>\n<h4 id=\"decode-packet\"><a href=\"#decode-packet\" class=\"headerlink\" title=\"decode_packet\"></a>decode_packet</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">decode_packet</span><span class=\"hljs-params\">(AVCodecContext *dec, <span class=\"hljs-type\">const</span> AVPacket *pkt)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> ret = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-comment\">// submit the packet to the decoder</span><br>    ret = avcodec_send_packet(dec, pkt);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error submitting a packet for decoding (%s)\\n&quot;</span>, av_err2str(ret));<br>        <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// get all the available frames from the decoder</span><br>    <span class=\"hljs-keyword\">while</span> (ret &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>        ret = avcodec_receive_frame(dec, frame);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-comment\">// those two return values are special and mean there is no output</span><br>            <span class=\"hljs-comment\">// frame available, but there were no errors during decoding</span><br>            <span class=\"hljs-keyword\">if</span> (ret == AVERROR_EOF || ret == AVERROR(EAGAIN))<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br><br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error during decoding (%s)\\n&quot;</span>, av_err2str(ret));<br>            <span class=\"hljs-keyword\">return</span> ret;<br>        &#125;<br><br>        <span class=\"hljs-comment\">// write the frame data to output file</span><br>        <span class=\"hljs-keyword\">if</span> (dec-&gt;codec-&gt;type == AVMEDIA_TYPE_VIDEO)<br>            ret = output_video_frame(frame);<br>        <span class=\"hljs-keyword\">else</span><br>            ret = output_audio_frame(frame);<br><br>        av_frame_unref(frame);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>调用avcodec_send_packet给解码器送pkt</p>\n</li>\n<li><p>调用avcodec_receive_frame从解码器读frame</p>\n</li>\n<li><p>调用output_video_frame将解码后视频写文件，调用output_audio_frame将解码后音频写文件</p>\n</li>\n</ol>\n<h4 id=\"output-video-frame\"><a href=\"#output-video-frame\" class=\"headerlink\" title=\"output_video_frame\"></a>output_video_frame</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">output_video_frame</span><span class=\"hljs-params\">(AVFrame *frame)</span><br>&#123;<br>    <span class=\"hljs-comment\">//解码中，发现宽高或者格式变了，报错</span><br>    <span class=\"hljs-keyword\">if</span> (frame-&gt;width != width || frame-&gt;height != height ||<br>        frame-&gt;format != pix_fmt) &#123;<br>        <span class=\"hljs-comment\">/* To handle this change, one could call av_image_alloc again and</span><br><span class=\"hljs-comment\">         * decode the following frames into another rawvideo file. */</span><br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error: Width, height and pixel format have to be &quot;</span><br>                <span class=\"hljs-string\">&quot;constant in a rawvideo file, but the width, height or &quot;</span><br>                <span class=\"hljs-string\">&quot;pixel format of the input video changed:\\n&quot;</span><br>                <span class=\"hljs-string\">&quot;old: width = %d, height = %d, format = %s\\n&quot;</span><br>                <span class=\"hljs-string\">&quot;new: width = %d, height = %d, format = %s\\n&quot;</span>,<br>                width, height, av_get_pix_fmt_name(pix_fmt),<br>                frame-&gt;width, frame-&gt;height,<br>                av_get_pix_fmt_name(frame-&gt;format));<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;video_frame n:%d coded_n:%d\\n&quot;</span>,<br>           video_frame_count++, frame-&gt;coded_picture_number);<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">     从frame中读取解码后的数据，拷贝到之前申请的buffer中</span><br><span class=\"hljs-comment\">     调用av_image_copy是为了去除frame中可能的字节对齐的数据</span><br><span class=\"hljs-comment\">     写入文件中的数据，要求不含有字节对齐的数据</span><br><span class=\"hljs-comment\">    */</span><br><br>    av_image_copy(video_dst_data, video_dst_linesize,<br>                  (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint8_t</span> **)(frame-&gt;data), frame-&gt;linesize,<br>                  pix_fmt, width, height);<br><br>    <span class=\"hljs-comment\">/* write to rawvideo file */</span><br>    fwrite(video_dst_data[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">1</span>, video_dst_bufsize, video_dst_file);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>判断解码后的宽高，格式是否变更，写入文件的宽高，格式应该是一致的，如果变更就报错</p>\n</li>\n<li><p>将frame中的数据拷贝到之前申请的buffer中，拷贝的时候，去除字节对齐数据</p>\n</li>\n<li><p>将buffer中的数据写入文件</p>\n</li>\n</ol>\n<h4 id=\"output-audio-frame\"><a href=\"#output-audio-frame\" class=\"headerlink\" title=\"output_audio_frame\"></a>output_audio_frame</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">output_audio_frame</span><span class=\"hljs-params\">(AVFrame *frame)</span><br>&#123;<br>    <span class=\"hljs-type\">size_t</span> unpadded_linesize = frame-&gt;nb_samples * av_get_bytes_per_sample(frame-&gt;format);<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;audio_frame n:%d nb_samples:%d pts:%s\\n&quot;</span>,<br>           audio_frame_count++, frame-&gt;nb_samples,<br>           av_ts2timestr(frame-&gt;pts, &amp;audio_dec_ctx-&gt;time_base));<br><br>    <span class=\"hljs-comment\">/* Write the raw audio data samples of the first plane. This works</span><br><span class=\"hljs-comment\">     * fine for packed formats (e.g. AV_SAMPLE_FMT_S16). However,</span><br><span class=\"hljs-comment\">     * most audio decoders output planar audio, which uses a separate</span><br><span class=\"hljs-comment\">     * plane of audio samples for each channel (e.g. AV_SAMPLE_FMT_S16P).</span><br><span class=\"hljs-comment\">     * In other words, this code will write only the first audio channel</span><br><span class=\"hljs-comment\">     * in these cases.</span><br><span class=\"hljs-comment\">     * You should use libswresample or libavfilter to convert the frame</span><br><span class=\"hljs-comment\">     * to packed data. */</span><br><br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">    只写了第一个声道的数据，如果是平面多声道，使用libswresample或libavfilter将其转化为交错类型的音频再写入文件</span><br><span class=\"hljs-comment\">    */</span><br>    fwrite(frame-&gt;extended_data[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">1</span>, unpadded_linesize, audio_dst_file);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>将frame中的音频的第一个声道数据写入文件</p>\n</li>\n<li><p>如果想写入多声道，需要通过libswresample或libavfilter转为交错型的再写入文件</p>\n<hr>\n</li>\n</ol>\n<p>参考了： <a href=\"https://blog.csdn.net/myvest/article/details/89254452\">FFmpeg 封装、解封装及解码的流程简介_myvest的专栏-CSDN博客_ffmpeg 封装流程</a></p>\n","excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>学习ffmpeg，打算从源码入手，源码又太多太复杂。好在ffmpeg提供了示例代码，演示如何使用ffmpeg的api， 示例代码位于<code>ffmpeg/doc/examples</code>目录下，可以<a href=\"https://yxibng.github.io/2022/03/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vscode%E5%9C%A8macOS%E5%B9%B3%E5%8F%B0%E8%B0%83%E8%AF%95ffmpeg/\">通过vscode 来调试</a>这些示例代码，理解ffmpeg的调用方式。</p>\n<p>该目录下的示例代码如下</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16468967433771646896743076.png\"></p>\n<ul>\n<li><p>decode_audio.c  演示如何解码音频</p>\n</li>\n<li><p>decode_video.c  演示如何解码视频</p>\n</li>\n<li><p>demuxing_decoding.c  演示如何解封装文件，和解码音视频</p>\n</li>\n</ul>\n<p>今天来分析 <code>demuxing_decoding.c</code></p>\n<h2 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h2><p>使用的模块<code>libavutil</code>,<code>libavcodec</code>,<code>libavformat</code></p>\n<ul>\n<li><p>libavutil  包含一些公共的工具函数</p>\n</li>\n<li><p>libavcodec 用于各种类型声音&#x2F;图像编解码</p>\n</li>\n<li><p>libavformat 用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能，包含demuxers和muxer库</p>\n</li>\n</ul>\n<h3 id=\"1-解封装\"><a href=\"#1-解封装\" class=\"headerlink\" title=\"1.解封装\"></a>1.解封装</h3><ol>\n<li><p>打开文件、获取封装信息上下文AVFormatContext（avformat_open_input）</p>\n</li>\n<li><p>获取媒体文件音视频信息，这一步会将AVFormatContext内部变量填充（avformat_find_stream_info）</p>\n</li>\n<li><p>获取音视频流ID。一般有两种方法：</p>\n<ol>\n<li><p>遍历AVFormatContext内部所有的stream，如果stream的codec_type对应为audio&#x2F;video，这记录当前stream的ID；</p>\n</li>\n<li><p>FFmpeg提供av_find_best_stream接口，可以直接获取相应类型（audio or video）的流ID</p>\n</li>\n</ol>\n</li>\n<li><p>获取流的每一帧数据（av_read_frame）  </p>\n</li>\n<li><p>关闭文件</p>\n</li>\n</ol>\n<h3 id=\"2-解码\"><a href=\"#2-解码\" class=\"headerlink\" title=\"2.解码\"></a>2.解码</h3><p>解码在解封装的基础上，将每一帧数据进行解码。步骤如下：</p>\n<ol>\n<li><p>申请解码器上下文AVCodecContext（avcodec_alloc_context3）</p>\n</li>\n<li><p>初始化AVCodecContext参数，可以使用将解封装得到的流的解码器参数设置进来（avcodec_parameters_to_context）</p>\n</li>\n<li><p>打开解码器（avcodec_open2）</p>\n</li>\n<li><p>解码每一帧数据。只需要将解封装获取的帧传递给解码器（avcodec_send_packet），再接收即可（avcodec_receive_frame）</p>\n</li>\n<li><p>关闭文件和解码器</p>\n</li>\n</ol>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h4 id=\"main-函数，简化版\"><a href=\"#main-函数，简化版\" class=\"headerlink\" title=\"main 函数，简化版\"></a>main 函数，简化版</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span><br>&#123;<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">     打开输入文件，创建AVFormatContext</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-keyword\">if</span> (avformat_open_input(&amp;fmt_ctx, src_filename, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-literal\">NULL</span>) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not open source file %s\\n&quot;</span>, src_filename);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 获取封装格式中的音视频信息，填充在AVFormatContext中 */</span><br>    <span class=\"hljs-keyword\">if</span> (avformat_find_stream_info(fmt_ctx, <span class=\"hljs-literal\">NULL</span>) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not find stream information\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">    1. 从 fmt_ctx 读取视频对应的AVStream</span><br><span class=\"hljs-comment\">    2. 从 AVStream 读取解码相关的 AVCodec</span><br><span class=\"hljs-comment\">    3. 根据 AVCodec 创建 AVCodecContext，根据 AVStream 给 AVCodecContext 填充解码参数</span><br><span class=\"hljs-comment\">    4. 打开解码器</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-keyword\">if</span> (open_codec_context(&amp;video_stream_idx, &amp;video_dec_ctx, fmt_ctx, AVMEDIA_TYPE_VIDEO) &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>        video_stream = fmt_ctx-&gt;streams[video_stream_idx];<br>    &#125;<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">    1. 从 fmt_ctx 读取音频对应的AVStream</span><br><span class=\"hljs-comment\">    2. 从 AVStream 读取解码相关的 AVCodec</span><br><span class=\"hljs-comment\">    3. 根据 AVCodec 创建 AVCodecContext，根据 AVStream 给 AVCodecContext 填充解码参数</span><br><span class=\"hljs-comment\">    4. 打开解码器</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-keyword\">if</span> (open_codec_context(&amp;audio_stream_idx, &amp;audio_dec_ctx, fmt_ctx, AVMEDIA_TYPE_AUDIO) &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>        audio_stream = fmt_ctx-&gt;streams[audio_stream_idx];<br>    &#125;<br><br>    <span class=\"hljs-comment\">//创建frame, 用于存储解码后的数据</span><br>    frame = av_frame_alloc();<br>    <span class=\"hljs-comment\">//创建pkt，用于存储解封装后从文件中读取的音视频包</span><br>    pkt = av_packet_alloc();<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">    从文件中循环读取音视频帧，存入pkt</span><br><span class=\"hljs-comment\">    根据类型区分音频帧还是视频帧，分别送给对应的解码器去解码</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-keyword\">while</span> (av_read_frame(fmt_ctx, pkt) &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-comment\">// check if the packet belongs to a stream we are interested in, otherwise</span><br>        <span class=\"hljs-comment\">// skip it</span><br>        <span class=\"hljs-keyword\">if</span> (pkt-&gt;stream_index == video_stream_idx)<br>            ret = decode_packet(video_dec_ctx, pkt);<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pkt-&gt;stream_index == audio_stream_idx)<br>            ret = decode_packet(audio_dec_ctx, pkt);<br>        av_packet_unref(pkt);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 冲洗音视频解码器，将剩余的解码数据读出来 */</span><br>    <span class=\"hljs-keyword\">if</span> (video_dec_ctx)<br>        decode_packet(video_dec_ctx, <span class=\"hljs-literal\">NULL</span>);<br>    <span class=\"hljs-keyword\">if</span> (audio_dec_ctx)<br>        decode_packet(audio_dec_ctx, <span class=\"hljs-literal\">NULL</span>);<br>end:<br>    <span class=\"hljs-comment\">//资源释放和退出</span><br>    avcodec_free_context(&amp;video_dec_ctx);<br>    avcodec_free_context(&amp;audio_dec_ctx);<br>    avformat_close_input(&amp;fmt_ctx);<br>    <span class=\"hljs-keyword\">if</span> (video_dst_file)<br>        fclose(video_dst_file);<br>    <span class=\"hljs-keyword\">if</span> (audio_dst_file)<br>        fclose(audio_dst_file);<br>    av_packet_free(&amp;pkt);<br>    av_frame_free(&amp;frame);<br>    av_free(video_dst_data[<span class=\"hljs-number\">0</span>]);<br><br>    <span class=\"hljs-keyword\">return</span> ret &lt; <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>验证输入参数是否正确</p>\n</li>\n<li><p>打开文件，读取封装信息</p>\n</li>\n<li><p>根据封装信息，分别创建视频解码器和音频解码器</p>\n</li>\n<li><p>循环从文件中读取pkt</p>\n<ol>\n<li><p>如果是视频数据，送到视频解码器，解码后写入视频文件</p>\n</li>\n<li><p>如果是音频数据，送到音频解码器，解码后写入音频文件</p>\n</li>\n</ol>\n</li>\n<li><p>冲洗音频视频解码器，读取剩余数据</p>\n</li>\n<li><p>清理资源退出</p>\n</li>\n</ol>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h4 id=\"open-codec-context\"><a href=\"#open-codec-context\" class=\"headerlink\" title=\"open_codec_context\"></a>open_codec_context</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">open_codec_context</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> *stream_idx,</span><br><span class=\"hljs-params\">                              AVCodecContext **dec_ctx, AVFormatContext *fmt_ctx, <span class=\"hljs-keyword\">enum</span> AVMediaType type)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> ret, stream_index;<br>    AVStream *st;<br>    <span class=\"hljs-type\">const</span> AVCodec *dec = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-comment\">//找到音频/视频对应的stream_index</span><br>    ret = av_find_best_stream(fmt_ctx, type, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not find %s stream in input file &#x27;%s&#x27;\\n&quot;</span>,<br>                av_get_media_type_string(type), src_filename);<br>        <span class=\"hljs-keyword\">return</span> ret;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        stream_index = ret;<br>        <span class=\"hljs-comment\">//获取音频/视频对应的AVStream</span><br>        st = fmt_ctx-&gt;streams[stream_index];<br><br>        <span class=\"hljs-comment\">/* 获取解码对应的AVCodec */</span><br>        dec = avcodec_find_decoder(st-&gt;codecpar-&gt;codec_id);<br>        <span class=\"hljs-keyword\">if</span> (!dec) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed to find %s codec\\n&quot;</span>,<br>                    av_get_media_type_string(type));<br>            <span class=\"hljs-keyword\">return</span> AVERROR(EINVAL);<br>        &#125;<br><br>        <span class=\"hljs-comment\">/* 根据AVCodec 创建 AVCodecContext */</span><br>        *dec_ctx = avcodec_alloc_context3(dec);<br>        <span class=\"hljs-keyword\">if</span> (!*dec_ctx) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed to allocate the %s codec context\\n&quot;</span>,<br>                    av_get_media_type_string(type));<br>            <span class=\"hljs-keyword\">return</span> AVERROR(ENOMEM);<br>        &#125;<br>        <span class=\"hljs-comment\">/* 将AVStream的codecpar中保存的解码相关的参数，填充到AVCodecContext中 */</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = avcodec_parameters_to_context(*dec_ctx, st-&gt;codecpar)) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed to copy %s codec parameters to decoder context\\n&quot;</span>,<br>                    av_get_media_type_string(type));<br>            <span class=\"hljs-keyword\">return</span> ret;<br>        &#125;<br><br>        <span class=\"hljs-comment\">/* 打开解码器 */</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = avcodec_open2(*dec_ctx, dec, <span class=\"hljs-literal\">NULL</span>)) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed to open %s codec\\n&quot;</span>,<br>                    av_get_media_type_string(type));<br>            <span class=\"hljs-keyword\">return</span> ret;<br>        &#125;<br>        <span class=\"hljs-comment\">//stream_index回传</span><br>        *stream_idx = stream_index;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>获取AVStream</p>\n</li>\n<li><p>从AVStream读取解码信息，创建AVCodecContext</p>\n</li>\n<li><p>给AVCodecContext配置参数</p>\n</li>\n<li><p>打开解码器</p>\n</li>\n</ol>\n<h4 id=\"decode-packet\"><a href=\"#decode-packet\" class=\"headerlink\" title=\"decode_packet\"></a>decode_packet</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">decode_packet</span><span class=\"hljs-params\">(AVCodecContext *dec, <span class=\"hljs-type\">const</span> AVPacket *pkt)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> ret = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-comment\">// submit the packet to the decoder</span><br>    ret = avcodec_send_packet(dec, pkt);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error submitting a packet for decoding (%s)\\n&quot;</span>, av_err2str(ret));<br>        <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// get all the available frames from the decoder</span><br>    <span class=\"hljs-keyword\">while</span> (ret &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>        ret = avcodec_receive_frame(dec, frame);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-comment\">// those two return values are special and mean there is no output</span><br>            <span class=\"hljs-comment\">// frame available, but there were no errors during decoding</span><br>            <span class=\"hljs-keyword\">if</span> (ret == AVERROR_EOF || ret == AVERROR(EAGAIN))<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br><br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error during decoding (%s)\\n&quot;</span>, av_err2str(ret));<br>            <span class=\"hljs-keyword\">return</span> ret;<br>        &#125;<br><br>        <span class=\"hljs-comment\">// write the frame data to output file</span><br>        <span class=\"hljs-keyword\">if</span> (dec-&gt;codec-&gt;type == AVMEDIA_TYPE_VIDEO)<br>            ret = output_video_frame(frame);<br>        <span class=\"hljs-keyword\">else</span><br>            ret = output_audio_frame(frame);<br><br>        av_frame_unref(frame);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>调用avcodec_send_packet给解码器送pkt</p>\n</li>\n<li><p>调用avcodec_receive_frame从解码器读frame</p>\n</li>\n<li><p>调用output_video_frame将解码后视频写文件，调用output_audio_frame将解码后音频写文件</p>\n</li>\n</ol>\n<h4 id=\"output-video-frame\"><a href=\"#output-video-frame\" class=\"headerlink\" title=\"output_video_frame\"></a>output_video_frame</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">output_video_frame</span><span class=\"hljs-params\">(AVFrame *frame)</span><br>&#123;<br>    <span class=\"hljs-comment\">//解码中，发现宽高或者格式变了，报错</span><br>    <span class=\"hljs-keyword\">if</span> (frame-&gt;width != width || frame-&gt;height != height ||<br>        frame-&gt;format != pix_fmt) &#123;<br>        <span class=\"hljs-comment\">/* To handle this change, one could call av_image_alloc again and</span><br><span class=\"hljs-comment\">         * decode the following frames into another rawvideo file. */</span><br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error: Width, height and pixel format have to be &quot;</span><br>                <span class=\"hljs-string\">&quot;constant in a rawvideo file, but the width, height or &quot;</span><br>                <span class=\"hljs-string\">&quot;pixel format of the input video changed:\\n&quot;</span><br>                <span class=\"hljs-string\">&quot;old: width = %d, height = %d, format = %s\\n&quot;</span><br>                <span class=\"hljs-string\">&quot;new: width = %d, height = %d, format = %s\\n&quot;</span>,<br>                width, height, av_get_pix_fmt_name(pix_fmt),<br>                frame-&gt;width, frame-&gt;height,<br>                av_get_pix_fmt_name(frame-&gt;format));<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;video_frame n:%d coded_n:%d\\n&quot;</span>,<br>           video_frame_count++, frame-&gt;coded_picture_number);<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">     从frame中读取解码后的数据，拷贝到之前申请的buffer中</span><br><span class=\"hljs-comment\">     调用av_image_copy是为了去除frame中可能的字节对齐的数据</span><br><span class=\"hljs-comment\">     写入文件中的数据，要求不含有字节对齐的数据</span><br><span class=\"hljs-comment\">    */</span><br><br>    av_image_copy(video_dst_data, video_dst_linesize,<br>                  (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint8_t</span> **)(frame-&gt;data), frame-&gt;linesize,<br>                  pix_fmt, width, height);<br><br>    <span class=\"hljs-comment\">/* write to rawvideo file */</span><br>    fwrite(video_dst_data[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">1</span>, video_dst_bufsize, video_dst_file);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>判断解码后的宽高，格式是否变更，写入文件的宽高，格式应该是一致的，如果变更就报错</p>\n</li>\n<li><p>将frame中的数据拷贝到之前申请的buffer中，拷贝的时候，去除字节对齐数据</p>\n</li>\n<li><p>将buffer中的数据写入文件</p>\n</li>\n</ol>\n<h4 id=\"output-audio-frame\"><a href=\"#output-audio-frame\" class=\"headerlink\" title=\"output_audio_frame\"></a>output_audio_frame</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">output_audio_frame</span><span class=\"hljs-params\">(AVFrame *frame)</span><br>&#123;<br>    <span class=\"hljs-type\">size_t</span> unpadded_linesize = frame-&gt;nb_samples * av_get_bytes_per_sample(frame-&gt;format);<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;audio_frame n:%d nb_samples:%d pts:%s\\n&quot;</span>,<br>           audio_frame_count++, frame-&gt;nb_samples,<br>           av_ts2timestr(frame-&gt;pts, &amp;audio_dec_ctx-&gt;time_base));<br><br>    <span class=\"hljs-comment\">/* Write the raw audio data samples of the first plane. This works</span><br><span class=\"hljs-comment\">     * fine for packed formats (e.g. AV_SAMPLE_FMT_S16). However,</span><br><span class=\"hljs-comment\">     * most audio decoders output planar audio, which uses a separate</span><br><span class=\"hljs-comment\">     * plane of audio samples for each channel (e.g. AV_SAMPLE_FMT_S16P).</span><br><span class=\"hljs-comment\">     * In other words, this code will write only the first audio channel</span><br><span class=\"hljs-comment\">     * in these cases.</span><br><span class=\"hljs-comment\">     * You should use libswresample or libavfilter to convert the frame</span><br><span class=\"hljs-comment\">     * to packed data. */</span><br><br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">    只写了第一个声道的数据，如果是平面多声道，使用libswresample或libavfilter将其转化为交错类型的音频再写入文件</span><br><span class=\"hljs-comment\">    */</span><br>    fwrite(frame-&gt;extended_data[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">1</span>, unpadded_linesize, audio_dst_file);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>将frame中的音频的第一个声道数据写入文件</p>\n</li>\n<li><p>如果想写入多声道，需要通过libswresample或libavfilter转为交错型的再写入文件</p>\n<hr>\n</li>\n</ol>\n<p>参考了： <a href=\"https://blog.csdn.net/myvest/article/details/89254452\">FFmpeg 封装、解封装及解码的流程简介_myvest的专栏-CSDN博客_ffmpeg 封装流程</a></p>\n"},{"layout":"post","title":"ffmpeg example 2.视频编码","date":"2022-03-10T16:00:00.000Z","_content":"\n调试ffmpeg源码教程\n\n- [如何使用vscode在macOS平台调试ffmpeg](https://yxibng.github.io/2022/03/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vscode%E5%9C%A8macOS%E5%B9%B3%E5%8F%B0%E8%B0%83%E8%AF%95ffmpeg/)\n\n- [使用Xcode调试ffmpeg](https://yxibng.github.io/2022/03/%E4%BD%BF%E7%94%A8Xcode%E8%B0%83%E8%AF%95ffmpeg/)\n  \n      \n\n今天用Xcode调试分析 `encode_video.c`\n\n## 配置ffmpeg 支持libx264和h264_videotoolbox来进行视频编码\n\n```shell\ncd ffmpeg\n./configure  --disable-optimizations --disable-stripping --enable-debug=3 --disable-doc --enable-libx264 --enable-gpl --enable-videotoolboxm\nmake -j 16\nmake examples\n```\n\n如果没有libx264， 通过 [Homebrew](https://brew.sh/) 安装一下\n\n```shell\nbrew install x264\n```\n\nffmpeg  通过[pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/)可以找到x264对应的头文件和库的路径\n\n```shell\n➜  ffmpeg git:(master) ✗ pkg-config --libs --cflags x264\n-DX264_API_IMPORTS -I/opt/homebrew/Cellar/x264/r3060/include -L/opt/homebrew/Cellar/x264/r3060/lib -lx264\n```\n\n## 配置Xcode\n\n添加target，配置路径\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16469917993141646991798582.png)\n\n配置可执行文件，启动参数\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16469918543121646991854240.png)\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16469918963141646991895699.png)\n\nencode_video_g 接受两个参数，\n\n1. 视频编码数据的写入路径\n\n2. 编码器名字（libx264 libx264rgb h264_videotoolbox）\n\n我们使用h264编码器，查看ffmpeg 支持的h264编码器\n\n```shell\nffmpeg -codecs | grep 264\nDEV.LS h264                 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (encoders: libx264 libx264rgb h264_videotoolbox )\n```\n\n## 源码分析\n\n### main函数\n\n```c\nint main(int argc, char **argv)\n{\n    const char *filename, *codec_name;\n    const AVCodec *codec;\n    AVCodecContext *c= NULL;\n    int i, ret, x, y;\n    FILE *f;\n    AVFrame *frame;\n    AVPacket *pkt;\n    uint8_t endcode[] = { 0, 0, 1, 0xb7 };\n\n    if (argc <= 2) {\n        fprintf(stderr, \"Usage: %s <output file> <codec name>\\n\", argv[0]);\n        exit(0);\n    }\n    filename = argv[1];\n    codec_name = argv[2];\n\n    /* 根据编码器名字，找到对应的编码器，编码器的名字如libx264,h264_videotoolbox */\n    codec = avcodec_find_encoder_by_name(codec_name);\n    if (!codec) {\n        fprintf(stderr, \"Codec '%s' not found\\n\", codec_name);\n        exit(1);\n    }\n    /* 创建编码器上下文 */\n    c = avcodec_alloc_context3(codec);\n    if (!c) {\n        fprintf(stderr, \"Could not allocate video codec context\\n\");\n        exit(1);\n    }\n    /* 创建 pkt 用于保存编码后的数据 */\n    pkt = av_packet_alloc();\n    if (!pkt)\n        exit(1);\n    /* 配置编码参数 */\n    //码率400000\n    c->bit_rate = 400000;\n    //编码分辨率，宽高必须能被2整除\n    c->width = 352;\n    c->height = 288;\n    /*\n     编码的时间基,可以理解为刻度，与 pts 有关\n     (AVRational){1, 25} 将1秒钟分成25份，每一份代表 1/25 秒\n     */\n    c->time_base = (AVRational){1, 25};\n    /* 编码帧率 25 帧 */\n    c->framerate = (AVRational){25, 1};\n\n    /* 关键帧间隔，每10帧产生一个关键帧, 如果frame->pict_type 被设置为AV_PICTURE_TYPE_I\n     gop_size的值会被忽略，编码器不产出B帧和P帧，只会编码I帧\n     */\n    c->gop_size = 10;\n    /* b帧的个数，实时通信一般设置为0 */\n    c->max_b_frames = 1;\n    /* 编码的数据源的格式，yuv420p */\n    c->pix_fmt = AV_PIX_FMT_YUV420P;\n    /* 如果使用h264编码器，设置preset 为slow */\n    if (codec->id == AV_CODEC_ID_H264)\n        av_opt_set(c->priv_data, \"preset\", \"slow\", 0);\n\n    /*\n     打开编码器\n     */\n    ret = avcodec_open2(c, codec, NULL);\n    if (ret < 0) {\n        fprintf(stderr, \"Could not open codec: %s\\n\", av_err2str(ret));\n        exit(1);\n    }\n    /* 打开输出文件 */\n    f = fopen(filename, \"wb\");\n    if (!f) {\n        fprintf(stderr, \"Could not open %s\\n\", filename);\n        exit(1);\n    }\n    /* 创建AVFrame用于存放待编码的数据，yuv */\n    frame = av_frame_alloc();\n    if (!frame) {\n        fprintf(stderr, \"Could not allocate video frame\\n\");\n        exit(1);\n    }\n    /* 设置frame 的颜色格式，宽高 */\n    frame->format = c->pix_fmt;\n    frame->width  = c->width;\n    frame->height = c->height;\n    /* 根据上面设置的参数，给frame 内部的 buf 分配内存 */\n    ret = av_frame_get_buffer(frame, 0);\n    if (ret < 0) {\n        fprintf(stderr, \"Could not allocate the video frame data\\n\");\n        exit(1);\n    }\n\n    /* 编码1秒钟的数据，上面设置的编码帧率是 25 帧  */\n    for (i = 0; i < 25; i++) {\n        fflush(stdout);\n        /*\n         确保frame中的数据是可写的。\n         刚开始调用 av_frame_get_buffer()，frame中的数据是可写的。\n         后面将frame送给编码器去编码，可能被编码器引用，此时frame是不可写的。\n         调用av_frame_make_writable()会检查frame 是否可写，\n         如果不可写，会给frame内部重新创建新的buffer。\n         */\n        ret = av_frame_make_writable(frame);\n        if (ret < 0)\n            exit(1);\n\n        /* 给frame填充数据，我们设置的是yuv420，这里填充假数据 */\n        /* Y */\n        for (y = 0; y < c->height; y++) {\n            for (x = 0; x < c->width; x++) {\n                frame->data[0][y * frame->linesize[0] + x] = x + y + i * 3;\n            }\n        }\n        /* Cb and Cr */\n        for (y = 0; y < c->height/2; y++) {\n            for (x = 0; x < c->width/2; x++) {\n                frame->data[1][y * frame->linesize[1] + x] = 128 + y + i * 2;\n                frame->data[2][y * frame->linesize[2] + x] = 64 + x + i * 5;\n            }\n        }\n\n        /*\n         设置frame的pts\n         我们设置的是每秒25帧\n         对应的时间转成秒是 pts * av_q2d(c->time_base)\n         */\n        frame->pts = i;\n\n        /*\n         将frame 送给编码器编码，将编码后的数据写入文件\n         */\n        encode(c, frame, pkt, f);\n    }\n\n    /*\n     冲洗编码器，将剩余的编码后的数据读出来，写入文件\n     */\n    encode(c, NULL, pkt, f);\n\n    /* Add sequence end code to have a real MPEG file.\n       It makes only sense because this tiny examples writes packets\n       directly. This is called \"elementary stream\" and only works for some\n       codecs. To create a valid file, you usually need to write packets\n       into a proper file format or protocol; see muxing.c.\n     */\n    if (codec->id == AV_CODEC_ID_MPEG1VIDEO || codec->id == AV_CODEC_ID_MPEG2VIDEO)\n        fwrite(endcode, 1, sizeof(endcode), f);\n\n    //关闭文件\n    fclose(f);\n    //释放资源\n    avcodec_free_context(&c);\n    av_frame_free(&frame);\n    av_packet_free(&pkt);\n\n    return 0;\n}\n```\n\n1. 从命令行中输出文件的路径， 使用的编码器名字\n\n2. 根据名字找到对应的编码器\n\n3. 创建编码器上下文，设置编码器的参数（码率，时间基，帧率，宽高，颜色格式，b帧个数）\n\n4. 打开编码器\n\n5. 创建AVFrame 保存待编码的数据\n\n6. 创建AVPacket保存编码后的数据\n\n7. 编码1秒钟的数据\n\n8. 冲洗编码器，将剩余数据读出\n\n9. 关闭文件，释放资源\n\n### encode\n\n```c\nstatic void encode(AVCodecContext *enc_ctx, AVFrame *frame, AVPacket *pkt,\n                   FILE *outfile)\n{\n    int ret;\n\n    /* send the frame to the encoder */\n    if (frame)\n        printf(\"Send frame %3\"PRId64\"\\n\", frame->pts);\n\n    //给编码器送frame\n    ret = avcodec_send_frame(enc_ctx, frame);\n    if (ret < 0) {\n        fprintf(stderr, \"Error sending a frame for encoding\\n\");\n        exit(1);\n    }\n\n    while (ret >= 0) {\n        //从编码器读pkt\n        ret = avcodec_receive_packet(enc_ctx, pkt);\n        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)\n        {\n            //EAGAIN 代表需要继续送入 frame 才可以开始读取\n            //AVERROR_EOF 代表编码器已经没有数据可以读了\n            return;\n        }\n        else if (ret < 0) {\n            fprintf(stderr, \"Error during encoding\\n\");\n            exit(1);\n        }\n\n        printf(\"Write packet %3\"PRId64\" (size=%5d)\\n\", pkt->pts, pkt->size);\n        //将编码后的数据写入文件\n        fwrite(pkt->data, 1, pkt->size, outfile);\n        //取消引用pkt\n        av_packet_unref(pkt);\n    }\n}\n```\n\n1. 调用   avcodec_send_frame 给编码器送frame\n\n2. 循环调用avcodec_receive_packet 从编码器读pkt\n   \n   - EAGAIN 代表需要继续送入 frame 才可以开始读取\n   \n   - AVERROR_EOF 代表编码器已经没有数据可以读了,例如传入空的frame，对编码器进行了flush操作\n\n3. 将编码后数据写入文件\n\n4. 取消引用pkt\n\n最后输出的文件，可以使用ffplay 进行播放\n\n```\n➜  /tmp ffplay -i encode_video.h264\n```\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16469965503041646996550013.png)\n","source":"_posts/ffmpeg/2022-03-11-ffmpeg example 学习 2.md","raw":"---\nlayout: post\ntitle: \"ffmpeg example 2.视频编码\"\ndate: 2022-03-11 \ntag: ffmpeg\n---\n\n调试ffmpeg源码教程\n\n- [如何使用vscode在macOS平台调试ffmpeg](https://yxibng.github.io/2022/03/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vscode%E5%9C%A8macOS%E5%B9%B3%E5%8F%B0%E8%B0%83%E8%AF%95ffmpeg/)\n\n- [使用Xcode调试ffmpeg](https://yxibng.github.io/2022/03/%E4%BD%BF%E7%94%A8Xcode%E8%B0%83%E8%AF%95ffmpeg/)\n  \n      \n\n今天用Xcode调试分析 `encode_video.c`\n\n## 配置ffmpeg 支持libx264和h264_videotoolbox来进行视频编码\n\n```shell\ncd ffmpeg\n./configure  --disable-optimizations --disable-stripping --enable-debug=3 --disable-doc --enable-libx264 --enable-gpl --enable-videotoolboxm\nmake -j 16\nmake examples\n```\n\n如果没有libx264， 通过 [Homebrew](https://brew.sh/) 安装一下\n\n```shell\nbrew install x264\n```\n\nffmpeg  通过[pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/)可以找到x264对应的头文件和库的路径\n\n```shell\n➜  ffmpeg git:(master) ✗ pkg-config --libs --cflags x264\n-DX264_API_IMPORTS -I/opt/homebrew/Cellar/x264/r3060/include -L/opt/homebrew/Cellar/x264/r3060/lib -lx264\n```\n\n## 配置Xcode\n\n添加target，配置路径\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16469917993141646991798582.png)\n\n配置可执行文件，启动参数\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16469918543121646991854240.png)\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16469918963141646991895699.png)\n\nencode_video_g 接受两个参数，\n\n1. 视频编码数据的写入路径\n\n2. 编码器名字（libx264 libx264rgb h264_videotoolbox）\n\n我们使用h264编码器，查看ffmpeg 支持的h264编码器\n\n```shell\nffmpeg -codecs | grep 264\nDEV.LS h264                 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (encoders: libx264 libx264rgb h264_videotoolbox )\n```\n\n## 源码分析\n\n### main函数\n\n```c\nint main(int argc, char **argv)\n{\n    const char *filename, *codec_name;\n    const AVCodec *codec;\n    AVCodecContext *c= NULL;\n    int i, ret, x, y;\n    FILE *f;\n    AVFrame *frame;\n    AVPacket *pkt;\n    uint8_t endcode[] = { 0, 0, 1, 0xb7 };\n\n    if (argc <= 2) {\n        fprintf(stderr, \"Usage: %s <output file> <codec name>\\n\", argv[0]);\n        exit(0);\n    }\n    filename = argv[1];\n    codec_name = argv[2];\n\n    /* 根据编码器名字，找到对应的编码器，编码器的名字如libx264,h264_videotoolbox */\n    codec = avcodec_find_encoder_by_name(codec_name);\n    if (!codec) {\n        fprintf(stderr, \"Codec '%s' not found\\n\", codec_name);\n        exit(1);\n    }\n    /* 创建编码器上下文 */\n    c = avcodec_alloc_context3(codec);\n    if (!c) {\n        fprintf(stderr, \"Could not allocate video codec context\\n\");\n        exit(1);\n    }\n    /* 创建 pkt 用于保存编码后的数据 */\n    pkt = av_packet_alloc();\n    if (!pkt)\n        exit(1);\n    /* 配置编码参数 */\n    //码率400000\n    c->bit_rate = 400000;\n    //编码分辨率，宽高必须能被2整除\n    c->width = 352;\n    c->height = 288;\n    /*\n     编码的时间基,可以理解为刻度，与 pts 有关\n     (AVRational){1, 25} 将1秒钟分成25份，每一份代表 1/25 秒\n     */\n    c->time_base = (AVRational){1, 25};\n    /* 编码帧率 25 帧 */\n    c->framerate = (AVRational){25, 1};\n\n    /* 关键帧间隔，每10帧产生一个关键帧, 如果frame->pict_type 被设置为AV_PICTURE_TYPE_I\n     gop_size的值会被忽略，编码器不产出B帧和P帧，只会编码I帧\n     */\n    c->gop_size = 10;\n    /* b帧的个数，实时通信一般设置为0 */\n    c->max_b_frames = 1;\n    /* 编码的数据源的格式，yuv420p */\n    c->pix_fmt = AV_PIX_FMT_YUV420P;\n    /* 如果使用h264编码器，设置preset 为slow */\n    if (codec->id == AV_CODEC_ID_H264)\n        av_opt_set(c->priv_data, \"preset\", \"slow\", 0);\n\n    /*\n     打开编码器\n     */\n    ret = avcodec_open2(c, codec, NULL);\n    if (ret < 0) {\n        fprintf(stderr, \"Could not open codec: %s\\n\", av_err2str(ret));\n        exit(1);\n    }\n    /* 打开输出文件 */\n    f = fopen(filename, \"wb\");\n    if (!f) {\n        fprintf(stderr, \"Could not open %s\\n\", filename);\n        exit(1);\n    }\n    /* 创建AVFrame用于存放待编码的数据，yuv */\n    frame = av_frame_alloc();\n    if (!frame) {\n        fprintf(stderr, \"Could not allocate video frame\\n\");\n        exit(1);\n    }\n    /* 设置frame 的颜色格式，宽高 */\n    frame->format = c->pix_fmt;\n    frame->width  = c->width;\n    frame->height = c->height;\n    /* 根据上面设置的参数，给frame 内部的 buf 分配内存 */\n    ret = av_frame_get_buffer(frame, 0);\n    if (ret < 0) {\n        fprintf(stderr, \"Could not allocate the video frame data\\n\");\n        exit(1);\n    }\n\n    /* 编码1秒钟的数据，上面设置的编码帧率是 25 帧  */\n    for (i = 0; i < 25; i++) {\n        fflush(stdout);\n        /*\n         确保frame中的数据是可写的。\n         刚开始调用 av_frame_get_buffer()，frame中的数据是可写的。\n         后面将frame送给编码器去编码，可能被编码器引用，此时frame是不可写的。\n         调用av_frame_make_writable()会检查frame 是否可写，\n         如果不可写，会给frame内部重新创建新的buffer。\n         */\n        ret = av_frame_make_writable(frame);\n        if (ret < 0)\n            exit(1);\n\n        /* 给frame填充数据，我们设置的是yuv420，这里填充假数据 */\n        /* Y */\n        for (y = 0; y < c->height; y++) {\n            for (x = 0; x < c->width; x++) {\n                frame->data[0][y * frame->linesize[0] + x] = x + y + i * 3;\n            }\n        }\n        /* Cb and Cr */\n        for (y = 0; y < c->height/2; y++) {\n            for (x = 0; x < c->width/2; x++) {\n                frame->data[1][y * frame->linesize[1] + x] = 128 + y + i * 2;\n                frame->data[2][y * frame->linesize[2] + x] = 64 + x + i * 5;\n            }\n        }\n\n        /*\n         设置frame的pts\n         我们设置的是每秒25帧\n         对应的时间转成秒是 pts * av_q2d(c->time_base)\n         */\n        frame->pts = i;\n\n        /*\n         将frame 送给编码器编码，将编码后的数据写入文件\n         */\n        encode(c, frame, pkt, f);\n    }\n\n    /*\n     冲洗编码器，将剩余的编码后的数据读出来，写入文件\n     */\n    encode(c, NULL, pkt, f);\n\n    /* Add sequence end code to have a real MPEG file.\n       It makes only sense because this tiny examples writes packets\n       directly. This is called \"elementary stream\" and only works for some\n       codecs. To create a valid file, you usually need to write packets\n       into a proper file format or protocol; see muxing.c.\n     */\n    if (codec->id == AV_CODEC_ID_MPEG1VIDEO || codec->id == AV_CODEC_ID_MPEG2VIDEO)\n        fwrite(endcode, 1, sizeof(endcode), f);\n\n    //关闭文件\n    fclose(f);\n    //释放资源\n    avcodec_free_context(&c);\n    av_frame_free(&frame);\n    av_packet_free(&pkt);\n\n    return 0;\n}\n```\n\n1. 从命令行中输出文件的路径， 使用的编码器名字\n\n2. 根据名字找到对应的编码器\n\n3. 创建编码器上下文，设置编码器的参数（码率，时间基，帧率，宽高，颜色格式，b帧个数）\n\n4. 打开编码器\n\n5. 创建AVFrame 保存待编码的数据\n\n6. 创建AVPacket保存编码后的数据\n\n7. 编码1秒钟的数据\n\n8. 冲洗编码器，将剩余数据读出\n\n9. 关闭文件，释放资源\n\n### encode\n\n```c\nstatic void encode(AVCodecContext *enc_ctx, AVFrame *frame, AVPacket *pkt,\n                   FILE *outfile)\n{\n    int ret;\n\n    /* send the frame to the encoder */\n    if (frame)\n        printf(\"Send frame %3\"PRId64\"\\n\", frame->pts);\n\n    //给编码器送frame\n    ret = avcodec_send_frame(enc_ctx, frame);\n    if (ret < 0) {\n        fprintf(stderr, \"Error sending a frame for encoding\\n\");\n        exit(1);\n    }\n\n    while (ret >= 0) {\n        //从编码器读pkt\n        ret = avcodec_receive_packet(enc_ctx, pkt);\n        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)\n        {\n            //EAGAIN 代表需要继续送入 frame 才可以开始读取\n            //AVERROR_EOF 代表编码器已经没有数据可以读了\n            return;\n        }\n        else if (ret < 0) {\n            fprintf(stderr, \"Error during encoding\\n\");\n            exit(1);\n        }\n\n        printf(\"Write packet %3\"PRId64\" (size=%5d)\\n\", pkt->pts, pkt->size);\n        //将编码后的数据写入文件\n        fwrite(pkt->data, 1, pkt->size, outfile);\n        //取消引用pkt\n        av_packet_unref(pkt);\n    }\n}\n```\n\n1. 调用   avcodec_send_frame 给编码器送frame\n\n2. 循环调用avcodec_receive_packet 从编码器读pkt\n   \n   - EAGAIN 代表需要继续送入 frame 才可以开始读取\n   \n   - AVERROR_EOF 代表编码器已经没有数据可以读了,例如传入空的frame，对编码器进行了flush操作\n\n3. 将编码后数据写入文件\n\n4. 取消引用pkt\n\n最后输出的文件，可以使用ffplay 进行播放\n\n```\n➜  /tmp ffplay -i encode_video.h264\n```\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16469965503041646996550013.png)\n","slug":"ffmpeg/2022-03-11-ffmpeg example 学习 2","published":1,"updated":"2024-03-06T11:53:13.565Z","comments":1,"photos":[],"_id":"cltgopenc001nqywhdxvqc0jy","content":"<p>调试ffmpeg源码教程</p>\n<ul>\n<li><p><a href=\"https://yxibng.github.io/2022/03/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vscode%E5%9C%A8macOS%E5%B9%B3%E5%8F%B0%E8%B0%83%E8%AF%95ffmpeg/\">如何使用vscode在macOS平台调试ffmpeg</a></p>\n</li>\n<li><p><a href=\"https://yxibng.github.io/2022/03/%E4%BD%BF%E7%94%A8Xcode%E8%B0%83%E8%AF%95ffmpeg/\">使用Xcode调试ffmpeg</a></p>\n</li>\n</ul>\n<p>      </p>\n<p>今天用Xcode调试分析 <code>encode_video.c</code></p>\n<h2 id=\"配置ffmpeg-支持libx264和h264-videotoolbox来进行视频编码\"><a href=\"#配置ffmpeg-支持libx264和h264-videotoolbox来进行视频编码\" class=\"headerlink\" title=\"配置ffmpeg 支持libx264和h264_videotoolbox来进行视频编码\"></a>配置ffmpeg 支持libx264和h264_videotoolbox来进行视频编码</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">cd ffmpeg<br>./configure  --disable-optimizations --disable-stripping --enable-debug=3 --disable-doc --enable-libx264 --enable-gpl --enable-videotoolboxm<br>make -j 16<br>make examples<br></code></pre></td></tr></table></figure>\n\n<p>如果没有libx264， 通过 <a href=\"https://brew.sh/\">Homebrew</a> 安装一下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">brew install x264<br></code></pre></td></tr></table></figure>\n\n<p>ffmpeg  通过<a href=\"https://www.freedesktop.org/wiki/Software/pkg-config/\">pkg-config</a>可以找到x264对应的头文件和库的路径</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">➜  ffmpeg git:(master) ✗ pkg-config --libs --cflags x264<br>-DX264_API_IMPORTS -I/opt/homebrew/Cellar/x264/r3060/include -L/opt/homebrew/Cellar/x264/r3060/lib -lx264<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"配置Xcode\"><a href=\"#配置Xcode\" class=\"headerlink\" title=\"配置Xcode\"></a>配置Xcode</h2><p>添加target，配置路径</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16469917993141646991798582.png\"></p>\n<p>配置可执行文件，启动参数</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16469918543121646991854240.png\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16469918963141646991895699.png\"></p>\n<p>encode_video_g 接受两个参数，</p>\n<ol>\n<li><p>视频编码数据的写入路径</p>\n</li>\n<li><p>编码器名字（libx264 libx264rgb h264_videotoolbox）</p>\n</li>\n</ol>\n<p>我们使用h264编码器，查看ffmpeg 支持的h264编码器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">ffmpeg -codecs | grep 264<br>DEV.LS h264                 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (encoders: libx264 libx264rgb h264_videotoolbox )<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h3 id=\"main函数\"><a href=\"#main函数\" class=\"headerlink\" title=\"main函数\"></a>main函数</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span><br>&#123;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *filename, *codec_name;<br>    <span class=\"hljs-type\">const</span> AVCodec *codec;<br>    AVCodecContext *c= <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-type\">int</span> i, ret, x, y;<br>    FILE *f;<br>    AVFrame *frame;<br>    AVPacket *pkt;<br>    <span class=\"hljs-type\">uint8_t</span> endcode[] = &#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0xb7</span> &#125;;<br><br>    <span class=\"hljs-keyword\">if</span> (argc &lt;= <span class=\"hljs-number\">2</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Usage: %s &lt;output file&gt; &lt;codec name&gt;\\n&quot;</span>, argv[<span class=\"hljs-number\">0</span>]);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">0</span>);<br>    &#125;<br>    filename = argv[<span class=\"hljs-number\">1</span>];<br>    codec_name = argv[<span class=\"hljs-number\">2</span>];<br><br>    <span class=\"hljs-comment\">/* 根据编码器名字，找到对应的编码器，编码器的名字如libx264,h264_videotoolbox */</span><br>    codec = avcodec_find_encoder_by_name(codec_name);<br>    <span class=\"hljs-keyword\">if</span> (!codec) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Codec &#x27;%s&#x27; not found\\n&quot;</span>, codec_name);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">/* 创建编码器上下文 */</span><br>    c = avcodec_alloc_context3(codec);<br>    <span class=\"hljs-keyword\">if</span> (!c) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not allocate video codec context\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">/* 创建 pkt 用于保存编码后的数据 */</span><br>    pkt = av_packet_alloc();<br>    <span class=\"hljs-keyword\">if</span> (!pkt)<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    <span class=\"hljs-comment\">/* 配置编码参数 */</span><br>    <span class=\"hljs-comment\">//码率400000</span><br>    c-&gt;bit_rate = <span class=\"hljs-number\">400000</span>;<br>    <span class=\"hljs-comment\">//编码分辨率，宽高必须能被2整除</span><br>    c-&gt;width = <span class=\"hljs-number\">352</span>;<br>    c-&gt;height = <span class=\"hljs-number\">288</span>;<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">     编码的时间基,可以理解为刻度，与 pts 有关</span><br><span class=\"hljs-comment\">     (AVRational)&#123;1, 25&#125; 将1秒钟分成25份，每一份代表 1/25 秒</span><br><span class=\"hljs-comment\">     */</span><br>    c-&gt;time_base = (AVRational)&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">25</span>&#125;;<br>    <span class=\"hljs-comment\">/* 编码帧率 25 帧 */</span><br>    c-&gt;framerate = (AVRational)&#123;<span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">1</span>&#125;;<br><br>    <span class=\"hljs-comment\">/* 关键帧间隔，每10帧产生一个关键帧, 如果frame-&gt;pict_type 被设置为AV_PICTURE_TYPE_I</span><br><span class=\"hljs-comment\">     gop_size的值会被忽略，编码器不产出B帧和P帧，只会编码I帧</span><br><span class=\"hljs-comment\">     */</span><br>    c-&gt;gop_size = <span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-comment\">/* b帧的个数，实时通信一般设置为0 */</span><br>    c-&gt;max_b_frames = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-comment\">/* 编码的数据源的格式，yuv420p */</span><br>    c-&gt;pix_fmt = AV_PIX_FMT_YUV420P;<br>    <span class=\"hljs-comment\">/* 如果使用h264编码器，设置preset 为slow */</span><br>    <span class=\"hljs-keyword\">if</span> (codec-&gt;id == AV_CODEC_ID_H264)<br>        av_opt_set(c-&gt;priv_data, <span class=\"hljs-string\">&quot;preset&quot;</span>, <span class=\"hljs-string\">&quot;slow&quot;</span>, <span class=\"hljs-number\">0</span>);<br><br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">     打开编码器</span><br><span class=\"hljs-comment\">     */</span><br>    ret = avcodec_open2(c, codec, <span class=\"hljs-literal\">NULL</span>);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not open codec: %s\\n&quot;</span>, av_err2str(ret));<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">/* 打开输出文件 */</span><br>    f = fopen(filename, <span class=\"hljs-string\">&quot;wb&quot;</span>);<br>    <span class=\"hljs-keyword\">if</span> (!f) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not open %s\\n&quot;</span>, filename);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">/* 创建AVFrame用于存放待编码的数据，yuv */</span><br>    frame = av_frame_alloc();<br>    <span class=\"hljs-keyword\">if</span> (!frame) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not allocate video frame\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">/* 设置frame 的颜色格式，宽高 */</span><br>    frame-&gt;format = c-&gt;pix_fmt;<br>    frame-&gt;width  = c-&gt;width;<br>    frame-&gt;height = c-&gt;height;<br>    <span class=\"hljs-comment\">/* 根据上面设置的参数，给frame 内部的 buf 分配内存 */</span><br>    ret = av_frame_get_buffer(frame, <span class=\"hljs-number\">0</span>);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not allocate the video frame data\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 编码1秒钟的数据，上面设置的编码帧率是 25 帧  */</span><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">25</span>; i++) &#123;<br>        fflush(<span class=\"hljs-built_in\">stdout</span>);<br>        <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">         确保frame中的数据是可写的。</span><br><span class=\"hljs-comment\">         刚开始调用 av_frame_get_buffer()，frame中的数据是可写的。</span><br><span class=\"hljs-comment\">         后面将frame送给编码器去编码，可能被编码器引用，此时frame是不可写的。</span><br><span class=\"hljs-comment\">         调用av_frame_make_writable()会检查frame 是否可写，</span><br><span class=\"hljs-comment\">         如果不可写，会给frame内部重新创建新的buffer。</span><br><span class=\"hljs-comment\">         */</span><br>        ret = av_frame_make_writable(frame);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br><br>        <span class=\"hljs-comment\">/* 给frame填充数据，我们设置的是yuv420，这里填充假数据 */</span><br>        <span class=\"hljs-comment\">/* Y */</span><br>        <span class=\"hljs-keyword\">for</span> (y = <span class=\"hljs-number\">0</span>; y &lt; c-&gt;height; y++) &#123;<br>            <span class=\"hljs-keyword\">for</span> (x = <span class=\"hljs-number\">0</span>; x &lt; c-&gt;width; x++) &#123;<br>                frame-&gt;data[<span class=\"hljs-number\">0</span>][y * frame-&gt;linesize[<span class=\"hljs-number\">0</span>] + x] = x + y + i * <span class=\"hljs-number\">3</span>;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-comment\">/* Cb and Cr */</span><br>        <span class=\"hljs-keyword\">for</span> (y = <span class=\"hljs-number\">0</span>; y &lt; c-&gt;height/<span class=\"hljs-number\">2</span>; y++) &#123;<br>            <span class=\"hljs-keyword\">for</span> (x = <span class=\"hljs-number\">0</span>; x &lt; c-&gt;width/<span class=\"hljs-number\">2</span>; x++) &#123;<br>                frame-&gt;data[<span class=\"hljs-number\">1</span>][y * frame-&gt;linesize[<span class=\"hljs-number\">1</span>] + x] = <span class=\"hljs-number\">128</span> + y + i * <span class=\"hljs-number\">2</span>;<br>                frame-&gt;data[<span class=\"hljs-number\">2</span>][y * frame-&gt;linesize[<span class=\"hljs-number\">2</span>] + x] = <span class=\"hljs-number\">64</span> + x + i * <span class=\"hljs-number\">5</span>;<br>            &#125;<br>        &#125;<br><br>        <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">         设置frame的pts</span><br><span class=\"hljs-comment\">         我们设置的是每秒25帧</span><br><span class=\"hljs-comment\">         对应的时间转成秒是 pts * av_q2d(c-&gt;time_base)</span><br><span class=\"hljs-comment\">         */</span><br>        frame-&gt;pts = i;<br><br>        <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">         将frame 送给编码器编码，将编码后的数据写入文件</span><br><span class=\"hljs-comment\">         */</span><br>        encode(c, frame, pkt, f);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">     冲洗编码器，将剩余的编码后的数据读出来，写入文件</span><br><span class=\"hljs-comment\">     */</span><br>    encode(c, <span class=\"hljs-literal\">NULL</span>, pkt, f);<br><br>    <span class=\"hljs-comment\">/* Add sequence end code to have a real MPEG file.</span><br><span class=\"hljs-comment\">       It makes only sense because this tiny examples writes packets</span><br><span class=\"hljs-comment\">       directly. This is called &quot;elementary stream&quot; and only works for some</span><br><span class=\"hljs-comment\">       codecs. To create a valid file, you usually need to write packets</span><br><span class=\"hljs-comment\">       into a proper file format or protocol; see muxing.c.</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">if</span> (codec-&gt;id == AV_CODEC_ID_MPEG1VIDEO || codec-&gt;id == AV_CODEC_ID_MPEG2VIDEO)<br>        fwrite(endcode, <span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">sizeof</span>(endcode), f);<br><br>    <span class=\"hljs-comment\">//关闭文件</span><br>    fclose(f);<br>    <span class=\"hljs-comment\">//释放资源</span><br>    avcodec_free_context(&amp;c);<br>    av_frame_free(&amp;frame);<br>    av_packet_free(&amp;pkt);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>从命令行中输出文件的路径， 使用的编码器名字</p>\n</li>\n<li><p>根据名字找到对应的编码器</p>\n</li>\n<li><p>创建编码器上下文，设置编码器的参数（码率，时间基，帧率，宽高，颜色格式，b帧个数）</p>\n</li>\n<li><p>打开编码器</p>\n</li>\n<li><p>创建AVFrame 保存待编码的数据</p>\n</li>\n<li><p>创建AVPacket保存编码后的数据</p>\n</li>\n<li><p>编码1秒钟的数据</p>\n</li>\n<li><p>冲洗编码器，将剩余数据读出</p>\n</li>\n<li><p>关闭文件，释放资源</p>\n</li>\n</ol>\n<h3 id=\"encode\"><a href=\"#encode\" class=\"headerlink\" title=\"encode\"></a>encode</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">encode</span><span class=\"hljs-params\">(AVCodecContext *enc_ctx, AVFrame *frame, AVPacket *pkt,</span><br><span class=\"hljs-params\">                   FILE *outfile)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> ret;<br><br>    <span class=\"hljs-comment\">/* send the frame to the encoder */</span><br>    <span class=\"hljs-keyword\">if</span> (frame)<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Send frame %3&quot;</span>PRId64<span class=\"hljs-string\">&quot;\\n&quot;</span>, frame-&gt;pts);<br><br>    <span class=\"hljs-comment\">//给编码器送frame</span><br>    ret = avcodec_send_frame(enc_ctx, frame);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error sending a frame for encoding\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">while</span> (ret &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-comment\">//从编码器读pkt</span><br>        ret = avcodec_receive_packet(enc_ctx, pkt);<br>        <span class=\"hljs-keyword\">if</span> (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)<br>        &#123;<br>            <span class=\"hljs-comment\">//EAGAIN 代表需要继续送入 frame 才可以开始读取</span><br>            <span class=\"hljs-comment\">//AVERROR_EOF 代表编码器已经没有数据可以读了</span><br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error during encoding\\n&quot;</span>);<br>            <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>        &#125;<br><br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Write packet %3&quot;</span>PRId64<span class=\"hljs-string\">&quot; (size=%5d)\\n&quot;</span>, pkt-&gt;pts, pkt-&gt;size);<br>        <span class=\"hljs-comment\">//将编码后的数据写入文件</span><br>        fwrite(pkt-&gt;data, <span class=\"hljs-number\">1</span>, pkt-&gt;size, outfile);<br>        <span class=\"hljs-comment\">//取消引用pkt</span><br>        av_packet_unref(pkt);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>调用   avcodec_send_frame 给编码器送frame</p>\n</li>\n<li><p>循环调用avcodec_receive_packet 从编码器读pkt</p>\n<ul>\n<li><p>EAGAIN 代表需要继续送入 frame 才可以开始读取</p>\n</li>\n<li><p>AVERROR_EOF 代表编码器已经没有数据可以读了,例如传入空的frame，对编码器进行了flush操作</p>\n</li>\n</ul>\n</li>\n<li><p>将编码后数据写入文件</p>\n</li>\n<li><p>取消引用pkt</p>\n</li>\n</ol>\n<p>最后输出的文件，可以使用ffplay 进行播放</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">➜  /tmp ffplay -i encode_video.h264<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16469965503041646996550013.png\"></p>\n","excerpt":"","more":"<p>调试ffmpeg源码教程</p>\n<ul>\n<li><p><a href=\"https://yxibng.github.io/2022/03/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vscode%E5%9C%A8macOS%E5%B9%B3%E5%8F%B0%E8%B0%83%E8%AF%95ffmpeg/\">如何使用vscode在macOS平台调试ffmpeg</a></p>\n</li>\n<li><p><a href=\"https://yxibng.github.io/2022/03/%E4%BD%BF%E7%94%A8Xcode%E8%B0%83%E8%AF%95ffmpeg/\">使用Xcode调试ffmpeg</a></p>\n</li>\n</ul>\n<p>      </p>\n<p>今天用Xcode调试分析 <code>encode_video.c</code></p>\n<h2 id=\"配置ffmpeg-支持libx264和h264-videotoolbox来进行视频编码\"><a href=\"#配置ffmpeg-支持libx264和h264-videotoolbox来进行视频编码\" class=\"headerlink\" title=\"配置ffmpeg 支持libx264和h264_videotoolbox来进行视频编码\"></a>配置ffmpeg 支持libx264和h264_videotoolbox来进行视频编码</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">cd ffmpeg<br>./configure  --disable-optimizations --disable-stripping --enable-debug=3 --disable-doc --enable-libx264 --enable-gpl --enable-videotoolboxm<br>make -j 16<br>make examples<br></code></pre></td></tr></table></figure>\n\n<p>如果没有libx264， 通过 <a href=\"https://brew.sh/\">Homebrew</a> 安装一下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">brew install x264<br></code></pre></td></tr></table></figure>\n\n<p>ffmpeg  通过<a href=\"https://www.freedesktop.org/wiki/Software/pkg-config/\">pkg-config</a>可以找到x264对应的头文件和库的路径</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">➜  ffmpeg git:(master) ✗ pkg-config --libs --cflags x264<br>-DX264_API_IMPORTS -I/opt/homebrew/Cellar/x264/r3060/include -L/opt/homebrew/Cellar/x264/r3060/lib -lx264<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"配置Xcode\"><a href=\"#配置Xcode\" class=\"headerlink\" title=\"配置Xcode\"></a>配置Xcode</h2><p>添加target，配置路径</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16469917993141646991798582.png\"></p>\n<p>配置可执行文件，启动参数</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16469918543121646991854240.png\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16469918963141646991895699.png\"></p>\n<p>encode_video_g 接受两个参数，</p>\n<ol>\n<li><p>视频编码数据的写入路径</p>\n</li>\n<li><p>编码器名字（libx264 libx264rgb h264_videotoolbox）</p>\n</li>\n</ol>\n<p>我们使用h264编码器，查看ffmpeg 支持的h264编码器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">ffmpeg -codecs | grep 264<br>DEV.LS h264                 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (encoders: libx264 libx264rgb h264_videotoolbox )<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h3 id=\"main函数\"><a href=\"#main函数\" class=\"headerlink\" title=\"main函数\"></a>main函数</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span><br>&#123;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *filename, *codec_name;<br>    <span class=\"hljs-type\">const</span> AVCodec *codec;<br>    AVCodecContext *c= <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-type\">int</span> i, ret, x, y;<br>    FILE *f;<br>    AVFrame *frame;<br>    AVPacket *pkt;<br>    <span class=\"hljs-type\">uint8_t</span> endcode[] = &#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0xb7</span> &#125;;<br><br>    <span class=\"hljs-keyword\">if</span> (argc &lt;= <span class=\"hljs-number\">2</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Usage: %s &lt;output file&gt; &lt;codec name&gt;\\n&quot;</span>, argv[<span class=\"hljs-number\">0</span>]);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">0</span>);<br>    &#125;<br>    filename = argv[<span class=\"hljs-number\">1</span>];<br>    codec_name = argv[<span class=\"hljs-number\">2</span>];<br><br>    <span class=\"hljs-comment\">/* 根据编码器名字，找到对应的编码器，编码器的名字如libx264,h264_videotoolbox */</span><br>    codec = avcodec_find_encoder_by_name(codec_name);<br>    <span class=\"hljs-keyword\">if</span> (!codec) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Codec &#x27;%s&#x27; not found\\n&quot;</span>, codec_name);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">/* 创建编码器上下文 */</span><br>    c = avcodec_alloc_context3(codec);<br>    <span class=\"hljs-keyword\">if</span> (!c) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not allocate video codec context\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">/* 创建 pkt 用于保存编码后的数据 */</span><br>    pkt = av_packet_alloc();<br>    <span class=\"hljs-keyword\">if</span> (!pkt)<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    <span class=\"hljs-comment\">/* 配置编码参数 */</span><br>    <span class=\"hljs-comment\">//码率400000</span><br>    c-&gt;bit_rate = <span class=\"hljs-number\">400000</span>;<br>    <span class=\"hljs-comment\">//编码分辨率，宽高必须能被2整除</span><br>    c-&gt;width = <span class=\"hljs-number\">352</span>;<br>    c-&gt;height = <span class=\"hljs-number\">288</span>;<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">     编码的时间基,可以理解为刻度，与 pts 有关</span><br><span class=\"hljs-comment\">     (AVRational)&#123;1, 25&#125; 将1秒钟分成25份，每一份代表 1/25 秒</span><br><span class=\"hljs-comment\">     */</span><br>    c-&gt;time_base = (AVRational)&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">25</span>&#125;;<br>    <span class=\"hljs-comment\">/* 编码帧率 25 帧 */</span><br>    c-&gt;framerate = (AVRational)&#123;<span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">1</span>&#125;;<br><br>    <span class=\"hljs-comment\">/* 关键帧间隔，每10帧产生一个关键帧, 如果frame-&gt;pict_type 被设置为AV_PICTURE_TYPE_I</span><br><span class=\"hljs-comment\">     gop_size的值会被忽略，编码器不产出B帧和P帧，只会编码I帧</span><br><span class=\"hljs-comment\">     */</span><br>    c-&gt;gop_size = <span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-comment\">/* b帧的个数，实时通信一般设置为0 */</span><br>    c-&gt;max_b_frames = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-comment\">/* 编码的数据源的格式，yuv420p */</span><br>    c-&gt;pix_fmt = AV_PIX_FMT_YUV420P;<br>    <span class=\"hljs-comment\">/* 如果使用h264编码器，设置preset 为slow */</span><br>    <span class=\"hljs-keyword\">if</span> (codec-&gt;id == AV_CODEC_ID_H264)<br>        av_opt_set(c-&gt;priv_data, <span class=\"hljs-string\">&quot;preset&quot;</span>, <span class=\"hljs-string\">&quot;slow&quot;</span>, <span class=\"hljs-number\">0</span>);<br><br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">     打开编码器</span><br><span class=\"hljs-comment\">     */</span><br>    ret = avcodec_open2(c, codec, <span class=\"hljs-literal\">NULL</span>);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not open codec: %s\\n&quot;</span>, av_err2str(ret));<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">/* 打开输出文件 */</span><br>    f = fopen(filename, <span class=\"hljs-string\">&quot;wb&quot;</span>);<br>    <span class=\"hljs-keyword\">if</span> (!f) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not open %s\\n&quot;</span>, filename);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">/* 创建AVFrame用于存放待编码的数据，yuv */</span><br>    frame = av_frame_alloc();<br>    <span class=\"hljs-keyword\">if</span> (!frame) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not allocate video frame\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">/* 设置frame 的颜色格式，宽高 */</span><br>    frame-&gt;format = c-&gt;pix_fmt;<br>    frame-&gt;width  = c-&gt;width;<br>    frame-&gt;height = c-&gt;height;<br>    <span class=\"hljs-comment\">/* 根据上面设置的参数，给frame 内部的 buf 分配内存 */</span><br>    ret = av_frame_get_buffer(frame, <span class=\"hljs-number\">0</span>);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not allocate the video frame data\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 编码1秒钟的数据，上面设置的编码帧率是 25 帧  */</span><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">25</span>; i++) &#123;<br>        fflush(<span class=\"hljs-built_in\">stdout</span>);<br>        <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">         确保frame中的数据是可写的。</span><br><span class=\"hljs-comment\">         刚开始调用 av_frame_get_buffer()，frame中的数据是可写的。</span><br><span class=\"hljs-comment\">         后面将frame送给编码器去编码，可能被编码器引用，此时frame是不可写的。</span><br><span class=\"hljs-comment\">         调用av_frame_make_writable()会检查frame 是否可写，</span><br><span class=\"hljs-comment\">         如果不可写，会给frame内部重新创建新的buffer。</span><br><span class=\"hljs-comment\">         */</span><br>        ret = av_frame_make_writable(frame);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br><br>        <span class=\"hljs-comment\">/* 给frame填充数据，我们设置的是yuv420，这里填充假数据 */</span><br>        <span class=\"hljs-comment\">/* Y */</span><br>        <span class=\"hljs-keyword\">for</span> (y = <span class=\"hljs-number\">0</span>; y &lt; c-&gt;height; y++) &#123;<br>            <span class=\"hljs-keyword\">for</span> (x = <span class=\"hljs-number\">0</span>; x &lt; c-&gt;width; x++) &#123;<br>                frame-&gt;data[<span class=\"hljs-number\">0</span>][y * frame-&gt;linesize[<span class=\"hljs-number\">0</span>] + x] = x + y + i * <span class=\"hljs-number\">3</span>;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-comment\">/* Cb and Cr */</span><br>        <span class=\"hljs-keyword\">for</span> (y = <span class=\"hljs-number\">0</span>; y &lt; c-&gt;height/<span class=\"hljs-number\">2</span>; y++) &#123;<br>            <span class=\"hljs-keyword\">for</span> (x = <span class=\"hljs-number\">0</span>; x &lt; c-&gt;width/<span class=\"hljs-number\">2</span>; x++) &#123;<br>                frame-&gt;data[<span class=\"hljs-number\">1</span>][y * frame-&gt;linesize[<span class=\"hljs-number\">1</span>] + x] = <span class=\"hljs-number\">128</span> + y + i * <span class=\"hljs-number\">2</span>;<br>                frame-&gt;data[<span class=\"hljs-number\">2</span>][y * frame-&gt;linesize[<span class=\"hljs-number\">2</span>] + x] = <span class=\"hljs-number\">64</span> + x + i * <span class=\"hljs-number\">5</span>;<br>            &#125;<br>        &#125;<br><br>        <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">         设置frame的pts</span><br><span class=\"hljs-comment\">         我们设置的是每秒25帧</span><br><span class=\"hljs-comment\">         对应的时间转成秒是 pts * av_q2d(c-&gt;time_base)</span><br><span class=\"hljs-comment\">         */</span><br>        frame-&gt;pts = i;<br><br>        <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">         将frame 送给编码器编码，将编码后的数据写入文件</span><br><span class=\"hljs-comment\">         */</span><br>        encode(c, frame, pkt, f);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">     冲洗编码器，将剩余的编码后的数据读出来，写入文件</span><br><span class=\"hljs-comment\">     */</span><br>    encode(c, <span class=\"hljs-literal\">NULL</span>, pkt, f);<br><br>    <span class=\"hljs-comment\">/* Add sequence end code to have a real MPEG file.</span><br><span class=\"hljs-comment\">       It makes only sense because this tiny examples writes packets</span><br><span class=\"hljs-comment\">       directly. This is called &quot;elementary stream&quot; and only works for some</span><br><span class=\"hljs-comment\">       codecs. To create a valid file, you usually need to write packets</span><br><span class=\"hljs-comment\">       into a proper file format or protocol; see muxing.c.</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">if</span> (codec-&gt;id == AV_CODEC_ID_MPEG1VIDEO || codec-&gt;id == AV_CODEC_ID_MPEG2VIDEO)<br>        fwrite(endcode, <span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">sizeof</span>(endcode), f);<br><br>    <span class=\"hljs-comment\">//关闭文件</span><br>    fclose(f);<br>    <span class=\"hljs-comment\">//释放资源</span><br>    avcodec_free_context(&amp;c);<br>    av_frame_free(&amp;frame);<br>    av_packet_free(&amp;pkt);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>从命令行中输出文件的路径， 使用的编码器名字</p>\n</li>\n<li><p>根据名字找到对应的编码器</p>\n</li>\n<li><p>创建编码器上下文，设置编码器的参数（码率，时间基，帧率，宽高，颜色格式，b帧个数）</p>\n</li>\n<li><p>打开编码器</p>\n</li>\n<li><p>创建AVFrame 保存待编码的数据</p>\n</li>\n<li><p>创建AVPacket保存编码后的数据</p>\n</li>\n<li><p>编码1秒钟的数据</p>\n</li>\n<li><p>冲洗编码器，将剩余数据读出</p>\n</li>\n<li><p>关闭文件，释放资源</p>\n</li>\n</ol>\n<h3 id=\"encode\"><a href=\"#encode\" class=\"headerlink\" title=\"encode\"></a>encode</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">encode</span><span class=\"hljs-params\">(AVCodecContext *enc_ctx, AVFrame *frame, AVPacket *pkt,</span><br><span class=\"hljs-params\">                   FILE *outfile)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> ret;<br><br>    <span class=\"hljs-comment\">/* send the frame to the encoder */</span><br>    <span class=\"hljs-keyword\">if</span> (frame)<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Send frame %3&quot;</span>PRId64<span class=\"hljs-string\">&quot;\\n&quot;</span>, frame-&gt;pts);<br><br>    <span class=\"hljs-comment\">//给编码器送frame</span><br>    ret = avcodec_send_frame(enc_ctx, frame);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error sending a frame for encoding\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">while</span> (ret &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-comment\">//从编码器读pkt</span><br>        ret = avcodec_receive_packet(enc_ctx, pkt);<br>        <span class=\"hljs-keyword\">if</span> (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)<br>        &#123;<br>            <span class=\"hljs-comment\">//EAGAIN 代表需要继续送入 frame 才可以开始读取</span><br>            <span class=\"hljs-comment\">//AVERROR_EOF 代表编码器已经没有数据可以读了</span><br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error during encoding\\n&quot;</span>);<br>            <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>        &#125;<br><br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Write packet %3&quot;</span>PRId64<span class=\"hljs-string\">&quot; (size=%5d)\\n&quot;</span>, pkt-&gt;pts, pkt-&gt;size);<br>        <span class=\"hljs-comment\">//将编码后的数据写入文件</span><br>        fwrite(pkt-&gt;data, <span class=\"hljs-number\">1</span>, pkt-&gt;size, outfile);<br>        <span class=\"hljs-comment\">//取消引用pkt</span><br>        av_packet_unref(pkt);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>调用   avcodec_send_frame 给编码器送frame</p>\n</li>\n<li><p>循环调用avcodec_receive_packet 从编码器读pkt</p>\n<ul>\n<li><p>EAGAIN 代表需要继续送入 frame 才可以开始读取</p>\n</li>\n<li><p>AVERROR_EOF 代表编码器已经没有数据可以读了,例如传入空的frame，对编码器进行了flush操作</p>\n</li>\n</ul>\n</li>\n<li><p>将编码后数据写入文件</p>\n</li>\n<li><p>取消引用pkt</p>\n</li>\n</ol>\n<p>最后输出的文件，可以使用ffplay 进行播放</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">➜  /tmp ffplay -i encode_video.h264<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16469965503041646996550013.png\"></p>\n"},{"layout":"post","title":"ffmpeg example 3.音频编码","date":"2022-03-11T16:00:00.000Z","_content":"\n关于如何源码调试，参考前面的文章[ffmpeg example 视频编码 - 掘金](https://juejin.cn/post/7073796134912655367)\n\n今天分析`encode_audio.c`学习ffmpeg如何编码音频数据，由于太简单了，直接贴代码\n\n##main函数\n\n```c\nint main(int argc, char **argv)\n{\n    const char *filename;\n    const AVCodec *codec;\n    AVCodecContext *c= NULL;\n    AVFrame *frame;\n    AVPacket *pkt;\n    int i, j, k, ret;\n    FILE *f;\n    uint16_t *samples;\n    float t, tincr;\n\n    if (argc <= 1) {\n        fprintf(stderr, \"Usage: %s <output file>\\n\", argv[0]);\n        return 0;\n    }\n    filename = argv[1];\n\n    /* 根据codec_id 找到对应的音频编码器 */\n    codec = avcodec_find_encoder(AV_CODEC_ID_MP2);\n    if (!codec) {\n        fprintf(stderr, \"Codec not found\\n\");\n        exit(1);\n    }\n    /* 创建编码器AVCodecContext上下文 */\n    c = avcodec_alloc_context3(codec);\n    if (!c) {\n        fprintf(stderr, \"Could not allocate audio codec context\\n\");\n        exit(1);\n    }\n\n    /* 设置码率 */\n    c->bit_rate = 64000;\n\n    /* 采样格式 */\n    c->sample_fmt = AV_SAMPLE_FMT_S16;\n    /* 检查编码器是否支持该采样格式 */\n    if (!check_sample_fmt(codec, c->sample_fmt)) {\n        fprintf(stderr, \"Encoder does not support sample format %s\",\n                av_get_sample_fmt_name(c->sample_fmt));\n        exit(1);\n    }\n\n    /* select other audio parameters supported by the encoder */\n    /* 设置采样率 */\n    c->sample_rate    = select_sample_rate(codec);\n    /* 声道布局 */\n    c->channel_layout = select_channel_layout(codec);\n    /* 声道数量 */\n    c->channels       = av_get_channel_layout_nb_channels(c->channel_layout);\n\n    /* 打开编码器 */\n    if (avcodec_open2(c, codec, NULL) < 0) {\n        fprintf(stderr, \"Could not open codec\\n\");\n        exit(1);\n    }\n    /* 打开写文件 */\n    f = fopen(filename, \"wb\");\n    if (!f) {\n        fprintf(stderr, \"Could not open %s\\n\", filename);\n        exit(1);\n    }\n\n    /* 创建pkt，保存编码后的数据 */\n    pkt = av_packet_alloc();\n    if (!pkt) {\n        fprintf(stderr, \"could not allocate the packet\\n\");\n        exit(1);\n    }\n\n    /* 创建frame， 保存编码前的数据 */\n    frame = av_frame_alloc();\n    if (!frame) {\n        fprintf(stderr, \"Could not allocate audio frame\\n\");\n        exit(1);\n    }\n    /* 给frame 设置参数 */\n    // 每个声道有多少个采样\n    frame->nb_samples     = c->frame_size;\n    // 采样的格式\n    frame->format         = c->sample_fmt;\n    // 声道布局\n    frame->channel_layout = c->channel_layout;\n\n    /* 给 frame 内部分配内存 */\n    ret = av_frame_get_buffer(frame, 0);\n    if (ret < 0) {\n        fprintf(stderr, \"Could not allocate audio data buffers\\n\");\n        exit(1);\n    }\n\n    /* 给frame填充数据，编码，写入文件 */\n    t = 0;\n    tincr = 2 * M_PI * 440.0 / c->sample_rate;\n    for (i = 0; i < 200; i++) {\n        /* make sure the frame is writable -- makes a copy if the encoder\n         * kept a reference internally */\n\n        /*确定frame是可写的，如果frame被编码器内部引用，会变成不可写，调用此方法，给frame内部的buf指向新分配的空间，使其变为可写。 */\n        ret = av_frame_make_writable(frame);\n        if (ret < 0)\n            exit(1);\n        //获得写入的指针，由于设置的是AV_SAMPLE_FMT_S16，非平面类型，data[0]保存了写入地址。\n        samples = (uint16_t*)frame->data[0];\n\n        for (j = 0; j < c->frame_size; j++) {\n            samples[2*j] = (int)(sin(t) * 10000);\n            //多个声道，交错写数据\n            for (k = 1; k < c->channels; k++)\n                samples[2*j + k] = samples[2*j];\n            t += tincr;\n        }\n        //编码，写文件\n        encode(c, frame, pkt, f);\n    }\n\n    /* 冲洗编码器，读出剩余数据，写入文件 */\n    encode(c, NULL, pkt, f);\n\n    //关闭文件\n    fclose(f);\n    //释放资源\n    av_frame_free(&frame);\n    av_packet_free(&pkt);\n    avcodec_free_context(&c);\n\n    return 0;\n}\n```\n\n## 验证采样格式，找最大采样率，声道数\n\n```c\n/* check that a given sample format is supported by the encoder */\nstatic int check_sample_fmt(const AVCodec *codec, enum AVSampleFormat sample_fmt)\n{\n    //sample_fmts: array of supported sample formats, or NULL if unknown, array is terminated by -1\n    //支持的采样格式数组，为空，或者以-1结尾\n    const enum AVSampleFormat *p = codec->sample_fmts;\n    //判断设置的采样格式是否支持，1 支持 0 不支持\n    while (*p != AV_SAMPLE_FMT_NONE) {\n        if (*p == sample_fmt)\n            return 1;\n        p++;\n    }\n    return 0;\n}\n\n/* just pick the highest supported samplerate */\nstatic int select_sample_rate(const AVCodec *codec)\n{\n    const int *p;\n    int best_samplerate = 0;\n    //supported_samplerates: array of supported audio samplerates, or NULL if unknown, array is terminated by 0\n    //supported_samplerates 保存了支持的采样率的数组，为空，或者以 0 结尾\n    if (!codec->supported_samplerates)\n        //为空，返回44100\n        return 44100;\n\n    p = codec->supported_samplerates;\n    //找到支持的采样率的最大值\n    while (*p) {\n        if (!best_samplerate || abs(44100 - *p) < abs(44100 - best_samplerate))\n            best_samplerate = *p;\n        p++;\n    }\n    return best_samplerate;\n}\n\n/* select layout with the highest channel count */\nstatic int select_channel_layout(const AVCodec *codec)\n{\n    const uint64_t *p;\n    uint64_t best_ch_layout = 0;\n    int best_nb_channels   = 0;\n    //channel_layouts: array of support channel layouts, or NULL if unknown. array is terminated by 0\n    //channel_layouts 保存了支持的所有声道布局数组，为空，或者以 0 结尾\n    if (!codec->channel_layouts)\n        //为空，返回AV_CH_LAYOUT_STEREO\n        return AV_CH_LAYOUT_STEREO;\n\n    //找声道数最多的那个\n    p = codec->channel_layouts;\n    while (*p) {\n        int nb_channels = av_get_channel_layout_nb_channels(*p);\n\n        if (nb_channels > best_nb_channels) {\n            best_ch_layout    = *p;\n            best_nb_channels = nb_channels;\n        }\n        p++;\n    }\n    return best_ch_layout;\n}\n```\n\n## encode\n\n```c\nstatic void encode(AVCodecContext *ctx, AVFrame *frame, AVPacket *pkt,\n                   FILE *output)\n{\n    int ret;\n\n    /* 给编码器发送frame */\n    ret = avcodec_send_frame(ctx, frame);\n    if (ret < 0) {\n        fprintf(stderr, \"Error sending the frame to the encoder\\n\");\n        exit(1);\n    }\n\n    /* read all the available output packets (in general there may be any\n     * number of them */\n    while (ret >= 0) {\n        //从编码器中读pkt，pkt里面保存了编码后的数据\n        ret = avcodec_receive_packet(ctx, pkt);\n        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)\n            //EAGAIN编码器还需要更多的frame才能继续输出pkt\n            //AVERROR_EOF编码器没有更多数据可以读取了，例如被冲洗了\n            return;\n        else if (ret < 0) {\n            fprintf(stderr, \"Error encoding audio frame\\n\");\n            exit(1);\n        }\n        //写入文件\n        fwrite(pkt->data, 1, pkt->size, output);\n        //取消引用pkt\n        av_packet_unref(pkt);\n    }\n}\n```\n\n## 备注\n\n### ffmpeg 支持的音频编码器\n\n```\nffmpeg -codecs | grep encoder | grep -i audio\n DEAIL. aac                  AAC (Advanced Audio Coding) (decoders: aac aac_fixed aac_at ) (encoders: aac aac_at )\n DEAI.S alac                 ALAC (Apple Lossless Audio Codec) (decoders: alac alac_at ) (encoders: alac alac_at )\n DEAIL. mp2                  MP2 (MPEG audio layer 2) (decoders: mp2 mp2float mp2_at ) (encoders: mp2 mp2fixed )\n DEAIL. mp3                  MP3 (MPEG audio layer 3) (decoders: mp3float mp3 mp3_at ) (encoders: libmp3lame )\n DEAIL. opus                 Opus (Opus Interactive Audio Codec) (decoders: opus libopus ) (encoders: opus libopus )\n DEAIL. ra_144               RealAudio 1.0 (14.4K) (decoders: real_144 ) (encoders: real_144 )\n```\n\n示例中选择的是AV_CODEC_ID_MP2\n\n通过avcodec_find_encoder(AV_CODEC_ID_MP2)来找到对应的编码器\n\n你也可以尝试mp3，aac ，opus 之类的。\n\n### 采样格式，分平面型和非平面型\n\n```\nenum AVSampleFormat {\n    AV_SAMPLE_FMT_NONE = -1,\n    AV_SAMPLE_FMT_U8,          ///< unsigned 8 bits\n    AV_SAMPLE_FMT_S16,         ///< signed 16 bits\n    AV_SAMPLE_FMT_S32,         ///< signed 32 bits\n    AV_SAMPLE_FMT_FLT,         ///< float\n    AV_SAMPLE_FMT_DBL,         ///< double\n\n    AV_SAMPLE_FMT_U8P,         ///< unsigned 8 bits, planar\n    AV_SAMPLE_FMT_S16P,        ///< signed 16 bits, planar\n    AV_SAMPLE_FMT_S32P,        ///< signed 32 bits, planar\n    AV_SAMPLE_FMT_FLTP,        ///< float, planar\n    AV_SAMPLE_FMT_DBLP,        ///< double, planar\n    AV_SAMPLE_FMT_S64,         ///< signed 64 bits\n    AV_SAMPLE_FMT_S64P,        ///< signed 64 bits, planar\n\n    AV_SAMPLE_FMT_NB           ///< Number of sample formats. DO NOT USE if linking dynamically\n};\n```\n\n后缀带P的就是平面型的，不带P的就是交错型的。\n\n参考[音频格式解析：交错模式 vs Plane模式_lyy901135的博客-CSDN博客_plane模式](https://blog.csdn.net/lyy901135/article/details/103061967)\n\n### 时间戳\n\n在h264视频编码的时候，有打时间戳，音频编码没有看到打时间戳的环节，之后再探究。\n","source":"_posts/ffmpeg/2022-03-12-ffmpeg example 学习 3.md","raw":"---\nlayout: post\ntitle: \"ffmpeg example 3.音频编码\"\ndate: 2022-03-12 \ntag: ffmpeg\n---\n\n关于如何源码调试，参考前面的文章[ffmpeg example 视频编码 - 掘金](https://juejin.cn/post/7073796134912655367)\n\n今天分析`encode_audio.c`学习ffmpeg如何编码音频数据，由于太简单了，直接贴代码\n\n##main函数\n\n```c\nint main(int argc, char **argv)\n{\n    const char *filename;\n    const AVCodec *codec;\n    AVCodecContext *c= NULL;\n    AVFrame *frame;\n    AVPacket *pkt;\n    int i, j, k, ret;\n    FILE *f;\n    uint16_t *samples;\n    float t, tincr;\n\n    if (argc <= 1) {\n        fprintf(stderr, \"Usage: %s <output file>\\n\", argv[0]);\n        return 0;\n    }\n    filename = argv[1];\n\n    /* 根据codec_id 找到对应的音频编码器 */\n    codec = avcodec_find_encoder(AV_CODEC_ID_MP2);\n    if (!codec) {\n        fprintf(stderr, \"Codec not found\\n\");\n        exit(1);\n    }\n    /* 创建编码器AVCodecContext上下文 */\n    c = avcodec_alloc_context3(codec);\n    if (!c) {\n        fprintf(stderr, \"Could not allocate audio codec context\\n\");\n        exit(1);\n    }\n\n    /* 设置码率 */\n    c->bit_rate = 64000;\n\n    /* 采样格式 */\n    c->sample_fmt = AV_SAMPLE_FMT_S16;\n    /* 检查编码器是否支持该采样格式 */\n    if (!check_sample_fmt(codec, c->sample_fmt)) {\n        fprintf(stderr, \"Encoder does not support sample format %s\",\n                av_get_sample_fmt_name(c->sample_fmt));\n        exit(1);\n    }\n\n    /* select other audio parameters supported by the encoder */\n    /* 设置采样率 */\n    c->sample_rate    = select_sample_rate(codec);\n    /* 声道布局 */\n    c->channel_layout = select_channel_layout(codec);\n    /* 声道数量 */\n    c->channels       = av_get_channel_layout_nb_channels(c->channel_layout);\n\n    /* 打开编码器 */\n    if (avcodec_open2(c, codec, NULL) < 0) {\n        fprintf(stderr, \"Could not open codec\\n\");\n        exit(1);\n    }\n    /* 打开写文件 */\n    f = fopen(filename, \"wb\");\n    if (!f) {\n        fprintf(stderr, \"Could not open %s\\n\", filename);\n        exit(1);\n    }\n\n    /* 创建pkt，保存编码后的数据 */\n    pkt = av_packet_alloc();\n    if (!pkt) {\n        fprintf(stderr, \"could not allocate the packet\\n\");\n        exit(1);\n    }\n\n    /* 创建frame， 保存编码前的数据 */\n    frame = av_frame_alloc();\n    if (!frame) {\n        fprintf(stderr, \"Could not allocate audio frame\\n\");\n        exit(1);\n    }\n    /* 给frame 设置参数 */\n    // 每个声道有多少个采样\n    frame->nb_samples     = c->frame_size;\n    // 采样的格式\n    frame->format         = c->sample_fmt;\n    // 声道布局\n    frame->channel_layout = c->channel_layout;\n\n    /* 给 frame 内部分配内存 */\n    ret = av_frame_get_buffer(frame, 0);\n    if (ret < 0) {\n        fprintf(stderr, \"Could not allocate audio data buffers\\n\");\n        exit(1);\n    }\n\n    /* 给frame填充数据，编码，写入文件 */\n    t = 0;\n    tincr = 2 * M_PI * 440.0 / c->sample_rate;\n    for (i = 0; i < 200; i++) {\n        /* make sure the frame is writable -- makes a copy if the encoder\n         * kept a reference internally */\n\n        /*确定frame是可写的，如果frame被编码器内部引用，会变成不可写，调用此方法，给frame内部的buf指向新分配的空间，使其变为可写。 */\n        ret = av_frame_make_writable(frame);\n        if (ret < 0)\n            exit(1);\n        //获得写入的指针，由于设置的是AV_SAMPLE_FMT_S16，非平面类型，data[0]保存了写入地址。\n        samples = (uint16_t*)frame->data[0];\n\n        for (j = 0; j < c->frame_size; j++) {\n            samples[2*j] = (int)(sin(t) * 10000);\n            //多个声道，交错写数据\n            for (k = 1; k < c->channels; k++)\n                samples[2*j + k] = samples[2*j];\n            t += tincr;\n        }\n        //编码，写文件\n        encode(c, frame, pkt, f);\n    }\n\n    /* 冲洗编码器，读出剩余数据，写入文件 */\n    encode(c, NULL, pkt, f);\n\n    //关闭文件\n    fclose(f);\n    //释放资源\n    av_frame_free(&frame);\n    av_packet_free(&pkt);\n    avcodec_free_context(&c);\n\n    return 0;\n}\n```\n\n## 验证采样格式，找最大采样率，声道数\n\n```c\n/* check that a given sample format is supported by the encoder */\nstatic int check_sample_fmt(const AVCodec *codec, enum AVSampleFormat sample_fmt)\n{\n    //sample_fmts: array of supported sample formats, or NULL if unknown, array is terminated by -1\n    //支持的采样格式数组，为空，或者以-1结尾\n    const enum AVSampleFormat *p = codec->sample_fmts;\n    //判断设置的采样格式是否支持，1 支持 0 不支持\n    while (*p != AV_SAMPLE_FMT_NONE) {\n        if (*p == sample_fmt)\n            return 1;\n        p++;\n    }\n    return 0;\n}\n\n/* just pick the highest supported samplerate */\nstatic int select_sample_rate(const AVCodec *codec)\n{\n    const int *p;\n    int best_samplerate = 0;\n    //supported_samplerates: array of supported audio samplerates, or NULL if unknown, array is terminated by 0\n    //supported_samplerates 保存了支持的采样率的数组，为空，或者以 0 结尾\n    if (!codec->supported_samplerates)\n        //为空，返回44100\n        return 44100;\n\n    p = codec->supported_samplerates;\n    //找到支持的采样率的最大值\n    while (*p) {\n        if (!best_samplerate || abs(44100 - *p) < abs(44100 - best_samplerate))\n            best_samplerate = *p;\n        p++;\n    }\n    return best_samplerate;\n}\n\n/* select layout with the highest channel count */\nstatic int select_channel_layout(const AVCodec *codec)\n{\n    const uint64_t *p;\n    uint64_t best_ch_layout = 0;\n    int best_nb_channels   = 0;\n    //channel_layouts: array of support channel layouts, or NULL if unknown. array is terminated by 0\n    //channel_layouts 保存了支持的所有声道布局数组，为空，或者以 0 结尾\n    if (!codec->channel_layouts)\n        //为空，返回AV_CH_LAYOUT_STEREO\n        return AV_CH_LAYOUT_STEREO;\n\n    //找声道数最多的那个\n    p = codec->channel_layouts;\n    while (*p) {\n        int nb_channels = av_get_channel_layout_nb_channels(*p);\n\n        if (nb_channels > best_nb_channels) {\n            best_ch_layout    = *p;\n            best_nb_channels = nb_channels;\n        }\n        p++;\n    }\n    return best_ch_layout;\n}\n```\n\n## encode\n\n```c\nstatic void encode(AVCodecContext *ctx, AVFrame *frame, AVPacket *pkt,\n                   FILE *output)\n{\n    int ret;\n\n    /* 给编码器发送frame */\n    ret = avcodec_send_frame(ctx, frame);\n    if (ret < 0) {\n        fprintf(stderr, \"Error sending the frame to the encoder\\n\");\n        exit(1);\n    }\n\n    /* read all the available output packets (in general there may be any\n     * number of them */\n    while (ret >= 0) {\n        //从编码器中读pkt，pkt里面保存了编码后的数据\n        ret = avcodec_receive_packet(ctx, pkt);\n        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)\n            //EAGAIN编码器还需要更多的frame才能继续输出pkt\n            //AVERROR_EOF编码器没有更多数据可以读取了，例如被冲洗了\n            return;\n        else if (ret < 0) {\n            fprintf(stderr, \"Error encoding audio frame\\n\");\n            exit(1);\n        }\n        //写入文件\n        fwrite(pkt->data, 1, pkt->size, output);\n        //取消引用pkt\n        av_packet_unref(pkt);\n    }\n}\n```\n\n## 备注\n\n### ffmpeg 支持的音频编码器\n\n```\nffmpeg -codecs | grep encoder | grep -i audio\n DEAIL. aac                  AAC (Advanced Audio Coding) (decoders: aac aac_fixed aac_at ) (encoders: aac aac_at )\n DEAI.S alac                 ALAC (Apple Lossless Audio Codec) (decoders: alac alac_at ) (encoders: alac alac_at )\n DEAIL. mp2                  MP2 (MPEG audio layer 2) (decoders: mp2 mp2float mp2_at ) (encoders: mp2 mp2fixed )\n DEAIL. mp3                  MP3 (MPEG audio layer 3) (decoders: mp3float mp3 mp3_at ) (encoders: libmp3lame )\n DEAIL. opus                 Opus (Opus Interactive Audio Codec) (decoders: opus libopus ) (encoders: opus libopus )\n DEAIL. ra_144               RealAudio 1.0 (14.4K) (decoders: real_144 ) (encoders: real_144 )\n```\n\n示例中选择的是AV_CODEC_ID_MP2\n\n通过avcodec_find_encoder(AV_CODEC_ID_MP2)来找到对应的编码器\n\n你也可以尝试mp3，aac ，opus 之类的。\n\n### 采样格式，分平面型和非平面型\n\n```\nenum AVSampleFormat {\n    AV_SAMPLE_FMT_NONE = -1,\n    AV_SAMPLE_FMT_U8,          ///< unsigned 8 bits\n    AV_SAMPLE_FMT_S16,         ///< signed 16 bits\n    AV_SAMPLE_FMT_S32,         ///< signed 32 bits\n    AV_SAMPLE_FMT_FLT,         ///< float\n    AV_SAMPLE_FMT_DBL,         ///< double\n\n    AV_SAMPLE_FMT_U8P,         ///< unsigned 8 bits, planar\n    AV_SAMPLE_FMT_S16P,        ///< signed 16 bits, planar\n    AV_SAMPLE_FMT_S32P,        ///< signed 32 bits, planar\n    AV_SAMPLE_FMT_FLTP,        ///< float, planar\n    AV_SAMPLE_FMT_DBLP,        ///< double, planar\n    AV_SAMPLE_FMT_S64,         ///< signed 64 bits\n    AV_SAMPLE_FMT_S64P,        ///< signed 64 bits, planar\n\n    AV_SAMPLE_FMT_NB           ///< Number of sample formats. DO NOT USE if linking dynamically\n};\n```\n\n后缀带P的就是平面型的，不带P的就是交错型的。\n\n参考[音频格式解析：交错模式 vs Plane模式_lyy901135的博客-CSDN博客_plane模式](https://blog.csdn.net/lyy901135/article/details/103061967)\n\n### 时间戳\n\n在h264视频编码的时候，有打时间戳，音频编码没有看到打时间戳的环节，之后再探究。\n","slug":"ffmpeg/2022-03-12-ffmpeg example 学习 3","published":1,"updated":"2024-03-06T11:53:13.565Z","comments":1,"photos":[],"_id":"cltgopenc001pqywh5t9za8tz","content":"<p>关于如何源码调试，参考前面的文章<a href=\"https://juejin.cn/post/7073796134912655367\">ffmpeg example 视频编码 - 掘金</a></p>\n<p>今天分析<code>encode_audio.c</code>学习ffmpeg如何编码音频数据，由于太简单了，直接贴代码</p>\n<p>##main函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span><br>&#123;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *filename;<br>    <span class=\"hljs-type\">const</span> AVCodec *codec;<br>    AVCodecContext *c= <span class=\"hljs-literal\">NULL</span>;<br>    AVFrame *frame;<br>    AVPacket *pkt;<br>    <span class=\"hljs-type\">int</span> i, j, k, ret;<br>    FILE *f;<br>    <span class=\"hljs-type\">uint16_t</span> *samples;<br>    <span class=\"hljs-type\">float</span> t, tincr;<br><br>    <span class=\"hljs-keyword\">if</span> (argc &lt;= <span class=\"hljs-number\">1</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Usage: %s &lt;output file&gt;\\n&quot;</span>, argv[<span class=\"hljs-number\">0</span>]);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    filename = argv[<span class=\"hljs-number\">1</span>];<br><br>    <span class=\"hljs-comment\">/* 根据codec_id 找到对应的音频编码器 */</span><br>    codec = avcodec_find_encoder(AV_CODEC_ID_MP2);<br>    <span class=\"hljs-keyword\">if</span> (!codec) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Codec not found\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">/* 创建编码器AVCodecContext上下文 */</span><br>    c = avcodec_alloc_context3(codec);<br>    <span class=\"hljs-keyword\">if</span> (!c) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not allocate audio codec context\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 设置码率 */</span><br>    c-&gt;bit_rate = <span class=\"hljs-number\">64000</span>;<br><br>    <span class=\"hljs-comment\">/* 采样格式 */</span><br>    c-&gt;sample_fmt = AV_SAMPLE_FMT_S16;<br>    <span class=\"hljs-comment\">/* 检查编码器是否支持该采样格式 */</span><br>    <span class=\"hljs-keyword\">if</span> (!check_sample_fmt(codec, c-&gt;sample_fmt)) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Encoder does not support sample format %s&quot;</span>,<br>                av_get_sample_fmt_name(c-&gt;sample_fmt));<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* select other audio parameters supported by the encoder */</span><br>    <span class=\"hljs-comment\">/* 设置采样率 */</span><br>    c-&gt;sample_rate    = select_sample_rate(codec);<br>    <span class=\"hljs-comment\">/* 声道布局 */</span><br>    c-&gt;channel_layout = select_channel_layout(codec);<br>    <span class=\"hljs-comment\">/* 声道数量 */</span><br>    c-&gt;channels       = av_get_channel_layout_nb_channels(c-&gt;channel_layout);<br><br>    <span class=\"hljs-comment\">/* 打开编码器 */</span><br>    <span class=\"hljs-keyword\">if</span> (avcodec_open2(c, codec, <span class=\"hljs-literal\">NULL</span>) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not open codec\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">/* 打开写文件 */</span><br>    f = fopen(filename, <span class=\"hljs-string\">&quot;wb&quot;</span>);<br>    <span class=\"hljs-keyword\">if</span> (!f) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not open %s\\n&quot;</span>, filename);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 创建pkt，保存编码后的数据 */</span><br>    pkt = av_packet_alloc();<br>    <span class=\"hljs-keyword\">if</span> (!pkt) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;could not allocate the packet\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 创建frame， 保存编码前的数据 */</span><br>    frame = av_frame_alloc();<br>    <span class=\"hljs-keyword\">if</span> (!frame) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not allocate audio frame\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">/* 给frame 设置参数 */</span><br>    <span class=\"hljs-comment\">// 每个声道有多少个采样</span><br>    frame-&gt;nb_samples     = c-&gt;frame_size;<br>    <span class=\"hljs-comment\">// 采样的格式</span><br>    frame-&gt;format         = c-&gt;sample_fmt;<br>    <span class=\"hljs-comment\">// 声道布局</span><br>    frame-&gt;channel_layout = c-&gt;channel_layout;<br><br>    <span class=\"hljs-comment\">/* 给 frame 内部分配内存 */</span><br>    ret = av_frame_get_buffer(frame, <span class=\"hljs-number\">0</span>);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not allocate audio data buffers\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 给frame填充数据，编码，写入文件 */</span><br>    t = <span class=\"hljs-number\">0</span>;<br>    tincr = <span class=\"hljs-number\">2</span> * M_PI * <span class=\"hljs-number\">440.0</span> / c-&gt;sample_rate;<br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">200</span>; i++) &#123;<br>        <span class=\"hljs-comment\">/* make sure the frame is writable -- makes a copy if the encoder</span><br><span class=\"hljs-comment\">         * kept a reference internally */</span><br><br>        <span class=\"hljs-comment\">/*确定frame是可写的，如果frame被编码器内部引用，会变成不可写，调用此方法，给frame内部的buf指向新分配的空间，使其变为可写。 */</span><br>        ret = av_frame_make_writable(frame);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-comment\">//获得写入的指针，由于设置的是AV_SAMPLE_FMT_S16，非平面类型，data[0]保存了写入地址。</span><br>        samples = (<span class=\"hljs-type\">uint16_t</span>*)frame-&gt;data[<span class=\"hljs-number\">0</span>];<br><br>        <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; c-&gt;frame_size; j++) &#123;<br>            samples[<span class=\"hljs-number\">2</span>*j] = (<span class=\"hljs-type\">int</span>)(<span class=\"hljs-built_in\">sin</span>(t) * <span class=\"hljs-number\">10000</span>);<br>            <span class=\"hljs-comment\">//多个声道，交错写数据</span><br>            <span class=\"hljs-keyword\">for</span> (k = <span class=\"hljs-number\">1</span>; k &lt; c-&gt;channels; k++)<br>                samples[<span class=\"hljs-number\">2</span>*j + k] = samples[<span class=\"hljs-number\">2</span>*j];<br>            t += tincr;<br>        &#125;<br>        <span class=\"hljs-comment\">//编码，写文件</span><br>        encode(c, frame, pkt, f);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 冲洗编码器，读出剩余数据，写入文件 */</span><br>    encode(c, <span class=\"hljs-literal\">NULL</span>, pkt, f);<br><br>    <span class=\"hljs-comment\">//关闭文件</span><br>    fclose(f);<br>    <span class=\"hljs-comment\">//释放资源</span><br>    av_frame_free(&amp;frame);<br>    av_packet_free(&amp;pkt);<br>    avcodec_free_context(&amp;c);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"验证采样格式，找最大采样率，声道数\"><a href=\"#验证采样格式，找最大采样率，声道数\" class=\"headerlink\" title=\"验证采样格式，找最大采样率，声道数\"></a>验证采样格式，找最大采样率，声道数</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* check that a given sample format is supported by the encoder */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">check_sample_fmt</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> AVCodec *codec, <span class=\"hljs-keyword\">enum</span> AVSampleFormat sample_fmt)</span><br>&#123;<br>    <span class=\"hljs-comment\">//sample_fmts: array of supported sample formats, or NULL if unknown, array is terminated by -1</span><br>    <span class=\"hljs-comment\">//支持的采样格式数组，为空，或者以-1结尾</span><br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">AVSampleFormat</span> *<span class=\"hljs-title\">p</span> =</span> codec-&gt;sample_fmts;<br>    <span class=\"hljs-comment\">//判断设置的采样格式是否支持，1 支持 0 不支持</span><br>    <span class=\"hljs-keyword\">while</span> (*p != AV_SAMPLE_FMT_NONE) &#123;<br>        <span class=\"hljs-keyword\">if</span> (*p == sample_fmt)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>        p++;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* just pick the highest supported samplerate */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">select_sample_rate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> AVCodec *codec)</span><br>&#123;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *p;<br>    <span class=\"hljs-type\">int</span> best_samplerate = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-comment\">//supported_samplerates: array of supported audio samplerates, or NULL if unknown, array is terminated by 0</span><br>    <span class=\"hljs-comment\">//supported_samplerates 保存了支持的采样率的数组，为空，或者以 0 结尾</span><br>    <span class=\"hljs-keyword\">if</span> (!codec-&gt;supported_samplerates)<br>        <span class=\"hljs-comment\">//为空，返回44100</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">44100</span>;<br><br>    p = codec-&gt;supported_samplerates;<br>    <span class=\"hljs-comment\">//找到支持的采样率的最大值</span><br>    <span class=\"hljs-keyword\">while</span> (*p) &#123;<br>        <span class=\"hljs-keyword\">if</span> (!best_samplerate || <span class=\"hljs-built_in\">abs</span>(<span class=\"hljs-number\">44100</span> - *p) &lt; <span class=\"hljs-built_in\">abs</span>(<span class=\"hljs-number\">44100</span> - best_samplerate))<br>            best_samplerate = *p;<br>        p++;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> best_samplerate;<br>&#125;<br><br><span class=\"hljs-comment\">/* select layout with the highest channel count */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">select_channel_layout</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> AVCodec *codec)</span><br>&#123;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint64_t</span> *p;<br>    <span class=\"hljs-type\">uint64_t</span> best_ch_layout = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">int</span> best_nb_channels   = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-comment\">//channel_layouts: array of support channel layouts, or NULL if unknown. array is terminated by 0</span><br>    <span class=\"hljs-comment\">//channel_layouts 保存了支持的所有声道布局数组，为空，或者以 0 结尾</span><br>    <span class=\"hljs-keyword\">if</span> (!codec-&gt;channel_layouts)<br>        <span class=\"hljs-comment\">//为空，返回AV_CH_LAYOUT_STEREO</span><br>        <span class=\"hljs-keyword\">return</span> AV_CH_LAYOUT_STEREO;<br><br>    <span class=\"hljs-comment\">//找声道数最多的那个</span><br>    p = codec-&gt;channel_layouts;<br>    <span class=\"hljs-keyword\">while</span> (*p) &#123;<br>        <span class=\"hljs-type\">int</span> nb_channels = av_get_channel_layout_nb_channels(*p);<br><br>        <span class=\"hljs-keyword\">if</span> (nb_channels &gt; best_nb_channels) &#123;<br>            best_ch_layout    = *p;<br>            best_nb_channels = nb_channels;<br>        &#125;<br>        p++;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> best_ch_layout;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"encode\"><a href=\"#encode\" class=\"headerlink\" title=\"encode\"></a>encode</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">encode</span><span class=\"hljs-params\">(AVCodecContext *ctx, AVFrame *frame, AVPacket *pkt,</span><br><span class=\"hljs-params\">                   FILE *output)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> ret;<br><br>    <span class=\"hljs-comment\">/* 给编码器发送frame */</span><br>    ret = avcodec_send_frame(ctx, frame);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error sending the frame to the encoder\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* read all the available output packets (in general there may be any</span><br><span class=\"hljs-comment\">     * number of them */</span><br>    <span class=\"hljs-keyword\">while</span> (ret &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-comment\">//从编码器中读pkt，pkt里面保存了编码后的数据</span><br>        ret = avcodec_receive_packet(ctx, pkt);<br>        <span class=\"hljs-keyword\">if</span> (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)<br>            <span class=\"hljs-comment\">//EAGAIN编码器还需要更多的frame才能继续输出pkt</span><br>            <span class=\"hljs-comment\">//AVERROR_EOF编码器没有更多数据可以读取了，例如被冲洗了</span><br>            <span class=\"hljs-keyword\">return</span>;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error encoding audio frame\\n&quot;</span>);<br>            <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>        &#125;<br>        <span class=\"hljs-comment\">//写入文件</span><br>        fwrite(pkt-&gt;data, <span class=\"hljs-number\">1</span>, pkt-&gt;size, output);<br>        <span class=\"hljs-comment\">//取消引用pkt</span><br>        av_packet_unref(pkt);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"备注\"><a href=\"#备注\" class=\"headerlink\" title=\"备注\"></a>备注</h2><h3 id=\"ffmpeg-支持的音频编码器\"><a href=\"#ffmpeg-支持的音频编码器\" class=\"headerlink\" title=\"ffmpeg 支持的音频编码器\"></a>ffmpeg 支持的音频编码器</h3><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs less\"><span class=\"hljs-selector-tag\">ffmpeg</span> <span class=\"hljs-selector-tag\">-codecs</span> | <span class=\"hljs-selector-tag\">grep</span> <span class=\"hljs-selector-tag\">encoder</span> | <span class=\"hljs-selector-tag\">grep</span> <span class=\"hljs-selector-tag\">-i</span> <span class=\"hljs-selector-tag\">audio</span><br> <span class=\"hljs-selector-tag\">DEAIL</span>. <span class=\"hljs-selector-tag\">aac</span>                  <span class=\"hljs-selector-tag\">AAC</span> (Advanced Audio Coding) (<span class=\"hljs-attribute\">decoders</span>: aac aac_fixed aac_at ) (<span class=\"hljs-attribute\">encoders</span>: aac aac_at )<br> <span class=\"hljs-selector-tag\">DEAI</span><span class=\"hljs-selector-class\">.S</span> <span class=\"hljs-selector-tag\">alac</span>                 <span class=\"hljs-selector-tag\">ALAC</span> (Apple Lossless Audio Codec) (<span class=\"hljs-attribute\">decoders</span>: alac alac_at ) (<span class=\"hljs-attribute\">encoders</span>: alac alac_at )<br> <span class=\"hljs-selector-tag\">DEAIL</span>. <span class=\"hljs-selector-tag\">mp2</span>                  <span class=\"hljs-selector-tag\">MP2</span> (MPEG audio layer <span class=\"hljs-number\">2</span>) (<span class=\"hljs-attribute\">decoders</span>: mp2 mp2float mp2_at ) (<span class=\"hljs-attribute\">encoders</span>: mp2 mp2fixed )<br> <span class=\"hljs-selector-tag\">DEAIL</span>. <span class=\"hljs-selector-tag\">mp3</span>                  <span class=\"hljs-selector-tag\">MP3</span> (MPEG audio layer <span class=\"hljs-number\">3</span>) (<span class=\"hljs-attribute\">decoders</span>: mp3float mp3 mp3_at ) (<span class=\"hljs-attribute\">encoders</span>: libmp3lame )<br> <span class=\"hljs-selector-tag\">DEAIL</span>. <span class=\"hljs-selector-tag\">opus</span>                 <span class=\"hljs-selector-tag\">Opus</span> (Opus Interactive Audio Codec) (<span class=\"hljs-attribute\">decoders</span>: opus libopus ) (<span class=\"hljs-attribute\">encoders</span>: opus libopus )<br> <span class=\"hljs-selector-tag\">DEAIL</span>. <span class=\"hljs-selector-tag\">ra_144</span>               <span class=\"hljs-selector-tag\">RealAudio</span> <span class=\"hljs-number\">1.0</span> (<span class=\"hljs-number\">14.4</span>K) (<span class=\"hljs-attribute\">decoders</span>: real_144 ) (<span class=\"hljs-attribute\">encoders</span>: real_144 )<br></code></pre></td></tr></table></figure>\n\n<p>示例中选择的是AV_CODEC_ID_MP2</p>\n<p>通过avcodec_find_encoder(AV_CODEC_ID_MP2)来找到对应的编码器</p>\n<p>你也可以尝试mp3，aac ，opus 之类的。</p>\n<h3 id=\"采样格式，分平面型和非平面型\"><a href=\"#采样格式，分平面型和非平面型\" class=\"headerlink\" title=\"采样格式，分平面型和非平面型\"></a>采样格式，分平面型和非平面型</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-built_in\">AVSampleFormat</span> &#123;<br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_NONE</span> = <span class=\"hljs-number\">-1</span>,<br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_U8</span>,          <span class=\"hljs-comment\">///&lt; unsigned 8 bits</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_S16</span>,         <span class=\"hljs-comment\">///&lt; signed 16 bits</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_S32</span>,         <span class=\"hljs-comment\">///&lt; signed 32 bits</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_FLT</span>,         <span class=\"hljs-comment\">///&lt; float</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_DBL</span>,         <span class=\"hljs-comment\">///&lt; double</span><br><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_U8P</span>,         <span class=\"hljs-comment\">///&lt; unsigned 8 bits, planar</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_S16P</span>,        <span class=\"hljs-comment\">///&lt; signed 16 bits, planar</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_S32P</span>,        <span class=\"hljs-comment\">///&lt; signed 32 bits, planar</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_FLTP</span>,        <span class=\"hljs-comment\">///&lt; float, planar</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_DBLP</span>,        <span class=\"hljs-comment\">///&lt; double, planar</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_S64</span>,         <span class=\"hljs-comment\">///&lt; signed 64 bits</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_S64P</span>,        <span class=\"hljs-comment\">///&lt; signed 64 bits, planar</span><br><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_NB</span>           <span class=\"hljs-comment\">///&lt; Number of sample formats. DO NOT USE if linking dynamically</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>后缀带P的就是平面型的，不带P的就是交错型的。</p>\n<p>参考<a href=\"https://blog.csdn.net/lyy901135/article/details/103061967\">音频格式解析：交错模式 vs Plane模式_lyy901135的博客-CSDN博客_plane模式</a></p>\n<h3 id=\"时间戳\"><a href=\"#时间戳\" class=\"headerlink\" title=\"时间戳\"></a>时间戳</h3><p>在h264视频编码的时候，有打时间戳，音频编码没有看到打时间戳的环节，之后再探究。</p>\n","excerpt":"","more":"<p>关于如何源码调试，参考前面的文章<a href=\"https://juejin.cn/post/7073796134912655367\">ffmpeg example 视频编码 - 掘金</a></p>\n<p>今天分析<code>encode_audio.c</code>学习ffmpeg如何编码音频数据，由于太简单了，直接贴代码</p>\n<p>##main函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span><br>&#123;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *filename;<br>    <span class=\"hljs-type\">const</span> AVCodec *codec;<br>    AVCodecContext *c= <span class=\"hljs-literal\">NULL</span>;<br>    AVFrame *frame;<br>    AVPacket *pkt;<br>    <span class=\"hljs-type\">int</span> i, j, k, ret;<br>    FILE *f;<br>    <span class=\"hljs-type\">uint16_t</span> *samples;<br>    <span class=\"hljs-type\">float</span> t, tincr;<br><br>    <span class=\"hljs-keyword\">if</span> (argc &lt;= <span class=\"hljs-number\">1</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Usage: %s &lt;output file&gt;\\n&quot;</span>, argv[<span class=\"hljs-number\">0</span>]);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    filename = argv[<span class=\"hljs-number\">1</span>];<br><br>    <span class=\"hljs-comment\">/* 根据codec_id 找到对应的音频编码器 */</span><br>    codec = avcodec_find_encoder(AV_CODEC_ID_MP2);<br>    <span class=\"hljs-keyword\">if</span> (!codec) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Codec not found\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">/* 创建编码器AVCodecContext上下文 */</span><br>    c = avcodec_alloc_context3(codec);<br>    <span class=\"hljs-keyword\">if</span> (!c) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not allocate audio codec context\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 设置码率 */</span><br>    c-&gt;bit_rate = <span class=\"hljs-number\">64000</span>;<br><br>    <span class=\"hljs-comment\">/* 采样格式 */</span><br>    c-&gt;sample_fmt = AV_SAMPLE_FMT_S16;<br>    <span class=\"hljs-comment\">/* 检查编码器是否支持该采样格式 */</span><br>    <span class=\"hljs-keyword\">if</span> (!check_sample_fmt(codec, c-&gt;sample_fmt)) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Encoder does not support sample format %s&quot;</span>,<br>                av_get_sample_fmt_name(c-&gt;sample_fmt));<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* select other audio parameters supported by the encoder */</span><br>    <span class=\"hljs-comment\">/* 设置采样率 */</span><br>    c-&gt;sample_rate    = select_sample_rate(codec);<br>    <span class=\"hljs-comment\">/* 声道布局 */</span><br>    c-&gt;channel_layout = select_channel_layout(codec);<br>    <span class=\"hljs-comment\">/* 声道数量 */</span><br>    c-&gt;channels       = av_get_channel_layout_nb_channels(c-&gt;channel_layout);<br><br>    <span class=\"hljs-comment\">/* 打开编码器 */</span><br>    <span class=\"hljs-keyword\">if</span> (avcodec_open2(c, codec, <span class=\"hljs-literal\">NULL</span>) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not open codec\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">/* 打开写文件 */</span><br>    f = fopen(filename, <span class=\"hljs-string\">&quot;wb&quot;</span>);<br>    <span class=\"hljs-keyword\">if</span> (!f) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not open %s\\n&quot;</span>, filename);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 创建pkt，保存编码后的数据 */</span><br>    pkt = av_packet_alloc();<br>    <span class=\"hljs-keyword\">if</span> (!pkt) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;could not allocate the packet\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 创建frame， 保存编码前的数据 */</span><br>    frame = av_frame_alloc();<br>    <span class=\"hljs-keyword\">if</span> (!frame) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not allocate audio frame\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">/* 给frame 设置参数 */</span><br>    <span class=\"hljs-comment\">// 每个声道有多少个采样</span><br>    frame-&gt;nb_samples     = c-&gt;frame_size;<br>    <span class=\"hljs-comment\">// 采样的格式</span><br>    frame-&gt;format         = c-&gt;sample_fmt;<br>    <span class=\"hljs-comment\">// 声道布局</span><br>    frame-&gt;channel_layout = c-&gt;channel_layout;<br><br>    <span class=\"hljs-comment\">/* 给 frame 内部分配内存 */</span><br>    ret = av_frame_get_buffer(frame, <span class=\"hljs-number\">0</span>);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not allocate audio data buffers\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 给frame填充数据，编码，写入文件 */</span><br>    t = <span class=\"hljs-number\">0</span>;<br>    tincr = <span class=\"hljs-number\">2</span> * M_PI * <span class=\"hljs-number\">440.0</span> / c-&gt;sample_rate;<br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">200</span>; i++) &#123;<br>        <span class=\"hljs-comment\">/* make sure the frame is writable -- makes a copy if the encoder</span><br><span class=\"hljs-comment\">         * kept a reference internally */</span><br><br>        <span class=\"hljs-comment\">/*确定frame是可写的，如果frame被编码器内部引用，会变成不可写，调用此方法，给frame内部的buf指向新分配的空间，使其变为可写。 */</span><br>        ret = av_frame_make_writable(frame);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-comment\">//获得写入的指针，由于设置的是AV_SAMPLE_FMT_S16，非平面类型，data[0]保存了写入地址。</span><br>        samples = (<span class=\"hljs-type\">uint16_t</span>*)frame-&gt;data[<span class=\"hljs-number\">0</span>];<br><br>        <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; c-&gt;frame_size; j++) &#123;<br>            samples[<span class=\"hljs-number\">2</span>*j] = (<span class=\"hljs-type\">int</span>)(<span class=\"hljs-built_in\">sin</span>(t) * <span class=\"hljs-number\">10000</span>);<br>            <span class=\"hljs-comment\">//多个声道，交错写数据</span><br>            <span class=\"hljs-keyword\">for</span> (k = <span class=\"hljs-number\">1</span>; k &lt; c-&gt;channels; k++)<br>                samples[<span class=\"hljs-number\">2</span>*j + k] = samples[<span class=\"hljs-number\">2</span>*j];<br>            t += tincr;<br>        &#125;<br>        <span class=\"hljs-comment\">//编码，写文件</span><br>        encode(c, frame, pkt, f);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 冲洗编码器，读出剩余数据，写入文件 */</span><br>    encode(c, <span class=\"hljs-literal\">NULL</span>, pkt, f);<br><br>    <span class=\"hljs-comment\">//关闭文件</span><br>    fclose(f);<br>    <span class=\"hljs-comment\">//释放资源</span><br>    av_frame_free(&amp;frame);<br>    av_packet_free(&amp;pkt);<br>    avcodec_free_context(&amp;c);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"验证采样格式，找最大采样率，声道数\"><a href=\"#验证采样格式，找最大采样率，声道数\" class=\"headerlink\" title=\"验证采样格式，找最大采样率，声道数\"></a>验证采样格式，找最大采样率，声道数</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* check that a given sample format is supported by the encoder */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">check_sample_fmt</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> AVCodec *codec, <span class=\"hljs-keyword\">enum</span> AVSampleFormat sample_fmt)</span><br>&#123;<br>    <span class=\"hljs-comment\">//sample_fmts: array of supported sample formats, or NULL if unknown, array is terminated by -1</span><br>    <span class=\"hljs-comment\">//支持的采样格式数组，为空，或者以-1结尾</span><br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">AVSampleFormat</span> *<span class=\"hljs-title\">p</span> =</span> codec-&gt;sample_fmts;<br>    <span class=\"hljs-comment\">//判断设置的采样格式是否支持，1 支持 0 不支持</span><br>    <span class=\"hljs-keyword\">while</span> (*p != AV_SAMPLE_FMT_NONE) &#123;<br>        <span class=\"hljs-keyword\">if</span> (*p == sample_fmt)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>        p++;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* just pick the highest supported samplerate */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">select_sample_rate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> AVCodec *codec)</span><br>&#123;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *p;<br>    <span class=\"hljs-type\">int</span> best_samplerate = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-comment\">//supported_samplerates: array of supported audio samplerates, or NULL if unknown, array is terminated by 0</span><br>    <span class=\"hljs-comment\">//supported_samplerates 保存了支持的采样率的数组，为空，或者以 0 结尾</span><br>    <span class=\"hljs-keyword\">if</span> (!codec-&gt;supported_samplerates)<br>        <span class=\"hljs-comment\">//为空，返回44100</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">44100</span>;<br><br>    p = codec-&gt;supported_samplerates;<br>    <span class=\"hljs-comment\">//找到支持的采样率的最大值</span><br>    <span class=\"hljs-keyword\">while</span> (*p) &#123;<br>        <span class=\"hljs-keyword\">if</span> (!best_samplerate || <span class=\"hljs-built_in\">abs</span>(<span class=\"hljs-number\">44100</span> - *p) &lt; <span class=\"hljs-built_in\">abs</span>(<span class=\"hljs-number\">44100</span> - best_samplerate))<br>            best_samplerate = *p;<br>        p++;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> best_samplerate;<br>&#125;<br><br><span class=\"hljs-comment\">/* select layout with the highest channel count */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">select_channel_layout</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> AVCodec *codec)</span><br>&#123;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint64_t</span> *p;<br>    <span class=\"hljs-type\">uint64_t</span> best_ch_layout = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">int</span> best_nb_channels   = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-comment\">//channel_layouts: array of support channel layouts, or NULL if unknown. array is terminated by 0</span><br>    <span class=\"hljs-comment\">//channel_layouts 保存了支持的所有声道布局数组，为空，或者以 0 结尾</span><br>    <span class=\"hljs-keyword\">if</span> (!codec-&gt;channel_layouts)<br>        <span class=\"hljs-comment\">//为空，返回AV_CH_LAYOUT_STEREO</span><br>        <span class=\"hljs-keyword\">return</span> AV_CH_LAYOUT_STEREO;<br><br>    <span class=\"hljs-comment\">//找声道数最多的那个</span><br>    p = codec-&gt;channel_layouts;<br>    <span class=\"hljs-keyword\">while</span> (*p) &#123;<br>        <span class=\"hljs-type\">int</span> nb_channels = av_get_channel_layout_nb_channels(*p);<br><br>        <span class=\"hljs-keyword\">if</span> (nb_channels &gt; best_nb_channels) &#123;<br>            best_ch_layout    = *p;<br>            best_nb_channels = nb_channels;<br>        &#125;<br>        p++;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> best_ch_layout;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"encode\"><a href=\"#encode\" class=\"headerlink\" title=\"encode\"></a>encode</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">encode</span><span class=\"hljs-params\">(AVCodecContext *ctx, AVFrame *frame, AVPacket *pkt,</span><br><span class=\"hljs-params\">                   FILE *output)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> ret;<br><br>    <span class=\"hljs-comment\">/* 给编码器发送frame */</span><br>    ret = avcodec_send_frame(ctx, frame);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error sending the frame to the encoder\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* read all the available output packets (in general there may be any</span><br><span class=\"hljs-comment\">     * number of them */</span><br>    <span class=\"hljs-keyword\">while</span> (ret &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-comment\">//从编码器中读pkt，pkt里面保存了编码后的数据</span><br>        ret = avcodec_receive_packet(ctx, pkt);<br>        <span class=\"hljs-keyword\">if</span> (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)<br>            <span class=\"hljs-comment\">//EAGAIN编码器还需要更多的frame才能继续输出pkt</span><br>            <span class=\"hljs-comment\">//AVERROR_EOF编码器没有更多数据可以读取了，例如被冲洗了</span><br>            <span class=\"hljs-keyword\">return</span>;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error encoding audio frame\\n&quot;</span>);<br>            <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>        &#125;<br>        <span class=\"hljs-comment\">//写入文件</span><br>        fwrite(pkt-&gt;data, <span class=\"hljs-number\">1</span>, pkt-&gt;size, output);<br>        <span class=\"hljs-comment\">//取消引用pkt</span><br>        av_packet_unref(pkt);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"备注\"><a href=\"#备注\" class=\"headerlink\" title=\"备注\"></a>备注</h2><h3 id=\"ffmpeg-支持的音频编码器\"><a href=\"#ffmpeg-支持的音频编码器\" class=\"headerlink\" title=\"ffmpeg 支持的音频编码器\"></a>ffmpeg 支持的音频编码器</h3><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs less\"><span class=\"hljs-selector-tag\">ffmpeg</span> <span class=\"hljs-selector-tag\">-codecs</span> | <span class=\"hljs-selector-tag\">grep</span> <span class=\"hljs-selector-tag\">encoder</span> | <span class=\"hljs-selector-tag\">grep</span> <span class=\"hljs-selector-tag\">-i</span> <span class=\"hljs-selector-tag\">audio</span><br> <span class=\"hljs-selector-tag\">DEAIL</span>. <span class=\"hljs-selector-tag\">aac</span>                  <span class=\"hljs-selector-tag\">AAC</span> (Advanced Audio Coding) (<span class=\"hljs-attribute\">decoders</span>: aac aac_fixed aac_at ) (<span class=\"hljs-attribute\">encoders</span>: aac aac_at )<br> <span class=\"hljs-selector-tag\">DEAI</span><span class=\"hljs-selector-class\">.S</span> <span class=\"hljs-selector-tag\">alac</span>                 <span class=\"hljs-selector-tag\">ALAC</span> (Apple Lossless Audio Codec) (<span class=\"hljs-attribute\">decoders</span>: alac alac_at ) (<span class=\"hljs-attribute\">encoders</span>: alac alac_at )<br> <span class=\"hljs-selector-tag\">DEAIL</span>. <span class=\"hljs-selector-tag\">mp2</span>                  <span class=\"hljs-selector-tag\">MP2</span> (MPEG audio layer <span class=\"hljs-number\">2</span>) (<span class=\"hljs-attribute\">decoders</span>: mp2 mp2float mp2_at ) (<span class=\"hljs-attribute\">encoders</span>: mp2 mp2fixed )<br> <span class=\"hljs-selector-tag\">DEAIL</span>. <span class=\"hljs-selector-tag\">mp3</span>                  <span class=\"hljs-selector-tag\">MP3</span> (MPEG audio layer <span class=\"hljs-number\">3</span>) (<span class=\"hljs-attribute\">decoders</span>: mp3float mp3 mp3_at ) (<span class=\"hljs-attribute\">encoders</span>: libmp3lame )<br> <span class=\"hljs-selector-tag\">DEAIL</span>. <span class=\"hljs-selector-tag\">opus</span>                 <span class=\"hljs-selector-tag\">Opus</span> (Opus Interactive Audio Codec) (<span class=\"hljs-attribute\">decoders</span>: opus libopus ) (<span class=\"hljs-attribute\">encoders</span>: opus libopus )<br> <span class=\"hljs-selector-tag\">DEAIL</span>. <span class=\"hljs-selector-tag\">ra_144</span>               <span class=\"hljs-selector-tag\">RealAudio</span> <span class=\"hljs-number\">1.0</span> (<span class=\"hljs-number\">14.4</span>K) (<span class=\"hljs-attribute\">decoders</span>: real_144 ) (<span class=\"hljs-attribute\">encoders</span>: real_144 )<br></code></pre></td></tr></table></figure>\n\n<p>示例中选择的是AV_CODEC_ID_MP2</p>\n<p>通过avcodec_find_encoder(AV_CODEC_ID_MP2)来找到对应的编码器</p>\n<p>你也可以尝试mp3，aac ，opus 之类的。</p>\n<h3 id=\"采样格式，分平面型和非平面型\"><a href=\"#采样格式，分平面型和非平面型\" class=\"headerlink\" title=\"采样格式，分平面型和非平面型\"></a>采样格式，分平面型和非平面型</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-built_in\">AVSampleFormat</span> &#123;<br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_NONE</span> = <span class=\"hljs-number\">-1</span>,<br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_U8</span>,          <span class=\"hljs-comment\">///&lt; unsigned 8 bits</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_S16</span>,         <span class=\"hljs-comment\">///&lt; signed 16 bits</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_S32</span>,         <span class=\"hljs-comment\">///&lt; signed 32 bits</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_FLT</span>,         <span class=\"hljs-comment\">///&lt; float</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_DBL</span>,         <span class=\"hljs-comment\">///&lt; double</span><br><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_U8P</span>,         <span class=\"hljs-comment\">///&lt; unsigned 8 bits, planar</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_S16P</span>,        <span class=\"hljs-comment\">///&lt; signed 16 bits, planar</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_S32P</span>,        <span class=\"hljs-comment\">///&lt; signed 32 bits, planar</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_FLTP</span>,        <span class=\"hljs-comment\">///&lt; float, planar</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_DBLP</span>,        <span class=\"hljs-comment\">///&lt; double, planar</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_S64</span>,         <span class=\"hljs-comment\">///&lt; signed 64 bits</span><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_S64P</span>,        <span class=\"hljs-comment\">///&lt; signed 64 bits, planar</span><br><br>    <span class=\"hljs-built_in\">AV_SAMPLE_FMT_NB</span>           <span class=\"hljs-comment\">///&lt; Number of sample formats. DO NOT USE if linking dynamically</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>后缀带P的就是平面型的，不带P的就是交错型的。</p>\n<p>参考<a href=\"https://blog.csdn.net/lyy901135/article/details/103061967\">音频格式解析：交错模式 vs Plane模式_lyy901135的博客-CSDN博客_plane模式</a></p>\n<h3 id=\"时间戳\"><a href=\"#时间戳\" class=\"headerlink\" title=\"时间戳\"></a>时间戳</h3><p>在h264视频编码的时候，有打时间戳，音频编码没有看到打时间戳的环节，之后再探究。</p>\n"},{"layout":"post","title":"ffmpeg example 4.视频文件封装和编码","date":"2022-03-12T16:00:00.000Z","_content":"\n今天学习 `ffmpeg/doc/examples/muxing.c`\n\n该程序接受一个参数，指定输出的文件的路径，例如`/tmp/mux.mp4`,`/tmp/mux.mov`。 文件名的后缀会用来推测生成的AVFormatContext的格式，如果没有指定，就使用`mpeg`。使用fmt 默认的视频编码器和音频编码器，编码10秒钟的音视频数据，交替写入文件。\n\n操作封装需要操作`AVFormatContext`\n\n## 创建AVFormatContext\n\n```c\n    //创建AVFormatContext， 根据文件后缀来推测output format\n    avformat_alloc_output_context2(&oc, NULL, NULL, filename);\n    if (!oc) {\n        printf(\"Could not deduce output format from file extension: using MPEG.\\n\");\n        //无法推测output format， 使用mpeg\n        avformat_alloc_output_context2(&oc, NULL, \"mpeg\", filename);\n    }\n```\n\n## 给AVFormatContext添加 video / audio stream\n\n```c\n    if (fmt->video_codec != AV_CODEC_ID_NONE) {\n        add_stream(&video_st, oc, &video_codec, fmt->video_codec);\n        have_video = 1;\n        encode_video = 1;\n    }\n    if (fmt->audio_codec != AV_CODEC_ID_NONE) {\n        add_stream(&audio_st, oc, &audio_codec, fmt->audio_codec);\n        have_audio = 1;\n        encode_audio = 1;\n    }\n```\n\n我们看看add_stream做了什么\n\n```c\n/* Add an output stream. */\nstatic void add_stream(OutputStream *ost, AVFormatContext *oc,\n                       const AVCodec **codec,\n                       enum AVCodecID codec_id)\n{\n    AVCodecContext *c;\n    int i;\n    /* find the encoder */\n    //找到codec_id对应的编码器AVCodec\n    *codec = avcodec_find_encoder(codec_id);\n    //创建pkt\n    ost->tmp_pkt = av_packet_alloc();\n    //创建AVStream\n    ost->st = avformat_new_stream(oc, NULL);\n    //设置stream的index\n    ost->st->id = oc->nb_streams-1;\n    //创建编码器上下文\n    c = avcodec_alloc_context3(*codec);\n    //保存编码器上下文\n    ost->enc = c;\n\n    switch ((*codec)->type) {\n    case AVMEDIA_TYPE_AUDIO:\n         //设置音频编码器上下文参数(码率，采样率，位深，声道布局等)\n              ...\n        //设置stream的时间基\n        ost->st->time_base = (AVRational){ 1, c->sample_rate };\n        break;\n\n    case AVMEDIA_TYPE_VIDEO:\n        //设置编码器上下文的参数\n        c->codec_id = codec_id;\n        //设置stream的时间基\n        ost->st->time_base = (AVRational){ 1, STREAM_FRAME_RATE };\n        c->time_base       = ost->st->time_base;\n        //编码器码率，帧率，gop，分辨率, 设置\n        ...\n        break;\n\n    default:\n        break;\n    }\n    /* Some formats want stream headers to be separate. */\n    //处理一下stream header\n    if (oc->oformat->flags & AVFMT_GLOBALHEADER)\n        c->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;\n}\n```\n\n1. 根据codec_id找到AVCodec\n\n2. 调用avformat_new_stream创建stream\n\n3. 设置stream的index\n\n4. 根据AVCodec创建编码器的上下文，配置编码器参数\n\n5. 设置stream的time_base\n\n6. 处理一下 stream headers 的标志位\n\n## 音视频流创建好了，下一步为写入准备\n\n1. 上面创建好了stream, 创建了编码器上下文。open_video/open_audio继续为写入做准备\n\n2. 准备完成就打开文件准备写入\n\n```c\n    /* Now that all the parameters are set, we can open the audio and\n     * video codecs and allocate the necessary encode buffers. */\n    if (have_video)\n        open_video(oc, video_codec, &video_st, opt);\n\n    if (have_audio)\n        open_audio(oc, audio_codec, &audio_st, opt);\n\n    //打印oc的信息\n    av_dump_format(oc, 0, filename, 1);\n\n    /* open the output file, if needed */\n    if (!(fmt->flags & AVFMT_NOFILE)) {\n        //打开文件\n        ret = avio_open(&oc->pb, filename, AVIO_FLAG_WRITE);\n        if (ret < 0) {\n            fprintf(stderr, \"Could not open '%s': %s\\n\", filename,\n                    av_err2str(ret));\n            return 1;\n        }\n    }\n```\n\n看看open_video 做了什么\n\n```c\nstatic void open_video(AVFormatContext *oc, const AVCodec *codec,\n                       OutputStream *ost, AVDictionary *opt_arg)\n{\n    int ret;\n    AVCodecContext *c = ost->enc;\n    AVDictionary *opt = NULL;\n    //将opt_arg中的内容拷贝到opt中\n    av_dict_copy(&opt, opt_arg, 0);\n    /* open the codec */\n    //打开编码器\n    ret = avcodec_open2(c, codec, &opt);\n    //释放opt\n    av_dict_free(&opt);\n    if (ret < 0) {\n        fprintf(stderr, \"Could not open video codec: %s\\n\", av_err2str(ret));\n        exit(1);\n    }\n\n    /* allocate and init a re-usable frame */\n    //根据格式，宽高，创建一个复用的AVFrame\n    ost->frame = alloc_picture(c->pix_fmt, c->width, c->height);\n    if (!ost->frame) {\n        fprintf(stderr, \"Could not allocate video frame\\n\");\n        exit(1);\n    }\n\n    /* If the output format is not YUV420P, then a temporary YUV420P\n     * picture is needed too. It is then converted to the required\n     * output format. */\n    ost->tmp_frame = NULL;\n    if (c->pix_fmt != AV_PIX_FMT_YUV420P) {\n        //如果编码器对应的pix_fmt不是yuv420p， 创建一个yuv420p格式的AVFrame，保存在ost->tmp_frame中\n        ost->tmp_frame = alloc_picture(AV_PIX_FMT_YUV420P, c->width, c->height);\n        if (!ost->tmp_frame) {\n            fprintf(stderr, \"Could not allocate temporary picture\\n\");\n            exit(1);\n        }\n    }\n\n    /* copy the stream parameters to the muxer */\n    //将编码器的参数拷贝到stream对应的编码参数中\n    ret = avcodec_parameters_from_context(ost->st->codecpar, c);\n    if (ret < 0) {\n        fprintf(stderr, \"Could not copy the stream parameters\\n\");\n        exit(1);\n    }\n}\n```\n\n1. 打开编码器\n\n2. 申请资源，创建一个AVFrame用于存储编码前数据\n\n3. 调用avcodec_parameters_from_context将编码器的编码参数拷贝到stream的codecpar中\n\n## 写音视频数据到文件\n\n写文件头\n\n```c\n    /* Write the stream header, if any. */\n    //将流信息写文件头\n    ret = avformat_write_header(oc, &opt);\n    if (ret < 0) {\n        fprintf(stderr, \"Error occurred when opening output file: %s\\n\",\n                av_err2str(ret));\n        return 1;\n    }\n```\n\n交替写音视频帧\n\n```c\n    while (encode_video || encode_audio) {\n        /* select the stream to encode */\n        /*\n         交替写入编码后的音频和视频帧\n         视频写入结束或者video_st.next_pts <= audio_st.next_pts, 写视频\n         否则写音频\n        */\n        if (encode_video &&\n            (!encode_audio || av_compare_ts(video_st.next_pts, video_st.enc->time_base,\n                                            audio_st.next_pts, audio_st.enc->time_base) <= 0)) {\n            //写入编码后的视频帧\n            encode_video = !write_video_frame(oc, &video_st);\n        } else {\n            //写入编码后的音频帧\n            encode_audio = !write_audio_frame(oc, &audio_st);\n        }\n    }\n```\n\n 写trailer\n\n```c\n    /* Write the trailer, if any. The trailer must be written before you\n     * close the CodecContexts open when you wrote the header; otherwise\n     * av_write_trailer() may try to use memory that was freed on\n     * av_codec_close(). */\n    av_write_trailer(oc);\n```\n\n关闭编码器，关闭文件，释放资源\n\n```c\n    /* Close each codec. */\n    if (have_video)\n        close_stream(oc, &video_st);\n    if (have_audio)\n        close_stream(oc, &audio_st);\n\n    if (!(fmt->flags & AVFMT_NOFILE))\n        /* Close the output file. */\n        avio_closep(&oc->pb);\n\n    /* free the stream */\n    avformat_free_context(oc);\n```\n\n### write_video_frame\n\n```\nstatic int write_video_frame(AVFormatContext *oc, OutputStream *ost)\n{\n    return write_frame(oc, ost->enc, ost->st, get_video_frame(ost), ost->tmp_pkt);\n}\n```\n\n只是简单调用了write_frame\n\n```c\nstatic int write_frame(AVFormatContext *fmt_ctx, AVCodecContext *c,\n                       AVStream *st, AVFrame *frame, AVPacket *pkt)\n{\n    int ret;\n\n    // send the frame to the encoder\n    //将frame送给编码器去编码\n    ret = avcodec_send_frame(c, frame);\n    if (ret < 0) {\n        fprintf(stderr, \"Error sending a frame to the encoder: %s\\n\",\n                av_err2str(ret));\n        exit(1);\n    }\n\n    while (ret >= 0) {\n        //从编码器中读出编码后的pkt\n        ret = avcodec_receive_packet(c, pkt);\n        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)\n            break;\n        else if (ret < 0) {\n            fprintf(stderr, \"Error encoding a frame: %s\\n\", av_err2str(ret));\n            exit(1);\n        }\n\n        /* rescale output packet timestamp values from codec to stream timebase */\n        //调整pkt的pts，pkt的时间基参编码器的时间基，将其转换为参考stream的时间基\n        av_packet_rescale_ts(pkt, c->time_base, st->time_base);\n        //设置pkt的stream_index和stream对应的一致，音视频分别对应于不同的stream_index\n        pkt->stream_index = st->index;\n\n        /* Write the compressed frame to the media file. */\n        log_packet(fmt_ctx, pkt);\n        //将pkt写入视频文件\n        ret = av_interleaved_write_frame(fmt_ctx, pkt);\n        /* pkt is now blank (av_interleaved_write_frame() takes ownership of\n         * its contents and resets pkt), so that no unreferencing is necessary.\n         * This would be different if one used av_write_frame(). */\n        if (ret < 0) {\n            fprintf(stderr, \"Error while writing output packet: %s\\n\", av_err2str(ret));\n            exit(1);\n        }\n    }\n\n    return ret == AVERROR_EOF ? 1 : 0;\n}\n```\n\n1. 将AVFrame送给编码器去编码\n\n2. 读取pkt\n\n3. 调用av_packet_rescale_ts，调整pkt的时间戳，写入文件pkt的pts要以stream的time_base为基准\n\n4. 设置pkt的index\n\n5. 调用av_interleaved_write_frame将pkt写入文件\n\n6. 返回写入结果。当AVFrame为空时，会冲洗编码器，ret = AVERROR_EOF， 返回1， 结束写入\n\nframe的每一帧数据，是来自于get_video_frame方法, 填充的假数据\n\n```c\nstatic AVFrame *get_video_frame(OutputStream *ost)\n{\n    AVCodecContext *c = ost->enc;\n\n    /* check if we want to generate more frames */\n    if (av_compare_ts(ost->next_pts, c->time_base,\n                      STREAM_DURATION, (AVRational){ 1, 1 }) > 0)\n        return NULL;\n\n    /* when we pass a frame to the encoder, it may keep a reference to it\n     * internally; make sure we do not overwrite it here */\n    if (av_frame_make_writable(ost->frame) < 0)\n        exit(1);\n\n    if (c->pix_fmt != AV_PIX_FMT_YUV420P) {\n        /* as we only generate a YUV420P picture, we must convert it\n         * to the codec pixel format if needed */\n        if (!ost->sws_ctx) {\n            ost->sws_ctx = sws_getContext(c->width, c->height,\n                                          AV_PIX_FMT_YUV420P,\n                                          c->width, c->height,\n                                          c->pix_fmt,\n                                          SCALE_FLAGS, NULL, NULL, NULL);\n            if (!ost->sws_ctx) {\n                fprintf(stderr,\n                        \"Could not initialize the conversion context\\n\");\n                exit(1);\n            }\n        }\n        fill_yuv_image(ost->tmp_frame, ost->next_pts, c->width, c->height);\n        sws_scale(ost->sws_ctx, (const uint8_t * const *) ost->tmp_frame->data,\n                  ost->tmp_frame->linesize, 0, c->height, ost->frame->data,\n                  ost->frame->linesize);\n    } else {\n        fill_yuv_image(ost->frame, ost->next_pts, c->width, c->height);\n    }\n\n    ost->frame->pts = ost->next_pts++;\n\n    return ost->frame;\n}\n```\n\n1. 调用av_compare_ts 判断是否继续生成新的frame，一开始规定了只写10秒钟的数据，超过了就不写了\n\n2. av_frame_make_writable使当前的frame可写，被编码器引用的frame不可写，调用该方法如果被引用，内部会创建新buf，变成可写的\n\n3. 填充数据yuv，还做了缩放处理，暂不讨论\n\n4. 更新frame的pts\n\n5. 返回生成的frame\n\nwrite_audio_frame\n\n```c\n/*\n * encode one audio frame and send it to the muxer\n * return 1 when encoding is finished, 0 otherwise\n */\nstatic int write_audio_frame(AVFormatContext *oc, OutputStream *ost)\n{\n    AVCodecContext *c;\n    AVFrame *frame;\n    int ret;\n    int dst_nb_samples;\n\n    c = ost->enc;\n\n    //获取音频帧\n    frame = get_audio_frame(ost);   \n\n    if (frame) {\n        /* convert samples from native format to destination codec format, using the resampler */\n        /* compute destination number of samples */\n\n        /*\n        计算根据重采样后应该生成的采样个数\n        */\n        dst_nb_samples = av_rescale_rnd(swr_get_delay(ost->swr_ctx, c->sample_rate) + frame->nb_samples,\n                                        c->sample_rate, c->sample_rate, AV_ROUND_UP);\n        //由于没有修改采样率，只是修改了位深，采样个数保持不变\n        av_assert0(dst_nb_samples == frame->nb_samples);\n\n        /* when we pass a frame to the encoder, it may keep a reference to it\n         * internally;\n         * make sure we do not overwrite it here\n         */\n        //使ost->frame可写\n        ret = av_frame_make_writable(ost->frame);\n        if (ret < 0)\n            exit(1);\n\n        /* convert to destination format */\n        //重采样\n        ret = swr_convert(ost->swr_ctx,\n                          ost->frame->data, dst_nb_samples,\n                          (const uint8_t **)frame->data, frame->nb_samples);\n        if (ret < 0) {\n            fprintf(stderr, \"Error while converting\\n\");\n            exit(1);\n        }\n\n        frame = ost->frame;\n        //重新计算音频pts\n        frame->pts = av_rescale_q(ost->samples_count, (AVRational){1, c->sample_rate}, c->time_base);\n        //计算samples_count\n        ost->samples_count += dst_nb_samples;\n    }\n    //将音频帧写入文件\n    return write_frame(oc, c, ost->st, frame, ost->tmp_pkt);\n}\n```\n\n1. 准备AVFrame，调用get_audio_frame获取一个AVFrame，内部根据编码格式，填充pcm假数据\n\n2. 调用av_rescale_rnd计算重采样个数，如果数据源和送入编码器的音频的采样率不同，需要转换采样率，示例程序只是变了采样格式，没有更改采样率，采样个数不变\n\n3. 做重采样，重采样数据保存在ost->frame中\n\n4. 重采样后，需要更新frame的pts\n\n5. 调用write_frame编码，将数据写入文件\n\n## 总结：\n\n学习了通过应用libavformat将音视频数据编码封装到文件中\n\n1. 创建AVFormatContext\n\n2. 添加stream\n\n3. 配置编解码器，stream 参数\n\n4. 编码frame，生成pkt，更新pts\n\n5. 交替写音视频pkt\n\n6. 关闭编解码器，结束写文件\n\n# \n","source":"_posts/ffmpeg/2022-03-13-ffmpeg example 学习 4.md","raw":"---\nlayout: post\ntitle: \"ffmpeg example 4.视频文件封装和编码\"\ndate: 2022-03-13 \ntag: ffmpeg\n---\n\n今天学习 `ffmpeg/doc/examples/muxing.c`\n\n该程序接受一个参数，指定输出的文件的路径，例如`/tmp/mux.mp4`,`/tmp/mux.mov`。 文件名的后缀会用来推测生成的AVFormatContext的格式，如果没有指定，就使用`mpeg`。使用fmt 默认的视频编码器和音频编码器，编码10秒钟的音视频数据，交替写入文件。\n\n操作封装需要操作`AVFormatContext`\n\n## 创建AVFormatContext\n\n```c\n    //创建AVFormatContext， 根据文件后缀来推测output format\n    avformat_alloc_output_context2(&oc, NULL, NULL, filename);\n    if (!oc) {\n        printf(\"Could not deduce output format from file extension: using MPEG.\\n\");\n        //无法推测output format， 使用mpeg\n        avformat_alloc_output_context2(&oc, NULL, \"mpeg\", filename);\n    }\n```\n\n## 给AVFormatContext添加 video / audio stream\n\n```c\n    if (fmt->video_codec != AV_CODEC_ID_NONE) {\n        add_stream(&video_st, oc, &video_codec, fmt->video_codec);\n        have_video = 1;\n        encode_video = 1;\n    }\n    if (fmt->audio_codec != AV_CODEC_ID_NONE) {\n        add_stream(&audio_st, oc, &audio_codec, fmt->audio_codec);\n        have_audio = 1;\n        encode_audio = 1;\n    }\n```\n\n我们看看add_stream做了什么\n\n```c\n/* Add an output stream. */\nstatic void add_stream(OutputStream *ost, AVFormatContext *oc,\n                       const AVCodec **codec,\n                       enum AVCodecID codec_id)\n{\n    AVCodecContext *c;\n    int i;\n    /* find the encoder */\n    //找到codec_id对应的编码器AVCodec\n    *codec = avcodec_find_encoder(codec_id);\n    //创建pkt\n    ost->tmp_pkt = av_packet_alloc();\n    //创建AVStream\n    ost->st = avformat_new_stream(oc, NULL);\n    //设置stream的index\n    ost->st->id = oc->nb_streams-1;\n    //创建编码器上下文\n    c = avcodec_alloc_context3(*codec);\n    //保存编码器上下文\n    ost->enc = c;\n\n    switch ((*codec)->type) {\n    case AVMEDIA_TYPE_AUDIO:\n         //设置音频编码器上下文参数(码率，采样率，位深，声道布局等)\n              ...\n        //设置stream的时间基\n        ost->st->time_base = (AVRational){ 1, c->sample_rate };\n        break;\n\n    case AVMEDIA_TYPE_VIDEO:\n        //设置编码器上下文的参数\n        c->codec_id = codec_id;\n        //设置stream的时间基\n        ost->st->time_base = (AVRational){ 1, STREAM_FRAME_RATE };\n        c->time_base       = ost->st->time_base;\n        //编码器码率，帧率，gop，分辨率, 设置\n        ...\n        break;\n\n    default:\n        break;\n    }\n    /* Some formats want stream headers to be separate. */\n    //处理一下stream header\n    if (oc->oformat->flags & AVFMT_GLOBALHEADER)\n        c->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;\n}\n```\n\n1. 根据codec_id找到AVCodec\n\n2. 调用avformat_new_stream创建stream\n\n3. 设置stream的index\n\n4. 根据AVCodec创建编码器的上下文，配置编码器参数\n\n5. 设置stream的time_base\n\n6. 处理一下 stream headers 的标志位\n\n## 音视频流创建好了，下一步为写入准备\n\n1. 上面创建好了stream, 创建了编码器上下文。open_video/open_audio继续为写入做准备\n\n2. 准备完成就打开文件准备写入\n\n```c\n    /* Now that all the parameters are set, we can open the audio and\n     * video codecs and allocate the necessary encode buffers. */\n    if (have_video)\n        open_video(oc, video_codec, &video_st, opt);\n\n    if (have_audio)\n        open_audio(oc, audio_codec, &audio_st, opt);\n\n    //打印oc的信息\n    av_dump_format(oc, 0, filename, 1);\n\n    /* open the output file, if needed */\n    if (!(fmt->flags & AVFMT_NOFILE)) {\n        //打开文件\n        ret = avio_open(&oc->pb, filename, AVIO_FLAG_WRITE);\n        if (ret < 0) {\n            fprintf(stderr, \"Could not open '%s': %s\\n\", filename,\n                    av_err2str(ret));\n            return 1;\n        }\n    }\n```\n\n看看open_video 做了什么\n\n```c\nstatic void open_video(AVFormatContext *oc, const AVCodec *codec,\n                       OutputStream *ost, AVDictionary *opt_arg)\n{\n    int ret;\n    AVCodecContext *c = ost->enc;\n    AVDictionary *opt = NULL;\n    //将opt_arg中的内容拷贝到opt中\n    av_dict_copy(&opt, opt_arg, 0);\n    /* open the codec */\n    //打开编码器\n    ret = avcodec_open2(c, codec, &opt);\n    //释放opt\n    av_dict_free(&opt);\n    if (ret < 0) {\n        fprintf(stderr, \"Could not open video codec: %s\\n\", av_err2str(ret));\n        exit(1);\n    }\n\n    /* allocate and init a re-usable frame */\n    //根据格式，宽高，创建一个复用的AVFrame\n    ost->frame = alloc_picture(c->pix_fmt, c->width, c->height);\n    if (!ost->frame) {\n        fprintf(stderr, \"Could not allocate video frame\\n\");\n        exit(1);\n    }\n\n    /* If the output format is not YUV420P, then a temporary YUV420P\n     * picture is needed too. It is then converted to the required\n     * output format. */\n    ost->tmp_frame = NULL;\n    if (c->pix_fmt != AV_PIX_FMT_YUV420P) {\n        //如果编码器对应的pix_fmt不是yuv420p， 创建一个yuv420p格式的AVFrame，保存在ost->tmp_frame中\n        ost->tmp_frame = alloc_picture(AV_PIX_FMT_YUV420P, c->width, c->height);\n        if (!ost->tmp_frame) {\n            fprintf(stderr, \"Could not allocate temporary picture\\n\");\n            exit(1);\n        }\n    }\n\n    /* copy the stream parameters to the muxer */\n    //将编码器的参数拷贝到stream对应的编码参数中\n    ret = avcodec_parameters_from_context(ost->st->codecpar, c);\n    if (ret < 0) {\n        fprintf(stderr, \"Could not copy the stream parameters\\n\");\n        exit(1);\n    }\n}\n```\n\n1. 打开编码器\n\n2. 申请资源，创建一个AVFrame用于存储编码前数据\n\n3. 调用avcodec_parameters_from_context将编码器的编码参数拷贝到stream的codecpar中\n\n## 写音视频数据到文件\n\n写文件头\n\n```c\n    /* Write the stream header, if any. */\n    //将流信息写文件头\n    ret = avformat_write_header(oc, &opt);\n    if (ret < 0) {\n        fprintf(stderr, \"Error occurred when opening output file: %s\\n\",\n                av_err2str(ret));\n        return 1;\n    }\n```\n\n交替写音视频帧\n\n```c\n    while (encode_video || encode_audio) {\n        /* select the stream to encode */\n        /*\n         交替写入编码后的音频和视频帧\n         视频写入结束或者video_st.next_pts <= audio_st.next_pts, 写视频\n         否则写音频\n        */\n        if (encode_video &&\n            (!encode_audio || av_compare_ts(video_st.next_pts, video_st.enc->time_base,\n                                            audio_st.next_pts, audio_st.enc->time_base) <= 0)) {\n            //写入编码后的视频帧\n            encode_video = !write_video_frame(oc, &video_st);\n        } else {\n            //写入编码后的音频帧\n            encode_audio = !write_audio_frame(oc, &audio_st);\n        }\n    }\n```\n\n 写trailer\n\n```c\n    /* Write the trailer, if any. The trailer must be written before you\n     * close the CodecContexts open when you wrote the header; otherwise\n     * av_write_trailer() may try to use memory that was freed on\n     * av_codec_close(). */\n    av_write_trailer(oc);\n```\n\n关闭编码器，关闭文件，释放资源\n\n```c\n    /* Close each codec. */\n    if (have_video)\n        close_stream(oc, &video_st);\n    if (have_audio)\n        close_stream(oc, &audio_st);\n\n    if (!(fmt->flags & AVFMT_NOFILE))\n        /* Close the output file. */\n        avio_closep(&oc->pb);\n\n    /* free the stream */\n    avformat_free_context(oc);\n```\n\n### write_video_frame\n\n```\nstatic int write_video_frame(AVFormatContext *oc, OutputStream *ost)\n{\n    return write_frame(oc, ost->enc, ost->st, get_video_frame(ost), ost->tmp_pkt);\n}\n```\n\n只是简单调用了write_frame\n\n```c\nstatic int write_frame(AVFormatContext *fmt_ctx, AVCodecContext *c,\n                       AVStream *st, AVFrame *frame, AVPacket *pkt)\n{\n    int ret;\n\n    // send the frame to the encoder\n    //将frame送给编码器去编码\n    ret = avcodec_send_frame(c, frame);\n    if (ret < 0) {\n        fprintf(stderr, \"Error sending a frame to the encoder: %s\\n\",\n                av_err2str(ret));\n        exit(1);\n    }\n\n    while (ret >= 0) {\n        //从编码器中读出编码后的pkt\n        ret = avcodec_receive_packet(c, pkt);\n        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)\n            break;\n        else if (ret < 0) {\n            fprintf(stderr, \"Error encoding a frame: %s\\n\", av_err2str(ret));\n            exit(1);\n        }\n\n        /* rescale output packet timestamp values from codec to stream timebase */\n        //调整pkt的pts，pkt的时间基参编码器的时间基，将其转换为参考stream的时间基\n        av_packet_rescale_ts(pkt, c->time_base, st->time_base);\n        //设置pkt的stream_index和stream对应的一致，音视频分别对应于不同的stream_index\n        pkt->stream_index = st->index;\n\n        /* Write the compressed frame to the media file. */\n        log_packet(fmt_ctx, pkt);\n        //将pkt写入视频文件\n        ret = av_interleaved_write_frame(fmt_ctx, pkt);\n        /* pkt is now blank (av_interleaved_write_frame() takes ownership of\n         * its contents and resets pkt), so that no unreferencing is necessary.\n         * This would be different if one used av_write_frame(). */\n        if (ret < 0) {\n            fprintf(stderr, \"Error while writing output packet: %s\\n\", av_err2str(ret));\n            exit(1);\n        }\n    }\n\n    return ret == AVERROR_EOF ? 1 : 0;\n}\n```\n\n1. 将AVFrame送给编码器去编码\n\n2. 读取pkt\n\n3. 调用av_packet_rescale_ts，调整pkt的时间戳，写入文件pkt的pts要以stream的time_base为基准\n\n4. 设置pkt的index\n\n5. 调用av_interleaved_write_frame将pkt写入文件\n\n6. 返回写入结果。当AVFrame为空时，会冲洗编码器，ret = AVERROR_EOF， 返回1， 结束写入\n\nframe的每一帧数据，是来自于get_video_frame方法, 填充的假数据\n\n```c\nstatic AVFrame *get_video_frame(OutputStream *ost)\n{\n    AVCodecContext *c = ost->enc;\n\n    /* check if we want to generate more frames */\n    if (av_compare_ts(ost->next_pts, c->time_base,\n                      STREAM_DURATION, (AVRational){ 1, 1 }) > 0)\n        return NULL;\n\n    /* when we pass a frame to the encoder, it may keep a reference to it\n     * internally; make sure we do not overwrite it here */\n    if (av_frame_make_writable(ost->frame) < 0)\n        exit(1);\n\n    if (c->pix_fmt != AV_PIX_FMT_YUV420P) {\n        /* as we only generate a YUV420P picture, we must convert it\n         * to the codec pixel format if needed */\n        if (!ost->sws_ctx) {\n            ost->sws_ctx = sws_getContext(c->width, c->height,\n                                          AV_PIX_FMT_YUV420P,\n                                          c->width, c->height,\n                                          c->pix_fmt,\n                                          SCALE_FLAGS, NULL, NULL, NULL);\n            if (!ost->sws_ctx) {\n                fprintf(stderr,\n                        \"Could not initialize the conversion context\\n\");\n                exit(1);\n            }\n        }\n        fill_yuv_image(ost->tmp_frame, ost->next_pts, c->width, c->height);\n        sws_scale(ost->sws_ctx, (const uint8_t * const *) ost->tmp_frame->data,\n                  ost->tmp_frame->linesize, 0, c->height, ost->frame->data,\n                  ost->frame->linesize);\n    } else {\n        fill_yuv_image(ost->frame, ost->next_pts, c->width, c->height);\n    }\n\n    ost->frame->pts = ost->next_pts++;\n\n    return ost->frame;\n}\n```\n\n1. 调用av_compare_ts 判断是否继续生成新的frame，一开始规定了只写10秒钟的数据，超过了就不写了\n\n2. av_frame_make_writable使当前的frame可写，被编码器引用的frame不可写，调用该方法如果被引用，内部会创建新buf，变成可写的\n\n3. 填充数据yuv，还做了缩放处理，暂不讨论\n\n4. 更新frame的pts\n\n5. 返回生成的frame\n\nwrite_audio_frame\n\n```c\n/*\n * encode one audio frame and send it to the muxer\n * return 1 when encoding is finished, 0 otherwise\n */\nstatic int write_audio_frame(AVFormatContext *oc, OutputStream *ost)\n{\n    AVCodecContext *c;\n    AVFrame *frame;\n    int ret;\n    int dst_nb_samples;\n\n    c = ost->enc;\n\n    //获取音频帧\n    frame = get_audio_frame(ost);   \n\n    if (frame) {\n        /* convert samples from native format to destination codec format, using the resampler */\n        /* compute destination number of samples */\n\n        /*\n        计算根据重采样后应该生成的采样个数\n        */\n        dst_nb_samples = av_rescale_rnd(swr_get_delay(ost->swr_ctx, c->sample_rate) + frame->nb_samples,\n                                        c->sample_rate, c->sample_rate, AV_ROUND_UP);\n        //由于没有修改采样率，只是修改了位深，采样个数保持不变\n        av_assert0(dst_nb_samples == frame->nb_samples);\n\n        /* when we pass a frame to the encoder, it may keep a reference to it\n         * internally;\n         * make sure we do not overwrite it here\n         */\n        //使ost->frame可写\n        ret = av_frame_make_writable(ost->frame);\n        if (ret < 0)\n            exit(1);\n\n        /* convert to destination format */\n        //重采样\n        ret = swr_convert(ost->swr_ctx,\n                          ost->frame->data, dst_nb_samples,\n                          (const uint8_t **)frame->data, frame->nb_samples);\n        if (ret < 0) {\n            fprintf(stderr, \"Error while converting\\n\");\n            exit(1);\n        }\n\n        frame = ost->frame;\n        //重新计算音频pts\n        frame->pts = av_rescale_q(ost->samples_count, (AVRational){1, c->sample_rate}, c->time_base);\n        //计算samples_count\n        ost->samples_count += dst_nb_samples;\n    }\n    //将音频帧写入文件\n    return write_frame(oc, c, ost->st, frame, ost->tmp_pkt);\n}\n```\n\n1. 准备AVFrame，调用get_audio_frame获取一个AVFrame，内部根据编码格式，填充pcm假数据\n\n2. 调用av_rescale_rnd计算重采样个数，如果数据源和送入编码器的音频的采样率不同，需要转换采样率，示例程序只是变了采样格式，没有更改采样率，采样个数不变\n\n3. 做重采样，重采样数据保存在ost->frame中\n\n4. 重采样后，需要更新frame的pts\n\n5. 调用write_frame编码，将数据写入文件\n\n## 总结：\n\n学习了通过应用libavformat将音视频数据编码封装到文件中\n\n1. 创建AVFormatContext\n\n2. 添加stream\n\n3. 配置编解码器，stream 参数\n\n4. 编码frame，生成pkt，更新pts\n\n5. 交替写音视频pkt\n\n6. 关闭编解码器，结束写文件\n\n# \n","slug":"ffmpeg/2022-03-13-ffmpeg example 学习 4","published":1,"updated":"2024-03-06T11:53:13.565Z","comments":1,"photos":[],"_id":"cltgopenc001rqywh1e20euw5","content":"<p>今天学习 <code>ffmpeg/doc/examples/muxing.c</code></p>\n<p>该程序接受一个参数，指定输出的文件的路径，例如<code>/tmp/mux.mp4</code>,<code>/tmp/mux.mov</code>。 文件名的后缀会用来推测生成的AVFormatContext的格式，如果没有指定，就使用<code>mpeg</code>。使用fmt 默认的视频编码器和音频编码器，编码10秒钟的音视频数据，交替写入文件。</p>\n<p>操作封装需要操作<code>AVFormatContext</code></p>\n<h2 id=\"创建AVFormatContext\"><a href=\"#创建AVFormatContext\" class=\"headerlink\" title=\"创建AVFormatContext\"></a>创建AVFormatContext</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//创建AVFormatContext， 根据文件后缀来推测output format</span><br>avformat_alloc_output_context2(&amp;oc, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-literal\">NULL</span>, filename);<br><span class=\"hljs-keyword\">if</span> (!oc) &#123;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Could not deduce output format from file extension: using MPEG.\\n&quot;</span>);<br>    <span class=\"hljs-comment\">//无法推测output format， 使用mpeg</span><br>    avformat_alloc_output_context2(&amp;oc, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-string\">&quot;mpeg&quot;</span>, filename);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"给AVFormatContext添加-video-audio-stream\"><a href=\"#给AVFormatContext添加-video-audio-stream\" class=\"headerlink\" title=\"给AVFormatContext添加 video &#x2F; audio stream\"></a>给AVFormatContext添加 video &#x2F; audio stream</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">if</span> (fmt-&gt;video_codec != AV_CODEC_ID_NONE) &#123;<br>    add_stream(&amp;video_st, oc, &amp;video_codec, fmt-&gt;video_codec);<br>    have_video = <span class=\"hljs-number\">1</span>;<br>    encode_video = <span class=\"hljs-number\">1</span>;<br>&#125;<br><span class=\"hljs-keyword\">if</span> (fmt-&gt;audio_codec != AV_CODEC_ID_NONE) &#123;<br>    add_stream(&amp;audio_st, oc, &amp;audio_codec, fmt-&gt;audio_codec);<br>    have_audio = <span class=\"hljs-number\">1</span>;<br>    encode_audio = <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们看看add_stream做了什么</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* Add an output stream. */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">add_stream</span><span class=\"hljs-params\">(OutputStream *ost, AVFormatContext *oc,</span><br><span class=\"hljs-params\">                       <span class=\"hljs-type\">const</span> AVCodec **codec,</span><br><span class=\"hljs-params\">                       <span class=\"hljs-keyword\">enum</span> AVCodecID codec_id)</span><br>&#123;<br>    AVCodecContext *c;<br>    <span class=\"hljs-type\">int</span> i;<br>    <span class=\"hljs-comment\">/* find the encoder */</span><br>    <span class=\"hljs-comment\">//找到codec_id对应的编码器AVCodec</span><br>    *codec = avcodec_find_encoder(codec_id);<br>    <span class=\"hljs-comment\">//创建pkt</span><br>    ost-&gt;tmp_pkt = av_packet_alloc();<br>    <span class=\"hljs-comment\">//创建AVStream</span><br>    ost-&gt;st = avformat_new_stream(oc, <span class=\"hljs-literal\">NULL</span>);<br>    <span class=\"hljs-comment\">//设置stream的index</span><br>    ost-&gt;st-&gt;id = oc-&gt;nb_streams<span class=\"hljs-number\">-1</span>;<br>    <span class=\"hljs-comment\">//创建编码器上下文</span><br>    c = avcodec_alloc_context3(*codec);<br>    <span class=\"hljs-comment\">//保存编码器上下文</span><br>    ost-&gt;enc = c;<br><br>    <span class=\"hljs-keyword\">switch</span> ((*codec)-&gt;type) &#123;<br>    <span class=\"hljs-keyword\">case</span> AVMEDIA_TYPE_AUDIO:<br>         <span class=\"hljs-comment\">//设置音频编码器上下文参数(码率，采样率，位深，声道布局等)</span><br>              ...<br>        <span class=\"hljs-comment\">//设置stream的时间基</span><br>        ost-&gt;st-&gt;time_base = (AVRational)&#123; <span class=\"hljs-number\">1</span>, c-&gt;sample_rate &#125;;<br>        <span class=\"hljs-keyword\">break</span>;<br><br>    <span class=\"hljs-keyword\">case</span> AVMEDIA_TYPE_VIDEO:<br>        <span class=\"hljs-comment\">//设置编码器上下文的参数</span><br>        c-&gt;codec_id = codec_id;<br>        <span class=\"hljs-comment\">//设置stream的时间基</span><br>        ost-&gt;st-&gt;time_base = (AVRational)&#123; <span class=\"hljs-number\">1</span>, STREAM_FRAME_RATE &#125;;<br>        c-&gt;time_base       = ost-&gt;st-&gt;time_base;<br>        <span class=\"hljs-comment\">//编码器码率，帧率，gop，分辨率, 设置</span><br>        ...<br>        <span class=\"hljs-keyword\">break</span>;<br><br>    <span class=\"hljs-keyword\">default</span>:<br>        <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">/* Some formats want stream headers to be separate. */</span><br>    <span class=\"hljs-comment\">//处理一下stream header</span><br>    <span class=\"hljs-keyword\">if</span> (oc-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)<br>        c-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>根据codec_id找到AVCodec</p>\n</li>\n<li><p>调用avformat_new_stream创建stream</p>\n</li>\n<li><p>设置stream的index</p>\n</li>\n<li><p>根据AVCodec创建编码器的上下文，配置编码器参数</p>\n</li>\n<li><p>设置stream的time_base</p>\n</li>\n<li><p>处理一下 stream headers 的标志位</p>\n</li>\n</ol>\n<h2 id=\"音视频流创建好了，下一步为写入准备\"><a href=\"#音视频流创建好了，下一步为写入准备\" class=\"headerlink\" title=\"音视频流创建好了，下一步为写入准备\"></a>音视频流创建好了，下一步为写入准备</h2><ol>\n<li><p>上面创建好了stream, 创建了编码器上下文。open_video&#x2F;open_audio继续为写入做准备</p>\n</li>\n<li><p>准备完成就打开文件准备写入</p>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* Now that all the parameters are set, we can open the audio and</span><br><span class=\"hljs-comment\"> * video codecs and allocate the necessary encode buffers. */</span><br><span class=\"hljs-keyword\">if</span> (have_video)<br>    open_video(oc, video_codec, &amp;video_st, opt);<br><br><span class=\"hljs-keyword\">if</span> (have_audio)<br>    open_audio(oc, audio_codec, &amp;audio_st, opt);<br><br><span class=\"hljs-comment\">//打印oc的信息</span><br>av_dump_format(oc, <span class=\"hljs-number\">0</span>, filename, <span class=\"hljs-number\">1</span>);<br><br><span class=\"hljs-comment\">/* open the output file, if needed */</span><br><span class=\"hljs-keyword\">if</span> (!(fmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;<br>    <span class=\"hljs-comment\">//打开文件</span><br>    ret = avio_open(&amp;oc-&gt;pb, filename, AVIO_FLAG_WRITE);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not open &#x27;%s&#x27;: %s\\n&quot;</span>, filename,<br>                av_err2str(ret));<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>看看open_video 做了什么</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">open_video</span><span class=\"hljs-params\">(AVFormatContext *oc, <span class=\"hljs-type\">const</span> AVCodec *codec,</span><br><span class=\"hljs-params\">                       OutputStream *ost, AVDictionary *opt_arg)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> ret;<br>    AVCodecContext *c = ost-&gt;enc;<br>    AVDictionary *opt = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-comment\">//将opt_arg中的内容拷贝到opt中</span><br>    av_dict_copy(&amp;opt, opt_arg, <span class=\"hljs-number\">0</span>);<br>    <span class=\"hljs-comment\">/* open the codec */</span><br>    <span class=\"hljs-comment\">//打开编码器</span><br>    ret = avcodec_open2(c, codec, &amp;opt);<br>    <span class=\"hljs-comment\">//释放opt</span><br>    av_dict_free(&amp;opt);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not open video codec: %s\\n&quot;</span>, av_err2str(ret));<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* allocate and init a re-usable frame */</span><br>    <span class=\"hljs-comment\">//根据格式，宽高，创建一个复用的AVFrame</span><br>    ost-&gt;frame = alloc_picture(c-&gt;pix_fmt, c-&gt;width, c-&gt;height);<br>    <span class=\"hljs-keyword\">if</span> (!ost-&gt;frame) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not allocate video frame\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* If the output format is not YUV420P, then a temporary YUV420P</span><br><span class=\"hljs-comment\">     * picture is needed too. It is then converted to the required</span><br><span class=\"hljs-comment\">     * output format. */</span><br>    ost-&gt;tmp_frame = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-keyword\">if</span> (c-&gt;pix_fmt != AV_PIX_FMT_YUV420P) &#123;<br>        <span class=\"hljs-comment\">//如果编码器对应的pix_fmt不是yuv420p， 创建一个yuv420p格式的AVFrame，保存在ost-&gt;tmp_frame中</span><br>        ost-&gt;tmp_frame = alloc_picture(AV_PIX_FMT_YUV420P, c-&gt;width, c-&gt;height);<br>        <span class=\"hljs-keyword\">if</span> (!ost-&gt;tmp_frame) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not allocate temporary picture\\n&quot;</span>);<br>            <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* copy the stream parameters to the muxer */</span><br>    <span class=\"hljs-comment\">//将编码器的参数拷贝到stream对应的编码参数中</span><br>    ret = avcodec_parameters_from_context(ost-&gt;st-&gt;codecpar, c);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not copy the stream parameters\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>打开编码器</p>\n</li>\n<li><p>申请资源，创建一个AVFrame用于存储编码前数据</p>\n</li>\n<li><p>调用avcodec_parameters_from_context将编码器的编码参数拷贝到stream的codecpar中</p>\n</li>\n</ol>\n<h2 id=\"写音视频数据到文件\"><a href=\"#写音视频数据到文件\" class=\"headerlink\" title=\"写音视频数据到文件\"></a>写音视频数据到文件</h2><p>写文件头</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* Write the stream header, if any. */</span><br><span class=\"hljs-comment\">//将流信息写文件头</span><br>ret = avformat_write_header(oc, &amp;opt);<br><span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>    <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error occurred when opening output file: %s\\n&quot;</span>,<br>            av_err2str(ret));<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>交替写音视频帧</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">while</span> (encode_video || encode_audio) &#123;<br>    <span class=\"hljs-comment\">/* select the stream to encode */</span><br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">     交替写入编码后的音频和视频帧</span><br><span class=\"hljs-comment\">     视频写入结束或者video_st.next_pts &lt;= audio_st.next_pts, 写视频</span><br><span class=\"hljs-comment\">     否则写音频</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-keyword\">if</span> (encode_video &amp;&amp;<br>        (!encode_audio || av_compare_ts(video_st.next_pts, video_st.enc-&gt;time_base,<br>                                        audio_st.next_pts, audio_st.enc-&gt;time_base) &lt;= <span class=\"hljs-number\">0</span>)) &#123;<br>        <span class=\"hljs-comment\">//写入编码后的视频帧</span><br>        encode_video = !write_video_frame(oc, &amp;video_st);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-comment\">//写入编码后的音频帧</span><br>        encode_audio = !write_audio_frame(oc, &amp;audio_st);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p> 写trailer</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* Write the trailer, if any. The trailer must be written before you</span><br><span class=\"hljs-comment\"> * close the CodecContexts open when you wrote the header; otherwise</span><br><span class=\"hljs-comment\"> * av_write_trailer() may try to use memory that was freed on</span><br><span class=\"hljs-comment\"> * av_codec_close(). */</span><br>av_write_trailer(oc);<br></code></pre></td></tr></table></figure>\n\n<p>关闭编码器，关闭文件，释放资源</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* Close each codec. */</span><br><span class=\"hljs-keyword\">if</span> (have_video)<br>    close_stream(oc, &amp;video_st);<br><span class=\"hljs-keyword\">if</span> (have_audio)<br>    close_stream(oc, &amp;audio_st);<br><br><span class=\"hljs-keyword\">if</span> (!(fmt-&gt;flags &amp; AVFMT_NOFILE))<br>    <span class=\"hljs-comment\">/* Close the output file. */</span><br>    avio_closep(&amp;oc-&gt;pb);<br><br><span class=\"hljs-comment\">/* free the stream */</span><br>avformat_free_context(oc);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"write-video-frame\"><a href=\"#write-video-frame\" class=\"headerlink\" title=\"write_video_frame\"></a>write_video_frame</h3><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">static int write_video_frame(AVFormatContext *oc, OutputStream *ost)<br>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">return</span> write_frame(oc, ost-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">enc</span>, ost-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">st</span>, get_video_frame(ost), ost-&gt;</span>tmp_pkt);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>只是简单调用了write_frame</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">write_frame</span><span class=\"hljs-params\">(AVFormatContext *fmt_ctx, AVCodecContext *c,</span><br><span class=\"hljs-params\">                       AVStream *st, AVFrame *frame, AVPacket *pkt)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> ret;<br><br>    <span class=\"hljs-comment\">// send the frame to the encoder</span><br>    <span class=\"hljs-comment\">//将frame送给编码器去编码</span><br>    ret = avcodec_send_frame(c, frame);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error sending a frame to the encoder: %s\\n&quot;</span>,<br>                av_err2str(ret));<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">while</span> (ret &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-comment\">//从编码器中读出编码后的pkt</span><br>        ret = avcodec_receive_packet(c, pkt);<br>        <span class=\"hljs-keyword\">if</span> (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)<br>            <span class=\"hljs-keyword\">break</span>;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error encoding a frame: %s\\n&quot;</span>, av_err2str(ret));<br>            <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>        &#125;<br><br>        <span class=\"hljs-comment\">/* rescale output packet timestamp values from codec to stream timebase */</span><br>        <span class=\"hljs-comment\">//调整pkt的pts，pkt的时间基参编码器的时间基，将其转换为参考stream的时间基</span><br>        av_packet_rescale_ts(pkt, c-&gt;time_base, st-&gt;time_base);<br>        <span class=\"hljs-comment\">//设置pkt的stream_index和stream对应的一致，音视频分别对应于不同的stream_index</span><br>        pkt-&gt;stream_index = st-&gt;index;<br><br>        <span class=\"hljs-comment\">/* Write the compressed frame to the media file. */</span><br>        log_packet(fmt_ctx, pkt);<br>        <span class=\"hljs-comment\">//将pkt写入视频文件</span><br>        ret = av_interleaved_write_frame(fmt_ctx, pkt);<br>        <span class=\"hljs-comment\">/* pkt is now blank (av_interleaved_write_frame() takes ownership of</span><br><span class=\"hljs-comment\">         * its contents and resets pkt), so that no unreferencing is necessary.</span><br><span class=\"hljs-comment\">         * This would be different if one used av_write_frame(). */</span><br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error while writing output packet: %s\\n&quot;</span>, av_err2str(ret));<br>            <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ret == AVERROR_EOF ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>将AVFrame送给编码器去编码</p>\n</li>\n<li><p>读取pkt</p>\n</li>\n<li><p>调用av_packet_rescale_ts，调整pkt的时间戳，写入文件pkt的pts要以stream的time_base为基准</p>\n</li>\n<li><p>设置pkt的index</p>\n</li>\n<li><p>调用av_interleaved_write_frame将pkt写入文件</p>\n</li>\n<li><p>返回写入结果。当AVFrame为空时，会冲洗编码器，ret &#x3D; AVERROR_EOF， 返回1， 结束写入</p>\n</li>\n</ol>\n<p>frame的每一帧数据，是来自于get_video_frame方法, 填充的假数据</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> AVFrame *<span class=\"hljs-title function_\">get_video_frame</span><span class=\"hljs-params\">(OutputStream *ost)</span><br>&#123;<br>    AVCodecContext *c = ost-&gt;enc;<br><br>    <span class=\"hljs-comment\">/* check if we want to generate more frames */</span><br>    <span class=\"hljs-keyword\">if</span> (av_compare_ts(ost-&gt;next_pts, c-&gt;time_base,<br>                      STREAM_DURATION, (AVRational)&#123; <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span> &#125;) &gt; <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br><br>    <span class=\"hljs-comment\">/* when we pass a frame to the encoder, it may keep a reference to it</span><br><span class=\"hljs-comment\">     * internally; make sure we do not overwrite it here */</span><br>    <span class=\"hljs-keyword\">if</span> (av_frame_make_writable(ost-&gt;frame) &lt; <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br><br>    <span class=\"hljs-keyword\">if</span> (c-&gt;pix_fmt != AV_PIX_FMT_YUV420P) &#123;<br>        <span class=\"hljs-comment\">/* as we only generate a YUV420P picture, we must convert it</span><br><span class=\"hljs-comment\">         * to the codec pixel format if needed */</span><br>        <span class=\"hljs-keyword\">if</span> (!ost-&gt;sws_ctx) &#123;<br>            ost-&gt;sws_ctx = sws_getContext(c-&gt;width, c-&gt;height,<br>                                          AV_PIX_FMT_YUV420P,<br>                                          c-&gt;width, c-&gt;height,<br>                                          c-&gt;pix_fmt,<br>                                          SCALE_FLAGS, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-literal\">NULL</span>);<br>            <span class=\"hljs-keyword\">if</span> (!ost-&gt;sws_ctx) &#123;<br>                <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>,<br>                        <span class=\"hljs-string\">&quot;Could not initialize the conversion context\\n&quot;</span>);<br>                <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>            &#125;<br>        &#125;<br>        fill_yuv_image(ost-&gt;tmp_frame, ost-&gt;next_pts, c-&gt;width, c-&gt;height);<br>        sws_scale(ost-&gt;sws_ctx, (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint8_t</span> * <span class=\"hljs-type\">const</span> *) ost-&gt;tmp_frame-&gt;data,<br>                  ost-&gt;tmp_frame-&gt;linesize, <span class=\"hljs-number\">0</span>, c-&gt;height, ost-&gt;frame-&gt;data,<br>                  ost-&gt;frame-&gt;linesize);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        fill_yuv_image(ost-&gt;frame, ost-&gt;next_pts, c-&gt;width, c-&gt;height);<br>    &#125;<br><br>    ost-&gt;frame-&gt;pts = ost-&gt;next_pts++;<br><br>    <span class=\"hljs-keyword\">return</span> ost-&gt;frame;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>调用av_compare_ts 判断是否继续生成新的frame，一开始规定了只写10秒钟的数据，超过了就不写了</p>\n</li>\n<li><p>av_frame_make_writable使当前的frame可写，被编码器引用的frame不可写，调用该方法如果被引用，内部会创建新buf，变成可写的</p>\n</li>\n<li><p>填充数据yuv，还做了缩放处理，暂不讨论</p>\n</li>\n<li><p>更新frame的pts</p>\n</li>\n<li><p>返回生成的frame</p>\n</li>\n</ol>\n<p>write_audio_frame</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\"> * encode one audio frame and send it to the muxer</span><br><span class=\"hljs-comment\"> * return 1 when encoding is finished, 0 otherwise</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">write_audio_frame</span><span class=\"hljs-params\">(AVFormatContext *oc, OutputStream *ost)</span><br>&#123;<br>    AVCodecContext *c;<br>    AVFrame *frame;<br>    <span class=\"hljs-type\">int</span> ret;<br>    <span class=\"hljs-type\">int</span> dst_nb_samples;<br><br>    c = ost-&gt;enc;<br><br>    <span class=\"hljs-comment\">//获取音频帧</span><br>    frame = get_audio_frame(ost);   <br><br>    <span class=\"hljs-keyword\">if</span> (frame) &#123;<br>        <span class=\"hljs-comment\">/* convert samples from native format to destination codec format, using the resampler */</span><br>        <span class=\"hljs-comment\">/* compute destination number of samples */</span><br><br>        <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">        计算根据重采样后应该生成的采样个数</span><br><span class=\"hljs-comment\">        */</span><br>        dst_nb_samples = av_rescale_rnd(swr_get_delay(ost-&gt;swr_ctx, c-&gt;sample_rate) + frame-&gt;nb_samples,<br>                                        c-&gt;sample_rate, c-&gt;sample_rate, AV_ROUND_UP);<br>        <span class=\"hljs-comment\">//由于没有修改采样率，只是修改了位深，采样个数保持不变</span><br>        av_assert0(dst_nb_samples == frame-&gt;nb_samples);<br><br>        <span class=\"hljs-comment\">/* when we pass a frame to the encoder, it may keep a reference to it</span><br><span class=\"hljs-comment\">         * internally;</span><br><span class=\"hljs-comment\">         * make sure we do not overwrite it here</span><br><span class=\"hljs-comment\">         */</span><br>        <span class=\"hljs-comment\">//使ost-&gt;frame可写</span><br>        ret = av_frame_make_writable(ost-&gt;frame);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br><br>        <span class=\"hljs-comment\">/* convert to destination format */</span><br>        <span class=\"hljs-comment\">//重采样</span><br>        ret = swr_convert(ost-&gt;swr_ctx,<br>                          ost-&gt;frame-&gt;data, dst_nb_samples,<br>                          (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint8_t</span> **)frame-&gt;data, frame-&gt;nb_samples);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error while converting\\n&quot;</span>);<br>            <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>        &#125;<br><br>        frame = ost-&gt;frame;<br>        <span class=\"hljs-comment\">//重新计算音频pts</span><br>        frame-&gt;pts = av_rescale_q(ost-&gt;samples_count, (AVRational)&#123;<span class=\"hljs-number\">1</span>, c-&gt;sample_rate&#125;, c-&gt;time_base);<br>        <span class=\"hljs-comment\">//计算samples_count</span><br>        ost-&gt;samples_count += dst_nb_samples;<br>    &#125;<br>    <span class=\"hljs-comment\">//将音频帧写入文件</span><br>    <span class=\"hljs-keyword\">return</span> write_frame(oc, c, ost-&gt;st, frame, ost-&gt;tmp_pkt);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>准备AVFrame，调用get_audio_frame获取一个AVFrame，内部根据编码格式，填充pcm假数据</p>\n</li>\n<li><p>调用av_rescale_rnd计算重采样个数，如果数据源和送入编码器的音频的采样率不同，需要转换采样率，示例程序只是变了采样格式，没有更改采样率，采样个数不变</p>\n</li>\n<li><p>做重采样，重采样数据保存在ost-&gt;frame中</p>\n</li>\n<li><p>重采样后，需要更新frame的pts</p>\n</li>\n<li><p>调用write_frame编码，将数据写入文件</p>\n</li>\n</ol>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>学习了通过应用libavformat将音视频数据编码封装到文件中</p>\n<ol>\n<li><p>创建AVFormatContext</p>\n</li>\n<li><p>添加stream</p>\n</li>\n<li><p>配置编解码器，stream 参数</p>\n</li>\n<li><p>编码frame，生成pkt，更新pts</p>\n</li>\n<li><p>交替写音视频pkt</p>\n</li>\n<li><p>关闭编解码器，结束写文件</p>\n</li>\n</ol>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>","excerpt":"","more":"<p>今天学习 <code>ffmpeg/doc/examples/muxing.c</code></p>\n<p>该程序接受一个参数，指定输出的文件的路径，例如<code>/tmp/mux.mp4</code>,<code>/tmp/mux.mov</code>。 文件名的后缀会用来推测生成的AVFormatContext的格式，如果没有指定，就使用<code>mpeg</code>。使用fmt 默认的视频编码器和音频编码器，编码10秒钟的音视频数据，交替写入文件。</p>\n<p>操作封装需要操作<code>AVFormatContext</code></p>\n<h2 id=\"创建AVFormatContext\"><a href=\"#创建AVFormatContext\" class=\"headerlink\" title=\"创建AVFormatContext\"></a>创建AVFormatContext</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//创建AVFormatContext， 根据文件后缀来推测output format</span><br>avformat_alloc_output_context2(&amp;oc, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-literal\">NULL</span>, filename);<br><span class=\"hljs-keyword\">if</span> (!oc) &#123;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Could not deduce output format from file extension: using MPEG.\\n&quot;</span>);<br>    <span class=\"hljs-comment\">//无法推测output format， 使用mpeg</span><br>    avformat_alloc_output_context2(&amp;oc, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-string\">&quot;mpeg&quot;</span>, filename);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"给AVFormatContext添加-video-audio-stream\"><a href=\"#给AVFormatContext添加-video-audio-stream\" class=\"headerlink\" title=\"给AVFormatContext添加 video &#x2F; audio stream\"></a>给AVFormatContext添加 video &#x2F; audio stream</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">if</span> (fmt-&gt;video_codec != AV_CODEC_ID_NONE) &#123;<br>    add_stream(&amp;video_st, oc, &amp;video_codec, fmt-&gt;video_codec);<br>    have_video = <span class=\"hljs-number\">1</span>;<br>    encode_video = <span class=\"hljs-number\">1</span>;<br>&#125;<br><span class=\"hljs-keyword\">if</span> (fmt-&gt;audio_codec != AV_CODEC_ID_NONE) &#123;<br>    add_stream(&amp;audio_st, oc, &amp;audio_codec, fmt-&gt;audio_codec);<br>    have_audio = <span class=\"hljs-number\">1</span>;<br>    encode_audio = <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们看看add_stream做了什么</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* Add an output stream. */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">add_stream</span><span class=\"hljs-params\">(OutputStream *ost, AVFormatContext *oc,</span><br><span class=\"hljs-params\">                       <span class=\"hljs-type\">const</span> AVCodec **codec,</span><br><span class=\"hljs-params\">                       <span class=\"hljs-keyword\">enum</span> AVCodecID codec_id)</span><br>&#123;<br>    AVCodecContext *c;<br>    <span class=\"hljs-type\">int</span> i;<br>    <span class=\"hljs-comment\">/* find the encoder */</span><br>    <span class=\"hljs-comment\">//找到codec_id对应的编码器AVCodec</span><br>    *codec = avcodec_find_encoder(codec_id);<br>    <span class=\"hljs-comment\">//创建pkt</span><br>    ost-&gt;tmp_pkt = av_packet_alloc();<br>    <span class=\"hljs-comment\">//创建AVStream</span><br>    ost-&gt;st = avformat_new_stream(oc, <span class=\"hljs-literal\">NULL</span>);<br>    <span class=\"hljs-comment\">//设置stream的index</span><br>    ost-&gt;st-&gt;id = oc-&gt;nb_streams<span class=\"hljs-number\">-1</span>;<br>    <span class=\"hljs-comment\">//创建编码器上下文</span><br>    c = avcodec_alloc_context3(*codec);<br>    <span class=\"hljs-comment\">//保存编码器上下文</span><br>    ost-&gt;enc = c;<br><br>    <span class=\"hljs-keyword\">switch</span> ((*codec)-&gt;type) &#123;<br>    <span class=\"hljs-keyword\">case</span> AVMEDIA_TYPE_AUDIO:<br>         <span class=\"hljs-comment\">//设置音频编码器上下文参数(码率，采样率，位深，声道布局等)</span><br>              ...<br>        <span class=\"hljs-comment\">//设置stream的时间基</span><br>        ost-&gt;st-&gt;time_base = (AVRational)&#123; <span class=\"hljs-number\">1</span>, c-&gt;sample_rate &#125;;<br>        <span class=\"hljs-keyword\">break</span>;<br><br>    <span class=\"hljs-keyword\">case</span> AVMEDIA_TYPE_VIDEO:<br>        <span class=\"hljs-comment\">//设置编码器上下文的参数</span><br>        c-&gt;codec_id = codec_id;<br>        <span class=\"hljs-comment\">//设置stream的时间基</span><br>        ost-&gt;st-&gt;time_base = (AVRational)&#123; <span class=\"hljs-number\">1</span>, STREAM_FRAME_RATE &#125;;<br>        c-&gt;time_base       = ost-&gt;st-&gt;time_base;<br>        <span class=\"hljs-comment\">//编码器码率，帧率，gop，分辨率, 设置</span><br>        ...<br>        <span class=\"hljs-keyword\">break</span>;<br><br>    <span class=\"hljs-keyword\">default</span>:<br>        <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">/* Some formats want stream headers to be separate. */</span><br>    <span class=\"hljs-comment\">//处理一下stream header</span><br>    <span class=\"hljs-keyword\">if</span> (oc-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)<br>        c-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>根据codec_id找到AVCodec</p>\n</li>\n<li><p>调用avformat_new_stream创建stream</p>\n</li>\n<li><p>设置stream的index</p>\n</li>\n<li><p>根据AVCodec创建编码器的上下文，配置编码器参数</p>\n</li>\n<li><p>设置stream的time_base</p>\n</li>\n<li><p>处理一下 stream headers 的标志位</p>\n</li>\n</ol>\n<h2 id=\"音视频流创建好了，下一步为写入准备\"><a href=\"#音视频流创建好了，下一步为写入准备\" class=\"headerlink\" title=\"音视频流创建好了，下一步为写入准备\"></a>音视频流创建好了，下一步为写入准备</h2><ol>\n<li><p>上面创建好了stream, 创建了编码器上下文。open_video&#x2F;open_audio继续为写入做准备</p>\n</li>\n<li><p>准备完成就打开文件准备写入</p>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* Now that all the parameters are set, we can open the audio and</span><br><span class=\"hljs-comment\"> * video codecs and allocate the necessary encode buffers. */</span><br><span class=\"hljs-keyword\">if</span> (have_video)<br>    open_video(oc, video_codec, &amp;video_st, opt);<br><br><span class=\"hljs-keyword\">if</span> (have_audio)<br>    open_audio(oc, audio_codec, &amp;audio_st, opt);<br><br><span class=\"hljs-comment\">//打印oc的信息</span><br>av_dump_format(oc, <span class=\"hljs-number\">0</span>, filename, <span class=\"hljs-number\">1</span>);<br><br><span class=\"hljs-comment\">/* open the output file, if needed */</span><br><span class=\"hljs-keyword\">if</span> (!(fmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;<br>    <span class=\"hljs-comment\">//打开文件</span><br>    ret = avio_open(&amp;oc-&gt;pb, filename, AVIO_FLAG_WRITE);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not open &#x27;%s&#x27;: %s\\n&quot;</span>, filename,<br>                av_err2str(ret));<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>看看open_video 做了什么</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">open_video</span><span class=\"hljs-params\">(AVFormatContext *oc, <span class=\"hljs-type\">const</span> AVCodec *codec,</span><br><span class=\"hljs-params\">                       OutputStream *ost, AVDictionary *opt_arg)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> ret;<br>    AVCodecContext *c = ost-&gt;enc;<br>    AVDictionary *opt = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-comment\">//将opt_arg中的内容拷贝到opt中</span><br>    av_dict_copy(&amp;opt, opt_arg, <span class=\"hljs-number\">0</span>);<br>    <span class=\"hljs-comment\">/* open the codec */</span><br>    <span class=\"hljs-comment\">//打开编码器</span><br>    ret = avcodec_open2(c, codec, &amp;opt);<br>    <span class=\"hljs-comment\">//释放opt</span><br>    av_dict_free(&amp;opt);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not open video codec: %s\\n&quot;</span>, av_err2str(ret));<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* allocate and init a re-usable frame */</span><br>    <span class=\"hljs-comment\">//根据格式，宽高，创建一个复用的AVFrame</span><br>    ost-&gt;frame = alloc_picture(c-&gt;pix_fmt, c-&gt;width, c-&gt;height);<br>    <span class=\"hljs-keyword\">if</span> (!ost-&gt;frame) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not allocate video frame\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* If the output format is not YUV420P, then a temporary YUV420P</span><br><span class=\"hljs-comment\">     * picture is needed too. It is then converted to the required</span><br><span class=\"hljs-comment\">     * output format. */</span><br>    ost-&gt;tmp_frame = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-keyword\">if</span> (c-&gt;pix_fmt != AV_PIX_FMT_YUV420P) &#123;<br>        <span class=\"hljs-comment\">//如果编码器对应的pix_fmt不是yuv420p， 创建一个yuv420p格式的AVFrame，保存在ost-&gt;tmp_frame中</span><br>        ost-&gt;tmp_frame = alloc_picture(AV_PIX_FMT_YUV420P, c-&gt;width, c-&gt;height);<br>        <span class=\"hljs-keyword\">if</span> (!ost-&gt;tmp_frame) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not allocate temporary picture\\n&quot;</span>);<br>            <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* copy the stream parameters to the muxer */</span><br>    <span class=\"hljs-comment\">//将编码器的参数拷贝到stream对应的编码参数中</span><br>    ret = avcodec_parameters_from_context(ost-&gt;st-&gt;codecpar, c);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Could not copy the stream parameters\\n&quot;</span>);<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>打开编码器</p>\n</li>\n<li><p>申请资源，创建一个AVFrame用于存储编码前数据</p>\n</li>\n<li><p>调用avcodec_parameters_from_context将编码器的编码参数拷贝到stream的codecpar中</p>\n</li>\n</ol>\n<h2 id=\"写音视频数据到文件\"><a href=\"#写音视频数据到文件\" class=\"headerlink\" title=\"写音视频数据到文件\"></a>写音视频数据到文件</h2><p>写文件头</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* Write the stream header, if any. */</span><br><span class=\"hljs-comment\">//将流信息写文件头</span><br>ret = avformat_write_header(oc, &amp;opt);<br><span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>    <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error occurred when opening output file: %s\\n&quot;</span>,<br>            av_err2str(ret));<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>交替写音视频帧</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">while</span> (encode_video || encode_audio) &#123;<br>    <span class=\"hljs-comment\">/* select the stream to encode */</span><br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">     交替写入编码后的音频和视频帧</span><br><span class=\"hljs-comment\">     视频写入结束或者video_st.next_pts &lt;= audio_st.next_pts, 写视频</span><br><span class=\"hljs-comment\">     否则写音频</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-keyword\">if</span> (encode_video &amp;&amp;<br>        (!encode_audio || av_compare_ts(video_st.next_pts, video_st.enc-&gt;time_base,<br>                                        audio_st.next_pts, audio_st.enc-&gt;time_base) &lt;= <span class=\"hljs-number\">0</span>)) &#123;<br>        <span class=\"hljs-comment\">//写入编码后的视频帧</span><br>        encode_video = !write_video_frame(oc, &amp;video_st);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-comment\">//写入编码后的音频帧</span><br>        encode_audio = !write_audio_frame(oc, &amp;audio_st);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p> 写trailer</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* Write the trailer, if any. The trailer must be written before you</span><br><span class=\"hljs-comment\"> * close the CodecContexts open when you wrote the header; otherwise</span><br><span class=\"hljs-comment\"> * av_write_trailer() may try to use memory that was freed on</span><br><span class=\"hljs-comment\"> * av_codec_close(). */</span><br>av_write_trailer(oc);<br></code></pre></td></tr></table></figure>\n\n<p>关闭编码器，关闭文件，释放资源</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* Close each codec. */</span><br><span class=\"hljs-keyword\">if</span> (have_video)<br>    close_stream(oc, &amp;video_st);<br><span class=\"hljs-keyword\">if</span> (have_audio)<br>    close_stream(oc, &amp;audio_st);<br><br><span class=\"hljs-keyword\">if</span> (!(fmt-&gt;flags &amp; AVFMT_NOFILE))<br>    <span class=\"hljs-comment\">/* Close the output file. */</span><br>    avio_closep(&amp;oc-&gt;pb);<br><br><span class=\"hljs-comment\">/* free the stream */</span><br>avformat_free_context(oc);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"write-video-frame\"><a href=\"#write-video-frame\" class=\"headerlink\" title=\"write_video_frame\"></a>write_video_frame</h3><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">static int write_video_frame(AVFormatContext *oc, OutputStream *ost)<br>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">return</span> write_frame(oc, ost-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">enc</span>, ost-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">st</span>, get_video_frame(ost), ost-&gt;</span>tmp_pkt);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>只是简单调用了write_frame</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">write_frame</span><span class=\"hljs-params\">(AVFormatContext *fmt_ctx, AVCodecContext *c,</span><br><span class=\"hljs-params\">                       AVStream *st, AVFrame *frame, AVPacket *pkt)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> ret;<br><br>    <span class=\"hljs-comment\">// send the frame to the encoder</span><br>    <span class=\"hljs-comment\">//将frame送给编码器去编码</span><br>    ret = avcodec_send_frame(c, frame);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error sending a frame to the encoder: %s\\n&quot;</span>,<br>                av_err2str(ret));<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">while</span> (ret &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-comment\">//从编码器中读出编码后的pkt</span><br>        ret = avcodec_receive_packet(c, pkt);<br>        <span class=\"hljs-keyword\">if</span> (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)<br>            <span class=\"hljs-keyword\">break</span>;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error encoding a frame: %s\\n&quot;</span>, av_err2str(ret));<br>            <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>        &#125;<br><br>        <span class=\"hljs-comment\">/* rescale output packet timestamp values from codec to stream timebase */</span><br>        <span class=\"hljs-comment\">//调整pkt的pts，pkt的时间基参编码器的时间基，将其转换为参考stream的时间基</span><br>        av_packet_rescale_ts(pkt, c-&gt;time_base, st-&gt;time_base);<br>        <span class=\"hljs-comment\">//设置pkt的stream_index和stream对应的一致，音视频分别对应于不同的stream_index</span><br>        pkt-&gt;stream_index = st-&gt;index;<br><br>        <span class=\"hljs-comment\">/* Write the compressed frame to the media file. */</span><br>        log_packet(fmt_ctx, pkt);<br>        <span class=\"hljs-comment\">//将pkt写入视频文件</span><br>        ret = av_interleaved_write_frame(fmt_ctx, pkt);<br>        <span class=\"hljs-comment\">/* pkt is now blank (av_interleaved_write_frame() takes ownership of</span><br><span class=\"hljs-comment\">         * its contents and resets pkt), so that no unreferencing is necessary.</span><br><span class=\"hljs-comment\">         * This would be different if one used av_write_frame(). */</span><br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error while writing output packet: %s\\n&quot;</span>, av_err2str(ret));<br>            <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> ret == AVERROR_EOF ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>将AVFrame送给编码器去编码</p>\n</li>\n<li><p>读取pkt</p>\n</li>\n<li><p>调用av_packet_rescale_ts，调整pkt的时间戳，写入文件pkt的pts要以stream的time_base为基准</p>\n</li>\n<li><p>设置pkt的index</p>\n</li>\n<li><p>调用av_interleaved_write_frame将pkt写入文件</p>\n</li>\n<li><p>返回写入结果。当AVFrame为空时，会冲洗编码器，ret &#x3D; AVERROR_EOF， 返回1， 结束写入</p>\n</li>\n</ol>\n<p>frame的每一帧数据，是来自于get_video_frame方法, 填充的假数据</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> AVFrame *<span class=\"hljs-title function_\">get_video_frame</span><span class=\"hljs-params\">(OutputStream *ost)</span><br>&#123;<br>    AVCodecContext *c = ost-&gt;enc;<br><br>    <span class=\"hljs-comment\">/* check if we want to generate more frames */</span><br>    <span class=\"hljs-keyword\">if</span> (av_compare_ts(ost-&gt;next_pts, c-&gt;time_base,<br>                      STREAM_DURATION, (AVRational)&#123; <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span> &#125;) &gt; <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br><br>    <span class=\"hljs-comment\">/* when we pass a frame to the encoder, it may keep a reference to it</span><br><span class=\"hljs-comment\">     * internally; make sure we do not overwrite it here */</span><br>    <span class=\"hljs-keyword\">if</span> (av_frame_make_writable(ost-&gt;frame) &lt; <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br><br>    <span class=\"hljs-keyword\">if</span> (c-&gt;pix_fmt != AV_PIX_FMT_YUV420P) &#123;<br>        <span class=\"hljs-comment\">/* as we only generate a YUV420P picture, we must convert it</span><br><span class=\"hljs-comment\">         * to the codec pixel format if needed */</span><br>        <span class=\"hljs-keyword\">if</span> (!ost-&gt;sws_ctx) &#123;<br>            ost-&gt;sws_ctx = sws_getContext(c-&gt;width, c-&gt;height,<br>                                          AV_PIX_FMT_YUV420P,<br>                                          c-&gt;width, c-&gt;height,<br>                                          c-&gt;pix_fmt,<br>                                          SCALE_FLAGS, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-literal\">NULL</span>);<br>            <span class=\"hljs-keyword\">if</span> (!ost-&gt;sws_ctx) &#123;<br>                <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>,<br>                        <span class=\"hljs-string\">&quot;Could not initialize the conversion context\\n&quot;</span>);<br>                <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>            &#125;<br>        &#125;<br>        fill_yuv_image(ost-&gt;tmp_frame, ost-&gt;next_pts, c-&gt;width, c-&gt;height);<br>        sws_scale(ost-&gt;sws_ctx, (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint8_t</span> * <span class=\"hljs-type\">const</span> *) ost-&gt;tmp_frame-&gt;data,<br>                  ost-&gt;tmp_frame-&gt;linesize, <span class=\"hljs-number\">0</span>, c-&gt;height, ost-&gt;frame-&gt;data,<br>                  ost-&gt;frame-&gt;linesize);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        fill_yuv_image(ost-&gt;frame, ost-&gt;next_pts, c-&gt;width, c-&gt;height);<br>    &#125;<br><br>    ost-&gt;frame-&gt;pts = ost-&gt;next_pts++;<br><br>    <span class=\"hljs-keyword\">return</span> ost-&gt;frame;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>调用av_compare_ts 判断是否继续生成新的frame，一开始规定了只写10秒钟的数据，超过了就不写了</p>\n</li>\n<li><p>av_frame_make_writable使当前的frame可写，被编码器引用的frame不可写，调用该方法如果被引用，内部会创建新buf，变成可写的</p>\n</li>\n<li><p>填充数据yuv，还做了缩放处理，暂不讨论</p>\n</li>\n<li><p>更新frame的pts</p>\n</li>\n<li><p>返回生成的frame</p>\n</li>\n</ol>\n<p>write_audio_frame</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\"> * encode one audio frame and send it to the muxer</span><br><span class=\"hljs-comment\"> * return 1 when encoding is finished, 0 otherwise</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">write_audio_frame</span><span class=\"hljs-params\">(AVFormatContext *oc, OutputStream *ost)</span><br>&#123;<br>    AVCodecContext *c;<br>    AVFrame *frame;<br>    <span class=\"hljs-type\">int</span> ret;<br>    <span class=\"hljs-type\">int</span> dst_nb_samples;<br><br>    c = ost-&gt;enc;<br><br>    <span class=\"hljs-comment\">//获取音频帧</span><br>    frame = get_audio_frame(ost);   <br><br>    <span class=\"hljs-keyword\">if</span> (frame) &#123;<br>        <span class=\"hljs-comment\">/* convert samples from native format to destination codec format, using the resampler */</span><br>        <span class=\"hljs-comment\">/* compute destination number of samples */</span><br><br>        <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">        计算根据重采样后应该生成的采样个数</span><br><span class=\"hljs-comment\">        */</span><br>        dst_nb_samples = av_rescale_rnd(swr_get_delay(ost-&gt;swr_ctx, c-&gt;sample_rate) + frame-&gt;nb_samples,<br>                                        c-&gt;sample_rate, c-&gt;sample_rate, AV_ROUND_UP);<br>        <span class=\"hljs-comment\">//由于没有修改采样率，只是修改了位深，采样个数保持不变</span><br>        av_assert0(dst_nb_samples == frame-&gt;nb_samples);<br><br>        <span class=\"hljs-comment\">/* when we pass a frame to the encoder, it may keep a reference to it</span><br><span class=\"hljs-comment\">         * internally;</span><br><span class=\"hljs-comment\">         * make sure we do not overwrite it here</span><br><span class=\"hljs-comment\">         */</span><br>        <span class=\"hljs-comment\">//使ost-&gt;frame可写</span><br>        ret = av_frame_make_writable(ost-&gt;frame);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br><br>        <span class=\"hljs-comment\">/* convert to destination format */</span><br>        <span class=\"hljs-comment\">//重采样</span><br>        ret = swr_convert(ost-&gt;swr_ctx,<br>                          ost-&gt;frame-&gt;data, dst_nb_samples,<br>                          (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint8_t</span> **)frame-&gt;data, frame-&gt;nb_samples);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Error while converting\\n&quot;</span>);<br>            <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);<br>        &#125;<br><br>        frame = ost-&gt;frame;<br>        <span class=\"hljs-comment\">//重新计算音频pts</span><br>        frame-&gt;pts = av_rescale_q(ost-&gt;samples_count, (AVRational)&#123;<span class=\"hljs-number\">1</span>, c-&gt;sample_rate&#125;, c-&gt;time_base);<br>        <span class=\"hljs-comment\">//计算samples_count</span><br>        ost-&gt;samples_count += dst_nb_samples;<br>    &#125;<br>    <span class=\"hljs-comment\">//将音频帧写入文件</span><br>    <span class=\"hljs-keyword\">return</span> write_frame(oc, c, ost-&gt;st, frame, ost-&gt;tmp_pkt);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>准备AVFrame，调用get_audio_frame获取一个AVFrame，内部根据编码格式，填充pcm假数据</p>\n</li>\n<li><p>调用av_rescale_rnd计算重采样个数，如果数据源和送入编码器的音频的采样率不同，需要转换采样率，示例程序只是变了采样格式，没有更改采样率，采样个数不变</p>\n</li>\n<li><p>做重采样，重采样数据保存在ost-&gt;frame中</p>\n</li>\n<li><p>重采样后，需要更新frame的pts</p>\n</li>\n<li><p>调用write_frame编码，将数据写入文件</p>\n</li>\n</ol>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>学习了通过应用libavformat将音视频数据编码封装到文件中</p>\n<ol>\n<li><p>创建AVFormatContext</p>\n</li>\n<li><p>添加stream</p>\n</li>\n<li><p>配置编解码器，stream 参数</p>\n</li>\n<li><p>编码frame，生成pkt，更新pts</p>\n</li>\n<li><p>交替写音视频pkt</p>\n</li>\n<li><p>关闭编解码器，结束写文件</p>\n</li>\n</ol>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>"},{"layout":"post","title":"ffmpeg+nginx+rtmp搭建本地推流服务器","date":"2022-03-12T16:00:00.000Z","_content":"\n## 安装[nginx](https://github.com/denji/homebrew-nginx)+[rtmp](https://github.com/sergey-dryabzhinsky/nginx-rtmp-module)\n\n```\nbrew tap denji/nginx\nbrew install nginx-full --with-rtmp-module\n```\n\n## 配置`nginx.conf`,路径`/opt/homebrew/etc/nginx/nginx.conf`\n\n```\nrtmp {\n    server {\n        listen 1935;\n        chunk_size 4096;\n\n        # live on\n        application rtmp_live {\n            live on;\n            # hls on; #这个参数把直播服务器改造成实时回放服务器。\n            # wait_key on; #对视频切片进行保护，这样就不会产生马赛克了。\n            # hls_path ./sbin/html; #切片视频文件存放位置。\n            # hls_fragment 10s;     #每个视频切片的时长。\n            # hls_playlist_length 60s;  #总共可以回看的时间，这里设置的是1分钟。\n            # hls_continuous on; #连续模式。\n            # hls_cleanup on;    #对多余的切片进行删除。\n            # hls_nested on;     #嵌套模式。\n        }\n\n        # play videos\n        application rtmp_play{\n            play ./videos;  #build directory\n        }\n    }\n}\n```\n\n更多配置参考:[example-nginxconf](https://github.com/sergey-dryabzhinsky/nginx-rtmp-module#example-nginxconf)\n\n### 重启 nginx\n\n```\nReload config:\n $ nginx -s reload\nReopen Logfile:\n $ nginx -s reopen\nStop process:\n $ nginx -s stop\nWaiting on exit process\n $ nginx -s quit\n```\n\n## 使用ffmpeg 推流\n\n```\nffmpeg -re -i test.flv -vcodec libx264 -acodec aac -strict -2 -f flv rtmp://localhost:1935/$app/$name\n```\n\n上面定义的app叫rtmp_live，假设name=video\n\n```\nffmpeg -re -i test.flv -vcodec libx264 -acodec aac -strict -2 -f flv rtmp://localhost:1935/rtmp_live/video\n```\n\n## 使用ffplay拉流或者vlc拉流\n\n```\nffplay rtmp://localhost:1935/rtmp_live/video\n```\n\n---\n\n参考：\n\n[MACOS上搭建nginx+rtmp环境](https://github.com/guoxiaopang/LiveExplanation/blob/master/MACOS%E4%B8%8A%E6%90%AD%E5%BB%BAnginx%2Brtmp%E7%8E%AF%E5%A2%83.md)\n\n\n","source":"_posts/ffmpeg/2022-03-13-ffmpeg+nginx+rtmp搭建推流服务器.md","raw":"---\nlayout: post\ntitle: \"ffmpeg+nginx+rtmp搭建本地推流服务器\"\ndate: 2022-03-13 \ntag: ffmpeg\n---\n\n## 安装[nginx](https://github.com/denji/homebrew-nginx)+[rtmp](https://github.com/sergey-dryabzhinsky/nginx-rtmp-module)\n\n```\nbrew tap denji/nginx\nbrew install nginx-full --with-rtmp-module\n```\n\n## 配置`nginx.conf`,路径`/opt/homebrew/etc/nginx/nginx.conf`\n\n```\nrtmp {\n    server {\n        listen 1935;\n        chunk_size 4096;\n\n        # live on\n        application rtmp_live {\n            live on;\n            # hls on; #这个参数把直播服务器改造成实时回放服务器。\n            # wait_key on; #对视频切片进行保护，这样就不会产生马赛克了。\n            # hls_path ./sbin/html; #切片视频文件存放位置。\n            # hls_fragment 10s;     #每个视频切片的时长。\n            # hls_playlist_length 60s;  #总共可以回看的时间，这里设置的是1分钟。\n            # hls_continuous on; #连续模式。\n            # hls_cleanup on;    #对多余的切片进行删除。\n            # hls_nested on;     #嵌套模式。\n        }\n\n        # play videos\n        application rtmp_play{\n            play ./videos;  #build directory\n        }\n    }\n}\n```\n\n更多配置参考:[example-nginxconf](https://github.com/sergey-dryabzhinsky/nginx-rtmp-module#example-nginxconf)\n\n### 重启 nginx\n\n```\nReload config:\n $ nginx -s reload\nReopen Logfile:\n $ nginx -s reopen\nStop process:\n $ nginx -s stop\nWaiting on exit process\n $ nginx -s quit\n```\n\n## 使用ffmpeg 推流\n\n```\nffmpeg -re -i test.flv -vcodec libx264 -acodec aac -strict -2 -f flv rtmp://localhost:1935/$app/$name\n```\n\n上面定义的app叫rtmp_live，假设name=video\n\n```\nffmpeg -re -i test.flv -vcodec libx264 -acodec aac -strict -2 -f flv rtmp://localhost:1935/rtmp_live/video\n```\n\n## 使用ffplay拉流或者vlc拉流\n\n```\nffplay rtmp://localhost:1935/rtmp_live/video\n```\n\n---\n\n参考：\n\n[MACOS上搭建nginx+rtmp环境](https://github.com/guoxiaopang/LiveExplanation/blob/master/MACOS%E4%B8%8A%E6%90%AD%E5%BB%BAnginx%2Brtmp%E7%8E%AF%E5%A2%83.md)\n\n\n","slug":"ffmpeg/2022-03-13-ffmpeg+nginx+rtmp搭建推流服务器","published":1,"updated":"2024-03-06T11:53:13.565Z","comments":1,"photos":[],"_id":"cltgopend001tqywhd18h4g4h","content":"<h2 id=\"安装nginx-rtmp\"><a href=\"#安装nginx-rtmp\" class=\"headerlink\" title=\"安装nginx+rtmp\"></a>安装<a href=\"https://github.com/denji/homebrew-nginx\">nginx</a>+<a href=\"https://github.com/sergey-dryabzhinsky/nginx-rtmp-module\">rtmp</a></h2><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clean\">brew tap denji/nginx<br>brew install nginx-full --<span class=\"hljs-keyword\">with</span>-rtmp-<span class=\"hljs-keyword\">module</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"配置nginx-conf-路径-opt-homebrew-etc-nginx-nginx-conf\"><a href=\"#配置nginx-conf-路径-opt-homebrew-etc-nginx-nginx-conf\" class=\"headerlink\" title=\"配置nginx.conf,路径/opt/homebrew/etc/nginx/nginx.conf\"></a>配置<code>nginx.conf</code>,路径<code>/opt/homebrew/etc/nginx/nginx.conf</code></h2><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clean\">rtmp &#123;<br>    server &#123;<br>        listen <span class=\"hljs-number\">1935</span>;<br>        chunk_size <span class=\"hljs-number\">4096</span>;<br><br>        # live on<br>        application rtmp_live &#123;<br>            live on;<br>            # hls on; #这个参数把直播服务器改造成实时回放服务器。<br>            # wait_key on; #对视频切片进行保护，这样就不会产生马赛克了。<br>            # hls_path ./sbin/html; #切片视频文件存放位置。<br>            # hls_fragment <span class=\"hljs-number\">10</span>s;     #每个视频切片的时长。<br>            # hls_playlist_length <span class=\"hljs-number\">60</span>s;  #总共可以回看的时间，这里设置的是<span class=\"hljs-number\">1</span>分钟。<br>            # hls_continuous on; #连续模式。<br>            # hls_cleanup on;    #对多余的切片进行删除。<br>            # hls_nested on;     #嵌套模式。<br>        &#125;<br><br>        # play videos<br>        application rtmp_play&#123;<br>            play ./videos;  #build directory<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>更多配置参考:<a href=\"https://github.com/sergey-dryabzhinsky/nginx-rtmp-module#example-nginxconf\">example-nginxconf</a></p>\n<h3 id=\"重启-nginx\"><a href=\"#重启-nginx\" class=\"headerlink\" title=\"重启 nginx\"></a>重启 nginx</h3><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">Reload config:<br> $ nginx -s reload<br>Reopen Logfile:<br> $ nginx -s reopen<br>Stop process:<br> $ nginx -s stop<br>Waiting on <span class=\"hljs-keyword\">exit</span> process<br> $ nginx -s quit<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用ffmpeg-推流\"><a href=\"#使用ffmpeg-推流\" class=\"headerlink\" title=\"使用ffmpeg 推流\"></a>使用ffmpeg 推流</h2><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">ffmpeg -re -i test.flv -vcodec libx264 -acodec aac -strict -<span class=\"hljs-number\">2</span> -f flv rtmp:<span class=\"hljs-regexp\">//</span>localhost:<span class=\"hljs-number\">1935</span><span class=\"hljs-regexp\">/$app/</span><span class=\"hljs-variable\">$name</span><br></code></pre></td></tr></table></figure>\n\n<p>上面定义的app叫rtmp_live，假设name&#x3D;video</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">ffmpeg -re -<span class=\"hljs-selector-tag\">i</span> test<span class=\"hljs-selector-class\">.flv</span> -vcodec libx264 -acodec aac -strict -<span class=\"hljs-number\">2</span> -f flv rtmp:<span class=\"hljs-comment\">//localhost:1935/rtmp_live/video</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用ffplay拉流或者vlc拉流\"><a href=\"#使用ffplay拉流或者vlc拉流\" class=\"headerlink\" title=\"使用ffplay拉流或者vlc拉流\"></a>使用ffplay拉流或者vlc拉流</h2><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">ffplay rtmp:<span class=\"hljs-regexp\">//</span>localhost:<span class=\"hljs-number\">1935</span><span class=\"hljs-regexp\">/rtmp_live/</span>video<br></code></pre></td></tr></table></figure>\n\n<hr>\n<p>参考：</p>\n<p><a href=\"https://github.com/guoxiaopang/LiveExplanation/blob/master/MACOS%E4%B8%8A%E6%90%AD%E5%BB%BAnginx%2Brtmp%E7%8E%AF%E5%A2%83.md\">MACOS上搭建nginx+rtmp环境</a></p>\n","excerpt":"","more":"<h2 id=\"安装nginx-rtmp\"><a href=\"#安装nginx-rtmp\" class=\"headerlink\" title=\"安装nginx+rtmp\"></a>安装<a href=\"https://github.com/denji/homebrew-nginx\">nginx</a>+<a href=\"https://github.com/sergey-dryabzhinsky/nginx-rtmp-module\">rtmp</a></h2><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clean\">brew tap denji/nginx<br>brew install nginx-full --<span class=\"hljs-keyword\">with</span>-rtmp-<span class=\"hljs-keyword\">module</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"配置nginx-conf-路径-opt-homebrew-etc-nginx-nginx-conf\"><a href=\"#配置nginx-conf-路径-opt-homebrew-etc-nginx-nginx-conf\" class=\"headerlink\" title=\"配置nginx.conf,路径/opt/homebrew/etc/nginx/nginx.conf\"></a>配置<code>nginx.conf</code>,路径<code>/opt/homebrew/etc/nginx/nginx.conf</code></h2><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clean\">rtmp &#123;<br>    server &#123;<br>        listen <span class=\"hljs-number\">1935</span>;<br>        chunk_size <span class=\"hljs-number\">4096</span>;<br><br>        # live on<br>        application rtmp_live &#123;<br>            live on;<br>            # hls on; #这个参数把直播服务器改造成实时回放服务器。<br>            # wait_key on; #对视频切片进行保护，这样就不会产生马赛克了。<br>            # hls_path ./sbin/html; #切片视频文件存放位置。<br>            # hls_fragment <span class=\"hljs-number\">10</span>s;     #每个视频切片的时长。<br>            # hls_playlist_length <span class=\"hljs-number\">60</span>s;  #总共可以回看的时间，这里设置的是<span class=\"hljs-number\">1</span>分钟。<br>            # hls_continuous on; #连续模式。<br>            # hls_cleanup on;    #对多余的切片进行删除。<br>            # hls_nested on;     #嵌套模式。<br>        &#125;<br><br>        # play videos<br>        application rtmp_play&#123;<br>            play ./videos;  #build directory<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>更多配置参考:<a href=\"https://github.com/sergey-dryabzhinsky/nginx-rtmp-module#example-nginxconf\">example-nginxconf</a></p>\n<h3 id=\"重启-nginx\"><a href=\"#重启-nginx\" class=\"headerlink\" title=\"重启 nginx\"></a>重启 nginx</h3><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">Reload config:<br> $ nginx -s reload<br>Reopen Logfile:<br> $ nginx -s reopen<br>Stop process:<br> $ nginx -s stop<br>Waiting on <span class=\"hljs-keyword\">exit</span> process<br> $ nginx -s quit<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用ffmpeg-推流\"><a href=\"#使用ffmpeg-推流\" class=\"headerlink\" title=\"使用ffmpeg 推流\"></a>使用ffmpeg 推流</h2><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">ffmpeg -re -i test.flv -vcodec libx264 -acodec aac -strict -<span class=\"hljs-number\">2</span> -f flv rtmp:<span class=\"hljs-regexp\">//</span>localhost:<span class=\"hljs-number\">1935</span><span class=\"hljs-regexp\">/$app/</span><span class=\"hljs-variable\">$name</span><br></code></pre></td></tr></table></figure>\n\n<p>上面定义的app叫rtmp_live，假设name&#x3D;video</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">ffmpeg -re -<span class=\"hljs-selector-tag\">i</span> test<span class=\"hljs-selector-class\">.flv</span> -vcodec libx264 -acodec aac -strict -<span class=\"hljs-number\">2</span> -f flv rtmp:<span class=\"hljs-comment\">//localhost:1935/rtmp_live/video</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用ffplay拉流或者vlc拉流\"><a href=\"#使用ffplay拉流或者vlc拉流\" class=\"headerlink\" title=\"使用ffplay拉流或者vlc拉流\"></a>使用ffplay拉流或者vlc拉流</h2><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">ffplay rtmp:<span class=\"hljs-regexp\">//</span>localhost:<span class=\"hljs-number\">1935</span><span class=\"hljs-regexp\">/rtmp_live/</span>video<br></code></pre></td></tr></table></figure>\n\n<hr>\n<p>参考：</p>\n<p><a href=\"https://github.com/guoxiaopang/LiveExplanation/blob/master/MACOS%E4%B8%8A%E6%90%AD%E5%BB%BAnginx%2Brtmp%E7%8E%AF%E5%A2%83.md\">MACOS上搭建nginx+rtmp环境</a></p>\n"},{"layout":"post","title":"ffmpeg example 5.硬件解码","date":"2022-03-12T16:00:00.000Z","_content":"\n\n\n在`hw_decode.c`示例中，ffmpeg展示了如何使用硬件加速来解码视频，我们来分析一下是怎么实现的。\n\n\n\n## 硬件加速设备类型\n\n展示所有可用的硬件加速方法, 在mac上只找到了`videotoolbox`加速的方式。\n\n```shell\nffmpeg -hwaccels\nHardware acceleration methods:\nvideotoolbox\n```\n\n查看 AVHWDeviceType的定义，发现别的平台可以使用cuda，opencl， mediacodec，vulkan等来实现硬件加速。\n\n```\nenum AVHWDeviceType {\n    AV_HWDEVICE_TYPE_NONE,\n    AV_HWDEVICE_TYPE_VDPAU,\n    AV_HWDEVICE_TYPE_CUDA,\n    AV_HWDEVICE_TYPE_VAAPI,\n    AV_HWDEVICE_TYPE_DXVA2,\n    AV_HWDEVICE_TYPE_QSV,\n    AV_HWDEVICE_TYPE_VIDEOTOOLBOX,\n    AV_HWDEVICE_TYPE_D3D11VA,\n    AV_HWDEVICE_TYPE_DRM,\n    AV_HWDEVICE_TYPE_OPENCL,\n    AV_HWDEVICE_TYPE_MEDIACODEC,\n    AV_HWDEVICE_TYPE_VULKAN,\n};\n```\n\n## 源码分析\n\n 调用该示例程序。\n\n```\n./hw_decode videotoolbox /tmp/test.mp4 /tmp/test.yuv\n```\n\n1. 参数videotoolbox 指定使用的硬件加速方式，mac平台只找到这一种\n\n2. /tmp/test.mp4 指定要解封装的文件，从文件中读取h264进行解码\n\n3. /tmp/test.yuv 指定解码后写入的文件路径\n\n### main 函数\n\n```\nint main(int argc, char *argv[])\n{\n    AVFormatContext *input_ctx = NULL;\n    int video_stream, ret;\n    AVStream *video = NULL;\n    AVCodecContext *decoder_ctx = NULL;\n    const AVCodec *decoder = NULL;\n    AVPacket *packet = NULL;\n    enum AVHWDeviceType type;\n    int i;\n\n    if (argc < 4) {\n        fprintf(stderr, \"Usage: %s <device type> <input file> <output file>\\n\", argv[0]);\n        return -1;\n    }\n    //根据传入加速器名字，找到对应的type\n    type = av_hwdevice_find_type_by_name(argv[1]);\n    if (type == AV_HWDEVICE_TYPE_NONE) {\n        fprintf(stderr, \"Device type %s is not supported.\\n\", argv[1]);\n        fprintf(stderr, \"Available device types:\");\n        //没找到加速器，打印ffmepg 支持的加速器列表\n        while((type = av_hwdevice_iterate_types(type)) != AV_HWDEVICE_TYPE_NONE)\n            fprintf(stderr, \" %s\", av_hwdevice_get_type_name(type));\n        fprintf(stderr, \"\\n\");\n        return -1;\n    }\n    //申请packet保存解码前数据\n    packet = av_packet_alloc();\n    if (!packet) {\n        fprintf(stderr, \"Failed to allocate AVPacket\\n\");\n        return -1;\n    }\n\n    //打开输入的文件，关联到AVFormatContext\n    if (avformat_open_input(&input_ctx, argv[2], NULL, NULL) != 0) {\n        fprintf(stderr, \"Cannot open input file '%s'\\n\", argv[2]);\n        return -1;\n    }\n    //填充AVFormatContext，获取解封装信息\n    if (avformat_find_stream_info(input_ctx, NULL) < 0) {\n        fprintf(stderr, \"Cannot find input stream information.\\n\");\n        return -1;\n    }\n\n    //找到video 对应的stream index， 获取对应的解码器信息\n    ret = av_find_best_stream(input_ctx, AVMEDIA_TYPE_VIDEO, -1, -1, &decoder, 0);\n    if (ret < 0) {\n        fprintf(stderr, \"Cannot find a video stream in the input file\\n\");\n        return -1;\n    }\n    video_stream = ret;\n\n    //遍历获取解码器对应的硬件配置信息\n    for (i = 0;; i++) {\n        const AVCodecHWConfig *config = avcodec_get_hw_config(decoder, i);\n        //如果没找到支持的config，结束程序\n        if (!config) {\n            fprintf(stderr, \"Decoder %s does not support device type %s.\\n\",\n                    decoder->name, av_hwdevice_get_type_name(type));\n            return -1;\n        }\n        /*\n         如果config的device_type匹配我们设置的类型，并且config的methods的值为AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX\n         保存支持的hw_pix_fmt，跳出循环\n         \n         关于AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX\n         如果我们选择了此种类型，需要在调用avcodec_open2()打开解码器之前，给AVCodecContext.hw_device_ctx设置正确的值。\n         */\n        \n        if (config->methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX &&\n            config->device_type == type) {\n            hw_pix_fmt = config->pix_fmt;\n            break;\n        }\n    }\n    //创建解码器上下文\n    if (!(decoder_ctx = avcodec_alloc_context3(decoder)))\n        return AVERROR(ENOMEM);\n\n    video = input_ctx->streams[video_stream];\n    //给解码器上下文填充参数，复制从文件中读的的解码器参数\n    if (avcodec_parameters_to_context(decoder_ctx, video->codecpar) < 0)\n        return -1;\n    \n    //get_format是一个函数指针，我们给ffmpeg提供一个函数，ffmpeg 调用该函数确定解码帧的数据格式\n    decoder_ctx->get_format  = get_hw_format;\n\n    //根据AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX的定义，我们需要给ctx->hw_device_ctx赋值\n    if (hw_decoder_init(decoder_ctx, type) < 0)\n        return -1;\n    //打开解码器\n    if ((ret = avcodec_open2(decoder_ctx, decoder, NULL)) < 0) {\n        fprintf(stderr, \"Failed to open codec for stream #%u\\n\", video_stream);\n        return -1;\n    }\n\n    /* open the file to dump raw data */\n    output_file = fopen(argv[3], \"w+b\");\n\n    /* actual decoding and dump the raw data */\n    while (ret >= 0) {\n        //从文件中循环读视频帧，存入packet\n        if ((ret = av_read_frame(input_ctx, packet)) < 0)\n            break;\n\n        if (video_stream == packet->stream_index)\n            //解码packet，写文件\n            ret = decode_write(decoder_ctx, packet);\n\n        av_packet_unref(packet);\n    }\n    //冲洗解码器\n    /* flush the decoder */\n    ret = decode_write(decoder_ctx, NULL);\n\n    if (output_file)\n        fclose(output_file);\n    av_packet_free(&packet);\n    avcodec_free_context(&decoder_ctx);\n    avformat_close_input(&input_ctx);\n    av_buffer_unref(&hw_device_ctx);\n\n    return 0;\n}\n\n```\n\n\n\n1. 验证我们设置的加速器是否正确\n\n2. 打开文件，解封装，读取视频流，解码器信息\n\n3. 获取解码器支持的硬件配置信息，遍历，找到我们设置的类型，保存目标颜色格式\n\n4. 创建解码器上下文，填充解码参数，通过`get_format`告知解码器目标颜色格式\n\n5. 创建加速器实例，告诉解码器使用我们创建的加速器实例\n\n6. 从文件中读视频帧，送入解码器\n\n7. 从解码器中读取frame，判断颜色格式，处理数据从GPU复制到CPU\n\n8. 去掉frame的字节对齐，写入输出文件中\n\n\n\n### 硬件加速器目标像素格式\n\n```\n    //遍历获取解码器对应的硬件配置信息\n    for (i = 0;; i++) {\n        const AVCodecHWConfig *config = avcodec_get_hw_config(decoder, i);\n        //如果没找到支持的config，结束程序\n        if (!config) {\n            fprintf(stderr, \"Decoder %s does not support device type %s.\\n\",\n                    decoder->name, av_hwdevice_get_type_name(type));\n            return -1;\n        }\n        /*\n         如果config的device_type匹配我们设置的类型，并且config的methods的值为AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX\n         保存支持的hw_pix_fmt，跳出循环\n         \n         关于AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX\n         如果我们选择了此种类型，需要在调用avcodec_open2()打开解码器之前，给AVCodecContext.hw_device_ctx设置正确的值。\n         */\n        \n        if (config->methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX &&\n            config->device_type == type) {\n            hw_pix_fmt = config->pix_fmt;\n            break;\n        }\n    }\n\n```\n\n\n\n告诉解码器，我们希望输出像素格式\n\n```\n    //get_format是一个函数指针，我们给ffmpeg提供一个函数，ffmpeg 调用该函数确定解码帧的数据格式\n    decoder_ctx->get_format  = get_hw_format;\n\n```\n\n get_hw_format\n\n```\nstatic enum AVPixelFormat get_hw_format(AVCodecContext *ctx,\n                                        const enum AVPixelFormat *pix_fmts)\n{\n    const enum AVPixelFormat *p;\n\n    for (p = pix_fmts; *p != -1; p++) {\n        if (*p == hw_pix_fmt)\n            return *p;\n    }\n\n    fprintf(stderr, \"Failed to get HW surface format.\\n\");\n    return AV_PIX_FMT_NONE;\n}\n\n```\n\n### 创建并设置加速器\n\n```\nstatic int hw_decoder_init(AVCodecContext *ctx, const enum AVHWDeviceType type)\n{\n    int err = 0;\n    //创建硬件加速器实例\n    if ((err = av_hwdevice_ctx_create(&hw_device_ctx, type,\n                                      NULL, NULL, 0)) < 0) {\n        fprintf(stderr, \"Failed to create specified HW device.\\n\");\n        return err;\n    }\n    //告诉解码器，使用我们创建的硬件加速器\n    ctx->hw_device_ctx = av_buffer_ref(hw_device_ctx);\n\n    return err;\n}\n\n\n```\n\n### 解码，数据从GPU到CPU\n\n```\nstatic int decode_write(AVCodecContext *avctx, AVPacket *packet)\n{\n    AVFrame *frame = NULL, *sw_frame = NULL;\n    AVFrame *tmp_frame = NULL;\n    uint8_t *buffer = NULL;\n    int size;\n    int ret = 0;\n\n    ret = avcodec_send_packet(avctx, packet);\n    if (ret < 0) {\n        fprintf(stderr, \"Error during decoding\\n\");\n        return ret;\n    }\n\n    while (1) {\n        if (!(frame = av_frame_alloc()) || !(sw_frame = av_frame_alloc())) {\n            fprintf(stderr, \"Can not alloc frame\\n\");\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n\n        ret = avcodec_receive_frame(avctx, frame);\n        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {\n            av_frame_free(&frame);\n            av_frame_free(&sw_frame);\n            return 0;\n        } else if (ret < 0) {\n            fprintf(stderr, \"Error while decoding\\n\");\n            goto fail;\n        }\n        /*\n         我们期待解码器能够解码出我们想要像素格式\n         如果解码器输出了我们想要的格式，由于使用了硬件加速，我们需要将数据从GPU拷贝到cpu\n         如果没有输出我们想要的格式，证明使用的是软件解码\n         */\n        if (frame->format == hw_pix_fmt) {\n            /* 将解码数据从GPU拷贝到CPU */\n            if ((ret = av_hwframe_transfer_data(sw_frame, frame, 0)) < 0) {\n                fprintf(stderr, \"Error transferring the data to system memory\\n\");\n                goto fail;\n            }\n            tmp_frame = sw_frame;\n        } else\n            tmp_frame = frame;\n        \n        //申请一个AVFrame, 将解码后的yuv/rgb，去掉字节对齐拷贝过来\n        size = av_image_get_buffer_size(tmp_frame->format, tmp_frame->width,\n                                        tmp_frame->height, 1);\n        buffer = av_malloc(size);\n        if (!buffer) {\n            fprintf(stderr, \"Can not alloc buffer\\n\");\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        //拷贝，去掉字节对齐\n        ret = av_image_copy_to_buffer(buffer, size,\n                                      (const uint8_t * const *)tmp_frame->data,\n                                      (const int *)tmp_frame->linesize, tmp_frame->format,\n                                      tmp_frame->width, tmp_frame->height, 1);\n        if (ret < 0) {\n            fprintf(stderr, \"Can not copy image to buffer\\n\");\n            goto fail;\n        }\n        //将已经去掉字节对齐的yuv/rgb数据，写入文件\n        if ((ret = fwrite(buffer, 1, size, output_file)) < 0) {\n            fprintf(stderr, \"Failed to dump raw data.\\n\");\n            goto fail;\n        }\n\n    fail:\n        av_frame_free(&frame);\n        av_frame_free(&sw_frame);\n        av_freep(&buffer);\n        if (ret < 0)\n            return ret;\n    }\n}\n```\n\n## 总结：\n\n1. 解码器配置的时候，需要告诉解码器我们使用的硬件加速器\n\n2. 与解码器商量输出的颜色格式\n\n3. 解码后处理，处理从GPU到CPU拷贝的内存拷贝\n\n\n\n\n","source":"_posts/ffmpeg/2022-03-14-ffmpeg example 学习 5.md","raw":"---\nlayout: post\ntitle: \"ffmpeg example 5.硬件解码\"\ndate: 2022-03-13 \ntag: ffmpeg\n---\n\n\n\n在`hw_decode.c`示例中，ffmpeg展示了如何使用硬件加速来解码视频，我们来分析一下是怎么实现的。\n\n\n\n## 硬件加速设备类型\n\n展示所有可用的硬件加速方法, 在mac上只找到了`videotoolbox`加速的方式。\n\n```shell\nffmpeg -hwaccels\nHardware acceleration methods:\nvideotoolbox\n```\n\n查看 AVHWDeviceType的定义，发现别的平台可以使用cuda，opencl， mediacodec，vulkan等来实现硬件加速。\n\n```\nenum AVHWDeviceType {\n    AV_HWDEVICE_TYPE_NONE,\n    AV_HWDEVICE_TYPE_VDPAU,\n    AV_HWDEVICE_TYPE_CUDA,\n    AV_HWDEVICE_TYPE_VAAPI,\n    AV_HWDEVICE_TYPE_DXVA2,\n    AV_HWDEVICE_TYPE_QSV,\n    AV_HWDEVICE_TYPE_VIDEOTOOLBOX,\n    AV_HWDEVICE_TYPE_D3D11VA,\n    AV_HWDEVICE_TYPE_DRM,\n    AV_HWDEVICE_TYPE_OPENCL,\n    AV_HWDEVICE_TYPE_MEDIACODEC,\n    AV_HWDEVICE_TYPE_VULKAN,\n};\n```\n\n## 源码分析\n\n 调用该示例程序。\n\n```\n./hw_decode videotoolbox /tmp/test.mp4 /tmp/test.yuv\n```\n\n1. 参数videotoolbox 指定使用的硬件加速方式，mac平台只找到这一种\n\n2. /tmp/test.mp4 指定要解封装的文件，从文件中读取h264进行解码\n\n3. /tmp/test.yuv 指定解码后写入的文件路径\n\n### main 函数\n\n```\nint main(int argc, char *argv[])\n{\n    AVFormatContext *input_ctx = NULL;\n    int video_stream, ret;\n    AVStream *video = NULL;\n    AVCodecContext *decoder_ctx = NULL;\n    const AVCodec *decoder = NULL;\n    AVPacket *packet = NULL;\n    enum AVHWDeviceType type;\n    int i;\n\n    if (argc < 4) {\n        fprintf(stderr, \"Usage: %s <device type> <input file> <output file>\\n\", argv[0]);\n        return -1;\n    }\n    //根据传入加速器名字，找到对应的type\n    type = av_hwdevice_find_type_by_name(argv[1]);\n    if (type == AV_HWDEVICE_TYPE_NONE) {\n        fprintf(stderr, \"Device type %s is not supported.\\n\", argv[1]);\n        fprintf(stderr, \"Available device types:\");\n        //没找到加速器，打印ffmepg 支持的加速器列表\n        while((type = av_hwdevice_iterate_types(type)) != AV_HWDEVICE_TYPE_NONE)\n            fprintf(stderr, \" %s\", av_hwdevice_get_type_name(type));\n        fprintf(stderr, \"\\n\");\n        return -1;\n    }\n    //申请packet保存解码前数据\n    packet = av_packet_alloc();\n    if (!packet) {\n        fprintf(stderr, \"Failed to allocate AVPacket\\n\");\n        return -1;\n    }\n\n    //打开输入的文件，关联到AVFormatContext\n    if (avformat_open_input(&input_ctx, argv[2], NULL, NULL) != 0) {\n        fprintf(stderr, \"Cannot open input file '%s'\\n\", argv[2]);\n        return -1;\n    }\n    //填充AVFormatContext，获取解封装信息\n    if (avformat_find_stream_info(input_ctx, NULL) < 0) {\n        fprintf(stderr, \"Cannot find input stream information.\\n\");\n        return -1;\n    }\n\n    //找到video 对应的stream index， 获取对应的解码器信息\n    ret = av_find_best_stream(input_ctx, AVMEDIA_TYPE_VIDEO, -1, -1, &decoder, 0);\n    if (ret < 0) {\n        fprintf(stderr, \"Cannot find a video stream in the input file\\n\");\n        return -1;\n    }\n    video_stream = ret;\n\n    //遍历获取解码器对应的硬件配置信息\n    for (i = 0;; i++) {\n        const AVCodecHWConfig *config = avcodec_get_hw_config(decoder, i);\n        //如果没找到支持的config，结束程序\n        if (!config) {\n            fprintf(stderr, \"Decoder %s does not support device type %s.\\n\",\n                    decoder->name, av_hwdevice_get_type_name(type));\n            return -1;\n        }\n        /*\n         如果config的device_type匹配我们设置的类型，并且config的methods的值为AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX\n         保存支持的hw_pix_fmt，跳出循环\n         \n         关于AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX\n         如果我们选择了此种类型，需要在调用avcodec_open2()打开解码器之前，给AVCodecContext.hw_device_ctx设置正确的值。\n         */\n        \n        if (config->methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX &&\n            config->device_type == type) {\n            hw_pix_fmt = config->pix_fmt;\n            break;\n        }\n    }\n    //创建解码器上下文\n    if (!(decoder_ctx = avcodec_alloc_context3(decoder)))\n        return AVERROR(ENOMEM);\n\n    video = input_ctx->streams[video_stream];\n    //给解码器上下文填充参数，复制从文件中读的的解码器参数\n    if (avcodec_parameters_to_context(decoder_ctx, video->codecpar) < 0)\n        return -1;\n    \n    //get_format是一个函数指针，我们给ffmpeg提供一个函数，ffmpeg 调用该函数确定解码帧的数据格式\n    decoder_ctx->get_format  = get_hw_format;\n\n    //根据AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX的定义，我们需要给ctx->hw_device_ctx赋值\n    if (hw_decoder_init(decoder_ctx, type) < 0)\n        return -1;\n    //打开解码器\n    if ((ret = avcodec_open2(decoder_ctx, decoder, NULL)) < 0) {\n        fprintf(stderr, \"Failed to open codec for stream #%u\\n\", video_stream);\n        return -1;\n    }\n\n    /* open the file to dump raw data */\n    output_file = fopen(argv[3], \"w+b\");\n\n    /* actual decoding and dump the raw data */\n    while (ret >= 0) {\n        //从文件中循环读视频帧，存入packet\n        if ((ret = av_read_frame(input_ctx, packet)) < 0)\n            break;\n\n        if (video_stream == packet->stream_index)\n            //解码packet，写文件\n            ret = decode_write(decoder_ctx, packet);\n\n        av_packet_unref(packet);\n    }\n    //冲洗解码器\n    /* flush the decoder */\n    ret = decode_write(decoder_ctx, NULL);\n\n    if (output_file)\n        fclose(output_file);\n    av_packet_free(&packet);\n    avcodec_free_context(&decoder_ctx);\n    avformat_close_input(&input_ctx);\n    av_buffer_unref(&hw_device_ctx);\n\n    return 0;\n}\n\n```\n\n\n\n1. 验证我们设置的加速器是否正确\n\n2. 打开文件，解封装，读取视频流，解码器信息\n\n3. 获取解码器支持的硬件配置信息，遍历，找到我们设置的类型，保存目标颜色格式\n\n4. 创建解码器上下文，填充解码参数，通过`get_format`告知解码器目标颜色格式\n\n5. 创建加速器实例，告诉解码器使用我们创建的加速器实例\n\n6. 从文件中读视频帧，送入解码器\n\n7. 从解码器中读取frame，判断颜色格式，处理数据从GPU复制到CPU\n\n8. 去掉frame的字节对齐，写入输出文件中\n\n\n\n### 硬件加速器目标像素格式\n\n```\n    //遍历获取解码器对应的硬件配置信息\n    for (i = 0;; i++) {\n        const AVCodecHWConfig *config = avcodec_get_hw_config(decoder, i);\n        //如果没找到支持的config，结束程序\n        if (!config) {\n            fprintf(stderr, \"Decoder %s does not support device type %s.\\n\",\n                    decoder->name, av_hwdevice_get_type_name(type));\n            return -1;\n        }\n        /*\n         如果config的device_type匹配我们设置的类型，并且config的methods的值为AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX\n         保存支持的hw_pix_fmt，跳出循环\n         \n         关于AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX\n         如果我们选择了此种类型，需要在调用avcodec_open2()打开解码器之前，给AVCodecContext.hw_device_ctx设置正确的值。\n         */\n        \n        if (config->methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX &&\n            config->device_type == type) {\n            hw_pix_fmt = config->pix_fmt;\n            break;\n        }\n    }\n\n```\n\n\n\n告诉解码器，我们希望输出像素格式\n\n```\n    //get_format是一个函数指针，我们给ffmpeg提供一个函数，ffmpeg 调用该函数确定解码帧的数据格式\n    decoder_ctx->get_format  = get_hw_format;\n\n```\n\n get_hw_format\n\n```\nstatic enum AVPixelFormat get_hw_format(AVCodecContext *ctx,\n                                        const enum AVPixelFormat *pix_fmts)\n{\n    const enum AVPixelFormat *p;\n\n    for (p = pix_fmts; *p != -1; p++) {\n        if (*p == hw_pix_fmt)\n            return *p;\n    }\n\n    fprintf(stderr, \"Failed to get HW surface format.\\n\");\n    return AV_PIX_FMT_NONE;\n}\n\n```\n\n### 创建并设置加速器\n\n```\nstatic int hw_decoder_init(AVCodecContext *ctx, const enum AVHWDeviceType type)\n{\n    int err = 0;\n    //创建硬件加速器实例\n    if ((err = av_hwdevice_ctx_create(&hw_device_ctx, type,\n                                      NULL, NULL, 0)) < 0) {\n        fprintf(stderr, \"Failed to create specified HW device.\\n\");\n        return err;\n    }\n    //告诉解码器，使用我们创建的硬件加速器\n    ctx->hw_device_ctx = av_buffer_ref(hw_device_ctx);\n\n    return err;\n}\n\n\n```\n\n### 解码，数据从GPU到CPU\n\n```\nstatic int decode_write(AVCodecContext *avctx, AVPacket *packet)\n{\n    AVFrame *frame = NULL, *sw_frame = NULL;\n    AVFrame *tmp_frame = NULL;\n    uint8_t *buffer = NULL;\n    int size;\n    int ret = 0;\n\n    ret = avcodec_send_packet(avctx, packet);\n    if (ret < 0) {\n        fprintf(stderr, \"Error during decoding\\n\");\n        return ret;\n    }\n\n    while (1) {\n        if (!(frame = av_frame_alloc()) || !(sw_frame = av_frame_alloc())) {\n            fprintf(stderr, \"Can not alloc frame\\n\");\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n\n        ret = avcodec_receive_frame(avctx, frame);\n        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {\n            av_frame_free(&frame);\n            av_frame_free(&sw_frame);\n            return 0;\n        } else if (ret < 0) {\n            fprintf(stderr, \"Error while decoding\\n\");\n            goto fail;\n        }\n        /*\n         我们期待解码器能够解码出我们想要像素格式\n         如果解码器输出了我们想要的格式，由于使用了硬件加速，我们需要将数据从GPU拷贝到cpu\n         如果没有输出我们想要的格式，证明使用的是软件解码\n         */\n        if (frame->format == hw_pix_fmt) {\n            /* 将解码数据从GPU拷贝到CPU */\n            if ((ret = av_hwframe_transfer_data(sw_frame, frame, 0)) < 0) {\n                fprintf(stderr, \"Error transferring the data to system memory\\n\");\n                goto fail;\n            }\n            tmp_frame = sw_frame;\n        } else\n            tmp_frame = frame;\n        \n        //申请一个AVFrame, 将解码后的yuv/rgb，去掉字节对齐拷贝过来\n        size = av_image_get_buffer_size(tmp_frame->format, tmp_frame->width,\n                                        tmp_frame->height, 1);\n        buffer = av_malloc(size);\n        if (!buffer) {\n            fprintf(stderr, \"Can not alloc buffer\\n\");\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        //拷贝，去掉字节对齐\n        ret = av_image_copy_to_buffer(buffer, size,\n                                      (const uint8_t * const *)tmp_frame->data,\n                                      (const int *)tmp_frame->linesize, tmp_frame->format,\n                                      tmp_frame->width, tmp_frame->height, 1);\n        if (ret < 0) {\n            fprintf(stderr, \"Can not copy image to buffer\\n\");\n            goto fail;\n        }\n        //将已经去掉字节对齐的yuv/rgb数据，写入文件\n        if ((ret = fwrite(buffer, 1, size, output_file)) < 0) {\n            fprintf(stderr, \"Failed to dump raw data.\\n\");\n            goto fail;\n        }\n\n    fail:\n        av_frame_free(&frame);\n        av_frame_free(&sw_frame);\n        av_freep(&buffer);\n        if (ret < 0)\n            return ret;\n    }\n}\n```\n\n## 总结：\n\n1. 解码器配置的时候，需要告诉解码器我们使用的硬件加速器\n\n2. 与解码器商量输出的颜色格式\n\n3. 解码后处理，处理从GPU到CPU拷贝的内存拷贝\n\n\n\n\n","slug":"ffmpeg/2022-03-14-ffmpeg example 学习 5","published":1,"updated":"2024-03-06T11:53:13.565Z","comments":1,"photos":[],"_id":"cltgopend001vqywh52ab4wv1","content":"<p>在<code>hw_decode.c</code>示例中，ffmpeg展示了如何使用硬件加速来解码视频，我们来分析一下是怎么实现的。</p>\n<h2 id=\"硬件加速设备类型\"><a href=\"#硬件加速设备类型\" class=\"headerlink\" title=\"硬件加速设备类型\"></a>硬件加速设备类型</h2><p>展示所有可用的硬件加速方法, 在mac上只找到了<code>videotoolbox</code>加速的方式。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">ffmpeg -hwaccels<br>Hardware acceleration methods:<br>videotoolbox<br></code></pre></td></tr></table></figure>\n\n<p>查看 AVHWDeviceType的定义，发现别的平台可以使用cuda，opencl， mediacodec，vulkan等来实现硬件加速。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-built_in\">AVHWDeviceType</span> &#123;<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_NONE</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_VDPAU</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_CUDA</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_VAAPI</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_DXVA2</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_QSV</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_VIDEOTOOLBOX</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_D3D11VA</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_DRM</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_OPENCL</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_MEDIACODEC</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_VULKAN</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><p> 调用该示例程序。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">./hw_decode videotoolbox /tmp/test.mp4 /tmp/test.yuv<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>参数videotoolbox 指定使用的硬件加速方式，mac平台只找到这一种</p>\n</li>\n<li><p>&#x2F;tmp&#x2F;test.mp4 指定要解封装的文件，从文件中读取h264进行解码</p>\n</li>\n<li><p>&#x2F;tmp&#x2F;test.yuv 指定解码后写入的文件路径</p>\n</li>\n</ol>\n<h3 id=\"main-函数\"><a href=\"#main-函数\" class=\"headerlink\" title=\"main 函数\"></a>main 函数</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    AVFormatContext *input_ctx = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-type\">int</span> video_stream, ret;<br>    AVStream *video = <span class=\"hljs-literal\">NULL</span>;<br>    AVCodecContext *decoder_ctx = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-type\">const</span> AVCodec *decoder = <span class=\"hljs-literal\">NULL</span>;<br>    AVPacket *packet = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">AVHWDeviceType</span> type;<br>    <span class=\"hljs-type\">int</span> i;<br><br>    <span class=\"hljs-keyword\">if</span> (argc &lt; <span class=\"hljs-number\">4</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Usage: %s &lt;device type&gt; &lt;input file&gt; &lt;output file&gt;\\n&quot;</span>, argv[<span class=\"hljs-number\">0</span>]);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">//根据传入加速器名字，找到对应的type</span><br>    type = <span class=\"hljs-built_in\">av_hwdevice_find_type_by_name</span>(argv[<span class=\"hljs-number\">1</span>]);<br>    <span class=\"hljs-keyword\">if</span> (type == AV_HWDEVICE_TYPE_NONE) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Device type %s is not supported.\\n&quot;</span>, argv[<span class=\"hljs-number\">1</span>]);<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Available device types:&quot;</span>);<br>        <span class=\"hljs-comment\">//没找到加速器，打印ffmepg 支持的加速器列表</span><br>        <span class=\"hljs-keyword\">while</span>((type = <span class=\"hljs-built_in\">av_hwdevice_iterate_types</span>(type)) != AV_HWDEVICE_TYPE_NONE)<br>            <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot; %s&quot;</span>, <span class=\"hljs-built_in\">av_hwdevice_get_type_name</span>(type));<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">//申请packet保存解码前数据</span><br>    packet = <span class=\"hljs-built_in\">av_packet_alloc</span>();<br>    <span class=\"hljs-keyword\">if</span> (!packet) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Failed to allocate AVPacket\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">//打开输入的文件，关联到AVFormatContext</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">avformat_open_input</span>(&amp;input_ctx, argv[<span class=\"hljs-number\">2</span>], <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-literal\">NULL</span>) != <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Cannot open input file &#x27;%s&#x27;\\n&quot;</span>, argv[<span class=\"hljs-number\">2</span>]);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">//填充AVFormatContext，获取解封装信息</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">avformat_find_stream_info</span>(input_ctx, <span class=\"hljs-literal\">NULL</span>) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Cannot find input stream information.\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">//找到video 对应的stream index， 获取对应的解码器信息</span><br>    ret = <span class=\"hljs-built_in\">av_find_best_stream</span>(input_ctx, AVMEDIA_TYPE_VIDEO, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>, &amp;decoder, <span class=\"hljs-number\">0</span>);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Cannot find a video stream in the input file\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br>    video_stream = ret;<br><br>    <span class=\"hljs-comment\">//遍历获取解码器对应的硬件配置信息</span><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>;; i++) &#123;<br>        <span class=\"hljs-type\">const</span> AVCodecHWConfig *config = <span class=\"hljs-built_in\">avcodec_get_hw_config</span>(decoder, i);<br>        <span class=\"hljs-comment\">//如果没找到支持的config，结束程序</span><br>        <span class=\"hljs-keyword\">if</span> (!config) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Decoder %s does not support device type %s.\\n&quot;</span>,<br>                    decoder-&gt;name, <span class=\"hljs-built_in\">av_hwdevice_get_type_name</span>(type));<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>        &#125;<br>        <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">         如果config的device_type匹配我们设置的类型，并且config的methods的值为AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX</span><br><span class=\"hljs-comment\">         保存支持的hw_pix_fmt，跳出循环</span><br><span class=\"hljs-comment\">         </span><br><span class=\"hljs-comment\">         关于AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX</span><br><span class=\"hljs-comment\">         如果我们选择了此种类型，需要在调用avcodec_open2()打开解码器之前，给AVCodecContext.hw_device_ctx设置正确的值。</span><br><span class=\"hljs-comment\">         */</span><br>        <br>        <span class=\"hljs-keyword\">if</span> (config-&gt;methods &amp; AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX &amp;&amp;<br>            config-&gt;device_type == type) &#123;<br>            hw_pix_fmt = config-&gt;pix_fmt;<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">//创建解码器上下文</span><br>    <span class=\"hljs-keyword\">if</span> (!(decoder_ctx = <span class=\"hljs-built_in\">avcodec_alloc_context3</span>(decoder)))<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">AVERROR</span>(ENOMEM);<br><br>    video = input_ctx-&gt;streams[video_stream];<br>    <span class=\"hljs-comment\">//给解码器上下文填充参数，复制从文件中读的的解码器参数</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">avcodec_parameters_to_context</span>(decoder_ctx, video-&gt;codecpar) &lt; <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    <br>    <span class=\"hljs-comment\">//get_format是一个函数指针，我们给ffmpeg提供一个函数，ffmpeg 调用该函数确定解码帧的数据格式</span><br>    decoder_ctx-&gt;get_format  = get_hw_format;<br><br>    <span class=\"hljs-comment\">//根据AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX的定义，我们需要给ctx-&gt;hw_device_ctx赋值</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">hw_decoder_init</span>(decoder_ctx, type) &lt; <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    <span class=\"hljs-comment\">//打开解码器</span><br>    <span class=\"hljs-keyword\">if</span> ((ret = <span class=\"hljs-built_in\">avcodec_open2</span>(decoder_ctx, decoder, <span class=\"hljs-literal\">NULL</span>)) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Failed to open codec for stream #%u\\n&quot;</span>, video_stream);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* open the file to dump raw data */</span><br>    output_file = <span class=\"hljs-built_in\">fopen</span>(argv[<span class=\"hljs-number\">3</span>], <span class=\"hljs-string\">&quot;w+b&quot;</span>);<br><br>    <span class=\"hljs-comment\">/* actual decoding and dump the raw data */</span><br>    <span class=\"hljs-keyword\">while</span> (ret &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-comment\">//从文件中循环读视频帧，存入packet</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = <span class=\"hljs-built_in\">av_read_frame</span>(input_ctx, packet)) &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">break</span>;<br><br>        <span class=\"hljs-keyword\">if</span> (video_stream == packet-&gt;stream_index)<br>            <span class=\"hljs-comment\">//解码packet，写文件</span><br>            ret = <span class=\"hljs-built_in\">decode_write</span>(decoder_ctx, packet);<br><br>        <span class=\"hljs-built_in\">av_packet_unref</span>(packet);<br>    &#125;<br>    <span class=\"hljs-comment\">//冲洗解码器</span><br>    <span class=\"hljs-comment\">/* flush the decoder */</span><br>    ret = <span class=\"hljs-built_in\">decode_write</span>(decoder_ctx, <span class=\"hljs-literal\">NULL</span>);<br><br>    <span class=\"hljs-keyword\">if</span> (output_file)<br>        <span class=\"hljs-built_in\">fclose</span>(output_file);<br>    <span class=\"hljs-built_in\">av_packet_free</span>(&amp;packet);<br>    <span class=\"hljs-built_in\">avcodec_free_context</span>(&amp;decoder_ctx);<br>    <span class=\"hljs-built_in\">avformat_close_input</span>(&amp;input_ctx);<br>    <span class=\"hljs-built_in\">av_buffer_unref</span>(&amp;hw_device_ctx);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li><p>验证我们设置的加速器是否正确</p>\n</li>\n<li><p>打开文件，解封装，读取视频流，解码器信息</p>\n</li>\n<li><p>获取解码器支持的硬件配置信息，遍历，找到我们设置的类型，保存目标颜色格式</p>\n</li>\n<li><p>创建解码器上下文，填充解码参数，通过<code>get_format</code>告知解码器目标颜色格式</p>\n</li>\n<li><p>创建加速器实例，告诉解码器使用我们创建的加速器实例</p>\n</li>\n<li><p>从文件中读视频帧，送入解码器</p>\n</li>\n<li><p>从解码器中读取frame，判断颜色格式，处理数据从GPU复制到CPU</p>\n</li>\n<li><p>去掉frame的字节对齐，写入输出文件中</p>\n</li>\n</ol>\n<h3 id=\"硬件加速器目标像素格式\"><a href=\"#硬件加速器目标像素格式\" class=\"headerlink\" title=\"硬件加速器目标像素格式\"></a>硬件加速器目标像素格式</h3><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\"><span class=\"hljs-comment\">//遍历获取解码器对应的硬件配置信息</span><br><span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>;; i++) &#123;<br>    <span class=\"hljs-keyword\">const</span> AVCodecHWConfig *<span class=\"hljs-keyword\">config</span> = avcodec_get_hw_config(decoder, i);<br>    <span class=\"hljs-comment\">//如果没找到支持的config，结束程序</span><br>    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">config</span>) &#123;<br>        fprintf(stderr, <span class=\"hljs-string\">&quot;Decoder %s does not support device type %s.\\n&quot;</span>,<br>                decoder-&gt;name, av_hwdevice_get_type_name(<span class=\"hljs-keyword\">type</span>));<br>        <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">     如果config的device_type匹配我们设置的类型，并且config的methods的值为AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX</span><br><span class=\"hljs-comment\">     保存支持的hw_pix_fmt，跳出循环</span><br><span class=\"hljs-comment\">     </span><br><span class=\"hljs-comment\">     关于AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX</span><br><span class=\"hljs-comment\">     如果我们选择了此种类型，需要在调用avcodec_open2()打开解码器之前，给AVCodecContext.hw_device_ctx设置正确的值。</span><br><span class=\"hljs-comment\">     */</span><br>    <br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">config</span>-&gt;methods &amp; AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX &amp;&amp;<br>        <span class=\"hljs-keyword\">config</span>-&gt;device_type == <span class=\"hljs-keyword\">type</span>) &#123;<br>        hw_pix_fmt = <span class=\"hljs-keyword\">config</span>-&gt;pix_fmt;<br>        <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<p>告诉解码器，我们希望输出像素格式</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"><span class=\"hljs-comment\">//get_format是一个函数指针，我们给ffmpeg提供一个函数，ffmpeg 调用该函数确定解码帧的数据格式</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">decoder_ctx</span>-&gt;</span>get_format  = get_hw_format;<br><br></code></pre></td></tr></table></figure>\n\n<p> get_hw_format</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-built_in\">AVPixelFormat</span> get_hw_format(<span class=\"hljs-built_in\">AVCodecContext</span> *ctx,<br>                                        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-built_in\">AVPixelFormat</span> *pix_fmts)<br>&#123;<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-built_in\">AVPixelFormat</span> *p;<br><br>    <span class=\"hljs-keyword\">for</span> (p = pix_fmts; *p != <span class=\"hljs-number\">-1</span>; p++) &#123;<br>        <span class=\"hljs-keyword\">if</span> (*p == hw_pix_fmt)<br>            <span class=\"hljs-keyword\">return</span> *p;<br>    &#125;<br><br>    fprintf(stderr, <span class=\"hljs-string\">&quot;Failed to get HW surface format.\\n&quot;</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">AV_PIX_FMT_NONE</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"创建并设置加速器\"><a href=\"#创建并设置加速器\" class=\"headerlink\" title=\"创建并设置加速器\"></a>创建并设置加速器</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">hw_decoder_init</span><span class=\"hljs-params\">(AVCodecContext *ctx, <span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">enum</span> AVHWDeviceType type)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> err = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-comment\">//创建硬件加速器实例</span><br>    <span class=\"hljs-keyword\">if</span> ((err = <span class=\"hljs-built_in\">av_hwdevice_ctx_create</span>(&amp;hw_device_ctx, type,<br>                                      <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>)) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Failed to create specified HW device.\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> err;<br>    &#125;<br>    <span class=\"hljs-comment\">//告诉解码器，使用我们创建的硬件加速器</span><br>    ctx-&gt;hw_device_ctx = <span class=\"hljs-built_in\">av_buffer_ref</span>(hw_device_ctx);<br><br>    <span class=\"hljs-keyword\">return</span> err;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"解码，数据从GPU到CPU\"><a href=\"#解码，数据从GPU到CPU\" class=\"headerlink\" title=\"解码，数据从GPU到CPU\"></a>解码，数据从GPU到CPU</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">decode_write</span><span class=\"hljs-params\">(AVCodecContext *avctx, AVPacket *packet)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    AVFrame *frame = <span class=\"hljs-literal\">NULL</span>, *sw_frame = <span class=\"hljs-literal\">NULL</span>;<br>    AVFrame *tmp_frame = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-type\">uint8_t</span> *buffer = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-type\">int</span> size;<br>    <span class=\"hljs-type\">int</span> ret = <span class=\"hljs-number\">0</span>;<br><br>    ret = <span class=\"hljs-built_in\">avcodec_send_packet</span>(avctx, packet);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Error during decoding\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (!(frame = <span class=\"hljs-built_in\">av_frame_alloc</span>()) || !(sw_frame = <span class=\"hljs-built_in\">av_frame_alloc</span>())) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Can not alloc frame\\n&quot;</span>);<br>            ret = <span class=\"hljs-built_in\">AVERROR</span>(ENOMEM);<br>            <span class=\"hljs-keyword\">goto</span> fail;<br>        &#125;<br><br>        ret = <span class=\"hljs-built_in\">avcodec_receive_frame</span>(avctx, frame);<br>        <span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-built_in\">AVERROR</span>(EAGAIN) || ret == AVERROR_EOF) &#123;<br>            <span class=\"hljs-built_in\">av_frame_free</span>(&amp;frame);<br>            <span class=\"hljs-built_in\">av_frame_free</span>(&amp;sw_frame);<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Error while decoding\\n&quot;</span>);<br>            <span class=\"hljs-keyword\">goto</span> fail;<br>        &#125;<br>        <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">         我们期待解码器能够解码出我们想要像素格式</span><br><span class=\"hljs-comment\">         如果解码器输出了我们想要的格式，由于使用了硬件加速，我们需要将数据从GPU拷贝到cpu</span><br><span class=\"hljs-comment\">         如果没有输出我们想要的格式，证明使用的是软件解码</span><br><span class=\"hljs-comment\">         */</span><br>        <span class=\"hljs-keyword\">if</span> (frame-&gt;format == hw_pix_fmt) &#123;<br>            <span class=\"hljs-comment\">/* 将解码数据从GPU拷贝到CPU */</span><br>            <span class=\"hljs-keyword\">if</span> ((ret = <span class=\"hljs-built_in\">av_hwframe_transfer_data</span>(sw_frame, frame, <span class=\"hljs-number\">0</span>)) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>                <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Error transferring the data to system memory\\n&quot;</span>);<br>                <span class=\"hljs-keyword\">goto</span> fail;<br>            &#125;<br>            tmp_frame = sw_frame;<br>        &#125; <span class=\"hljs-keyword\">else</span><br>            tmp_frame = frame;<br>        <br>        <span class=\"hljs-comment\">//申请一个AVFrame, 将解码后的yuv/rgb，去掉字节对齐拷贝过来</span><br>        size = <span class=\"hljs-built_in\">av_image_get_buffer_size</span>(tmp_frame-&gt;format, tmp_frame-&gt;width,<br>                                        tmp_frame-&gt;height, <span class=\"hljs-number\">1</span>);<br>        buffer = <span class=\"hljs-built_in\">av_malloc</span>(size);<br>        <span class=\"hljs-keyword\">if</span> (!buffer) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Can not alloc buffer\\n&quot;</span>);<br>            ret = <span class=\"hljs-built_in\">AVERROR</span>(ENOMEM);<br>            <span class=\"hljs-keyword\">goto</span> fail;<br>        &#125;<br>        <span class=\"hljs-comment\">//拷贝，去掉字节对齐</span><br>        ret = <span class=\"hljs-built_in\">av_image_copy_to_buffer</span>(buffer, size,<br>                                      (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint8_t</span> * <span class=\"hljs-type\">const</span> *)tmp_frame-&gt;data,<br>                                      (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *)tmp_frame-&gt;linesize, tmp_frame-&gt;format,<br>                                      tmp_frame-&gt;width, tmp_frame-&gt;height, <span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Can not copy image to buffer\\n&quot;</span>);<br>            <span class=\"hljs-keyword\">goto</span> fail;<br>        &#125;<br>        <span class=\"hljs-comment\">//将已经去掉字节对齐的yuv/rgb数据，写入文件</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = <span class=\"hljs-built_in\">fwrite</span>(buffer, <span class=\"hljs-number\">1</span>, size, output_file)) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Failed to dump raw data.\\n&quot;</span>);<br>            <span class=\"hljs-keyword\">goto</span> fail;<br>        &#125;<br><br>    fail:<br>        <span class=\"hljs-built_in\">av_frame_free</span>(&amp;frame);<br>        <span class=\"hljs-built_in\">av_frame_free</span>(&amp;sw_frame);<br>        <span class=\"hljs-built_in\">av_freep</span>(&amp;buffer);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ol>\n<li><p>解码器配置的时候，需要告诉解码器我们使用的硬件加速器</p>\n</li>\n<li><p>与解码器商量输出的颜色格式</p>\n</li>\n<li><p>解码后处理，处理从GPU到CPU拷贝的内存拷贝</p>\n</li>\n</ol>\n","excerpt":"","more":"<p>在<code>hw_decode.c</code>示例中，ffmpeg展示了如何使用硬件加速来解码视频，我们来分析一下是怎么实现的。</p>\n<h2 id=\"硬件加速设备类型\"><a href=\"#硬件加速设备类型\" class=\"headerlink\" title=\"硬件加速设备类型\"></a>硬件加速设备类型</h2><p>展示所有可用的硬件加速方法, 在mac上只找到了<code>videotoolbox</code>加速的方式。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">ffmpeg -hwaccels<br>Hardware acceleration methods:<br>videotoolbox<br></code></pre></td></tr></table></figure>\n\n<p>查看 AVHWDeviceType的定义，发现别的平台可以使用cuda，opencl， mediacodec，vulkan等来实现硬件加速。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-built_in\">AVHWDeviceType</span> &#123;<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_NONE</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_VDPAU</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_CUDA</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_VAAPI</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_DXVA2</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_QSV</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_VIDEOTOOLBOX</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_D3D11VA</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_DRM</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_OPENCL</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_MEDIACODEC</span>,<br>    <span class=\"hljs-built_in\">AV_HWDEVICE_TYPE_VULKAN</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><p> 调用该示例程序。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">./hw_decode videotoolbox /tmp/test.mp4 /tmp/test.yuv<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>参数videotoolbox 指定使用的硬件加速方式，mac平台只找到这一种</p>\n</li>\n<li><p>&#x2F;tmp&#x2F;test.mp4 指定要解封装的文件，从文件中读取h264进行解码</p>\n</li>\n<li><p>&#x2F;tmp&#x2F;test.yuv 指定解码后写入的文件路径</p>\n</li>\n</ol>\n<h3 id=\"main-函数\"><a href=\"#main-函数\" class=\"headerlink\" title=\"main 函数\"></a>main 函数</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    AVFormatContext *input_ctx = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-type\">int</span> video_stream, ret;<br>    AVStream *video = <span class=\"hljs-literal\">NULL</span>;<br>    AVCodecContext *decoder_ctx = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-type\">const</span> AVCodec *decoder = <span class=\"hljs-literal\">NULL</span>;<br>    AVPacket *packet = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">AVHWDeviceType</span> type;<br>    <span class=\"hljs-type\">int</span> i;<br><br>    <span class=\"hljs-keyword\">if</span> (argc &lt; <span class=\"hljs-number\">4</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Usage: %s &lt;device type&gt; &lt;input file&gt; &lt;output file&gt;\\n&quot;</span>, argv[<span class=\"hljs-number\">0</span>]);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">//根据传入加速器名字，找到对应的type</span><br>    type = <span class=\"hljs-built_in\">av_hwdevice_find_type_by_name</span>(argv[<span class=\"hljs-number\">1</span>]);<br>    <span class=\"hljs-keyword\">if</span> (type == AV_HWDEVICE_TYPE_NONE) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Device type %s is not supported.\\n&quot;</span>, argv[<span class=\"hljs-number\">1</span>]);<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Available device types:&quot;</span>);<br>        <span class=\"hljs-comment\">//没找到加速器，打印ffmepg 支持的加速器列表</span><br>        <span class=\"hljs-keyword\">while</span>((type = <span class=\"hljs-built_in\">av_hwdevice_iterate_types</span>(type)) != AV_HWDEVICE_TYPE_NONE)<br>            <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot; %s&quot;</span>, <span class=\"hljs-built_in\">av_hwdevice_get_type_name</span>(type));<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">//申请packet保存解码前数据</span><br>    packet = <span class=\"hljs-built_in\">av_packet_alloc</span>();<br>    <span class=\"hljs-keyword\">if</span> (!packet) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Failed to allocate AVPacket\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">//打开输入的文件，关联到AVFormatContext</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">avformat_open_input</span>(&amp;input_ctx, argv[<span class=\"hljs-number\">2</span>], <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-literal\">NULL</span>) != <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Cannot open input file &#x27;%s&#x27;\\n&quot;</span>, argv[<span class=\"hljs-number\">2</span>]);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">//填充AVFormatContext，获取解封装信息</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">avformat_find_stream_info</span>(input_ctx, <span class=\"hljs-literal\">NULL</span>) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Cannot find input stream information.\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">//找到video 对应的stream index， 获取对应的解码器信息</span><br>    ret = <span class=\"hljs-built_in\">av_find_best_stream</span>(input_ctx, AVMEDIA_TYPE_VIDEO, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>, &amp;decoder, <span class=\"hljs-number\">0</span>);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Cannot find a video stream in the input file\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br>    video_stream = ret;<br><br>    <span class=\"hljs-comment\">//遍历获取解码器对应的硬件配置信息</span><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>;; i++) &#123;<br>        <span class=\"hljs-type\">const</span> AVCodecHWConfig *config = <span class=\"hljs-built_in\">avcodec_get_hw_config</span>(decoder, i);<br>        <span class=\"hljs-comment\">//如果没找到支持的config，结束程序</span><br>        <span class=\"hljs-keyword\">if</span> (!config) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Decoder %s does not support device type %s.\\n&quot;</span>,<br>                    decoder-&gt;name, <span class=\"hljs-built_in\">av_hwdevice_get_type_name</span>(type));<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>        &#125;<br>        <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">         如果config的device_type匹配我们设置的类型，并且config的methods的值为AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX</span><br><span class=\"hljs-comment\">         保存支持的hw_pix_fmt，跳出循环</span><br><span class=\"hljs-comment\">         </span><br><span class=\"hljs-comment\">         关于AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX</span><br><span class=\"hljs-comment\">         如果我们选择了此种类型，需要在调用avcodec_open2()打开解码器之前，给AVCodecContext.hw_device_ctx设置正确的值。</span><br><span class=\"hljs-comment\">         */</span><br>        <br>        <span class=\"hljs-keyword\">if</span> (config-&gt;methods &amp; AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX &amp;&amp;<br>            config-&gt;device_type == type) &#123;<br>            hw_pix_fmt = config-&gt;pix_fmt;<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">//创建解码器上下文</span><br>    <span class=\"hljs-keyword\">if</span> (!(decoder_ctx = <span class=\"hljs-built_in\">avcodec_alloc_context3</span>(decoder)))<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">AVERROR</span>(ENOMEM);<br><br>    video = input_ctx-&gt;streams[video_stream];<br>    <span class=\"hljs-comment\">//给解码器上下文填充参数，复制从文件中读的的解码器参数</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">avcodec_parameters_to_context</span>(decoder_ctx, video-&gt;codecpar) &lt; <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    <br>    <span class=\"hljs-comment\">//get_format是一个函数指针，我们给ffmpeg提供一个函数，ffmpeg 调用该函数确定解码帧的数据格式</span><br>    decoder_ctx-&gt;get_format  = get_hw_format;<br><br>    <span class=\"hljs-comment\">//根据AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX的定义，我们需要给ctx-&gt;hw_device_ctx赋值</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">hw_decoder_init</span>(decoder_ctx, type) &lt; <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    <span class=\"hljs-comment\">//打开解码器</span><br>    <span class=\"hljs-keyword\">if</span> ((ret = <span class=\"hljs-built_in\">avcodec_open2</span>(decoder_ctx, decoder, <span class=\"hljs-literal\">NULL</span>)) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Failed to open codec for stream #%u\\n&quot;</span>, video_stream);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* open the file to dump raw data */</span><br>    output_file = <span class=\"hljs-built_in\">fopen</span>(argv[<span class=\"hljs-number\">3</span>], <span class=\"hljs-string\">&quot;w+b&quot;</span>);<br><br>    <span class=\"hljs-comment\">/* actual decoding and dump the raw data */</span><br>    <span class=\"hljs-keyword\">while</span> (ret &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-comment\">//从文件中循环读视频帧，存入packet</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = <span class=\"hljs-built_in\">av_read_frame</span>(input_ctx, packet)) &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">break</span>;<br><br>        <span class=\"hljs-keyword\">if</span> (video_stream == packet-&gt;stream_index)<br>            <span class=\"hljs-comment\">//解码packet，写文件</span><br>            ret = <span class=\"hljs-built_in\">decode_write</span>(decoder_ctx, packet);<br><br>        <span class=\"hljs-built_in\">av_packet_unref</span>(packet);<br>    &#125;<br>    <span class=\"hljs-comment\">//冲洗解码器</span><br>    <span class=\"hljs-comment\">/* flush the decoder */</span><br>    ret = <span class=\"hljs-built_in\">decode_write</span>(decoder_ctx, <span class=\"hljs-literal\">NULL</span>);<br><br>    <span class=\"hljs-keyword\">if</span> (output_file)<br>        <span class=\"hljs-built_in\">fclose</span>(output_file);<br>    <span class=\"hljs-built_in\">av_packet_free</span>(&amp;packet);<br>    <span class=\"hljs-built_in\">avcodec_free_context</span>(&amp;decoder_ctx);<br>    <span class=\"hljs-built_in\">avformat_close_input</span>(&amp;input_ctx);<br>    <span class=\"hljs-built_in\">av_buffer_unref</span>(&amp;hw_device_ctx);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li><p>验证我们设置的加速器是否正确</p>\n</li>\n<li><p>打开文件，解封装，读取视频流，解码器信息</p>\n</li>\n<li><p>获取解码器支持的硬件配置信息，遍历，找到我们设置的类型，保存目标颜色格式</p>\n</li>\n<li><p>创建解码器上下文，填充解码参数，通过<code>get_format</code>告知解码器目标颜色格式</p>\n</li>\n<li><p>创建加速器实例，告诉解码器使用我们创建的加速器实例</p>\n</li>\n<li><p>从文件中读视频帧，送入解码器</p>\n</li>\n<li><p>从解码器中读取frame，判断颜色格式，处理数据从GPU复制到CPU</p>\n</li>\n<li><p>去掉frame的字节对齐，写入输出文件中</p>\n</li>\n</ol>\n<h3 id=\"硬件加速器目标像素格式\"><a href=\"#硬件加速器目标像素格式\" class=\"headerlink\" title=\"硬件加速器目标像素格式\"></a>硬件加速器目标像素格式</h3><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\"><span class=\"hljs-comment\">//遍历获取解码器对应的硬件配置信息</span><br><span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>;; i++) &#123;<br>    <span class=\"hljs-keyword\">const</span> AVCodecHWConfig *<span class=\"hljs-keyword\">config</span> = avcodec_get_hw_config(decoder, i);<br>    <span class=\"hljs-comment\">//如果没找到支持的config，结束程序</span><br>    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">config</span>) &#123;<br>        fprintf(stderr, <span class=\"hljs-string\">&quot;Decoder %s does not support device type %s.\\n&quot;</span>,<br>                decoder-&gt;name, av_hwdevice_get_type_name(<span class=\"hljs-keyword\">type</span>));<br>        <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">     如果config的device_type匹配我们设置的类型，并且config的methods的值为AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX</span><br><span class=\"hljs-comment\">     保存支持的hw_pix_fmt，跳出循环</span><br><span class=\"hljs-comment\">     </span><br><span class=\"hljs-comment\">     关于AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX</span><br><span class=\"hljs-comment\">     如果我们选择了此种类型，需要在调用avcodec_open2()打开解码器之前，给AVCodecContext.hw_device_ctx设置正确的值。</span><br><span class=\"hljs-comment\">     */</span><br>    <br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">config</span>-&gt;methods &amp; AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX &amp;&amp;<br>        <span class=\"hljs-keyword\">config</span>-&gt;device_type == <span class=\"hljs-keyword\">type</span>) &#123;<br>        hw_pix_fmt = <span class=\"hljs-keyword\">config</span>-&gt;pix_fmt;<br>        <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<p>告诉解码器，我们希望输出像素格式</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"><span class=\"hljs-comment\">//get_format是一个函数指针，我们给ffmpeg提供一个函数，ffmpeg 调用该函数确定解码帧的数据格式</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">decoder_ctx</span>-&gt;</span>get_format  = get_hw_format;<br><br></code></pre></td></tr></table></figure>\n\n<p> get_hw_format</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-built_in\">AVPixelFormat</span> get_hw_format(<span class=\"hljs-built_in\">AVCodecContext</span> *ctx,<br>                                        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-built_in\">AVPixelFormat</span> *pix_fmts)<br>&#123;<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-built_in\">AVPixelFormat</span> *p;<br><br>    <span class=\"hljs-keyword\">for</span> (p = pix_fmts; *p != <span class=\"hljs-number\">-1</span>; p++) &#123;<br>        <span class=\"hljs-keyword\">if</span> (*p == hw_pix_fmt)<br>            <span class=\"hljs-keyword\">return</span> *p;<br>    &#125;<br><br>    fprintf(stderr, <span class=\"hljs-string\">&quot;Failed to get HW surface format.\\n&quot;</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">AV_PIX_FMT_NONE</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"创建并设置加速器\"><a href=\"#创建并设置加速器\" class=\"headerlink\" title=\"创建并设置加速器\"></a>创建并设置加速器</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">hw_decoder_init</span><span class=\"hljs-params\">(AVCodecContext *ctx, <span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">enum</span> AVHWDeviceType type)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> err = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-comment\">//创建硬件加速器实例</span><br>    <span class=\"hljs-keyword\">if</span> ((err = <span class=\"hljs-built_in\">av_hwdevice_ctx_create</span>(&amp;hw_device_ctx, type,<br>                                      <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>)) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Failed to create specified HW device.\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> err;<br>    &#125;<br>    <span class=\"hljs-comment\">//告诉解码器，使用我们创建的硬件加速器</span><br>    ctx-&gt;hw_device_ctx = <span class=\"hljs-built_in\">av_buffer_ref</span>(hw_device_ctx);<br><br>    <span class=\"hljs-keyword\">return</span> err;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"解码，数据从GPU到CPU\"><a href=\"#解码，数据从GPU到CPU\" class=\"headerlink\" title=\"解码，数据从GPU到CPU\"></a>解码，数据从GPU到CPU</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">decode_write</span><span class=\"hljs-params\">(AVCodecContext *avctx, AVPacket *packet)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    AVFrame *frame = <span class=\"hljs-literal\">NULL</span>, *sw_frame = <span class=\"hljs-literal\">NULL</span>;<br>    AVFrame *tmp_frame = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-type\">uint8_t</span> *buffer = <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-type\">int</span> size;<br>    <span class=\"hljs-type\">int</span> ret = <span class=\"hljs-number\">0</span>;<br><br>    ret = <span class=\"hljs-built_in\">avcodec_send_packet</span>(avctx, packet);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Error during decoding\\n&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (!(frame = <span class=\"hljs-built_in\">av_frame_alloc</span>()) || !(sw_frame = <span class=\"hljs-built_in\">av_frame_alloc</span>())) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Can not alloc frame\\n&quot;</span>);<br>            ret = <span class=\"hljs-built_in\">AVERROR</span>(ENOMEM);<br>            <span class=\"hljs-keyword\">goto</span> fail;<br>        &#125;<br><br>        ret = <span class=\"hljs-built_in\">avcodec_receive_frame</span>(avctx, frame);<br>        <span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-built_in\">AVERROR</span>(EAGAIN) || ret == AVERROR_EOF) &#123;<br>            <span class=\"hljs-built_in\">av_frame_free</span>(&amp;frame);<br>            <span class=\"hljs-built_in\">av_frame_free</span>(&amp;sw_frame);<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Error while decoding\\n&quot;</span>);<br>            <span class=\"hljs-keyword\">goto</span> fail;<br>        &#125;<br>        <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">         我们期待解码器能够解码出我们想要像素格式</span><br><span class=\"hljs-comment\">         如果解码器输出了我们想要的格式，由于使用了硬件加速，我们需要将数据从GPU拷贝到cpu</span><br><span class=\"hljs-comment\">         如果没有输出我们想要的格式，证明使用的是软件解码</span><br><span class=\"hljs-comment\">         */</span><br>        <span class=\"hljs-keyword\">if</span> (frame-&gt;format == hw_pix_fmt) &#123;<br>            <span class=\"hljs-comment\">/* 将解码数据从GPU拷贝到CPU */</span><br>            <span class=\"hljs-keyword\">if</span> ((ret = <span class=\"hljs-built_in\">av_hwframe_transfer_data</span>(sw_frame, frame, <span class=\"hljs-number\">0</span>)) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>                <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Error transferring the data to system memory\\n&quot;</span>);<br>                <span class=\"hljs-keyword\">goto</span> fail;<br>            &#125;<br>            tmp_frame = sw_frame;<br>        &#125; <span class=\"hljs-keyword\">else</span><br>            tmp_frame = frame;<br>        <br>        <span class=\"hljs-comment\">//申请一个AVFrame, 将解码后的yuv/rgb，去掉字节对齐拷贝过来</span><br>        size = <span class=\"hljs-built_in\">av_image_get_buffer_size</span>(tmp_frame-&gt;format, tmp_frame-&gt;width,<br>                                        tmp_frame-&gt;height, <span class=\"hljs-number\">1</span>);<br>        buffer = <span class=\"hljs-built_in\">av_malloc</span>(size);<br>        <span class=\"hljs-keyword\">if</span> (!buffer) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Can not alloc buffer\\n&quot;</span>);<br>            ret = <span class=\"hljs-built_in\">AVERROR</span>(ENOMEM);<br>            <span class=\"hljs-keyword\">goto</span> fail;<br>        &#125;<br>        <span class=\"hljs-comment\">//拷贝，去掉字节对齐</span><br>        ret = <span class=\"hljs-built_in\">av_image_copy_to_buffer</span>(buffer, size,<br>                                      (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint8_t</span> * <span class=\"hljs-type\">const</span> *)tmp_frame-&gt;data,<br>                                      (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *)tmp_frame-&gt;linesize, tmp_frame-&gt;format,<br>                                      tmp_frame-&gt;width, tmp_frame-&gt;height, <span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Can not copy image to buffer\\n&quot;</span>);<br>            <span class=\"hljs-keyword\">goto</span> fail;<br>        &#125;<br>        <span class=\"hljs-comment\">//将已经去掉字节对齐的yuv/rgb数据，写入文件</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = <span class=\"hljs-built_in\">fwrite</span>(buffer, <span class=\"hljs-number\">1</span>, size, output_file)) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Failed to dump raw data.\\n&quot;</span>);<br>            <span class=\"hljs-keyword\">goto</span> fail;<br>        &#125;<br><br>    fail:<br>        <span class=\"hljs-built_in\">av_frame_free</span>(&amp;frame);<br>        <span class=\"hljs-built_in\">av_frame_free</span>(&amp;sw_frame);<br>        <span class=\"hljs-built_in\">av_freep</span>(&amp;buffer);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ol>\n<li><p>解码器配置的时候，需要告诉解码器我们使用的硬件加速器</p>\n</li>\n<li><p>与解码器商量输出的颜色格式</p>\n</li>\n<li><p>解码后处理，处理从GPU到CPU拷贝的内存拷贝</p>\n</li>\n</ol>\n"},{"layout":"post","title":"ffplay packet queue 分析","date":"2022-03-13T16:00:00.000Z","_content":"\n参考： [ffplay packet queue分析](https://zhuanlan.zhihu.com/p/43295650)\n\n---\n\nffplay  用 PacketQueue 来保存解封装后的数据，即AVPacket。\n定义MyAVPacketList表示队列中的元素，这里命名为MyAVPacketNode可能更合理。\n\n```c\ntypedef struct MyAVPacketList {\n    //待解码的数据\n    AVPacket *pkt;\n    //pkt序列号\n    int serial;\n} MyAVPacketList;\n\ntypedef struct PacketQueue {\n    /* ffmpeg封装的队列数据结构，先入先出 */\n    AVFifo *pkt_list;\n    /* 当前队里的pkt的数量 */\n    int nb_packets;\n    /* 当前所有节点占用的总内存大小 */\n    int size;\n    /* 队列所有节点的合计时长 */\n    int64_t duration;\n    /* 是否要中止队列操作，用于安全快速退出播放 */\n    int abort_request;\n    //序列号，和MyAVPacketList的serial作用相同，但改变的时序稍微有点不同\n    int serial;\n    //用于维持PacketQueue的多线程安全(SDL_mutex可以按pthread_mutex_t理解）\n    SDL_mutex *mutex;\n    //用于读、写线程相互通知(SDL_cond可以按pthread_cond_t理解)\n    SDL_cond *cond;\n} PacketQueue;\n```\n\n结构体的第一个成员是AVFifo指针类型的。FFmpeg 定义了AVFifo结构体和操作这个结构体的一系列函数，实现了队列的数据结构。PacketQueue 是封装了AVFifo 实例，来管理MyAVPacketList，进而管理解封装后的AVPacket的。\n\n## AVFifo\n\n```c\nstruct AVFifo {\n    uint8_t *buffer;\n\n    size_t elem_size, nb_elems;\n    size_t offset_r, offset_w;\n    // distinguishes the ambiguous situation offset_r == offset_w\n    int    is_empty;\n\n    unsigned int flags;\n    size_t       auto_grow_limit;\n};\n```\n\n操作\n\n```\nAVFifo *av_fifo_alloc2(size_t elems, size_t elem_size,\n                       unsigned int flags);\n\nint av_fifo_write(AVFifo *f, const void *buf, size_t nb_elems);\n\nint av_fifo_read(AVFifo *f, void *buf, size_t nb_elems);\n\nvoid av_fifo_freep2(AVFifo **f);\n```\n\n- av_fifo_alloc2 创建队列\n\n- av_fifo_read 从队列中读一个元素，队列长度减 1\n\n- av_fifo_write 给队列添加一个元素， 队列长度加1 \n\n- av_fifo_freep2 销毁队列\n\n# PacketQueue 操作函数\n\n`PacketQueue`操作提供以下方法：\n\n- packet_queue_init:  初始化\n\n- packet_queue_destroy： 销毁\n\n- packet_queue_start： 开启\n\n- packet_queue_abort： 终止\n\n- packet_queue_get： 获取一个节点\n\n- packet_queue_put： 存入一个节点\n\n- packet_queue_put_nullpacket： 存入一个空节点\n\n- packet_queue_flush： 清除队列内所有的节点\n\n## packet_queue_init\n\n```\nstatic int packet_queue_init(PacketQueue *q)\n{\n    memset(q, 0, sizeof(PacketQueue));\n    q->pkt_list = av_fifo_alloc2(1, sizeof(MyAVPacketList), AV_FIFO_FLAG_AUTO_GROW);\n    if (!q->pkt_list)\n        return AVERROR(ENOMEM);\n    q->mutex = SDL_CreateMutex();\n    if (!q->mutex) {\n        av_log(NULL, AV_LOG_FATAL, \"SDL_CreateMutex(): %s\\n\", SDL_GetError());\n        return AVERROR(ENOMEM);\n    }\n    q->cond = SDL_CreateCond();\n    if (!q->cond) {\n        av_log(NULL, AV_LOG_FATAL, \"SDL_CreateCond(): %s\\n\", SDL_GetError());\n        return AVERROR(ENOMEM);\n    }\n    q->abort_request = 1;\n    return 0;\n}\n```\n\n1. 内部调用av_fifo_alloc2 创建AVFifo 队列实例\n\n2. 创建mutex用于队列安全访问\n\n3. 创建cond 用于队列等待和唤醒控制\n\n4. 初始设置abort_request = 1\n\n## packet_queue_destroy\n\n```\nstatic void packet_queue_destroy(PacketQueue *q)\n{\n    packet_queue_flush(q);\n    av_fifo_freep2(&q->pkt_list);\n    SDL_DestroyMutex(q->mutex);\n    SDL_DestroyCond(q->cond);\n}\n```\n\n1. 调用packet_queue_flush清空队列中的元素\n\n2. 销毁AVFifo 队列实例\n\n3. 销毁mutex\n\n4. 销毁cond\n\n## packet_queue_start\n\n```\nstatic void packet_queue_start(PacketQueue *q)\n{\n    SDL_LockMutex(q->mutex);\n    q->abort_request = 0;\n    q->serial++;\n    SDL_UnlockMutex(q->mutex);\n}\n```\n\n只是加锁，将abort_request设置为0，并且将serial加1，然后解锁。\n\n## packet_queue_abort\n\n```\nstatic void packet_queue_abort(PacketQueue *q)\n{\n    SDL_LockMutex(q->mutex);\n\n    q->abort_request = 1;\n\n    SDL_CondSignal(q->cond);\n\n    SDL_UnlockMutex(q->mutex);\n}\n```\n\n加锁，将abort_request设置为1，标记为队列被终止。\n\n同时唤醒等待条件变量的线程，使其正常退出,   解锁。\n\n## packet_queue_get\n\n```c\n/* return < 0 if aborted, 0 if no packet and > 0 if packet.  */\nstatic int packet_queue_get(PacketQueue *q, AVPacket *pkt, int block, int *serial)\n{\n    MyAVPacketList pkt1;\n    int ret;\n    //加锁\n    SDL_LockMutex(q->mutex);\n\n    for (;;) {\n        if (q->abort_request) {\n            //队列终止了, 设置返回值为-1\n            ret = -1;\n            break;\n        }\n        //从pkt_list中读出一个节点，放入MyAVPacketList中，同时更新队列的信息\n        if (av_fifo_read(q->pkt_list, &pkt1, 1) >= 0) {\n            //更新队列长度\n            q->nb_packets--;\n            //更新队列占用内存大小\n            q->size -= pkt1.pkt->size + sizeof(pkt1);\n            //更新队列时长\n            q->duration -= pkt1.pkt->duration;\n            //转移pkt1.pkt的内容到pkt中\n            av_packet_move_ref(pkt, pkt1.pkt);\n            //设置serial的值\n            if (serial)\n                *serial = pkt1.serial;\n            //pkt1.pkt内容已近被转移，释放pkt1.pkt的内存\n            av_packet_free(&pkt1.pkt);\n            //返回值>0,代表从队列获取到了元素\n            ret = 1;\n            break;\n        } else if (!block) {\n            //没有获取到元素，但是调用放要求不阻塞，设置返回值为0，跳出循环\n            ret = 0;\n            break;\n        } else {\n            //没读到元素，阻塞等待有元素可以获取\n            SDL_CondWait(q->cond, q->mutex);\n        }\n    }\n    //解锁\n    SDL_UnlockMutex(q->mutex);\n    return ret;\n}\n```\n\n从队列中获取一个元素\n\n1. 加锁\n\n2. 获取成功，队列元素减少，更新队列信息\n\n3. 获取失败，要求不阻塞，立马返回\n\n4. 获取失败，要求阻塞，调用wait进入等待状态\n\n5. 解锁\n\n## packet_queue_put\n\n```\nstatic int packet_queue_put_private(PacketQueue *q, AVPacket *pkt)\n{\n    MyAVPacketList pkt1;\n    int ret;\n    //如果队列被终止，返回-1\n    if (q->abort_request)\n       return -1;\n\n    //给节点填充数据\n    pkt1.pkt = pkt;\n    //设置pkt的序列号\n    pkt1.serial = q->serial;\n    //将节点添加到队列\n    ret = av_fifo_write(q->pkt_list, &pkt1, 1);\n    if (ret < 0)\n        return ret;\n    //更新队列大小\n    q->nb_packets++;\n    //更新队列内存大小，添加节点size(pkt内存的大小 + 节点数据大小)\n    q->size += pkt1.pkt->size + sizeof(pkt1);\n    //更新队列的总时长\n    q->duration += pkt1.pkt->duration;\n    /* XXX: should duplicate packet data in DV case */\n    SDL_CondSignal(q->cond);\n    return 0;\n}\n\nstatic int packet_queue_put(PacketQueue *q, AVPacket *pkt)\n{\n    AVPacket *pkt1;\n    int ret;\n    //创建pkt1\n    pkt1 = av_packet_alloc();\n    if (!pkt1) {\n        //创建pkt1失败，取消引用pkt\n        av_packet_unref(pkt);\n        return -1;\n    }\n    //将pkt内容转移到pkt1中\n    av_packet_move_ref(pkt1, pkt);\n    //加锁操加入队列\n    SDL_LockMutex(q->mutex);\n    //调用packet_queue_put_private将pkt1放入队列中\n    ret = packet_queue_put_private(q, pkt1);\n    SDL_UnlockMutex(q->mutex);\n\n    if (ret < 0)\n        //放入队列失败，需要取消引用pkt1\n        av_packet_free(&pkt1);\n\n    return ret;\n}\n```\n\n1. 将AVPacket封装为MyAVPacketList，保存在内部的队列中\n\n2. 队列长度加1，同时更新时长，内存占用等信息\n\n3. packet_queue_put内部调用packet_queue_put_private来完成相关的操作\n\n## packet_queue_put_nullpacket\n\n```\n//播放完了，从文件中读出了空的pkt，空的pkt丢给解码器的时候，会冲洗解码器，将解码器剩余的额数据读出来\nstatic int packet_queue_put_nullpacket(PacketQueue *q, AVPacket *pkt, int stream_index)\n{\n    //设置pkt对应的stream_index \n    pkt->stream_index = stream_index;\n    //添加有一个内容为空的pkt到队列中\n    return packet_queue_put(q, pkt);\n}\n```\n\n1. 给队列添加一个内容为空的pkt\n\n2. 设置pkt对应的stream_index，追加到队列中\n\n## packet_queue_flush\n\n```\nstatic void packet_queue_flush(PacketQueue *q)\n{\n    MyAVPacketList pkt1;\n    //加锁\n    SDL_LockMutex(q->mutex);\n    //从内部队列循环获取元素，存入pkt1中\n    while (av_fifo_read(q->pkt_list, &pkt1, 1) >= 0)\n        //释放MyAVPacketList中的AVPacket的内存\n        av_packet_free(&pkt1.pkt);\n    //更新队列信息\n    q->nb_packets = 0;\n    q->size = 0;\n    q->duration = 0;\n    //serial加1\n    q->serial++;\n    //解锁\n    SDL_UnlockMutex(q->mutex);\n}\n```\n\n 清空队列，释放节点的内存，更新队列信息。\n\n而对于serial的操作不是设置为0，而是在原来的基础上增加了1，为什么呢？\n\n## 总结：\n\n1. ffplay 用PacketQueue来保存解封装后的AVPacket\n\n2. PacketQueue对元素的操作，依赖于内部基于ffmpeg AVFifo的队列实例\n\n3. PacketQueue通过mutex来保证线层安全\n\n4. PacketQueue通过条件变量来控制写入和读取的顺序\n","source":"_posts/ffmpeg/2022-03-14-ffplay-packet queue  分析.md","raw":"---\nlayout: post\ntitle: \"ffplay packet queue 分析\"\ndate: 2022-03-14\ntag: ffmpeg\n\n---\n\n参考： [ffplay packet queue分析](https://zhuanlan.zhihu.com/p/43295650)\n\n---\n\nffplay  用 PacketQueue 来保存解封装后的数据，即AVPacket。\n定义MyAVPacketList表示队列中的元素，这里命名为MyAVPacketNode可能更合理。\n\n```c\ntypedef struct MyAVPacketList {\n    //待解码的数据\n    AVPacket *pkt;\n    //pkt序列号\n    int serial;\n} MyAVPacketList;\n\ntypedef struct PacketQueue {\n    /* ffmpeg封装的队列数据结构，先入先出 */\n    AVFifo *pkt_list;\n    /* 当前队里的pkt的数量 */\n    int nb_packets;\n    /* 当前所有节点占用的总内存大小 */\n    int size;\n    /* 队列所有节点的合计时长 */\n    int64_t duration;\n    /* 是否要中止队列操作，用于安全快速退出播放 */\n    int abort_request;\n    //序列号，和MyAVPacketList的serial作用相同，但改变的时序稍微有点不同\n    int serial;\n    //用于维持PacketQueue的多线程安全(SDL_mutex可以按pthread_mutex_t理解）\n    SDL_mutex *mutex;\n    //用于读、写线程相互通知(SDL_cond可以按pthread_cond_t理解)\n    SDL_cond *cond;\n} PacketQueue;\n```\n\n结构体的第一个成员是AVFifo指针类型的。FFmpeg 定义了AVFifo结构体和操作这个结构体的一系列函数，实现了队列的数据结构。PacketQueue 是封装了AVFifo 实例，来管理MyAVPacketList，进而管理解封装后的AVPacket的。\n\n## AVFifo\n\n```c\nstruct AVFifo {\n    uint8_t *buffer;\n\n    size_t elem_size, nb_elems;\n    size_t offset_r, offset_w;\n    // distinguishes the ambiguous situation offset_r == offset_w\n    int    is_empty;\n\n    unsigned int flags;\n    size_t       auto_grow_limit;\n};\n```\n\n操作\n\n```\nAVFifo *av_fifo_alloc2(size_t elems, size_t elem_size,\n                       unsigned int flags);\n\nint av_fifo_write(AVFifo *f, const void *buf, size_t nb_elems);\n\nint av_fifo_read(AVFifo *f, void *buf, size_t nb_elems);\n\nvoid av_fifo_freep2(AVFifo **f);\n```\n\n- av_fifo_alloc2 创建队列\n\n- av_fifo_read 从队列中读一个元素，队列长度减 1\n\n- av_fifo_write 给队列添加一个元素， 队列长度加1 \n\n- av_fifo_freep2 销毁队列\n\n# PacketQueue 操作函数\n\n`PacketQueue`操作提供以下方法：\n\n- packet_queue_init:  初始化\n\n- packet_queue_destroy： 销毁\n\n- packet_queue_start： 开启\n\n- packet_queue_abort： 终止\n\n- packet_queue_get： 获取一个节点\n\n- packet_queue_put： 存入一个节点\n\n- packet_queue_put_nullpacket： 存入一个空节点\n\n- packet_queue_flush： 清除队列内所有的节点\n\n## packet_queue_init\n\n```\nstatic int packet_queue_init(PacketQueue *q)\n{\n    memset(q, 0, sizeof(PacketQueue));\n    q->pkt_list = av_fifo_alloc2(1, sizeof(MyAVPacketList), AV_FIFO_FLAG_AUTO_GROW);\n    if (!q->pkt_list)\n        return AVERROR(ENOMEM);\n    q->mutex = SDL_CreateMutex();\n    if (!q->mutex) {\n        av_log(NULL, AV_LOG_FATAL, \"SDL_CreateMutex(): %s\\n\", SDL_GetError());\n        return AVERROR(ENOMEM);\n    }\n    q->cond = SDL_CreateCond();\n    if (!q->cond) {\n        av_log(NULL, AV_LOG_FATAL, \"SDL_CreateCond(): %s\\n\", SDL_GetError());\n        return AVERROR(ENOMEM);\n    }\n    q->abort_request = 1;\n    return 0;\n}\n```\n\n1. 内部调用av_fifo_alloc2 创建AVFifo 队列实例\n\n2. 创建mutex用于队列安全访问\n\n3. 创建cond 用于队列等待和唤醒控制\n\n4. 初始设置abort_request = 1\n\n## packet_queue_destroy\n\n```\nstatic void packet_queue_destroy(PacketQueue *q)\n{\n    packet_queue_flush(q);\n    av_fifo_freep2(&q->pkt_list);\n    SDL_DestroyMutex(q->mutex);\n    SDL_DestroyCond(q->cond);\n}\n```\n\n1. 调用packet_queue_flush清空队列中的元素\n\n2. 销毁AVFifo 队列实例\n\n3. 销毁mutex\n\n4. 销毁cond\n\n## packet_queue_start\n\n```\nstatic void packet_queue_start(PacketQueue *q)\n{\n    SDL_LockMutex(q->mutex);\n    q->abort_request = 0;\n    q->serial++;\n    SDL_UnlockMutex(q->mutex);\n}\n```\n\n只是加锁，将abort_request设置为0，并且将serial加1，然后解锁。\n\n## packet_queue_abort\n\n```\nstatic void packet_queue_abort(PacketQueue *q)\n{\n    SDL_LockMutex(q->mutex);\n\n    q->abort_request = 1;\n\n    SDL_CondSignal(q->cond);\n\n    SDL_UnlockMutex(q->mutex);\n}\n```\n\n加锁，将abort_request设置为1，标记为队列被终止。\n\n同时唤醒等待条件变量的线程，使其正常退出,   解锁。\n\n## packet_queue_get\n\n```c\n/* return < 0 if aborted, 0 if no packet and > 0 if packet.  */\nstatic int packet_queue_get(PacketQueue *q, AVPacket *pkt, int block, int *serial)\n{\n    MyAVPacketList pkt1;\n    int ret;\n    //加锁\n    SDL_LockMutex(q->mutex);\n\n    for (;;) {\n        if (q->abort_request) {\n            //队列终止了, 设置返回值为-1\n            ret = -1;\n            break;\n        }\n        //从pkt_list中读出一个节点，放入MyAVPacketList中，同时更新队列的信息\n        if (av_fifo_read(q->pkt_list, &pkt1, 1) >= 0) {\n            //更新队列长度\n            q->nb_packets--;\n            //更新队列占用内存大小\n            q->size -= pkt1.pkt->size + sizeof(pkt1);\n            //更新队列时长\n            q->duration -= pkt1.pkt->duration;\n            //转移pkt1.pkt的内容到pkt中\n            av_packet_move_ref(pkt, pkt1.pkt);\n            //设置serial的值\n            if (serial)\n                *serial = pkt1.serial;\n            //pkt1.pkt内容已近被转移，释放pkt1.pkt的内存\n            av_packet_free(&pkt1.pkt);\n            //返回值>0,代表从队列获取到了元素\n            ret = 1;\n            break;\n        } else if (!block) {\n            //没有获取到元素，但是调用放要求不阻塞，设置返回值为0，跳出循环\n            ret = 0;\n            break;\n        } else {\n            //没读到元素，阻塞等待有元素可以获取\n            SDL_CondWait(q->cond, q->mutex);\n        }\n    }\n    //解锁\n    SDL_UnlockMutex(q->mutex);\n    return ret;\n}\n```\n\n从队列中获取一个元素\n\n1. 加锁\n\n2. 获取成功，队列元素减少，更新队列信息\n\n3. 获取失败，要求不阻塞，立马返回\n\n4. 获取失败，要求阻塞，调用wait进入等待状态\n\n5. 解锁\n\n## packet_queue_put\n\n```\nstatic int packet_queue_put_private(PacketQueue *q, AVPacket *pkt)\n{\n    MyAVPacketList pkt1;\n    int ret;\n    //如果队列被终止，返回-1\n    if (q->abort_request)\n       return -1;\n\n    //给节点填充数据\n    pkt1.pkt = pkt;\n    //设置pkt的序列号\n    pkt1.serial = q->serial;\n    //将节点添加到队列\n    ret = av_fifo_write(q->pkt_list, &pkt1, 1);\n    if (ret < 0)\n        return ret;\n    //更新队列大小\n    q->nb_packets++;\n    //更新队列内存大小，添加节点size(pkt内存的大小 + 节点数据大小)\n    q->size += pkt1.pkt->size + sizeof(pkt1);\n    //更新队列的总时长\n    q->duration += pkt1.pkt->duration;\n    /* XXX: should duplicate packet data in DV case */\n    SDL_CondSignal(q->cond);\n    return 0;\n}\n\nstatic int packet_queue_put(PacketQueue *q, AVPacket *pkt)\n{\n    AVPacket *pkt1;\n    int ret;\n    //创建pkt1\n    pkt1 = av_packet_alloc();\n    if (!pkt1) {\n        //创建pkt1失败，取消引用pkt\n        av_packet_unref(pkt);\n        return -1;\n    }\n    //将pkt内容转移到pkt1中\n    av_packet_move_ref(pkt1, pkt);\n    //加锁操加入队列\n    SDL_LockMutex(q->mutex);\n    //调用packet_queue_put_private将pkt1放入队列中\n    ret = packet_queue_put_private(q, pkt1);\n    SDL_UnlockMutex(q->mutex);\n\n    if (ret < 0)\n        //放入队列失败，需要取消引用pkt1\n        av_packet_free(&pkt1);\n\n    return ret;\n}\n```\n\n1. 将AVPacket封装为MyAVPacketList，保存在内部的队列中\n\n2. 队列长度加1，同时更新时长，内存占用等信息\n\n3. packet_queue_put内部调用packet_queue_put_private来完成相关的操作\n\n## packet_queue_put_nullpacket\n\n```\n//播放完了，从文件中读出了空的pkt，空的pkt丢给解码器的时候，会冲洗解码器，将解码器剩余的额数据读出来\nstatic int packet_queue_put_nullpacket(PacketQueue *q, AVPacket *pkt, int stream_index)\n{\n    //设置pkt对应的stream_index \n    pkt->stream_index = stream_index;\n    //添加有一个内容为空的pkt到队列中\n    return packet_queue_put(q, pkt);\n}\n```\n\n1. 给队列添加一个内容为空的pkt\n\n2. 设置pkt对应的stream_index，追加到队列中\n\n## packet_queue_flush\n\n```\nstatic void packet_queue_flush(PacketQueue *q)\n{\n    MyAVPacketList pkt1;\n    //加锁\n    SDL_LockMutex(q->mutex);\n    //从内部队列循环获取元素，存入pkt1中\n    while (av_fifo_read(q->pkt_list, &pkt1, 1) >= 0)\n        //释放MyAVPacketList中的AVPacket的内存\n        av_packet_free(&pkt1.pkt);\n    //更新队列信息\n    q->nb_packets = 0;\n    q->size = 0;\n    q->duration = 0;\n    //serial加1\n    q->serial++;\n    //解锁\n    SDL_UnlockMutex(q->mutex);\n}\n```\n\n 清空队列，释放节点的内存，更新队列信息。\n\n而对于serial的操作不是设置为0，而是在原来的基础上增加了1，为什么呢？\n\n## 总结：\n\n1. ffplay 用PacketQueue来保存解封装后的AVPacket\n\n2. PacketQueue对元素的操作，依赖于内部基于ffmpeg AVFifo的队列实例\n\n3. PacketQueue通过mutex来保证线层安全\n\n4. PacketQueue通过条件变量来控制写入和读取的顺序\n","slug":"ffmpeg/2022-03-14-ffplay-packet queue  分析","published":1,"updated":"2024-03-06T11:53:13.566Z","comments":1,"photos":[],"_id":"cltgopend001xqywhh41s2cre","content":"<p>参考： <a href=\"https://zhuanlan.zhihu.com/p/43295650\">ffplay packet queue分析</a></p>\n<hr>\n<p>ffplay  用 PacketQueue 来保存解封装后的数据，即AVPacket。<br>定义MyAVPacketList表示队列中的元素，这里命名为MyAVPacketNode可能更合理。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyAVPacketList</span> &#123;</span><br>    <span class=\"hljs-comment\">//待解码的数据</span><br>    AVPacket *pkt;<br>    <span class=\"hljs-comment\">//pkt序列号</span><br>    <span class=\"hljs-type\">int</span> serial;<br>&#125; MyAVPacketList;<br><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">PacketQueue</span> &#123;</span><br>    <span class=\"hljs-comment\">/* ffmpeg封装的队列数据结构，先入先出 */</span><br>    AVFifo *pkt_list;<br>    <span class=\"hljs-comment\">/* 当前队里的pkt的数量 */</span><br>    <span class=\"hljs-type\">int</span> nb_packets;<br>    <span class=\"hljs-comment\">/* 当前所有节点占用的总内存大小 */</span><br>    <span class=\"hljs-type\">int</span> size;<br>    <span class=\"hljs-comment\">/* 队列所有节点的合计时长 */</span><br>    <span class=\"hljs-type\">int64_t</span> duration;<br>    <span class=\"hljs-comment\">/* 是否要中止队列操作，用于安全快速退出播放 */</span><br>    <span class=\"hljs-type\">int</span> abort_request;<br>    <span class=\"hljs-comment\">//序列号，和MyAVPacketList的serial作用相同，但改变的时序稍微有点不同</span><br>    <span class=\"hljs-type\">int</span> serial;<br>    <span class=\"hljs-comment\">//用于维持PacketQueue的多线程安全(SDL_mutex可以按pthread_mutex_t理解）</span><br>    SDL_mutex *mutex;<br>    <span class=\"hljs-comment\">//用于读、写线程相互通知(SDL_cond可以按pthread_cond_t理解)</span><br>    SDL_cond *cond;<br>&#125; PacketQueue;<br></code></pre></td></tr></table></figure>\n\n<p>结构体的第一个成员是AVFifo指针类型的。FFmpeg 定义了AVFifo结构体和操作这个结构体的一系列函数，实现了队列的数据结构。PacketQueue 是封装了AVFifo 实例，来管理MyAVPacketList，进而管理解封装后的AVPacket的。</p>\n<h2 id=\"AVFifo\"><a href=\"#AVFifo\" class=\"headerlink\" title=\"AVFifo\"></a>AVFifo</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">AVFifo</span> &#123;</span><br>    <span class=\"hljs-type\">uint8_t</span> *buffer;<br><br>    <span class=\"hljs-type\">size_t</span> elem_size, nb_elems;<br>    <span class=\"hljs-type\">size_t</span> offset_r, offset_w;<br>    <span class=\"hljs-comment\">// distinguishes the ambiguous situation offset_r == offset_w</span><br>    <span class=\"hljs-type\">int</span>    is_empty;<br><br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> flags;<br>    <span class=\"hljs-type\">size_t</span>       auto_grow_limit;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>操作</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">AVFifo *<span class=\"hljs-title\">av_fifo_alloc2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> elems, <span class=\"hljs-type\">size_t</span> elem_size,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                       <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> flags)</span></span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">av_fifo_write</span><span class=\"hljs-params\">(AVFifo *f, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span> *buf, <span class=\"hljs-type\">size_t</span> nb_elems)</span></span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">av_fifo_read</span><span class=\"hljs-params\">(AVFifo *f, <span class=\"hljs-type\">void</span> *buf, <span class=\"hljs-type\">size_t</span> nb_elems)</span></span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">av_fifo_freep2</span><span class=\"hljs-params\">(AVFifo **f)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>av_fifo_alloc2 创建队列</p>\n</li>\n<li><p>av_fifo_read 从队列中读一个元素，队列长度减 1</p>\n</li>\n<li><p>av_fifo_write 给队列添加一个元素， 队列长度加1 </p>\n</li>\n<li><p>av_fifo_freep2 销毁队列</p>\n</li>\n</ul>\n<h1 id=\"PacketQueue-操作函数\"><a href=\"#PacketQueue-操作函数\" class=\"headerlink\" title=\"PacketQueue 操作函数\"></a>PacketQueue 操作函数</h1><p><code>PacketQueue</code>操作提供以下方法：</p>\n<ul>\n<li><p>packet_queue_init:  初始化</p>\n</li>\n<li><p>packet_queue_destroy： 销毁</p>\n</li>\n<li><p>packet_queue_start： 开启</p>\n</li>\n<li><p>packet_queue_abort： 终止</p>\n</li>\n<li><p>packet_queue_get： 获取一个节点</p>\n</li>\n<li><p>packet_queue_put： 存入一个节点</p>\n</li>\n<li><p>packet_queue_put_nullpacket： 存入一个空节点</p>\n</li>\n<li><p>packet_queue_flush： 清除队列内所有的节点</p>\n</li>\n</ul>\n<h2 id=\"packet-queue-init\"><a href=\"#packet-queue-init\" class=\"headerlink\" title=\"packet_queue_init\"></a>packet_queue_init</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> packet_queue_init(PacketQueue *q)<br>&#123;<br>    memset(q, <span class=\"hljs-number\">0</span>, <span class=\"hljs-keyword\">sizeof</span>(PacketQueue));<br>    q-&gt;pkt_list = av_fifo_alloc2(<span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">sizeof</span>(MyAVPacketList), <span class=\"hljs-built_in\">AV_FIFO_FLAG_AUTO_GROW</span>);<br>    <span class=\"hljs-keyword\">if</span> (!q-&gt;pkt_list)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">AVERROR</span>(ENOMEM);<br>    q-&gt;mutex = SDL_CreateMutex();<br>    <span class=\"hljs-keyword\">if</span> (!q-&gt;mutex) &#123;<br>        av_log(<span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-built_in\">AV_LOG_FATAL</span>, <span class=\"hljs-string\">&quot;SDL_CreateMutex(): %s\\n&quot;</span>, SDL_GetError());<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">AVERROR</span>(ENOMEM);<br>    &#125;<br>    q-&gt;cond = SDL_CreateCond();<br>    <span class=\"hljs-keyword\">if</span> (!q-&gt;cond) &#123;<br>        av_log(<span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-built_in\">AV_LOG_FATAL</span>, <span class=\"hljs-string\">&quot;SDL_CreateCond(): %s\\n&quot;</span>, SDL_GetError());<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">AVERROR</span>(ENOMEM);<br>    &#125;<br>    q-&gt;abort_request = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>内部调用av_fifo_alloc2 创建AVFifo 队列实例</p>\n</li>\n<li><p>创建mutex用于队列安全访问</p>\n</li>\n<li><p>创建cond 用于队列等待和唤醒控制</p>\n</li>\n<li><p>初始设置abort_request &#x3D; 1</p>\n</li>\n</ol>\n<h2 id=\"packet-queue-destroy\"><a href=\"#packet-queue-destroy\" class=\"headerlink\" title=\"packet_queue_destroy\"></a>packet_queue_destroy</h2><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">static void <span class=\"hljs-built_in\">packet_queue_destroy</span>(PacketQueue *q)<br>&#123;<br>    <span class=\"hljs-built_in\">packet_queue_flush</span>(q);<br>    <span class=\"hljs-built_in\">av_fifo_freep2</span>(&amp;q-&gt;pkt_list);<br>    <span class=\"hljs-built_in\">SDL_DestroyMutex</span>(q-&gt;mutex);<br>    <span class=\"hljs-built_in\">SDL_DestroyCond</span>(q-&gt;cond);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>调用packet_queue_flush清空队列中的元素</p>\n</li>\n<li><p>销毁AVFifo 队列实例</p>\n</li>\n<li><p>销毁mutex</p>\n</li>\n<li><p>销毁cond</p>\n</li>\n</ol>\n<h2 id=\"packet-queue-start\"><a href=\"#packet-queue-start\" class=\"headerlink\" title=\"packet_queue_start\"></a>packet_queue_start</h2><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">static void packet_queue_start(PacketQueue *q)<br>&#123;<br>    SDL_L<span class=\"hljs-function\"><span class=\"hljs-title\">ockMutex</span>(q-&gt;</span>mutex);<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span>abort_request = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span>serial++;<br>    SDL_U<span class=\"hljs-function\"><span class=\"hljs-title\">nlockMutex</span>(q-&gt;</span>mutex);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>只是加锁，将abort_request设置为0，并且将serial加1，然后解锁。</p>\n<h2 id=\"packet-queue-abort\"><a href=\"#packet-queue-abort\" class=\"headerlink\" title=\"packet_queue_abort\"></a>packet_queue_abort</h2><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">static void packet_queue_abort(PacketQueue *q)<br>&#123;<br>    SDL_L<span class=\"hljs-function\"><span class=\"hljs-title\">ockMutex</span>(q-&gt;</span>mutex);<br><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span>abort_request = <span class=\"hljs-number\">1</span>;<br><br>    SDL_C<span class=\"hljs-function\"><span class=\"hljs-title\">ondSignal</span>(q-&gt;</span>cond);<br><br>    SDL_U<span class=\"hljs-function\"><span class=\"hljs-title\">nlockMutex</span>(q-&gt;</span>mutex);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>加锁，将abort_request设置为1，标记为队列被终止。</p>\n<p>同时唤醒等待条件变量的线程，使其正常退出,   解锁。</p>\n<h2 id=\"packet-queue-get\"><a href=\"#packet-queue-get\" class=\"headerlink\" title=\"packet_queue_get\"></a>packet_queue_get</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* return &lt; 0 if aborted, 0 if no packet and &gt; 0 if packet.  */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">packet_queue_get</span><span class=\"hljs-params\">(PacketQueue *q, AVPacket *pkt, <span class=\"hljs-type\">int</span> block, <span class=\"hljs-type\">int</span> *serial)</span><br>&#123;<br>    MyAVPacketList pkt1;<br>    <span class=\"hljs-type\">int</span> ret;<br>    <span class=\"hljs-comment\">//加锁</span><br>    SDL_LockMutex(q-&gt;mutex);<br><br>    <span class=\"hljs-keyword\">for</span> (;;) &#123;<br>        <span class=\"hljs-keyword\">if</span> (q-&gt;abort_request) &#123;<br>            <span class=\"hljs-comment\">//队列终止了, 设置返回值为-1</span><br>            ret = <span class=\"hljs-number\">-1</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>        <span class=\"hljs-comment\">//从pkt_list中读出一个节点，放入MyAVPacketList中，同时更新队列的信息</span><br>        <span class=\"hljs-keyword\">if</span> (av_fifo_read(q-&gt;pkt_list, &amp;pkt1, <span class=\"hljs-number\">1</span>) &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-comment\">//更新队列长度</span><br>            q-&gt;nb_packets--;<br>            <span class=\"hljs-comment\">//更新队列占用内存大小</span><br>            q-&gt;size -= pkt1.pkt-&gt;size + <span class=\"hljs-keyword\">sizeof</span>(pkt1);<br>            <span class=\"hljs-comment\">//更新队列时长</span><br>            q-&gt;duration -= pkt1.pkt-&gt;duration;<br>            <span class=\"hljs-comment\">//转移pkt1.pkt的内容到pkt中</span><br>            av_packet_move_ref(pkt, pkt1.pkt);<br>            <span class=\"hljs-comment\">//设置serial的值</span><br>            <span class=\"hljs-keyword\">if</span> (serial)<br>                *serial = pkt1.serial;<br>            <span class=\"hljs-comment\">//pkt1.pkt内容已近被转移，释放pkt1.pkt的内存</span><br>            av_packet_free(&amp;pkt1.pkt);<br>            <span class=\"hljs-comment\">//返回值&gt;0,代表从队列获取到了元素</span><br>            ret = <span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!block) &#123;<br>            <span class=\"hljs-comment\">//没有获取到元素，但是调用放要求不阻塞，设置返回值为0，跳出循环</span><br>            ret = <span class=\"hljs-number\">0</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">//没读到元素，阻塞等待有元素可以获取</span><br>            SDL_CondWait(q-&gt;cond, q-&gt;mutex);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">//解锁</span><br>    SDL_UnlockMutex(q-&gt;mutex);<br>    <span class=\"hljs-keyword\">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从队列中获取一个元素</p>\n<ol>\n<li><p>加锁</p>\n</li>\n<li><p>获取成功，队列元素减少，更新队列信息</p>\n</li>\n<li><p>获取失败，要求不阻塞，立马返回</p>\n</li>\n<li><p>获取失败，要求阻塞，调用wait进入等待状态</p>\n</li>\n<li><p>解锁</p>\n</li>\n</ol>\n<h2 id=\"packet-queue-put\"><a href=\"#packet-queue-put\" class=\"headerlink\" title=\"packet_queue_put\"></a>packet_queue_put</h2><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">static int packet_queue_put_private(PacketQueue *q, AVPacket *pkt)<br>&#123;<br>    MyAVPacketList pkt1;<br>    int ret;<br>    <span class=\"hljs-comment\">//如果队列被终止，返回-1</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (q-&gt;</span>abort_request)<br>       return -<span class=\"hljs-number\">1</span>;<br><br>    <span class=\"hljs-comment\">//给节点填充数据</span><br>    pkt1.pkt = pkt;<br>    <span class=\"hljs-comment\">//设置pkt的序列号</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">pkt1</span>.serial = q-&gt;</span>serial;<br>    <span class=\"hljs-comment\">//将节点添加到队列</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">ret</span> = av_fifo_write(q-&gt;</span>pkt_list, &amp;pkt1, <span class=\"hljs-number\">1</span>);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>)<br>        return ret;<br>    <span class=\"hljs-comment\">//更新队列大小</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span>nb_packets++;<br>    <span class=\"hljs-comment\">//更新队列内存大小，添加节点size(pkt内存的大小 + 节点数据大小)</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">size</span> += pkt1.pkt-&gt;</span>size + sizeof(pkt1);<br>    <span class=\"hljs-comment\">//更新队列的总时长</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">duration</span> += pkt1.pkt-&gt;</span>duration;<br>    <span class=\"hljs-comment\">/* <span class=\"hljs-doctag\">XXX:</span> should duplicate packet data in DV case */</span><br>    SDL_C<span class=\"hljs-function\"><span class=\"hljs-title\">ondSignal</span>(q-&gt;</span>cond);<br>    return <span class=\"hljs-number\">0</span>;<br>&#125;<br><br>static int packet_queue_put(PacketQueue *q, AVPacket *pkt)<br>&#123;<br>    AVPacket *pkt1;<br>    int ret;<br>    <span class=\"hljs-comment\">//创建pkt1</span><br>    pkt1 = av_packet_alloc();<br>    <span class=\"hljs-keyword\">if</span> (!pkt1) &#123;<br>        <span class=\"hljs-comment\">//创建pkt1失败，取消引用pkt</span><br>        av_packet_unref(pkt);<br>        return -<span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">//将pkt内容转移到pkt1中</span><br>    av_packet_move_ref(pkt1, pkt);<br>    <span class=\"hljs-comment\">//加锁操加入队列</span><br>    SDL_L<span class=\"hljs-function\"><span class=\"hljs-title\">ockMutex</span>(q-&gt;</span>mutex);<br>    <span class=\"hljs-comment\">//调用packet_queue_put_private将pkt1放入队列中</span><br>    ret = packet_queue_put_private(q, pkt1);<br>    SDL_U<span class=\"hljs-function\"><span class=\"hljs-title\">nlockMutex</span>(q-&gt;</span>mutex);<br><br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-comment\">//放入队列失败，需要取消引用pkt1</span><br>        av_packet_free(&amp;pkt1);<br><br>    return ret;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>将AVPacket封装为MyAVPacketList，保存在内部的队列中</p>\n</li>\n<li><p>队列长度加1，同时更新时长，内存占用等信息</p>\n</li>\n<li><p>packet_queue_put内部调用packet_queue_put_private来完成相关的操作</p>\n</li>\n</ol>\n<h2 id=\"packet-queue-put-nullpacket\"><a href=\"#packet-queue-put-nullpacket\" class=\"headerlink\" title=\"packet_queue_put_nullpacket\"></a>packet_queue_put_nullpacket</h2><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">//播放完了，从文件中读出了空的pkt，空的pkt丢给解码器的时候，会冲洗解码器，将解码器剩余的额数据读出来</span><br><span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">packet_queue_put_nullpacket</span><span class=\"hljs-params\">(PacketQueue *q, AVPacket *pkt, <span class=\"hljs-keyword\">int</span> stream_index)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//设置pkt对应的stream_index </span><br>    pkt-&gt;stream_index = stream_index;<br>    <span class=\"hljs-comment\">//添加有一个内容为空的pkt到队列中</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title\">packet_queue_put</span><span class=\"hljs-params\">(q, pkt)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>给队列添加一个内容为空的pkt</p>\n</li>\n<li><p>设置pkt对应的stream_index，追加到队列中</p>\n</li>\n</ol>\n<h2 id=\"packet-queue-flush\"><a href=\"#packet-queue-flush\" class=\"headerlink\" title=\"packet_queue_flush\"></a>packet_queue_flush</h2><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">static void packet_queue_flush(PacketQueue *q)<br>&#123;<br>    MyAVPacketList pkt1;<br>    <span class=\"hljs-comment\">//加锁</span><br>    SDL_L<span class=\"hljs-function\"><span class=\"hljs-title\">ockMutex</span>(q-&gt;</span>mutex);<br>    <span class=\"hljs-comment\">//从内部队列循环获取元素，存入pkt1中</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">while</span> (av_fifo_read(q-&gt;</span>pkt_list, &amp;pkt1, <span class=\"hljs-number\">1</span>) &gt;= <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-comment\">//释放MyAVPacketList中的AVPacket的内存</span><br>        av_packet_free(&amp;pkt1.pkt);<br>    <span class=\"hljs-comment\">//更新队列信息</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span>nb_packets = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span>size = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span>duration = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-comment\">//serial加1</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span>serial++;<br>    <span class=\"hljs-comment\">//解锁</span><br>    SDL_U<span class=\"hljs-function\"><span class=\"hljs-title\">nlockMutex</span>(q-&gt;</span>mutex);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p> 清空队列，释放节点的内存，更新队列信息。</p>\n<p>而对于serial的操作不是设置为0，而是在原来的基础上增加了1，为什么呢？</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ol>\n<li><p>ffplay 用PacketQueue来保存解封装后的AVPacket</p>\n</li>\n<li><p>PacketQueue对元素的操作，依赖于内部基于ffmpeg AVFifo的队列实例</p>\n</li>\n<li><p>PacketQueue通过mutex来保证线层安全</p>\n</li>\n<li><p>PacketQueue通过条件变量来控制写入和读取的顺序</p>\n</li>\n</ol>\n","excerpt":"","more":"<p>参考： <a href=\"https://zhuanlan.zhihu.com/p/43295650\">ffplay packet queue分析</a></p>\n<hr>\n<p>ffplay  用 PacketQueue 来保存解封装后的数据，即AVPacket。<br>定义MyAVPacketList表示队列中的元素，这里命名为MyAVPacketNode可能更合理。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">MyAVPacketList</span> &#123;</span><br>    <span class=\"hljs-comment\">//待解码的数据</span><br>    AVPacket *pkt;<br>    <span class=\"hljs-comment\">//pkt序列号</span><br>    <span class=\"hljs-type\">int</span> serial;<br>&#125; MyAVPacketList;<br><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">PacketQueue</span> &#123;</span><br>    <span class=\"hljs-comment\">/* ffmpeg封装的队列数据结构，先入先出 */</span><br>    AVFifo *pkt_list;<br>    <span class=\"hljs-comment\">/* 当前队里的pkt的数量 */</span><br>    <span class=\"hljs-type\">int</span> nb_packets;<br>    <span class=\"hljs-comment\">/* 当前所有节点占用的总内存大小 */</span><br>    <span class=\"hljs-type\">int</span> size;<br>    <span class=\"hljs-comment\">/* 队列所有节点的合计时长 */</span><br>    <span class=\"hljs-type\">int64_t</span> duration;<br>    <span class=\"hljs-comment\">/* 是否要中止队列操作，用于安全快速退出播放 */</span><br>    <span class=\"hljs-type\">int</span> abort_request;<br>    <span class=\"hljs-comment\">//序列号，和MyAVPacketList的serial作用相同，但改变的时序稍微有点不同</span><br>    <span class=\"hljs-type\">int</span> serial;<br>    <span class=\"hljs-comment\">//用于维持PacketQueue的多线程安全(SDL_mutex可以按pthread_mutex_t理解）</span><br>    SDL_mutex *mutex;<br>    <span class=\"hljs-comment\">//用于读、写线程相互通知(SDL_cond可以按pthread_cond_t理解)</span><br>    SDL_cond *cond;<br>&#125; PacketQueue;<br></code></pre></td></tr></table></figure>\n\n<p>结构体的第一个成员是AVFifo指针类型的。FFmpeg 定义了AVFifo结构体和操作这个结构体的一系列函数，实现了队列的数据结构。PacketQueue 是封装了AVFifo 实例，来管理MyAVPacketList，进而管理解封装后的AVPacket的。</p>\n<h2 id=\"AVFifo\"><a href=\"#AVFifo\" class=\"headerlink\" title=\"AVFifo\"></a>AVFifo</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">AVFifo</span> &#123;</span><br>    <span class=\"hljs-type\">uint8_t</span> *buffer;<br><br>    <span class=\"hljs-type\">size_t</span> elem_size, nb_elems;<br>    <span class=\"hljs-type\">size_t</span> offset_r, offset_w;<br>    <span class=\"hljs-comment\">// distinguishes the ambiguous situation offset_r == offset_w</span><br>    <span class=\"hljs-type\">int</span>    is_empty;<br><br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> flags;<br>    <span class=\"hljs-type\">size_t</span>       auto_grow_limit;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>操作</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">AVFifo *<span class=\"hljs-title\">av_fifo_alloc2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> elems, <span class=\"hljs-type\">size_t</span> elem_size,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                       <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> flags)</span></span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">av_fifo_write</span><span class=\"hljs-params\">(AVFifo *f, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span> *buf, <span class=\"hljs-type\">size_t</span> nb_elems)</span></span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">av_fifo_read</span><span class=\"hljs-params\">(AVFifo *f, <span class=\"hljs-type\">void</span> *buf, <span class=\"hljs-type\">size_t</span> nb_elems)</span></span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">av_fifo_freep2</span><span class=\"hljs-params\">(AVFifo **f)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>av_fifo_alloc2 创建队列</p>\n</li>\n<li><p>av_fifo_read 从队列中读一个元素，队列长度减 1</p>\n</li>\n<li><p>av_fifo_write 给队列添加一个元素， 队列长度加1 </p>\n</li>\n<li><p>av_fifo_freep2 销毁队列</p>\n</li>\n</ul>\n<h1 id=\"PacketQueue-操作函数\"><a href=\"#PacketQueue-操作函数\" class=\"headerlink\" title=\"PacketQueue 操作函数\"></a>PacketQueue 操作函数</h1><p><code>PacketQueue</code>操作提供以下方法：</p>\n<ul>\n<li><p>packet_queue_init:  初始化</p>\n</li>\n<li><p>packet_queue_destroy： 销毁</p>\n</li>\n<li><p>packet_queue_start： 开启</p>\n</li>\n<li><p>packet_queue_abort： 终止</p>\n</li>\n<li><p>packet_queue_get： 获取一个节点</p>\n</li>\n<li><p>packet_queue_put： 存入一个节点</p>\n</li>\n<li><p>packet_queue_put_nullpacket： 存入一个空节点</p>\n</li>\n<li><p>packet_queue_flush： 清除队列内所有的节点</p>\n</li>\n</ul>\n<h2 id=\"packet-queue-init\"><a href=\"#packet-queue-init\" class=\"headerlink\" title=\"packet_queue_init\"></a>packet_queue_init</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> packet_queue_init(PacketQueue *q)<br>&#123;<br>    memset(q, <span class=\"hljs-number\">0</span>, <span class=\"hljs-keyword\">sizeof</span>(PacketQueue));<br>    q-&gt;pkt_list = av_fifo_alloc2(<span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">sizeof</span>(MyAVPacketList), <span class=\"hljs-built_in\">AV_FIFO_FLAG_AUTO_GROW</span>);<br>    <span class=\"hljs-keyword\">if</span> (!q-&gt;pkt_list)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">AVERROR</span>(ENOMEM);<br>    q-&gt;mutex = SDL_CreateMutex();<br>    <span class=\"hljs-keyword\">if</span> (!q-&gt;mutex) &#123;<br>        av_log(<span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-built_in\">AV_LOG_FATAL</span>, <span class=\"hljs-string\">&quot;SDL_CreateMutex(): %s\\n&quot;</span>, SDL_GetError());<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">AVERROR</span>(ENOMEM);<br>    &#125;<br>    q-&gt;cond = SDL_CreateCond();<br>    <span class=\"hljs-keyword\">if</span> (!q-&gt;cond) &#123;<br>        av_log(<span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-built_in\">AV_LOG_FATAL</span>, <span class=\"hljs-string\">&quot;SDL_CreateCond(): %s\\n&quot;</span>, SDL_GetError());<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">AVERROR</span>(ENOMEM);<br>    &#125;<br>    q-&gt;abort_request = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>内部调用av_fifo_alloc2 创建AVFifo 队列实例</p>\n</li>\n<li><p>创建mutex用于队列安全访问</p>\n</li>\n<li><p>创建cond 用于队列等待和唤醒控制</p>\n</li>\n<li><p>初始设置abort_request &#x3D; 1</p>\n</li>\n</ol>\n<h2 id=\"packet-queue-destroy\"><a href=\"#packet-queue-destroy\" class=\"headerlink\" title=\"packet_queue_destroy\"></a>packet_queue_destroy</h2><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">static void <span class=\"hljs-built_in\">packet_queue_destroy</span>(PacketQueue *q)<br>&#123;<br>    <span class=\"hljs-built_in\">packet_queue_flush</span>(q);<br>    <span class=\"hljs-built_in\">av_fifo_freep2</span>(&amp;q-&gt;pkt_list);<br>    <span class=\"hljs-built_in\">SDL_DestroyMutex</span>(q-&gt;mutex);<br>    <span class=\"hljs-built_in\">SDL_DestroyCond</span>(q-&gt;cond);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>调用packet_queue_flush清空队列中的元素</p>\n</li>\n<li><p>销毁AVFifo 队列实例</p>\n</li>\n<li><p>销毁mutex</p>\n</li>\n<li><p>销毁cond</p>\n</li>\n</ol>\n<h2 id=\"packet-queue-start\"><a href=\"#packet-queue-start\" class=\"headerlink\" title=\"packet_queue_start\"></a>packet_queue_start</h2><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">static void packet_queue_start(PacketQueue *q)<br>&#123;<br>    SDL_L<span class=\"hljs-function\"><span class=\"hljs-title\">ockMutex</span>(q-&gt;</span>mutex);<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span>abort_request = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span>serial++;<br>    SDL_U<span class=\"hljs-function\"><span class=\"hljs-title\">nlockMutex</span>(q-&gt;</span>mutex);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>只是加锁，将abort_request设置为0，并且将serial加1，然后解锁。</p>\n<h2 id=\"packet-queue-abort\"><a href=\"#packet-queue-abort\" class=\"headerlink\" title=\"packet_queue_abort\"></a>packet_queue_abort</h2><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">static void packet_queue_abort(PacketQueue *q)<br>&#123;<br>    SDL_L<span class=\"hljs-function\"><span class=\"hljs-title\">ockMutex</span>(q-&gt;</span>mutex);<br><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span>abort_request = <span class=\"hljs-number\">1</span>;<br><br>    SDL_C<span class=\"hljs-function\"><span class=\"hljs-title\">ondSignal</span>(q-&gt;</span>cond);<br><br>    SDL_U<span class=\"hljs-function\"><span class=\"hljs-title\">nlockMutex</span>(q-&gt;</span>mutex);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>加锁，将abort_request设置为1，标记为队列被终止。</p>\n<p>同时唤醒等待条件变量的线程，使其正常退出,   解锁。</p>\n<h2 id=\"packet-queue-get\"><a href=\"#packet-queue-get\" class=\"headerlink\" title=\"packet_queue_get\"></a>packet_queue_get</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* return &lt; 0 if aborted, 0 if no packet and &gt; 0 if packet.  */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">packet_queue_get</span><span class=\"hljs-params\">(PacketQueue *q, AVPacket *pkt, <span class=\"hljs-type\">int</span> block, <span class=\"hljs-type\">int</span> *serial)</span><br>&#123;<br>    MyAVPacketList pkt1;<br>    <span class=\"hljs-type\">int</span> ret;<br>    <span class=\"hljs-comment\">//加锁</span><br>    SDL_LockMutex(q-&gt;mutex);<br><br>    <span class=\"hljs-keyword\">for</span> (;;) &#123;<br>        <span class=\"hljs-keyword\">if</span> (q-&gt;abort_request) &#123;<br>            <span class=\"hljs-comment\">//队列终止了, 设置返回值为-1</span><br>            ret = <span class=\"hljs-number\">-1</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>        <span class=\"hljs-comment\">//从pkt_list中读出一个节点，放入MyAVPacketList中，同时更新队列的信息</span><br>        <span class=\"hljs-keyword\">if</span> (av_fifo_read(q-&gt;pkt_list, &amp;pkt1, <span class=\"hljs-number\">1</span>) &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-comment\">//更新队列长度</span><br>            q-&gt;nb_packets--;<br>            <span class=\"hljs-comment\">//更新队列占用内存大小</span><br>            q-&gt;size -= pkt1.pkt-&gt;size + <span class=\"hljs-keyword\">sizeof</span>(pkt1);<br>            <span class=\"hljs-comment\">//更新队列时长</span><br>            q-&gt;duration -= pkt1.pkt-&gt;duration;<br>            <span class=\"hljs-comment\">//转移pkt1.pkt的内容到pkt中</span><br>            av_packet_move_ref(pkt, pkt1.pkt);<br>            <span class=\"hljs-comment\">//设置serial的值</span><br>            <span class=\"hljs-keyword\">if</span> (serial)<br>                *serial = pkt1.serial;<br>            <span class=\"hljs-comment\">//pkt1.pkt内容已近被转移，释放pkt1.pkt的内存</span><br>            av_packet_free(&amp;pkt1.pkt);<br>            <span class=\"hljs-comment\">//返回值&gt;0,代表从队列获取到了元素</span><br>            ret = <span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!block) &#123;<br>            <span class=\"hljs-comment\">//没有获取到元素，但是调用放要求不阻塞，设置返回值为0，跳出循环</span><br>            ret = <span class=\"hljs-number\">0</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">//没读到元素，阻塞等待有元素可以获取</span><br>            SDL_CondWait(q-&gt;cond, q-&gt;mutex);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">//解锁</span><br>    SDL_UnlockMutex(q-&gt;mutex);<br>    <span class=\"hljs-keyword\">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从队列中获取一个元素</p>\n<ol>\n<li><p>加锁</p>\n</li>\n<li><p>获取成功，队列元素减少，更新队列信息</p>\n</li>\n<li><p>获取失败，要求不阻塞，立马返回</p>\n</li>\n<li><p>获取失败，要求阻塞，调用wait进入等待状态</p>\n</li>\n<li><p>解锁</p>\n</li>\n</ol>\n<h2 id=\"packet-queue-put\"><a href=\"#packet-queue-put\" class=\"headerlink\" title=\"packet_queue_put\"></a>packet_queue_put</h2><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">static int packet_queue_put_private(PacketQueue *q, AVPacket *pkt)<br>&#123;<br>    MyAVPacketList pkt1;<br>    int ret;<br>    <span class=\"hljs-comment\">//如果队列被终止，返回-1</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (q-&gt;</span>abort_request)<br>       return -<span class=\"hljs-number\">1</span>;<br><br>    <span class=\"hljs-comment\">//给节点填充数据</span><br>    pkt1.pkt = pkt;<br>    <span class=\"hljs-comment\">//设置pkt的序列号</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">pkt1</span>.serial = q-&gt;</span>serial;<br>    <span class=\"hljs-comment\">//将节点添加到队列</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">ret</span> = av_fifo_write(q-&gt;</span>pkt_list, &amp;pkt1, <span class=\"hljs-number\">1</span>);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>)<br>        return ret;<br>    <span class=\"hljs-comment\">//更新队列大小</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span>nb_packets++;<br>    <span class=\"hljs-comment\">//更新队列内存大小，添加节点size(pkt内存的大小 + 节点数据大小)</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">size</span> += pkt1.pkt-&gt;</span>size + sizeof(pkt1);<br>    <span class=\"hljs-comment\">//更新队列的总时长</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">duration</span> += pkt1.pkt-&gt;</span>duration;<br>    <span class=\"hljs-comment\">/* <span class=\"hljs-doctag\">XXX:</span> should duplicate packet data in DV case */</span><br>    SDL_C<span class=\"hljs-function\"><span class=\"hljs-title\">ondSignal</span>(q-&gt;</span>cond);<br>    return <span class=\"hljs-number\">0</span>;<br>&#125;<br><br>static int packet_queue_put(PacketQueue *q, AVPacket *pkt)<br>&#123;<br>    AVPacket *pkt1;<br>    int ret;<br>    <span class=\"hljs-comment\">//创建pkt1</span><br>    pkt1 = av_packet_alloc();<br>    <span class=\"hljs-keyword\">if</span> (!pkt1) &#123;<br>        <span class=\"hljs-comment\">//创建pkt1失败，取消引用pkt</span><br>        av_packet_unref(pkt);<br>        return -<span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">//将pkt内容转移到pkt1中</span><br>    av_packet_move_ref(pkt1, pkt);<br>    <span class=\"hljs-comment\">//加锁操加入队列</span><br>    SDL_L<span class=\"hljs-function\"><span class=\"hljs-title\">ockMutex</span>(q-&gt;</span>mutex);<br>    <span class=\"hljs-comment\">//调用packet_queue_put_private将pkt1放入队列中</span><br>    ret = packet_queue_put_private(q, pkt1);<br>    SDL_U<span class=\"hljs-function\"><span class=\"hljs-title\">nlockMutex</span>(q-&gt;</span>mutex);<br><br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-comment\">//放入队列失败，需要取消引用pkt1</span><br>        av_packet_free(&amp;pkt1);<br><br>    return ret;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>将AVPacket封装为MyAVPacketList，保存在内部的队列中</p>\n</li>\n<li><p>队列长度加1，同时更新时长，内存占用等信息</p>\n</li>\n<li><p>packet_queue_put内部调用packet_queue_put_private来完成相关的操作</p>\n</li>\n</ol>\n<h2 id=\"packet-queue-put-nullpacket\"><a href=\"#packet-queue-put-nullpacket\" class=\"headerlink\" title=\"packet_queue_put_nullpacket\"></a>packet_queue_put_nullpacket</h2><figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">//播放完了，从文件中读出了空的pkt，空的pkt丢给解码器的时候，会冲洗解码器，将解码器剩余的额数据读出来</span><br><span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">packet_queue_put_nullpacket</span><span class=\"hljs-params\">(PacketQueue *q, AVPacket *pkt, <span class=\"hljs-keyword\">int</span> stream_index)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//设置pkt对应的stream_index </span><br>    pkt-&gt;stream_index = stream_index;<br>    <span class=\"hljs-comment\">//添加有一个内容为空的pkt到队列中</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title\">packet_queue_put</span><span class=\"hljs-params\">(q, pkt)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><p>给队列添加一个内容为空的pkt</p>\n</li>\n<li><p>设置pkt对应的stream_index，追加到队列中</p>\n</li>\n</ol>\n<h2 id=\"packet-queue-flush\"><a href=\"#packet-queue-flush\" class=\"headerlink\" title=\"packet_queue_flush\"></a>packet_queue_flush</h2><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">static void packet_queue_flush(PacketQueue *q)<br>&#123;<br>    MyAVPacketList pkt1;<br>    <span class=\"hljs-comment\">//加锁</span><br>    SDL_L<span class=\"hljs-function\"><span class=\"hljs-title\">ockMutex</span>(q-&gt;</span>mutex);<br>    <span class=\"hljs-comment\">//从内部队列循环获取元素，存入pkt1中</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">while</span> (av_fifo_read(q-&gt;</span>pkt_list, &amp;pkt1, <span class=\"hljs-number\">1</span>) &gt;= <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-comment\">//释放MyAVPacketList中的AVPacket的内存</span><br>        av_packet_free(&amp;pkt1.pkt);<br>    <span class=\"hljs-comment\">//更新队列信息</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span>nb_packets = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span>size = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span>duration = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-comment\">//serial加1</span><br>    <span class=\"hljs-function\"><span class=\"hljs-title\">q</span>-&gt;</span>serial++;<br>    <span class=\"hljs-comment\">//解锁</span><br>    SDL_U<span class=\"hljs-function\"><span class=\"hljs-title\">nlockMutex</span>(q-&gt;</span>mutex);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p> 清空队列，释放节点的内存，更新队列信息。</p>\n<p>而对于serial的操作不是设置为0，而是在原来的基础上增加了1，为什么呢？</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ol>\n<li><p>ffplay 用PacketQueue来保存解封装后的AVPacket</p>\n</li>\n<li><p>PacketQueue对元素的操作，依赖于内部基于ffmpeg AVFifo的队列实例</p>\n</li>\n<li><p>PacketQueue通过mutex来保证线层安全</p>\n</li>\n<li><p>PacketQueue通过条件变量来控制写入和读取的顺序</p>\n</li>\n</ol>\n"},{"layout":"post","title":"FFmpeg filter","date":"2022-03-14T16:00:00.000Z","_content":"\n参考：\n\n[FFmpeg filter简介 - Tocy - 博客园](https://www.cnblogs.com/tocy/p/ffmpeg-filter-intro.html)\n\n[FFmpeg Filtering Guide](https://trac.ffmpeg.org/wiki/FilteringGuide)\n\n[FFmpeg Filters Documentation](http://ffmpeg.org/ffmpeg-filters.html)\n\n[FFmpeg filter的使用介绍]([FFmpeg filter的使用介绍 - 简书](https://www.jianshu.com/p/b16835da62ab))\n\n\n","source":"_posts/ffmpeg/2022-03-15-ffmpeg filters.md","raw":"---\nlayout: post\ntitle: \"FFmpeg filter\"\ndate: 2022-03-15\ntag: ffmpeg\n\n---\n\n参考：\n\n[FFmpeg filter简介 - Tocy - 博客园](https://www.cnblogs.com/tocy/p/ffmpeg-filter-intro.html)\n\n[FFmpeg Filtering Guide](https://trac.ffmpeg.org/wiki/FilteringGuide)\n\n[FFmpeg Filters Documentation](http://ffmpeg.org/ffmpeg-filters.html)\n\n[FFmpeg filter的使用介绍]([FFmpeg filter的使用介绍 - 简书](https://www.jianshu.com/p/b16835da62ab))\n\n\n","slug":"ffmpeg/2022-03-15-ffmpeg filters","published":1,"updated":"2024-03-07T03:07:32.474Z","comments":1,"photos":[],"_id":"cltgopend001zqywh5cpcegts","content":"<p>参考：</p>\n<p><a href=\"https://www.cnblogs.com/tocy/p/ffmpeg-filter-intro.html\">FFmpeg filter简介 - Tocy - 博客园</a></p>\n<p><a href=\"https://trac.ffmpeg.org/wiki/FilteringGuide\">FFmpeg Filtering Guide</a></p>\n<p><a href=\"http://ffmpeg.org/ffmpeg-filters.html\">FFmpeg Filters Documentation</a></p>\n<p>[FFmpeg filter的使用介绍](<a href=\"https://www.jianshu.com/p/b16835da62ab\">FFmpeg filter的使用介绍 - 简书</a>)</p>\n","excerpt":"","more":"<p>参考：</p>\n<p><a href=\"https://www.cnblogs.com/tocy/p/ffmpeg-filter-intro.html\">FFmpeg filter简介 - Tocy - 博客园</a></p>\n<p><a href=\"https://trac.ffmpeg.org/wiki/FilteringGuide\">FFmpeg Filtering Guide</a></p>\n<p><a href=\"http://ffmpeg.org/ffmpeg-filters.html\">FFmpeg Filters Documentation</a></p>\n<p>[FFmpeg filter的使用介绍](<a href=\"https://www.jianshu.com/p/b16835da62ab\">FFmpeg filter的使用介绍 - 简书</a>)</p>\n"},{"layout":"post","title":"ffplay frame queue 分析","date":"2022-03-14T16:00:00.000Z","_content":"\n参考：  [ffplay frame queue分析](https://zhuanlan.zhihu.com/p/43564980)\n\n## FrameQueue数据结构\n\nffplay 定义了 FrameQueue 来管理解码后的音频，视频以及字幕。\n\n```c\n/* Common struct for handling all types of decoded data and allocated render buffers. */\ntypedef struct Frame {\n    AVFrame *frame;       //audio/video frame\n    AVSubtitle sub;       //字幕\n    int serial;           //序列号\n    double pts;           /* presentation timestamp for the frame */\n    double duration;      /* estimated duration of the frame */\n    int64_t pos;          /* byte position of the frame in the input file */\n    int width;\n    int height;\n    int format;\n    AVRational sar;       //video aspect ratio\n    int uploaded;\n    int flip_v;           //video，是否应该在垂直方向翻转\n} Frame;\n\ntypedef struct FrameQueue {\n    Frame queue[FRAME_QUEUE_SIZE];  //frame数组，环形buffer\n    int rindex;                     //读指针，指向下一个可读的位置\n    int windex;                     //写指针，指向下一个可写的位置\n    int size;                       //队列元素个数\n    int max_size;                   //队列容量\n    int keep_last;                  //是否在队列中保留上一个已读的元素\n    int rindex_shown;               //标记rindex指向的元素是否已经展示（已读），keep_last为1时生效。\n    SDL_mutex *mutex;               //锁,用于安全访问\n    SDL_cond *cond;                 //条件变量，用于控制读取和写入，防止overrun和underflow\n    PacketQueue *pktq;              //该frame queue 对应的 pkt queue\n} FrameQueue;\n```\n\n> Frame的设计试图用一个结构体“融合”3种数据：视频、音频、字幕，虽然AVFrame既可以表示视频又可以表示音频，但在融合字幕时又需要引入AVSubtitle，以及一些其他字段，如width/height等来补充AVSubtitle，所以整个结构体看起来很“拼凑”（甚至还有视频专用的flip_v字段）\n> \n> FrameQueue的设计理念：\n> \n> 1. 高效率的读写模型\n> 2. 高效的内存模型（节点内存以数组形式预分配，无需动态分配）\n> 3. 环形缓冲区设计，同时可以访问上一读节点\n\n## 队列的操作：\n\n### 队列初始化\n\n```c\nstatic int frame_queue_init(FrameQueue *f, PacketQueue *pktq, int max_size, int keep_last)\n{\n    int i;\n    memset(f, 0, sizeof(FrameQueue));\n    //互斥锁创建\n    if (!(f->mutex = SDL_CreateMutex())) {\n        av_log(NULL, AV_LOG_FATAL, \"SDL_CreateMutex(): %s\\n\", SDL_GetError());\n        return AVERROR(ENOMEM);\n    }\n    //条件变量创建\n    if (!(f->cond = SDL_CreateCond())) {\n        av_log(NULL, AV_LOG_FATAL, \"SDL_CreateCond(): %s\\n\", SDL_GetError());\n        return AVERROR(ENOMEM);\n    }\n    //设置对应的pkt queue\n    f->pktq = pktq;\n    //设置队列的容量，视频 3, 音频 9，字幕 16\n    f->max_size = FFMIN(max_size, FRAME_QUEUE_SIZE);\n    //是否保留最后一个位置，视频音频保留，字幕不保留\n    f->keep_last = !!keep_last;\n    //给队列中的每个节点对应的frame初始化\n    for (i = 0; i < f->max_size; i++)\n        if (!(f->queue[i].frame = av_frame_alloc()))\n            return AVERROR(ENOMEM);\n    return 0;\n}\n```\n\n初始化队列的内存，创建锁，条件变量，保存pkt queue，设置队列的容量，keep_last标志位初始化。初始化队列节点，给队列中的每个节点对应的frame调用av_frame_alloc分配内存。\n\n参数max_size用来设置队列的容量，最大不超过FRAME_QUEUE_SIZE。其中视频队列的容量为3，音频9，字幕16。FRAME_QUEUE_SIZE定义如下:\n\n```c\n#define VIDEO_PICTURE_QUEUE_SIZE 3\n#define SUBPICTURE_QUEUE_SIZE 16\n#define SAMPLE_QUEUE_SIZE 9\n#define FRAME_QUEUE_SIZE FFMAX(SAMPLE_QUEUE_SIZE, FFMAX(VIDEO_PICTURE_QUEUE_SIZE, SUBPICTURE_QUEUE_SIZE))\n```\n\n展开后FRAME_QUEUE_SIZE的值为16。\n\nkeep_last是一个bool值，表示是否在环形缓冲区的读写过程中保留最后一个读节点不被覆写。`f->keep_last = !!keep_last;`里的双感叹号是C中的一种技巧，旨在让int参数规整为0/1的“bool值”。视频和音频会保留最后一个节点，而字幕不保留。\n\n\n\n### 队列销毁\n\n```c\nstatic void frame_queue_destory(FrameQueue *f)\n{\n    int i;\n    for (i = 0; i < f->max_size; i++) {\n        Frame *vp = &f->queue[i];\n        //对每个节点调用frame_queue_unref_item\n        frame_queue_unref_item(vp);\n        //调用av_frame_free释放frame的内存\n        av_frame_free(&vp->frame);\n    }\n    SDL_DestroyMutex(f->mutex);\n    SDL_DestroyCond(f->cond);\n}\n```\n\n较为重要的是queue元素的释放。分两步，分别是`frame_queue_unref_item`和`av_frame_free`。其中`av_frame_free`与初始化中的`av_frame_alloc`对应，用于释放AVFrame.\n\n`frame_queue_unref_item`的定义如下：\n\n```c\nstatic void frame_queue_unref_item(Frame *vp)\n{\n    av_frame_unref(vp->frame);//引用计数-1\n    avsubtitle_free(&vp->sub);//sub关联的内存释放\n}\n```\n\n`frame_queue_unref_item`释放的内存都是**关联**的内存，而非结构体自身内存。\n\nAVFrame内部有许多的AVBufferRef类型字段，而AVBufferRef只是AVBuffer的引用，AVBuffer通过引用计数自动管理内存（简易垃圾回收机制）。因此AVFrame在不需要的时候，需要通过`av_frame_unref`减少引用计数。\n\n> 关于AVBufferRef的内存管理机制，可以参考这篇文章： [深入理解FFMPEG-AVBuffer/AVBufferRef/AVBufferPool]([深入理解FFMPEG-AVBuffer/AVBufferRef/AVBufferPool_muyuyuzhong的专栏-CSDN博客](https://blog.csdn.net/muyuyuzhong/article/details/79381152))\n\n### 队列写操作\n\nFrameQueue的“写”分两步，先调用`frame_queue_peek_writable`获取一个可写节点，在对节点操作结束后，调用`frame_queue_push`告知FrameQueue“存入”该节点。\n\n> 阅读提示：  \n> 在ffplay中，FrameQueue始终是一个线程写，另一个线程读。也就是只有一个读线程，不会有其他读线程竞争读；只有一个写线程，不会有其他线程竞争写；唯一需要的是读与写线程间的同步。FrameQueue的整个优化和设计思路正是基于这一点的。\n\n先看`frame_queue_peek_writable`：\n\n```c\nstatic Frame *frame_queue_peek_writable(FrameQueue *f)\n{\n    /* wait until we have space to put a new frame */\n    SDL_LockMutex(f->mutex);\n    while (f->size >= f->max_size &&\n           !f->pktq->abort_request) {\n        //等待有空间可以写，才继续执行\n        SDL_CondWait(f->cond, f->mutex);\n    }\n    SDL_UnlockMutex(f->mutex);\n\n    if (f->pktq->abort_request)\n        return NULL;\n    //返回f->windex对应的frame\n    return &f->queue[f->windex];\n}\n```\n\n整个函数分3步：\n\n1. 加锁情况下，等待直到队列有空余空间可写（`f->size < f->max_size`）\n2. 如果有退出请求（`f->pktq->abort_request`），则返回NULL\n3. 返回`windex`位置的元素（`windex`指向当前应写位置）\n\n> 为什么这里锁的范围不是整个函数呢？这是为了减小锁的范围，以提高效率。而之所以可以在无锁的情况下安全访问queue 字段，是因为上文中提到的单读单写的特殊场景。首先，queue是一个预先分配好的数组，因此queue本身不发生变化，可以安全访问；接着queue内的元素，读和写不存在重叠，即windex和rindex不会重叠。\n> \n> 关于“读和写不存在重叠”，仔细看看。因为queue数组被当做一个环形缓冲区使用，那么的确存在underrun和overrun的情况，即读过快，或写过快的情况，这时如果不加控制，就会呈现缓冲区覆盖。\n> \n> FrameQueue的精明之处在于，先通过size判断当前缓冲区内空间是否够写，或者够读，比如这里先通过一个循环的条件等待，判断`f->size >= f->max_size`，如果`f->size >= f->max_size`，那么说明队列中的节点已经写满，也就是已经overrun了，此时如果再写，肯定会覆写未读数据，那么就需要继续等待。当无需等待时，windex指向的内存一定是已经读过的（除非代码异常了）。\n> \n> 调用`frame_queue_peek_writable`取到Frame指针后，就可以对Frame内的字段自由改写，因为只有一个写进程，且无需担心读进程覆写。如上分析，读进程要读一个节点时，也会先判断underrun的情况）。\n\n一般步骤是：\n\n```c\nFrame* vp = frame_queue_peek_writable(q);\n//将要存储的数据写入frame字段，比如：\nav_frame_move_ref(vp->frame, src_frame);\n//存入队列\nframe_queue_push(q);\n```\n\n`frame_queue_push`怎么知道要push的是这里的vp呢？\n\n```c\nstatic void frame_queue_push(FrameQueue *f)\n{\n    if (++f->windex == f->max_size)\n        f->windex = 0;\n    SDL_LockMutex(f->mutex);\n    f->size++;\n    SDL_CondSignal(f->cond);\n    SDL_UnlockMutex(f->mutex);\n}\n```\n\n答案是push当前windex节点。看`frame_queue_push`函数，执行两个步骤：\n\n1. windex加1，如果超过max_size，则回环为0\n2. 加锁情况下大小加1.\n\n> 因为FrameQueue是基于固定长度的数组实现的队列，与链表队列不同，其节点在初始化的时候已经在队列中了，push所要做的只是通过某种标志记录该节点是否是写入未读的。ffplay的做法是对windex加1，将写指针移动到下一个元素，凡是windex“之前”的节点，都是写过的。（至于是否可读，rindex知道；至于后续有多少空间可写，size知道）\n\n### 队列读操作\n\n和写一样，FrameQueue的读也分两步。`frame_queue_peek_readable`和`frame_queue_next`。相比写要复杂一点的是 ，读的代码多考虑另一个特性，即允许保留上一读节点。\n\n`frame_queue_peek_readable`代码如下：\n\n```c\nstatic Frame *frame_queue_peek_readable(FrameQueue *f)\n{\n    /* wait until we have a readable a new frame */\n    SDL_LockMutex(f->mutex);\n    while (f->size - f->rindex_shown <= 0 &&\n           !f->pktq->abort_request) {\n        SDL_CondWait(f->cond, f->mutex);\n    }\n    SDL_UnlockMutex(f->mutex);\n\n    if (f->pktq->abort_request)\n        return NULL;\n\n    return &f->queue[(f->rindex + f->rindex_shown) % f->max_size];\n}\n```\n\n和`frame_queue_peek_writable`类似，分三步:\n\n1. 加锁情况下，判断是否有可读节点（`f->size - f->rindex_shown > 0`)\n2. 如果有退出请求，则返回NULL\n3. 读取当前可读节点`(f->rindex + f->rindex_shown) % f->max_size`\n\n`rindex_shown`有些干扰代码分析，我们先看不支持keep_last的情况（只需要在初始化的时候传入keep_last = 0），此事`rindex_shown`始终为0，所以，`frame_queue_peek_readable`简化如下：\n\n```c\nstatic Frame *frame_queue_peek_readable(FrameQueue *f)\n{\n    /* wait until we have a readable a new frame */\n    SDL_LockMutex(f->mutex);\n    while (f->size <= 0 &&\n           !f->pktq->abort_request) {\n        SDL_CondWait(f->cond, f->mutex);\n    }\n    SDL_UnlockMutex(f->mutex);\n\n    if (f->pktq->abort_request)\n        return NULL;\n\n    return &f->queue[f->rindex];\n}\n\n```\n\n和peek_writable几乎是一一对应的。就不分析了。\n\n\n\n在简化版本上理解引入`rindex_shown`的代码，我们需要先理解`rindex_shown`。`rindex_shown`的意思是`rindex`指向的节点是否被读过，如果被读过， 为1，反之，为0。这一行为，体现在`frame_queue_next`：\n\n```c\nstatic void frame_queue_next(FrameQueue *f)\n{   \n    //如果支持keep_last，并且f->rindex_shown为0, 将rindex_shown设置为1，返回\n    if (f->keep_last && !f->rindex_shown) {\n        f->rindex_shown = 1;\n        return;\n    }\n    //否则，移动rindex指针，并减小size\n    frame_queue_unref_item(&f->queue[f->rindex]);\n    if (++f->rindex == f->max_size)\n        f->rindex = 0;\n    SDL_LockMutex(f->mutex);\n    f->size--;\n    SDL_CondSignal(f->cond);\n    SDL_UnlockMutex(f->mutex);\n}\n```\n\n`frame_queue_next`用于在读完一个节点后调用，用于标记一个节点已经被读过。\n\n与写过程类似，读过程可以描述为：\n\n```c\nFrame* vp = frame_queue_peek_readable(f);\n//读取vp的数据，比如\nprintf(\"pict_type=%d\\n\", vp->frame->pict_type);\nframe_queue_next(f);\n```\n\n`frame_queue_next`比`frame_queue_push`略复杂，我们要分析两个行为：标记一个节点为已读，以及`rindex_shown`的赋值。\n\n标记一个节点为已读于标记一个节点为已写是类似的，执行两个步骤：\n\n1. rindex加1，如果超过max_size，则回环为0\n2. 加锁情况下大小减1.\n\n特别的是，对于以及读过的节点，需要调用`frame_queue_unref_item`释放关联内存。\n\n执行rindex操作前，需要先判断`rindex_shown`的值，如果为0，则赋1。这么做的意图不妨画图分析：\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16473273492201647327349203.png)\n\n这里模拟了从初始化开始的2次“读”。\n\n还没开始读，rindex和rindex_shown均为0。这时要peek的读节点是节点0(图中黑色块）。\n\n第一次读，调用next，满足条件`f->keep_last && !f->rindex_shown`，所以rindex仍然是0，而rindex_shown为1.此时节点0（灰色块）是已读节点，也是要keep的last节点，将要读的节点是节点1（黑色块）。（恰好是rindex+rindex_shown）\n\n第二次读，peek了黑色块后，调用next，不满足条件`f->keep_last && !f->rindex_shown`，所以rindex为1，而rindex_shown为2.此时节点1（灰色块）是last节点，节点2（黑色块）是将要读的节点。（也恰好是rindex+rindex_shown）\n\n继续往后分析，会一直重复第二次读的情况，始终是rindex指向了last，而rindex_shown一直为1，rindex+rindex_shown刚好是将要读的节点。\n\n至此，`frame_queue_next`的行为算是明确了。回头看看`frame_queue_peek_readable`。\n\n步骤1中，判断无可读节点，用的是`f->size - f->rindex_shown <= 0`，其实是以下代码的简化：\n\n```c\nif (f->rindex_shown)\n    return f->size - 1;\nelse\n    return f->size;\n```\n\n只是C中用int模拟bool，刚好rindex_shown为true是1，所以可以简化为`` `f->size - f->rindex_shown ``.\n\n步骤3中，取将要读的节点用的是`(f->rindex + f->rindex_shown) % f->max_size`，同样也是一个简化：\n\n```c\n//这段代码根据上图很容易推导\nif (f->rindex_shown)\n    return (f->rindex + 1) % f->max_size; //因为rindex加1后可能超过max_size，所以这里取余\nelse\n    return f->rindex;\n```\n\n以上，FrameQueue的读过程也分析完了。\n\n为了支持灵活地读，还有一些辅助函数：\n\n```c\n//读当前节点（上文中的用词是“将要读的节点”，也就是黑色块），与frame_queue_peek_readable等效，但没有检查是否有可读节点\nstatic Frame *frame_queue_peek(FrameQueue *f)\n{\n    return &f->queue[(f->rindex + f->rindex_shown) % f->max_size];\n}\n\n//读下一个节点\nstatic Frame *frame_queue_peek_next(FrameQueue *f)\n{\n    return &f->queue[(f->rindex + f->rindex_shown + 1) % f->max_size];\n}\n\n//读上一个节点\nstatic Frame *frame_queue_peek_last(FrameQueue *f)\n{\n    return &f->queue[f->rindex];\n}\n\n/* return the number of undisplayed frames in the queue */\nstatic int frame_queue_nb_remaining(FrameQueue *f)\n{\n    return f->size - f->rindex_shown;\n}\n```\n\n实现都比较简单，借助上图看下节点位置：\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16473274840541647327483583.png)\n\n至此，FrameQueue的主体功能分析完了。从源码中可以看到FrameQueue是针对单读单写优化的高效的多线程模型，其设计思路不失为在C语言实践中可借鉴的一个好例子。\n","source":"_posts/ffmpeg/2022-03-15-ffplay-frame queue 分析.md","raw":"---\nlayout: post\ntitle: \"ffplay frame queue 分析\"\ndate: 2022-03-15\ntag: ffmpeg\n\n---\n\n参考：  [ffplay frame queue分析](https://zhuanlan.zhihu.com/p/43564980)\n\n## FrameQueue数据结构\n\nffplay 定义了 FrameQueue 来管理解码后的音频，视频以及字幕。\n\n```c\n/* Common struct for handling all types of decoded data and allocated render buffers. */\ntypedef struct Frame {\n    AVFrame *frame;       //audio/video frame\n    AVSubtitle sub;       //字幕\n    int serial;           //序列号\n    double pts;           /* presentation timestamp for the frame */\n    double duration;      /* estimated duration of the frame */\n    int64_t pos;          /* byte position of the frame in the input file */\n    int width;\n    int height;\n    int format;\n    AVRational sar;       //video aspect ratio\n    int uploaded;\n    int flip_v;           //video，是否应该在垂直方向翻转\n} Frame;\n\ntypedef struct FrameQueue {\n    Frame queue[FRAME_QUEUE_SIZE];  //frame数组，环形buffer\n    int rindex;                     //读指针，指向下一个可读的位置\n    int windex;                     //写指针，指向下一个可写的位置\n    int size;                       //队列元素个数\n    int max_size;                   //队列容量\n    int keep_last;                  //是否在队列中保留上一个已读的元素\n    int rindex_shown;               //标记rindex指向的元素是否已经展示（已读），keep_last为1时生效。\n    SDL_mutex *mutex;               //锁,用于安全访问\n    SDL_cond *cond;                 //条件变量，用于控制读取和写入，防止overrun和underflow\n    PacketQueue *pktq;              //该frame queue 对应的 pkt queue\n} FrameQueue;\n```\n\n> Frame的设计试图用一个结构体“融合”3种数据：视频、音频、字幕，虽然AVFrame既可以表示视频又可以表示音频，但在融合字幕时又需要引入AVSubtitle，以及一些其他字段，如width/height等来补充AVSubtitle，所以整个结构体看起来很“拼凑”（甚至还有视频专用的flip_v字段）\n> \n> FrameQueue的设计理念：\n> \n> 1. 高效率的读写模型\n> 2. 高效的内存模型（节点内存以数组形式预分配，无需动态分配）\n> 3. 环形缓冲区设计，同时可以访问上一读节点\n\n## 队列的操作：\n\n### 队列初始化\n\n```c\nstatic int frame_queue_init(FrameQueue *f, PacketQueue *pktq, int max_size, int keep_last)\n{\n    int i;\n    memset(f, 0, sizeof(FrameQueue));\n    //互斥锁创建\n    if (!(f->mutex = SDL_CreateMutex())) {\n        av_log(NULL, AV_LOG_FATAL, \"SDL_CreateMutex(): %s\\n\", SDL_GetError());\n        return AVERROR(ENOMEM);\n    }\n    //条件变量创建\n    if (!(f->cond = SDL_CreateCond())) {\n        av_log(NULL, AV_LOG_FATAL, \"SDL_CreateCond(): %s\\n\", SDL_GetError());\n        return AVERROR(ENOMEM);\n    }\n    //设置对应的pkt queue\n    f->pktq = pktq;\n    //设置队列的容量，视频 3, 音频 9，字幕 16\n    f->max_size = FFMIN(max_size, FRAME_QUEUE_SIZE);\n    //是否保留最后一个位置，视频音频保留，字幕不保留\n    f->keep_last = !!keep_last;\n    //给队列中的每个节点对应的frame初始化\n    for (i = 0; i < f->max_size; i++)\n        if (!(f->queue[i].frame = av_frame_alloc()))\n            return AVERROR(ENOMEM);\n    return 0;\n}\n```\n\n初始化队列的内存，创建锁，条件变量，保存pkt queue，设置队列的容量，keep_last标志位初始化。初始化队列节点，给队列中的每个节点对应的frame调用av_frame_alloc分配内存。\n\n参数max_size用来设置队列的容量，最大不超过FRAME_QUEUE_SIZE。其中视频队列的容量为3，音频9，字幕16。FRAME_QUEUE_SIZE定义如下:\n\n```c\n#define VIDEO_PICTURE_QUEUE_SIZE 3\n#define SUBPICTURE_QUEUE_SIZE 16\n#define SAMPLE_QUEUE_SIZE 9\n#define FRAME_QUEUE_SIZE FFMAX(SAMPLE_QUEUE_SIZE, FFMAX(VIDEO_PICTURE_QUEUE_SIZE, SUBPICTURE_QUEUE_SIZE))\n```\n\n展开后FRAME_QUEUE_SIZE的值为16。\n\nkeep_last是一个bool值，表示是否在环形缓冲区的读写过程中保留最后一个读节点不被覆写。`f->keep_last = !!keep_last;`里的双感叹号是C中的一种技巧，旨在让int参数规整为0/1的“bool值”。视频和音频会保留最后一个节点，而字幕不保留。\n\n\n\n### 队列销毁\n\n```c\nstatic void frame_queue_destory(FrameQueue *f)\n{\n    int i;\n    for (i = 0; i < f->max_size; i++) {\n        Frame *vp = &f->queue[i];\n        //对每个节点调用frame_queue_unref_item\n        frame_queue_unref_item(vp);\n        //调用av_frame_free释放frame的内存\n        av_frame_free(&vp->frame);\n    }\n    SDL_DestroyMutex(f->mutex);\n    SDL_DestroyCond(f->cond);\n}\n```\n\n较为重要的是queue元素的释放。分两步，分别是`frame_queue_unref_item`和`av_frame_free`。其中`av_frame_free`与初始化中的`av_frame_alloc`对应，用于释放AVFrame.\n\n`frame_queue_unref_item`的定义如下：\n\n```c\nstatic void frame_queue_unref_item(Frame *vp)\n{\n    av_frame_unref(vp->frame);//引用计数-1\n    avsubtitle_free(&vp->sub);//sub关联的内存释放\n}\n```\n\n`frame_queue_unref_item`释放的内存都是**关联**的内存，而非结构体自身内存。\n\nAVFrame内部有许多的AVBufferRef类型字段，而AVBufferRef只是AVBuffer的引用，AVBuffer通过引用计数自动管理内存（简易垃圾回收机制）。因此AVFrame在不需要的时候，需要通过`av_frame_unref`减少引用计数。\n\n> 关于AVBufferRef的内存管理机制，可以参考这篇文章： [深入理解FFMPEG-AVBuffer/AVBufferRef/AVBufferPool]([深入理解FFMPEG-AVBuffer/AVBufferRef/AVBufferPool_muyuyuzhong的专栏-CSDN博客](https://blog.csdn.net/muyuyuzhong/article/details/79381152))\n\n### 队列写操作\n\nFrameQueue的“写”分两步，先调用`frame_queue_peek_writable`获取一个可写节点，在对节点操作结束后，调用`frame_queue_push`告知FrameQueue“存入”该节点。\n\n> 阅读提示：  \n> 在ffplay中，FrameQueue始终是一个线程写，另一个线程读。也就是只有一个读线程，不会有其他读线程竞争读；只有一个写线程，不会有其他线程竞争写；唯一需要的是读与写线程间的同步。FrameQueue的整个优化和设计思路正是基于这一点的。\n\n先看`frame_queue_peek_writable`：\n\n```c\nstatic Frame *frame_queue_peek_writable(FrameQueue *f)\n{\n    /* wait until we have space to put a new frame */\n    SDL_LockMutex(f->mutex);\n    while (f->size >= f->max_size &&\n           !f->pktq->abort_request) {\n        //等待有空间可以写，才继续执行\n        SDL_CondWait(f->cond, f->mutex);\n    }\n    SDL_UnlockMutex(f->mutex);\n\n    if (f->pktq->abort_request)\n        return NULL;\n    //返回f->windex对应的frame\n    return &f->queue[f->windex];\n}\n```\n\n整个函数分3步：\n\n1. 加锁情况下，等待直到队列有空余空间可写（`f->size < f->max_size`）\n2. 如果有退出请求（`f->pktq->abort_request`），则返回NULL\n3. 返回`windex`位置的元素（`windex`指向当前应写位置）\n\n> 为什么这里锁的范围不是整个函数呢？这是为了减小锁的范围，以提高效率。而之所以可以在无锁的情况下安全访问queue 字段，是因为上文中提到的单读单写的特殊场景。首先，queue是一个预先分配好的数组，因此queue本身不发生变化，可以安全访问；接着queue内的元素，读和写不存在重叠，即windex和rindex不会重叠。\n> \n> 关于“读和写不存在重叠”，仔细看看。因为queue数组被当做一个环形缓冲区使用，那么的确存在underrun和overrun的情况，即读过快，或写过快的情况，这时如果不加控制，就会呈现缓冲区覆盖。\n> \n> FrameQueue的精明之处在于，先通过size判断当前缓冲区内空间是否够写，或者够读，比如这里先通过一个循环的条件等待，判断`f->size >= f->max_size`，如果`f->size >= f->max_size`，那么说明队列中的节点已经写满，也就是已经overrun了，此时如果再写，肯定会覆写未读数据，那么就需要继续等待。当无需等待时，windex指向的内存一定是已经读过的（除非代码异常了）。\n> \n> 调用`frame_queue_peek_writable`取到Frame指针后，就可以对Frame内的字段自由改写，因为只有一个写进程，且无需担心读进程覆写。如上分析，读进程要读一个节点时，也会先判断underrun的情况）。\n\n一般步骤是：\n\n```c\nFrame* vp = frame_queue_peek_writable(q);\n//将要存储的数据写入frame字段，比如：\nav_frame_move_ref(vp->frame, src_frame);\n//存入队列\nframe_queue_push(q);\n```\n\n`frame_queue_push`怎么知道要push的是这里的vp呢？\n\n```c\nstatic void frame_queue_push(FrameQueue *f)\n{\n    if (++f->windex == f->max_size)\n        f->windex = 0;\n    SDL_LockMutex(f->mutex);\n    f->size++;\n    SDL_CondSignal(f->cond);\n    SDL_UnlockMutex(f->mutex);\n}\n```\n\n答案是push当前windex节点。看`frame_queue_push`函数，执行两个步骤：\n\n1. windex加1，如果超过max_size，则回环为0\n2. 加锁情况下大小加1.\n\n> 因为FrameQueue是基于固定长度的数组实现的队列，与链表队列不同，其节点在初始化的时候已经在队列中了，push所要做的只是通过某种标志记录该节点是否是写入未读的。ffplay的做法是对windex加1，将写指针移动到下一个元素，凡是windex“之前”的节点，都是写过的。（至于是否可读，rindex知道；至于后续有多少空间可写，size知道）\n\n### 队列读操作\n\n和写一样，FrameQueue的读也分两步。`frame_queue_peek_readable`和`frame_queue_next`。相比写要复杂一点的是 ，读的代码多考虑另一个特性，即允许保留上一读节点。\n\n`frame_queue_peek_readable`代码如下：\n\n```c\nstatic Frame *frame_queue_peek_readable(FrameQueue *f)\n{\n    /* wait until we have a readable a new frame */\n    SDL_LockMutex(f->mutex);\n    while (f->size - f->rindex_shown <= 0 &&\n           !f->pktq->abort_request) {\n        SDL_CondWait(f->cond, f->mutex);\n    }\n    SDL_UnlockMutex(f->mutex);\n\n    if (f->pktq->abort_request)\n        return NULL;\n\n    return &f->queue[(f->rindex + f->rindex_shown) % f->max_size];\n}\n```\n\n和`frame_queue_peek_writable`类似，分三步:\n\n1. 加锁情况下，判断是否有可读节点（`f->size - f->rindex_shown > 0`)\n2. 如果有退出请求，则返回NULL\n3. 读取当前可读节点`(f->rindex + f->rindex_shown) % f->max_size`\n\n`rindex_shown`有些干扰代码分析，我们先看不支持keep_last的情况（只需要在初始化的时候传入keep_last = 0），此事`rindex_shown`始终为0，所以，`frame_queue_peek_readable`简化如下：\n\n```c\nstatic Frame *frame_queue_peek_readable(FrameQueue *f)\n{\n    /* wait until we have a readable a new frame */\n    SDL_LockMutex(f->mutex);\n    while (f->size <= 0 &&\n           !f->pktq->abort_request) {\n        SDL_CondWait(f->cond, f->mutex);\n    }\n    SDL_UnlockMutex(f->mutex);\n\n    if (f->pktq->abort_request)\n        return NULL;\n\n    return &f->queue[f->rindex];\n}\n\n```\n\n和peek_writable几乎是一一对应的。就不分析了。\n\n\n\n在简化版本上理解引入`rindex_shown`的代码，我们需要先理解`rindex_shown`。`rindex_shown`的意思是`rindex`指向的节点是否被读过，如果被读过， 为1，反之，为0。这一行为，体现在`frame_queue_next`：\n\n```c\nstatic void frame_queue_next(FrameQueue *f)\n{   \n    //如果支持keep_last，并且f->rindex_shown为0, 将rindex_shown设置为1，返回\n    if (f->keep_last && !f->rindex_shown) {\n        f->rindex_shown = 1;\n        return;\n    }\n    //否则，移动rindex指针，并减小size\n    frame_queue_unref_item(&f->queue[f->rindex]);\n    if (++f->rindex == f->max_size)\n        f->rindex = 0;\n    SDL_LockMutex(f->mutex);\n    f->size--;\n    SDL_CondSignal(f->cond);\n    SDL_UnlockMutex(f->mutex);\n}\n```\n\n`frame_queue_next`用于在读完一个节点后调用，用于标记一个节点已经被读过。\n\n与写过程类似，读过程可以描述为：\n\n```c\nFrame* vp = frame_queue_peek_readable(f);\n//读取vp的数据，比如\nprintf(\"pict_type=%d\\n\", vp->frame->pict_type);\nframe_queue_next(f);\n```\n\n`frame_queue_next`比`frame_queue_push`略复杂，我们要分析两个行为：标记一个节点为已读，以及`rindex_shown`的赋值。\n\n标记一个节点为已读于标记一个节点为已写是类似的，执行两个步骤：\n\n1. rindex加1，如果超过max_size，则回环为0\n2. 加锁情况下大小减1.\n\n特别的是，对于以及读过的节点，需要调用`frame_queue_unref_item`释放关联内存。\n\n执行rindex操作前，需要先判断`rindex_shown`的值，如果为0，则赋1。这么做的意图不妨画图分析：\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16473273492201647327349203.png)\n\n这里模拟了从初始化开始的2次“读”。\n\n还没开始读，rindex和rindex_shown均为0。这时要peek的读节点是节点0(图中黑色块）。\n\n第一次读，调用next，满足条件`f->keep_last && !f->rindex_shown`，所以rindex仍然是0，而rindex_shown为1.此时节点0（灰色块）是已读节点，也是要keep的last节点，将要读的节点是节点1（黑色块）。（恰好是rindex+rindex_shown）\n\n第二次读，peek了黑色块后，调用next，不满足条件`f->keep_last && !f->rindex_shown`，所以rindex为1，而rindex_shown为2.此时节点1（灰色块）是last节点，节点2（黑色块）是将要读的节点。（也恰好是rindex+rindex_shown）\n\n继续往后分析，会一直重复第二次读的情况，始终是rindex指向了last，而rindex_shown一直为1，rindex+rindex_shown刚好是将要读的节点。\n\n至此，`frame_queue_next`的行为算是明确了。回头看看`frame_queue_peek_readable`。\n\n步骤1中，判断无可读节点，用的是`f->size - f->rindex_shown <= 0`，其实是以下代码的简化：\n\n```c\nif (f->rindex_shown)\n    return f->size - 1;\nelse\n    return f->size;\n```\n\n只是C中用int模拟bool，刚好rindex_shown为true是1，所以可以简化为`` `f->size - f->rindex_shown ``.\n\n步骤3中，取将要读的节点用的是`(f->rindex + f->rindex_shown) % f->max_size`，同样也是一个简化：\n\n```c\n//这段代码根据上图很容易推导\nif (f->rindex_shown)\n    return (f->rindex + 1) % f->max_size; //因为rindex加1后可能超过max_size，所以这里取余\nelse\n    return f->rindex;\n```\n\n以上，FrameQueue的读过程也分析完了。\n\n为了支持灵活地读，还有一些辅助函数：\n\n```c\n//读当前节点（上文中的用词是“将要读的节点”，也就是黑色块），与frame_queue_peek_readable等效，但没有检查是否有可读节点\nstatic Frame *frame_queue_peek(FrameQueue *f)\n{\n    return &f->queue[(f->rindex + f->rindex_shown) % f->max_size];\n}\n\n//读下一个节点\nstatic Frame *frame_queue_peek_next(FrameQueue *f)\n{\n    return &f->queue[(f->rindex + f->rindex_shown + 1) % f->max_size];\n}\n\n//读上一个节点\nstatic Frame *frame_queue_peek_last(FrameQueue *f)\n{\n    return &f->queue[f->rindex];\n}\n\n/* return the number of undisplayed frames in the queue */\nstatic int frame_queue_nb_remaining(FrameQueue *f)\n{\n    return f->size - f->rindex_shown;\n}\n```\n\n实现都比较简单，借助上图看下节点位置：\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16473274840541647327483583.png)\n\n至此，FrameQueue的主体功能分析完了。从源码中可以看到FrameQueue是针对单读单写优化的高效的多线程模型，其设计思路不失为在C语言实践中可借鉴的一个好例子。\n","slug":"ffmpeg/2022-03-15-ffplay-frame queue 分析","published":1,"updated":"2024-03-06T11:53:13.566Z","comments":1,"photos":[],"_id":"cltgopend0021qywh93q22jqd","content":"<p>参考：  <a href=\"https://zhuanlan.zhihu.com/p/43564980\">ffplay frame queue分析</a></p>\n<h2 id=\"FrameQueue数据结构\"><a href=\"#FrameQueue数据结构\" class=\"headerlink\" title=\"FrameQueue数据结构\"></a>FrameQueue数据结构</h2><p>ffplay 定义了 FrameQueue 来管理解码后的音频，视频以及字幕。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* Common struct for handling all types of decoded data and allocated render buffers. */</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Frame</span> &#123;</span><br>    AVFrame *frame;       <span class=\"hljs-comment\">//audio/video frame</span><br>    AVSubtitle sub;       <span class=\"hljs-comment\">//字幕</span><br>    <span class=\"hljs-type\">int</span> serial;           <span class=\"hljs-comment\">//序列号</span><br>    <span class=\"hljs-type\">double</span> pts;           <span class=\"hljs-comment\">/* presentation timestamp for the frame */</span><br>    <span class=\"hljs-type\">double</span> duration;      <span class=\"hljs-comment\">/* estimated duration of the frame */</span><br>    <span class=\"hljs-type\">int64_t</span> pos;          <span class=\"hljs-comment\">/* byte position of the frame in the input file */</span><br>    <span class=\"hljs-type\">int</span> width;<br>    <span class=\"hljs-type\">int</span> height;<br>    <span class=\"hljs-type\">int</span> format;<br>    AVRational sar;       <span class=\"hljs-comment\">//video aspect ratio</span><br>    <span class=\"hljs-type\">int</span> uploaded;<br>    <span class=\"hljs-type\">int</span> flip_v;           <span class=\"hljs-comment\">//video，是否应该在垂直方向翻转</span><br>&#125; Frame;<br><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">FrameQueue</span> &#123;</span><br>    Frame <span class=\"hljs-built_in\">queue</span>[FRAME_QUEUE_SIZE];  <span class=\"hljs-comment\">//frame数组，环形buffer</span><br>    <span class=\"hljs-type\">int</span> rindex;                     <span class=\"hljs-comment\">//读指针，指向下一个可读的位置</span><br>    <span class=\"hljs-type\">int</span> windex;                     <span class=\"hljs-comment\">//写指针，指向下一个可写的位置</span><br>    <span class=\"hljs-type\">int</span> size;                       <span class=\"hljs-comment\">//队列元素个数</span><br>    <span class=\"hljs-type\">int</span> max_size;                   <span class=\"hljs-comment\">//队列容量</span><br>    <span class=\"hljs-type\">int</span> keep_last;                  <span class=\"hljs-comment\">//是否在队列中保留上一个已读的元素</span><br>    <span class=\"hljs-type\">int</span> rindex_shown;               <span class=\"hljs-comment\">//标记rindex指向的元素是否已经展示（已读），keep_last为1时生效。</span><br>    SDL_mutex *mutex;               <span class=\"hljs-comment\">//锁,用于安全访问</span><br>    SDL_cond *cond;                 <span class=\"hljs-comment\">//条件变量，用于控制读取和写入，防止overrun和underflow</span><br>    PacketQueue *pktq;              <span class=\"hljs-comment\">//该frame queue 对应的 pkt queue</span><br>&#125; FrameQueue;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Frame的设计试图用一个结构体“融合”3种数据：视频、音频、字幕，虽然AVFrame既可以表示视频又可以表示音频，但在融合字幕时又需要引入AVSubtitle，以及一些其他字段，如width&#x2F;height等来补充AVSubtitle，所以整个结构体看起来很“拼凑”（甚至还有视频专用的flip_v字段）</p>\n<p>FrameQueue的设计理念：</p>\n<ol>\n<li>高效率的读写模型</li>\n<li>高效的内存模型（节点内存以数组形式预分配，无需动态分配）</li>\n<li>环形缓冲区设计，同时可以访问上一读节点</li>\n</ol>\n</blockquote>\n<h2 id=\"队列的操作：\"><a href=\"#队列的操作：\" class=\"headerlink\" title=\"队列的操作：\"></a>队列的操作：</h2><h3 id=\"队列初始化\"><a href=\"#队列初始化\" class=\"headerlink\" title=\"队列初始化\"></a>队列初始化</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">frame_queue_init</span><span class=\"hljs-params\">(FrameQueue *f, PacketQueue *pktq, <span class=\"hljs-type\">int</span> max_size, <span class=\"hljs-type\">int</span> keep_last)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> i;<br>    <span class=\"hljs-built_in\">memset</span>(f, <span class=\"hljs-number\">0</span>, <span class=\"hljs-keyword\">sizeof</span>(FrameQueue));<br>    <span class=\"hljs-comment\">//互斥锁创建</span><br>    <span class=\"hljs-keyword\">if</span> (!(f-&gt;mutex = SDL_CreateMutex())) &#123;<br>        av_log(<span class=\"hljs-literal\">NULL</span>, AV_LOG_FATAL, <span class=\"hljs-string\">&quot;SDL_CreateMutex(): %s\\n&quot;</span>, SDL_GetError());<br>        <span class=\"hljs-keyword\">return</span> AVERROR(ENOMEM);<br>    &#125;<br>    <span class=\"hljs-comment\">//条件变量创建</span><br>    <span class=\"hljs-keyword\">if</span> (!(f-&gt;cond = SDL_CreateCond())) &#123;<br>        av_log(<span class=\"hljs-literal\">NULL</span>, AV_LOG_FATAL, <span class=\"hljs-string\">&quot;SDL_CreateCond(): %s\\n&quot;</span>, SDL_GetError());<br>        <span class=\"hljs-keyword\">return</span> AVERROR(ENOMEM);<br>    &#125;<br>    <span class=\"hljs-comment\">//设置对应的pkt queue</span><br>    f-&gt;pktq = pktq;<br>    <span class=\"hljs-comment\">//设置队列的容量，视频 3, 音频 9，字幕 16</span><br>    f-&gt;max_size = FFMIN(max_size, FRAME_QUEUE_SIZE);<br>    <span class=\"hljs-comment\">//是否保留最后一个位置，视频音频保留，字幕不保留</span><br>    f-&gt;keep_last = !!keep_last;<br>    <span class=\"hljs-comment\">//给队列中的每个节点对应的frame初始化</span><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; f-&gt;max_size; i++)<br>        <span class=\"hljs-keyword\">if</span> (!(f-&gt;<span class=\"hljs-built_in\">queue</span>[i].frame = av_frame_alloc()))<br>            <span class=\"hljs-keyword\">return</span> AVERROR(ENOMEM);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>初始化队列的内存，创建锁，条件变量，保存pkt queue，设置队列的容量，keep_last标志位初始化。初始化队列节点，给队列中的每个节点对应的frame调用av_frame_alloc分配内存。</p>\n<p>参数max_size用来设置队列的容量，最大不超过FRAME_QUEUE_SIZE。其中视频队列的容量为3，音频9，字幕16。FRAME_QUEUE_SIZE定义如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> VIDEO_PICTURE_QUEUE_SIZE 3</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> SUBPICTURE_QUEUE_SIZE 16</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> SAMPLE_QUEUE_SIZE 9</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> FRAME_QUEUE_SIZE FFMAX(SAMPLE_QUEUE_SIZE, FFMAX(VIDEO_PICTURE_QUEUE_SIZE, SUBPICTURE_QUEUE_SIZE))</span><br></code></pre></td></tr></table></figure>\n\n<p>展开后FRAME_QUEUE_SIZE的值为16。</p>\n<p>keep_last是一个bool值，表示是否在环形缓冲区的读写过程中保留最后一个读节点不被覆写。<code>f-&gt;keep_last = !!keep_last;</code>里的双感叹号是C中的一种技巧，旨在让int参数规整为0&#x2F;1的“bool值”。视频和音频会保留最后一个节点，而字幕不保留。</p>\n<h3 id=\"队列销毁\"><a href=\"#队列销毁\" class=\"headerlink\" title=\"队列销毁\"></a>队列销毁</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">frame_queue_destory</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> i;<br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; f-&gt;max_size; i++) &#123;<br>        Frame *vp = &amp;f-&gt;<span class=\"hljs-built_in\">queue</span>[i];<br>        <span class=\"hljs-comment\">//对每个节点调用frame_queue_unref_item</span><br>        frame_queue_unref_item(vp);<br>        <span class=\"hljs-comment\">//调用av_frame_free释放frame的内存</span><br>        av_frame_free(&amp;vp-&gt;frame);<br>    &#125;<br>    SDL_DestroyMutex(f-&gt;mutex);<br>    SDL_DestroyCond(f-&gt;cond);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>较为重要的是queue元素的释放。分两步，分别是<code>frame_queue_unref_item</code>和<code>av_frame_free</code>。其中<code>av_frame_free</code>与初始化中的<code>av_frame_alloc</code>对应，用于释放AVFrame.</p>\n<p><code>frame_queue_unref_item</code>的定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">frame_queue_unref_item</span><span class=\"hljs-params\">(Frame *vp)</span><br>&#123;<br>    av_frame_unref(vp-&gt;frame);<span class=\"hljs-comment\">//引用计数-1</span><br>    avsubtitle_free(&amp;vp-&gt;sub);<span class=\"hljs-comment\">//sub关联的内存释放</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>frame_queue_unref_item</code>释放的内存都是<strong>关联</strong>的内存，而非结构体自身内存。</p>\n<p>AVFrame内部有许多的AVBufferRef类型字段，而AVBufferRef只是AVBuffer的引用，AVBuffer通过引用计数自动管理内存（简易垃圾回收机制）。因此AVFrame在不需要的时候，需要通过<code>av_frame_unref</code>减少引用计数。</p>\n<blockquote>\n<p>关于AVBufferRef的内存管理机制，可以参考这篇文章： <a href=\"%5B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3FFMPEG-AVBuffer/AVBufferRef/AVBufferPool_muyuyuzhong%E7%9A%84%E4%B8%93%E6%A0%8F-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/muyuyuzhong/article/details/79381152)\">深入理解FFMPEG-AVBuffer&#x2F;AVBufferRef&#x2F;AVBufferPool</a></p>\n</blockquote>\n<h3 id=\"队列写操作\"><a href=\"#队列写操作\" class=\"headerlink\" title=\"队列写操作\"></a>队列写操作</h3><p>FrameQueue的“写”分两步，先调用<code>frame_queue_peek_writable</code>获取一个可写节点，在对节点操作结束后，调用<code>frame_queue_push</code>告知FrameQueue“存入”该节点。</p>\n<blockquote>\n<p>阅读提示：<br>在ffplay中，FrameQueue始终是一个线程写，另一个线程读。也就是只有一个读线程，不会有其他读线程竞争读；只有一个写线程，不会有其他线程竞争写；唯一需要的是读与写线程间的同步。FrameQueue的整个优化和设计思路正是基于这一点的。</p>\n</blockquote>\n<p>先看<code>frame_queue_peek_writable</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> Frame *<span class=\"hljs-title function_\">frame_queue_peek_writable</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;<br>    <span class=\"hljs-comment\">/* wait until we have space to put a new frame */</span><br>    SDL_LockMutex(f-&gt;mutex);<br>    <span class=\"hljs-keyword\">while</span> (f-&gt;size &gt;= f-&gt;max_size &amp;&amp;<br>           !f-&gt;pktq-&gt;abort_request) &#123;<br>        <span class=\"hljs-comment\">//等待有空间可以写，才继续执行</span><br>        SDL_CondWait(f-&gt;cond, f-&gt;mutex);<br>    &#125;<br>    SDL_UnlockMutex(f-&gt;mutex);<br><br>    <span class=\"hljs-keyword\">if</span> (f-&gt;pktq-&gt;abort_request)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-comment\">//返回f-&gt;windex对应的frame</span><br>    <span class=\"hljs-keyword\">return</span> &amp;f-&gt;<span class=\"hljs-built_in\">queue</span>[f-&gt;windex];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>整个函数分3步：</p>\n<ol>\n<li>加锁情况下，等待直到队列有空余空间可写（<code>f-&gt;size &lt; f-&gt;max_size</code>）</li>\n<li>如果有退出请求（<code>f-&gt;pktq-&gt;abort_request</code>），则返回NULL</li>\n<li>返回<code>windex</code>位置的元素（<code>windex</code>指向当前应写位置）</li>\n</ol>\n<blockquote>\n<p>为什么这里锁的范围不是整个函数呢？这是为了减小锁的范围，以提高效率。而之所以可以在无锁的情况下安全访问queue 字段，是因为上文中提到的单读单写的特殊场景。首先，queue是一个预先分配好的数组，因此queue本身不发生变化，可以安全访问；接着queue内的元素，读和写不存在重叠，即windex和rindex不会重叠。</p>\n<p>关于“读和写不存在重叠”，仔细看看。因为queue数组被当做一个环形缓冲区使用，那么的确存在underrun和overrun的情况，即读过快，或写过快的情况，这时如果不加控制，就会呈现缓冲区覆盖。</p>\n<p>FrameQueue的精明之处在于，先通过size判断当前缓冲区内空间是否够写，或者够读，比如这里先通过一个循环的条件等待，判断<code>f-&gt;size &gt;= f-&gt;max_size</code>，如果<code>f-&gt;size &gt;= f-&gt;max_size</code>，那么说明队列中的节点已经写满，也就是已经overrun了，此时如果再写，肯定会覆写未读数据，那么就需要继续等待。当无需等待时，windex指向的内存一定是已经读过的（除非代码异常了）。</p>\n<p>调用<code>frame_queue_peek_writable</code>取到Frame指针后，就可以对Frame内的字段自由改写，因为只有一个写进程，且无需担心读进程覆写。如上分析，读进程要读一个节点时，也会先判断underrun的情况）。</p>\n</blockquote>\n<p>一般步骤是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">Frame* vp = frame_queue_peek_writable(q);<br><span class=\"hljs-comment\">//将要存储的数据写入frame字段，比如：</span><br>av_frame_move_ref(vp-&gt;frame, src_frame);<br><span class=\"hljs-comment\">//存入队列</span><br>frame_queue_push(q);<br></code></pre></td></tr></table></figure>\n\n<p><code>frame_queue_push</code>怎么知道要push的是这里的vp呢？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">frame_queue_push</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;<br>    <span class=\"hljs-keyword\">if</span> (++f-&gt;windex == f-&gt;max_size)<br>        f-&gt;windex = <span class=\"hljs-number\">0</span>;<br>    SDL_LockMutex(f-&gt;mutex);<br>    f-&gt;size++;<br>    SDL_CondSignal(f-&gt;cond);<br>    SDL_UnlockMutex(f-&gt;mutex);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>答案是push当前windex节点。看<code>frame_queue_push</code>函数，执行两个步骤：</p>\n<ol>\n<li>windex加1，如果超过max_size，则回环为0</li>\n<li>加锁情况下大小加1.</li>\n</ol>\n<blockquote>\n<p>因为FrameQueue是基于固定长度的数组实现的队列，与链表队列不同，其节点在初始化的时候已经在队列中了，push所要做的只是通过某种标志记录该节点是否是写入未读的。ffplay的做法是对windex加1，将写指针移动到下一个元素，凡是windex“之前”的节点，都是写过的。（至于是否可读，rindex知道；至于后续有多少空间可写，size知道）</p>\n</blockquote>\n<h3 id=\"队列读操作\"><a href=\"#队列读操作\" class=\"headerlink\" title=\"队列读操作\"></a>队列读操作</h3><p>和写一样，FrameQueue的读也分两步。<code>frame_queue_peek_readable</code>和<code>frame_queue_next</code>。相比写要复杂一点的是 ，读的代码多考虑另一个特性，即允许保留上一读节点。</p>\n<p><code>frame_queue_peek_readable</code>代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> Frame *<span class=\"hljs-title function_\">frame_queue_peek_readable</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;<br>    <span class=\"hljs-comment\">/* wait until we have a readable a new frame */</span><br>    SDL_LockMutex(f-&gt;mutex);<br>    <span class=\"hljs-keyword\">while</span> (f-&gt;size - f-&gt;rindex_shown &lt;= <span class=\"hljs-number\">0</span> &amp;&amp;<br>           !f-&gt;pktq-&gt;abort_request) &#123;<br>        SDL_CondWait(f-&gt;cond, f-&gt;mutex);<br>    &#125;<br>    SDL_UnlockMutex(f-&gt;mutex);<br><br>    <span class=\"hljs-keyword\">if</span> (f-&gt;pktq-&gt;abort_request)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br><br>    <span class=\"hljs-keyword\">return</span> &amp;f-&gt;<span class=\"hljs-built_in\">queue</span>[(f-&gt;rindex + f-&gt;rindex_shown) % f-&gt;max_size];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>和<code>frame_queue_peek_writable</code>类似，分三步:</p>\n<ol>\n<li>加锁情况下，判断是否有可读节点（<code>f-&gt;size - f-&gt;rindex_shown &gt; 0</code>)</li>\n<li>如果有退出请求，则返回NULL</li>\n<li>读取当前可读节点<code>(f-&gt;rindex + f-&gt;rindex_shown) % f-&gt;max_size</code></li>\n</ol>\n<p><code>rindex_shown</code>有些干扰代码分析，我们先看不支持keep_last的情况（只需要在初始化的时候传入keep_last &#x3D; 0），此事<code>rindex_shown</code>始终为0，所以，<code>frame_queue_peek_readable</code>简化如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> Frame *<span class=\"hljs-title function_\">frame_queue_peek_readable</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;<br>    <span class=\"hljs-comment\">/* wait until we have a readable a new frame */</span><br>    SDL_LockMutex(f-&gt;mutex);<br>    <span class=\"hljs-keyword\">while</span> (f-&gt;size &lt;= <span class=\"hljs-number\">0</span> &amp;&amp;<br>           !f-&gt;pktq-&gt;abort_request) &#123;<br>        SDL_CondWait(f-&gt;cond, f-&gt;mutex);<br>    &#125;<br>    SDL_UnlockMutex(f-&gt;mutex);<br><br>    <span class=\"hljs-keyword\">if</span> (f-&gt;pktq-&gt;abort_request)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br><br>    <span class=\"hljs-keyword\">return</span> &amp;f-&gt;<span class=\"hljs-built_in\">queue</span>[f-&gt;rindex];<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>和peek_writable几乎是一一对应的。就不分析了。</p>\n<p>在简化版本上理解引入<code>rindex_shown</code>的代码，我们需要先理解<code>rindex_shown</code>。<code>rindex_shown</code>的意思是<code>rindex</code>指向的节点是否被读过，如果被读过， 为1，反之，为0。这一行为，体现在<code>frame_queue_next</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">frame_queue_next</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;   <br>    <span class=\"hljs-comment\">//如果支持keep_last，并且f-&gt;rindex_shown为0, 将rindex_shown设置为1，返回</span><br>    <span class=\"hljs-keyword\">if</span> (f-&gt;keep_last &amp;&amp; !f-&gt;rindex_shown) &#123;<br>        f-&gt;rindex_shown = <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">//否则，移动rindex指针，并减小size</span><br>    frame_queue_unref_item(&amp;f-&gt;<span class=\"hljs-built_in\">queue</span>[f-&gt;rindex]);<br>    <span class=\"hljs-keyword\">if</span> (++f-&gt;rindex == f-&gt;max_size)<br>        f-&gt;rindex = <span class=\"hljs-number\">0</span>;<br>    SDL_LockMutex(f-&gt;mutex);<br>    f-&gt;size--;<br>    SDL_CondSignal(f-&gt;cond);<br>    SDL_UnlockMutex(f-&gt;mutex);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>frame_queue_next</code>用于在读完一个节点后调用，用于标记一个节点已经被读过。</p>\n<p>与写过程类似，读过程可以描述为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">Frame* vp = frame_queue_peek_readable(f);<br><span class=\"hljs-comment\">//读取vp的数据，比如</span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;pict_type=%d\\n&quot;</span>, vp-&gt;frame-&gt;pict_type);<br>frame_queue_next(f);<br></code></pre></td></tr></table></figure>\n\n<p><code>frame_queue_next</code>比<code>frame_queue_push</code>略复杂，我们要分析两个行为：标记一个节点为已读，以及<code>rindex_shown</code>的赋值。</p>\n<p>标记一个节点为已读于标记一个节点为已写是类似的，执行两个步骤：</p>\n<ol>\n<li>rindex加1，如果超过max_size，则回环为0</li>\n<li>加锁情况下大小减1.</li>\n</ol>\n<p>特别的是，对于以及读过的节点，需要调用<code>frame_queue_unref_item</code>释放关联内存。</p>\n<p>执行rindex操作前，需要先判断<code>rindex_shown</code>的值，如果为0，则赋1。这么做的意图不妨画图分析：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16473273492201647327349203.png\"></p>\n<p>这里模拟了从初始化开始的2次“读”。</p>\n<p>还没开始读，rindex和rindex_shown均为0。这时要peek的读节点是节点0(图中黑色块）。</p>\n<p>第一次读，调用next，满足条件<code>f-&gt;keep_last &amp;&amp; !f-&gt;rindex_shown</code>，所以rindex仍然是0，而rindex_shown为1.此时节点0（灰色块）是已读节点，也是要keep的last节点，将要读的节点是节点1（黑色块）。（恰好是rindex+rindex_shown）</p>\n<p>第二次读，peek了黑色块后，调用next，不满足条件<code>f-&gt;keep_last &amp;&amp; !f-&gt;rindex_shown</code>，所以rindex为1，而rindex_shown为2.此时节点1（灰色块）是last节点，节点2（黑色块）是将要读的节点。（也恰好是rindex+rindex_shown）</p>\n<p>继续往后分析，会一直重复第二次读的情况，始终是rindex指向了last，而rindex_shown一直为1，rindex+rindex_shown刚好是将要读的节点。</p>\n<p>至此，<code>frame_queue_next</code>的行为算是明确了。回头看看<code>frame_queue_peek_readable</code>。</p>\n<p>步骤1中，判断无可读节点，用的是<code>f-&gt;size - f-&gt;rindex_shown &lt;= 0</code>，其实是以下代码的简化：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">if</span> (f-&gt;rindex_shown)<br>    <span class=\"hljs-keyword\">return</span> f-&gt;size - <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">else</span><br>    <span class=\"hljs-keyword\">return</span> f-&gt;size;<br></code></pre></td></tr></table></figure>\n\n<p>只是C中用int模拟bool，刚好rindex_shown为true是1，所以可以简化为<code>`f-&gt;size - f-&gt;rindex_shown</code>.</p>\n<p>步骤3中，取将要读的节点用的是<code>(f-&gt;rindex + f-&gt;rindex_shown) % f-&gt;max_size</code>，同样也是一个简化：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//这段代码根据上图很容易推导</span><br><span class=\"hljs-keyword\">if</span> (f-&gt;rindex_shown)<br>    <span class=\"hljs-keyword\">return</span> (f-&gt;rindex + <span class=\"hljs-number\">1</span>) % f-&gt;max_size; <span class=\"hljs-comment\">//因为rindex加1后可能超过max_size，所以这里取余</span><br><span class=\"hljs-keyword\">else</span><br>    <span class=\"hljs-keyword\">return</span> f-&gt;rindex;<br></code></pre></td></tr></table></figure>\n\n<p>以上，FrameQueue的读过程也分析完了。</p>\n<p>为了支持灵活地读，还有一些辅助函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//读当前节点（上文中的用词是“将要读的节点”，也就是黑色块），与frame_queue_peek_readable等效，但没有检查是否有可读节点</span><br><span class=\"hljs-type\">static</span> Frame *<span class=\"hljs-title function_\">frame_queue_peek</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;<br>    <span class=\"hljs-keyword\">return</span> &amp;f-&gt;<span class=\"hljs-built_in\">queue</span>[(f-&gt;rindex + f-&gt;rindex_shown) % f-&gt;max_size];<br>&#125;<br><br><span class=\"hljs-comment\">//读下一个节点</span><br><span class=\"hljs-type\">static</span> Frame *<span class=\"hljs-title function_\">frame_queue_peek_next</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;<br>    <span class=\"hljs-keyword\">return</span> &amp;f-&gt;<span class=\"hljs-built_in\">queue</span>[(f-&gt;rindex + f-&gt;rindex_shown + <span class=\"hljs-number\">1</span>) % f-&gt;max_size];<br>&#125;<br><br><span class=\"hljs-comment\">//读上一个节点</span><br><span class=\"hljs-type\">static</span> Frame *<span class=\"hljs-title function_\">frame_queue_peek_last</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;<br>    <span class=\"hljs-keyword\">return</span> &amp;f-&gt;<span class=\"hljs-built_in\">queue</span>[f-&gt;rindex];<br>&#125;<br><br><span class=\"hljs-comment\">/* return the number of undisplayed frames in the queue */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">frame_queue_nb_remaining</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;<br>    <span class=\"hljs-keyword\">return</span> f-&gt;size - f-&gt;rindex_shown;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>实现都比较简单，借助上图看下节点位置：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16473274840541647327483583.png\"></p>\n<p>至此，FrameQueue的主体功能分析完了。从源码中可以看到FrameQueue是针对单读单写优化的高效的多线程模型，其设计思路不失为在C语言实践中可借鉴的一个好例子。</p>\n","excerpt":"","more":"<p>参考：  <a href=\"https://zhuanlan.zhihu.com/p/43564980\">ffplay frame queue分析</a></p>\n<h2 id=\"FrameQueue数据结构\"><a href=\"#FrameQueue数据结构\" class=\"headerlink\" title=\"FrameQueue数据结构\"></a>FrameQueue数据结构</h2><p>ffplay 定义了 FrameQueue 来管理解码后的音频，视频以及字幕。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* Common struct for handling all types of decoded data and allocated render buffers. */</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Frame</span> &#123;</span><br>    AVFrame *frame;       <span class=\"hljs-comment\">//audio/video frame</span><br>    AVSubtitle sub;       <span class=\"hljs-comment\">//字幕</span><br>    <span class=\"hljs-type\">int</span> serial;           <span class=\"hljs-comment\">//序列号</span><br>    <span class=\"hljs-type\">double</span> pts;           <span class=\"hljs-comment\">/* presentation timestamp for the frame */</span><br>    <span class=\"hljs-type\">double</span> duration;      <span class=\"hljs-comment\">/* estimated duration of the frame */</span><br>    <span class=\"hljs-type\">int64_t</span> pos;          <span class=\"hljs-comment\">/* byte position of the frame in the input file */</span><br>    <span class=\"hljs-type\">int</span> width;<br>    <span class=\"hljs-type\">int</span> height;<br>    <span class=\"hljs-type\">int</span> format;<br>    AVRational sar;       <span class=\"hljs-comment\">//video aspect ratio</span><br>    <span class=\"hljs-type\">int</span> uploaded;<br>    <span class=\"hljs-type\">int</span> flip_v;           <span class=\"hljs-comment\">//video，是否应该在垂直方向翻转</span><br>&#125; Frame;<br><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">FrameQueue</span> &#123;</span><br>    Frame <span class=\"hljs-built_in\">queue</span>[FRAME_QUEUE_SIZE];  <span class=\"hljs-comment\">//frame数组，环形buffer</span><br>    <span class=\"hljs-type\">int</span> rindex;                     <span class=\"hljs-comment\">//读指针，指向下一个可读的位置</span><br>    <span class=\"hljs-type\">int</span> windex;                     <span class=\"hljs-comment\">//写指针，指向下一个可写的位置</span><br>    <span class=\"hljs-type\">int</span> size;                       <span class=\"hljs-comment\">//队列元素个数</span><br>    <span class=\"hljs-type\">int</span> max_size;                   <span class=\"hljs-comment\">//队列容量</span><br>    <span class=\"hljs-type\">int</span> keep_last;                  <span class=\"hljs-comment\">//是否在队列中保留上一个已读的元素</span><br>    <span class=\"hljs-type\">int</span> rindex_shown;               <span class=\"hljs-comment\">//标记rindex指向的元素是否已经展示（已读），keep_last为1时生效。</span><br>    SDL_mutex *mutex;               <span class=\"hljs-comment\">//锁,用于安全访问</span><br>    SDL_cond *cond;                 <span class=\"hljs-comment\">//条件变量，用于控制读取和写入，防止overrun和underflow</span><br>    PacketQueue *pktq;              <span class=\"hljs-comment\">//该frame queue 对应的 pkt queue</span><br>&#125; FrameQueue;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Frame的设计试图用一个结构体“融合”3种数据：视频、音频、字幕，虽然AVFrame既可以表示视频又可以表示音频，但在融合字幕时又需要引入AVSubtitle，以及一些其他字段，如width&#x2F;height等来补充AVSubtitle，所以整个结构体看起来很“拼凑”（甚至还有视频专用的flip_v字段）</p>\n<p>FrameQueue的设计理念：</p>\n<ol>\n<li>高效率的读写模型</li>\n<li>高效的内存模型（节点内存以数组形式预分配，无需动态分配）</li>\n<li>环形缓冲区设计，同时可以访问上一读节点</li>\n</ol>\n</blockquote>\n<h2 id=\"队列的操作：\"><a href=\"#队列的操作：\" class=\"headerlink\" title=\"队列的操作：\"></a>队列的操作：</h2><h3 id=\"队列初始化\"><a href=\"#队列初始化\" class=\"headerlink\" title=\"队列初始化\"></a>队列初始化</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">frame_queue_init</span><span class=\"hljs-params\">(FrameQueue *f, PacketQueue *pktq, <span class=\"hljs-type\">int</span> max_size, <span class=\"hljs-type\">int</span> keep_last)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> i;<br>    <span class=\"hljs-built_in\">memset</span>(f, <span class=\"hljs-number\">0</span>, <span class=\"hljs-keyword\">sizeof</span>(FrameQueue));<br>    <span class=\"hljs-comment\">//互斥锁创建</span><br>    <span class=\"hljs-keyword\">if</span> (!(f-&gt;mutex = SDL_CreateMutex())) &#123;<br>        av_log(<span class=\"hljs-literal\">NULL</span>, AV_LOG_FATAL, <span class=\"hljs-string\">&quot;SDL_CreateMutex(): %s\\n&quot;</span>, SDL_GetError());<br>        <span class=\"hljs-keyword\">return</span> AVERROR(ENOMEM);<br>    &#125;<br>    <span class=\"hljs-comment\">//条件变量创建</span><br>    <span class=\"hljs-keyword\">if</span> (!(f-&gt;cond = SDL_CreateCond())) &#123;<br>        av_log(<span class=\"hljs-literal\">NULL</span>, AV_LOG_FATAL, <span class=\"hljs-string\">&quot;SDL_CreateCond(): %s\\n&quot;</span>, SDL_GetError());<br>        <span class=\"hljs-keyword\">return</span> AVERROR(ENOMEM);<br>    &#125;<br>    <span class=\"hljs-comment\">//设置对应的pkt queue</span><br>    f-&gt;pktq = pktq;<br>    <span class=\"hljs-comment\">//设置队列的容量，视频 3, 音频 9，字幕 16</span><br>    f-&gt;max_size = FFMIN(max_size, FRAME_QUEUE_SIZE);<br>    <span class=\"hljs-comment\">//是否保留最后一个位置，视频音频保留，字幕不保留</span><br>    f-&gt;keep_last = !!keep_last;<br>    <span class=\"hljs-comment\">//给队列中的每个节点对应的frame初始化</span><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; f-&gt;max_size; i++)<br>        <span class=\"hljs-keyword\">if</span> (!(f-&gt;<span class=\"hljs-built_in\">queue</span>[i].frame = av_frame_alloc()))<br>            <span class=\"hljs-keyword\">return</span> AVERROR(ENOMEM);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>初始化队列的内存，创建锁，条件变量，保存pkt queue，设置队列的容量，keep_last标志位初始化。初始化队列节点，给队列中的每个节点对应的frame调用av_frame_alloc分配内存。</p>\n<p>参数max_size用来设置队列的容量，最大不超过FRAME_QUEUE_SIZE。其中视频队列的容量为3，音频9，字幕16。FRAME_QUEUE_SIZE定义如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> VIDEO_PICTURE_QUEUE_SIZE 3</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> SUBPICTURE_QUEUE_SIZE 16</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> SAMPLE_QUEUE_SIZE 9</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> FRAME_QUEUE_SIZE FFMAX(SAMPLE_QUEUE_SIZE, FFMAX(VIDEO_PICTURE_QUEUE_SIZE, SUBPICTURE_QUEUE_SIZE))</span><br></code></pre></td></tr></table></figure>\n\n<p>展开后FRAME_QUEUE_SIZE的值为16。</p>\n<p>keep_last是一个bool值，表示是否在环形缓冲区的读写过程中保留最后一个读节点不被覆写。<code>f-&gt;keep_last = !!keep_last;</code>里的双感叹号是C中的一种技巧，旨在让int参数规整为0&#x2F;1的“bool值”。视频和音频会保留最后一个节点，而字幕不保留。</p>\n<h3 id=\"队列销毁\"><a href=\"#队列销毁\" class=\"headerlink\" title=\"队列销毁\"></a>队列销毁</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">frame_queue_destory</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> i;<br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; f-&gt;max_size; i++) &#123;<br>        Frame *vp = &amp;f-&gt;<span class=\"hljs-built_in\">queue</span>[i];<br>        <span class=\"hljs-comment\">//对每个节点调用frame_queue_unref_item</span><br>        frame_queue_unref_item(vp);<br>        <span class=\"hljs-comment\">//调用av_frame_free释放frame的内存</span><br>        av_frame_free(&amp;vp-&gt;frame);<br>    &#125;<br>    SDL_DestroyMutex(f-&gt;mutex);<br>    SDL_DestroyCond(f-&gt;cond);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>较为重要的是queue元素的释放。分两步，分别是<code>frame_queue_unref_item</code>和<code>av_frame_free</code>。其中<code>av_frame_free</code>与初始化中的<code>av_frame_alloc</code>对应，用于释放AVFrame.</p>\n<p><code>frame_queue_unref_item</code>的定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">frame_queue_unref_item</span><span class=\"hljs-params\">(Frame *vp)</span><br>&#123;<br>    av_frame_unref(vp-&gt;frame);<span class=\"hljs-comment\">//引用计数-1</span><br>    avsubtitle_free(&amp;vp-&gt;sub);<span class=\"hljs-comment\">//sub关联的内存释放</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>frame_queue_unref_item</code>释放的内存都是<strong>关联</strong>的内存，而非结构体自身内存。</p>\n<p>AVFrame内部有许多的AVBufferRef类型字段，而AVBufferRef只是AVBuffer的引用，AVBuffer通过引用计数自动管理内存（简易垃圾回收机制）。因此AVFrame在不需要的时候，需要通过<code>av_frame_unref</code>减少引用计数。</p>\n<blockquote>\n<p>关于AVBufferRef的内存管理机制，可以参考这篇文章： <a href=\"%5B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3FFMPEG-AVBuffer/AVBufferRef/AVBufferPool_muyuyuzhong%E7%9A%84%E4%B8%93%E6%A0%8F-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/muyuyuzhong/article/details/79381152)\">深入理解FFMPEG-AVBuffer&#x2F;AVBufferRef&#x2F;AVBufferPool</a></p>\n</blockquote>\n<h3 id=\"队列写操作\"><a href=\"#队列写操作\" class=\"headerlink\" title=\"队列写操作\"></a>队列写操作</h3><p>FrameQueue的“写”分两步，先调用<code>frame_queue_peek_writable</code>获取一个可写节点，在对节点操作结束后，调用<code>frame_queue_push</code>告知FrameQueue“存入”该节点。</p>\n<blockquote>\n<p>阅读提示：<br>在ffplay中，FrameQueue始终是一个线程写，另一个线程读。也就是只有一个读线程，不会有其他读线程竞争读；只有一个写线程，不会有其他线程竞争写；唯一需要的是读与写线程间的同步。FrameQueue的整个优化和设计思路正是基于这一点的。</p>\n</blockquote>\n<p>先看<code>frame_queue_peek_writable</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> Frame *<span class=\"hljs-title function_\">frame_queue_peek_writable</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;<br>    <span class=\"hljs-comment\">/* wait until we have space to put a new frame */</span><br>    SDL_LockMutex(f-&gt;mutex);<br>    <span class=\"hljs-keyword\">while</span> (f-&gt;size &gt;= f-&gt;max_size &amp;&amp;<br>           !f-&gt;pktq-&gt;abort_request) &#123;<br>        <span class=\"hljs-comment\">//等待有空间可以写，才继续执行</span><br>        SDL_CondWait(f-&gt;cond, f-&gt;mutex);<br>    &#125;<br>    SDL_UnlockMutex(f-&gt;mutex);<br><br>    <span class=\"hljs-keyword\">if</span> (f-&gt;pktq-&gt;abort_request)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>    <span class=\"hljs-comment\">//返回f-&gt;windex对应的frame</span><br>    <span class=\"hljs-keyword\">return</span> &amp;f-&gt;<span class=\"hljs-built_in\">queue</span>[f-&gt;windex];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>整个函数分3步：</p>\n<ol>\n<li>加锁情况下，等待直到队列有空余空间可写（<code>f-&gt;size &lt; f-&gt;max_size</code>）</li>\n<li>如果有退出请求（<code>f-&gt;pktq-&gt;abort_request</code>），则返回NULL</li>\n<li>返回<code>windex</code>位置的元素（<code>windex</code>指向当前应写位置）</li>\n</ol>\n<blockquote>\n<p>为什么这里锁的范围不是整个函数呢？这是为了减小锁的范围，以提高效率。而之所以可以在无锁的情况下安全访问queue 字段，是因为上文中提到的单读单写的特殊场景。首先，queue是一个预先分配好的数组，因此queue本身不发生变化，可以安全访问；接着queue内的元素，读和写不存在重叠，即windex和rindex不会重叠。</p>\n<p>关于“读和写不存在重叠”，仔细看看。因为queue数组被当做一个环形缓冲区使用，那么的确存在underrun和overrun的情况，即读过快，或写过快的情况，这时如果不加控制，就会呈现缓冲区覆盖。</p>\n<p>FrameQueue的精明之处在于，先通过size判断当前缓冲区内空间是否够写，或者够读，比如这里先通过一个循环的条件等待，判断<code>f-&gt;size &gt;= f-&gt;max_size</code>，如果<code>f-&gt;size &gt;= f-&gt;max_size</code>，那么说明队列中的节点已经写满，也就是已经overrun了，此时如果再写，肯定会覆写未读数据，那么就需要继续等待。当无需等待时，windex指向的内存一定是已经读过的（除非代码异常了）。</p>\n<p>调用<code>frame_queue_peek_writable</code>取到Frame指针后，就可以对Frame内的字段自由改写，因为只有一个写进程，且无需担心读进程覆写。如上分析，读进程要读一个节点时，也会先判断underrun的情况）。</p>\n</blockquote>\n<p>一般步骤是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">Frame* vp = frame_queue_peek_writable(q);<br><span class=\"hljs-comment\">//将要存储的数据写入frame字段，比如：</span><br>av_frame_move_ref(vp-&gt;frame, src_frame);<br><span class=\"hljs-comment\">//存入队列</span><br>frame_queue_push(q);<br></code></pre></td></tr></table></figure>\n\n<p><code>frame_queue_push</code>怎么知道要push的是这里的vp呢？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">frame_queue_push</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;<br>    <span class=\"hljs-keyword\">if</span> (++f-&gt;windex == f-&gt;max_size)<br>        f-&gt;windex = <span class=\"hljs-number\">0</span>;<br>    SDL_LockMutex(f-&gt;mutex);<br>    f-&gt;size++;<br>    SDL_CondSignal(f-&gt;cond);<br>    SDL_UnlockMutex(f-&gt;mutex);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>答案是push当前windex节点。看<code>frame_queue_push</code>函数，执行两个步骤：</p>\n<ol>\n<li>windex加1，如果超过max_size，则回环为0</li>\n<li>加锁情况下大小加1.</li>\n</ol>\n<blockquote>\n<p>因为FrameQueue是基于固定长度的数组实现的队列，与链表队列不同，其节点在初始化的时候已经在队列中了，push所要做的只是通过某种标志记录该节点是否是写入未读的。ffplay的做法是对windex加1，将写指针移动到下一个元素，凡是windex“之前”的节点，都是写过的。（至于是否可读，rindex知道；至于后续有多少空间可写，size知道）</p>\n</blockquote>\n<h3 id=\"队列读操作\"><a href=\"#队列读操作\" class=\"headerlink\" title=\"队列读操作\"></a>队列读操作</h3><p>和写一样，FrameQueue的读也分两步。<code>frame_queue_peek_readable</code>和<code>frame_queue_next</code>。相比写要复杂一点的是 ，读的代码多考虑另一个特性，即允许保留上一读节点。</p>\n<p><code>frame_queue_peek_readable</code>代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> Frame *<span class=\"hljs-title function_\">frame_queue_peek_readable</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;<br>    <span class=\"hljs-comment\">/* wait until we have a readable a new frame */</span><br>    SDL_LockMutex(f-&gt;mutex);<br>    <span class=\"hljs-keyword\">while</span> (f-&gt;size - f-&gt;rindex_shown &lt;= <span class=\"hljs-number\">0</span> &amp;&amp;<br>           !f-&gt;pktq-&gt;abort_request) &#123;<br>        SDL_CondWait(f-&gt;cond, f-&gt;mutex);<br>    &#125;<br>    SDL_UnlockMutex(f-&gt;mutex);<br><br>    <span class=\"hljs-keyword\">if</span> (f-&gt;pktq-&gt;abort_request)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br><br>    <span class=\"hljs-keyword\">return</span> &amp;f-&gt;<span class=\"hljs-built_in\">queue</span>[(f-&gt;rindex + f-&gt;rindex_shown) % f-&gt;max_size];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>和<code>frame_queue_peek_writable</code>类似，分三步:</p>\n<ol>\n<li>加锁情况下，判断是否有可读节点（<code>f-&gt;size - f-&gt;rindex_shown &gt; 0</code>)</li>\n<li>如果有退出请求，则返回NULL</li>\n<li>读取当前可读节点<code>(f-&gt;rindex + f-&gt;rindex_shown) % f-&gt;max_size</code></li>\n</ol>\n<p><code>rindex_shown</code>有些干扰代码分析，我们先看不支持keep_last的情况（只需要在初始化的时候传入keep_last &#x3D; 0），此事<code>rindex_shown</code>始终为0，所以，<code>frame_queue_peek_readable</code>简化如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> Frame *<span class=\"hljs-title function_\">frame_queue_peek_readable</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;<br>    <span class=\"hljs-comment\">/* wait until we have a readable a new frame */</span><br>    SDL_LockMutex(f-&gt;mutex);<br>    <span class=\"hljs-keyword\">while</span> (f-&gt;size &lt;= <span class=\"hljs-number\">0</span> &amp;&amp;<br>           !f-&gt;pktq-&gt;abort_request) &#123;<br>        SDL_CondWait(f-&gt;cond, f-&gt;mutex);<br>    &#125;<br>    SDL_UnlockMutex(f-&gt;mutex);<br><br>    <span class=\"hljs-keyword\">if</span> (f-&gt;pktq-&gt;abort_request)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br><br>    <span class=\"hljs-keyword\">return</span> &amp;f-&gt;<span class=\"hljs-built_in\">queue</span>[f-&gt;rindex];<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>和peek_writable几乎是一一对应的。就不分析了。</p>\n<p>在简化版本上理解引入<code>rindex_shown</code>的代码，我们需要先理解<code>rindex_shown</code>。<code>rindex_shown</code>的意思是<code>rindex</code>指向的节点是否被读过，如果被读过， 为1，反之，为0。这一行为，体现在<code>frame_queue_next</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">frame_queue_next</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;   <br>    <span class=\"hljs-comment\">//如果支持keep_last，并且f-&gt;rindex_shown为0, 将rindex_shown设置为1，返回</span><br>    <span class=\"hljs-keyword\">if</span> (f-&gt;keep_last &amp;&amp; !f-&gt;rindex_shown) &#123;<br>        f-&gt;rindex_shown = <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">//否则，移动rindex指针，并减小size</span><br>    frame_queue_unref_item(&amp;f-&gt;<span class=\"hljs-built_in\">queue</span>[f-&gt;rindex]);<br>    <span class=\"hljs-keyword\">if</span> (++f-&gt;rindex == f-&gt;max_size)<br>        f-&gt;rindex = <span class=\"hljs-number\">0</span>;<br>    SDL_LockMutex(f-&gt;mutex);<br>    f-&gt;size--;<br>    SDL_CondSignal(f-&gt;cond);<br>    SDL_UnlockMutex(f-&gt;mutex);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>frame_queue_next</code>用于在读完一个节点后调用，用于标记一个节点已经被读过。</p>\n<p>与写过程类似，读过程可以描述为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">Frame* vp = frame_queue_peek_readable(f);<br><span class=\"hljs-comment\">//读取vp的数据，比如</span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;pict_type=%d\\n&quot;</span>, vp-&gt;frame-&gt;pict_type);<br>frame_queue_next(f);<br></code></pre></td></tr></table></figure>\n\n<p><code>frame_queue_next</code>比<code>frame_queue_push</code>略复杂，我们要分析两个行为：标记一个节点为已读，以及<code>rindex_shown</code>的赋值。</p>\n<p>标记一个节点为已读于标记一个节点为已写是类似的，执行两个步骤：</p>\n<ol>\n<li>rindex加1，如果超过max_size，则回环为0</li>\n<li>加锁情况下大小减1.</li>\n</ol>\n<p>特别的是，对于以及读过的节点，需要调用<code>frame_queue_unref_item</code>释放关联内存。</p>\n<p>执行rindex操作前，需要先判断<code>rindex_shown</code>的值，如果为0，则赋1。这么做的意图不妨画图分析：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16473273492201647327349203.png\"></p>\n<p>这里模拟了从初始化开始的2次“读”。</p>\n<p>还没开始读，rindex和rindex_shown均为0。这时要peek的读节点是节点0(图中黑色块）。</p>\n<p>第一次读，调用next，满足条件<code>f-&gt;keep_last &amp;&amp; !f-&gt;rindex_shown</code>，所以rindex仍然是0，而rindex_shown为1.此时节点0（灰色块）是已读节点，也是要keep的last节点，将要读的节点是节点1（黑色块）。（恰好是rindex+rindex_shown）</p>\n<p>第二次读，peek了黑色块后，调用next，不满足条件<code>f-&gt;keep_last &amp;&amp; !f-&gt;rindex_shown</code>，所以rindex为1，而rindex_shown为2.此时节点1（灰色块）是last节点，节点2（黑色块）是将要读的节点。（也恰好是rindex+rindex_shown）</p>\n<p>继续往后分析，会一直重复第二次读的情况，始终是rindex指向了last，而rindex_shown一直为1，rindex+rindex_shown刚好是将要读的节点。</p>\n<p>至此，<code>frame_queue_next</code>的行为算是明确了。回头看看<code>frame_queue_peek_readable</code>。</p>\n<p>步骤1中，判断无可读节点，用的是<code>f-&gt;size - f-&gt;rindex_shown &lt;= 0</code>，其实是以下代码的简化：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">if</span> (f-&gt;rindex_shown)<br>    <span class=\"hljs-keyword\">return</span> f-&gt;size - <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">else</span><br>    <span class=\"hljs-keyword\">return</span> f-&gt;size;<br></code></pre></td></tr></table></figure>\n\n<p>只是C中用int模拟bool，刚好rindex_shown为true是1，所以可以简化为<code>`f-&gt;size - f-&gt;rindex_shown</code>.</p>\n<p>步骤3中，取将要读的节点用的是<code>(f-&gt;rindex + f-&gt;rindex_shown) % f-&gt;max_size</code>，同样也是一个简化：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//这段代码根据上图很容易推导</span><br><span class=\"hljs-keyword\">if</span> (f-&gt;rindex_shown)<br>    <span class=\"hljs-keyword\">return</span> (f-&gt;rindex + <span class=\"hljs-number\">1</span>) % f-&gt;max_size; <span class=\"hljs-comment\">//因为rindex加1后可能超过max_size，所以这里取余</span><br><span class=\"hljs-keyword\">else</span><br>    <span class=\"hljs-keyword\">return</span> f-&gt;rindex;<br></code></pre></td></tr></table></figure>\n\n<p>以上，FrameQueue的读过程也分析完了。</p>\n<p>为了支持灵活地读，还有一些辅助函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//读当前节点（上文中的用词是“将要读的节点”，也就是黑色块），与frame_queue_peek_readable等效，但没有检查是否有可读节点</span><br><span class=\"hljs-type\">static</span> Frame *<span class=\"hljs-title function_\">frame_queue_peek</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;<br>    <span class=\"hljs-keyword\">return</span> &amp;f-&gt;<span class=\"hljs-built_in\">queue</span>[(f-&gt;rindex + f-&gt;rindex_shown) % f-&gt;max_size];<br>&#125;<br><br><span class=\"hljs-comment\">//读下一个节点</span><br><span class=\"hljs-type\">static</span> Frame *<span class=\"hljs-title function_\">frame_queue_peek_next</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;<br>    <span class=\"hljs-keyword\">return</span> &amp;f-&gt;<span class=\"hljs-built_in\">queue</span>[(f-&gt;rindex + f-&gt;rindex_shown + <span class=\"hljs-number\">1</span>) % f-&gt;max_size];<br>&#125;<br><br><span class=\"hljs-comment\">//读上一个节点</span><br><span class=\"hljs-type\">static</span> Frame *<span class=\"hljs-title function_\">frame_queue_peek_last</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;<br>    <span class=\"hljs-keyword\">return</span> &amp;f-&gt;<span class=\"hljs-built_in\">queue</span>[f-&gt;rindex];<br>&#125;<br><br><span class=\"hljs-comment\">/* return the number of undisplayed frames in the queue */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">frame_queue_nb_remaining</span><span class=\"hljs-params\">(FrameQueue *f)</span><br>&#123;<br>    <span class=\"hljs-keyword\">return</span> f-&gt;size - f-&gt;rindex_shown;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>实现都比较简单，借助上图看下节点位置：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16473274840541647327483583.png\"></p>\n<p>至此，FrameQueue的主体功能分析完了。从源码中可以看到FrameQueue是针对单读单写优化的高效的多线程模型，其设计思路不失为在C语言实践中可借鉴的一个好例子。</p>\n"},{"layout":"post","title":"ffplay read_thread 分析","date":"2022-03-19T16:00:00.000Z","_content":"\n\n参考： [ffplay read线程分析](https://zhuanlan.zhihu.com/p/43672062)\n\n> ffplay main 函数 做了什么\n\n1. 参数验证与解析\n\n2. 注册codecs， demux， protocols\n\n3. sdl 初始化，创建窗口\n\n4. 调用stream_open打开流\n\n5. 调用event_loop进入运行循环\n\n> stream_open 做了什么\n\n    主要是初始化VideoState *is，填充关键信息\n\n1. 初始化，分配内存`is = av_mallocz(sizeof(VideoState));`\n\n2. 调用frame_queue_init给VideoState对应的音频，视频，字幕对应Frame队列初始化分配内存\n\n3. 调用packet_queue_init给VideoState对应的音频，视频，字幕对应Packet队列初始化分配内存\n\n4. 创建条件变量continue_read_thread， 用于控制是否继续读取或者等待\n\n5. 调用init_clock 初始化音频，视频，外部时钟\n\n6. 设置同步类型av_sync_type\n\n7. 创建并开启read_thread\n\n## read_thread\n\n分为两个阶段：\n\n1. 准备阶段\n\n2. 循环读pkt\n\n准备阶段：\n\nstream_open 对VideoState *is 做了初始化关键参数的填充。read_thread 在这个基础上，打开输入的流，解封装，读取流的信息，找到音频，视频，字幕对应的stream，读取解码参数，创建解码器，开启解码器。分别为音频，视频，字幕开启创建解码线程。\n\n循环读pkt：\n\n然后进入循环，从流中读取pkt，根据同步时钟，放入pkt队列或者丢弃。如果读结束，给pkt队列放入空包，用于冲洗解码器。\n\n循环中还要处理终止暂停恢复事件，seek事件，根据队列的状态（是否有足够的数据）控制等待还是继续读取新的pkt。\n\n### 准备阶段\n\n打开文件，解封装，获取文件信息\n\n```c\nVideoState *is = arg;\nAVFormatContext *ic = NULL;\n//创建AVFormatContext\nic = avformat_alloc_context();\n//interrupt_callback用于ffmpeg内部在执行耗时操作时检查是否有退出请求，并提前中断，避免用户退出请求没有及时响应\nic->interrupt_callback.callback = decode_interrupt_cb;\nic->interrupt_callback.opaque = is;\n//特定选项处理\nif (!av_dict_get(format_opts, \"scan_all_pmts\", NULL, AV_DICT_MATCH_CASE)) {\n    av_dict_set(&format_opts, \"scan_all_pmts\", \"1\", AV_DICT_DONT_OVERWRITE);\n    scan_all_pmts_set = 1;\n}\n//打开输入的流，读取流的头部信息\nerr = avformat_open_input(&ic, is->filename, is->iformat, &format_opts);\n//保存AVFormatContext\nis->ic = ic;\nif (find_stream_info) {\n    //如果文件不包含头部信息(如ts)，通过读取一段文件分析后得到流信息\n    err = avformat_find_stream_info(ic, opts);\n}\n```\n\n判断是否是实时流\n\n```c\n//是否是实时流rtp/rtsp/sdp等\nis->realtime = is_realtime(ic);\n```\n\nis_realtime 函数\n\n```c\nstatic int is_realtime(AVFormatContext *s)\n{\n    if(   !strcmp(s->iformat->name, \"rtp\")\n       || !strcmp(s->iformat->name, \"rtsp\")\n       || !strcmp(s->iformat->name, \"sdp\")\n    )\n        return 1;\n\n    if(s->pb && (   !strncmp(s->url, \"rtp:\", 4)\n                 || !strncmp(s->url, \"udp:\", 4)\n                )\n    )\n        return 1;\n    return 0;\n}\n```\n\n选择音频，视频，字幕流。实际操作中，选择的策略很多，一般根据具体需求来定——比如可以是选择最高清的视频流；选择本地语言的音频流；直接选择第一条视频、音频轨道；等等。\n\nffplay主要是通过`av_find_best_stream`来选择：\n\n```c\n    //如果用户通过wanted_stream_spec指定了流，找到用户选择的流\n    for (i = 0; i < ic->nb_streams; i++) {\n        AVStream *st = ic->streams[i];\n        enum AVMediaType type = st->codecpar->codec_type;\n        st->discard = AVDISCARD_ALL;\n        if (type >= 0 && wanted_stream_spec[type] && st_index[type] == -1)\n            if (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) > 0)\n                st_index[type] = i;\n    }\n    for (i = 0; i < AVMEDIA_TYPE_NB; i++) {\n        if (wanted_stream_spec[i] && st_index[i] == -1) {\n            //处理找不到用户选择的流的情况\n            av_log(NULL, AV_LOG_ERROR, \"Stream specifier %s does not match any %s stream\\n\", wanted_stream_spec[i], av_get_media_type_string(i));\n            st_index[i] = INT_MAX;\n        }\n    }\n\n    //获取video stream\n    if (!video_disable)\n        st_index[AVMEDIA_TYPE_VIDEO] =\n            av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,\n                                st_index[AVMEDIA_TYPE_VIDEO], -1, NULL, 0);\n    //获取audio stream，参考视频流选择\n    if (!audio_disable)\n        st_index[AVMEDIA_TYPE_AUDIO] =\n            av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,\n                                st_index[AVMEDIA_TYPE_AUDIO],\n                                st_index[AVMEDIA_TYPE_VIDEO],\n                                NULL, 0);\n    //获取subtitle stream，优先参考音频流\n    if (!video_disable && !subtitle_disable)\n        st_index[AVMEDIA_TYPE_SUBTITLE] =\n            av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,\n                                st_index[AVMEDIA_TYPE_SUBTITLE],\n                                (st_index[AVMEDIA_TYPE_AUDIO] >= 0 ?\n                                 st_index[AVMEDIA_TYPE_AUDIO] :\n                                 st_index[AVMEDIA_TYPE_VIDEO]),\n                                NULL, 0);\n```\n\nwanted_stream_spec通过main函数传参设定，格式可以有很多种，参考[官方文档](https://www.ffmpeg.org/ffplay.html#Stream-specifiers-1)\n\n如果用户没有指定流，或指定部分流，或指定流不存在，则主要由av_find_best_stream发挥作用。\n\n```c\nint av_find_best_stream(AVFormatContext *ic,\n                        enum AVMediaType type,//要选择的流类型\n                        int wanted_stream_nb,//目标流索引\n                        int related_stream,//参考流索引\n                        AVCodec **decoder_ret,\n                        int flags);\n```\n\n如果指定了正确的wanted_stream_nb，一般情况都是直接返回该指定流，即用户选择的流。如果指定了参考流，且未指定目标流的情况，会根据参考流去查找所需类型的流，但一般结果，都是返回该类型第一个流。\n\n已经获取了流信息，下一步就是创建解码器，开启解码线程。 \n\n主要在`stream_component_open`方法中实现, 简化代码如下\n\n```c\nstatic int stream_component_open(VideoState *is, int stream_index)\n{\n    //创建解码器上下文\n    avctx = avcodec_alloc_context3(NULL);        \n    //填充解码参数\n    ret = avcodec_parameters_to_context(avctx, ic->streams[stream_index]->codecpar);\n    //设置解码器的时间基，等于stream的时间基\n    avctx->pkt_timebase = ic->streams[stream_index]->time_base;\n    //找解码器\n    codec = avcodec_find_decoder(avctx->codec_id);\n    if (forced_codec_name)\n        //如果用户指定了解码器，使用用户指定的解码器\n        codec = avcodec_find_decoder_by_name(forced_codec_name);\n    //打开解码器\n    if ((ret = avcodec_open2(avctx, codec, &opts)) < 0) {\n        goto fail;\n    }\n    switch (avctx->codec_type) {\n    case AVMEDIA_TYPE_AUDIO:\n        //打开音频播放器\n        if ((ret = audio_open(is, channel_layout, nb_channels, sample_rate, &is->audio_tgt)) < 0)\n            goto fail;\n        //给is->auddec初始化\n        if ((ret = decoder_init(&is->auddec, avctx, &is->audioq, is->continue_read_thread)) < 0)\n            goto fail;\n        //开启音频解码线程\n        if ((ret = decoder_start(&is->auddec, audio_thread, \"audio_decoder\", is)) < 0)\n            goto out;\n        //暂停音频播放器\n        SDL_PauseAudioDevice(audio_dev, 0);\n        break;\n    case AVMEDIA_TYPE_VIDEO:\n        is->video_stream = stream_index;\n        is->video_st = ic->streams[stream_index];\n        //给is->viddec初始化\n        if ((ret = decoder_init(&is->viddec, avctx, &is->videoq, is->continue_read_thread)) < 0)\n            goto fail;\n        //开启视频解码线程\n        if ((ret = decoder_start(&is->viddec, video_thread, \"video_decoder\", is)) < 0)\n            goto out;\n        is->queue_attachments_req = 1;\n        break;\n    case AVMEDIA_TYPE_SUBTITLE:\n        is->subtitle_stream = stream_index;\n        is->subtitle_st = ic->streams[stream_index];\n        //初始化字幕解码\n        if ((ret = decoder_init(&is->subdec, avctx, &is->subtitleq, is->continue_read_thread)) < 0)\n            goto fail;\n        //开启字幕解码线程\n        if ((ret = decoder_start(&is->subdec, subtitle_thread, \"subtitle_decoder\", is)) < 0)\n            goto out;\n        break;\n    }\n    //....\n    return ret;\n}\n```\n\n针对音频，需要另外处理音频播放器的初始化，暂停状态。\n\n对音频，视频，字幕，调用`decoder_init`初始化Decoder， 调用`decoder_start`开启对应的解码线程。\n\ndecoder_init\n\n```\nstatic int decoder_init(Decoder *d, AVCodecContext *avctx, PacketQueue *queue, SDL_cond *empty_queue_cond) {\n    memset(d, 0, sizeof(Decoder));\n    d->pkt = av_packet_alloc();\n    if (!d->pkt)\n        return AVERROR(ENOMEM);\n    d->avctx = avctx;\n    d->queue = queue;\n    d->empty_queue_cond = empty_queue_cond;\n    d->start_pts = AV_NOPTS_VALUE;\n    d->pkt_serial = -1;\n    return 0;\n}\n```\n\ndecoder_start\n\n```\nstatic int decoder_start(Decoder *d, int (*fn)(void *), const char *thread_name, void* arg)\n{\n    //开启packet queue\n    packet_queue_start(d->queue);\n    //开启解码线程\n    d->decoder_tid = SDL_CreateThread(fn, thread_name, arg);\n    if (!d->decoder_tid) {\n        av_log(NULL, AV_LOG_ERROR, \"SDL_CreateThread(): %s\\n\", SDL_GetError());\n        return AVERROR(ENOMEM);\n    }\n    return 0;\n}\n```\n\n### 主循环读包\n\n简化一下如下\n\n```\nfor (;;) {\n        if (is->abort_request)\n            break;//处理退出消息\n        if (is->paused != is->last_paused) {\n            //处理暂停与恢复\n            //.......\n        }\n\n        if (is->seek_req) {\n            //处理seek操作\n            ret = avformat_seek_file(is->ic, -1, seek_min, seek_target, seek_max, is->seek_flags);\n        }\n        /*\n        控制队列大小\n        */\n        if (infinite_buffer<1 &&\n              (is->audioq.size + is->videoq.size + is->subtitleq.size > MAX_QUEUE_SIZE\n            || (stream_has_enough_packets(is->audio_st, is->audio_stream, &is->audioq) &&\n                stream_has_enough_packets(is->video_st, is->video_stream, &is->videoq) &&\n                stream_has_enough_packets(is->subtitle_st, is->subtitle_stream, &is->subtitleq)))) {\n            /* wait 10 ms */\n            SDL_LockMutex(wait_mutex);\n            SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n            SDL_UnlockMutex(wait_mutex);\n            continue;\n        }\n        //处理循环播放\n        if (!is->paused &&\n            (!is->audio_st || (is->auddec.finished == is->audioq.serial && frame_queue_nb_remaining(&is->sampq) == 0)) &&\n            (!is->video_st || (is->viddec.finished == is->videoq.serial && frame_queue_nb_remaining(&is->pictq) == 0))) {\n            if (loop != 1 && (!loop || --loop)) {\n                stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0);\n            } else if (autoexit) {\n                ret = AVERROR_EOF;\n                goto fail;\n            }\n        }\n        //读pkt\n        ret = av_read_frame(ic, pkt);\n\n        //在播放区间，放入队列\n        packet_queue_put(&is->videoq, pkt);\n        //不在播放区间，丢弃\n        av_packet_unref(pkt);\n\n    }\n```\n\n主要的代码就`av_read_frame`和`packet_queue_put`，`av_read_frame`从文件中读取视频数据，并获取一个AVPacket，`packet_queue_put`把它放入到对应的PacketQueue中。\n\n当然，读取过程还会有seek、pause、resume、abort等事件，所以有专门的分支处理这些请求。\n\nPacketQueue默认情况下会有大小限制，达到这个大小后，就需要等待10ms，以让消费者——解码线程能有时间消耗。\n\n播放完成后，会根据loop的设置决定是否循环。\n\n暂停/恢复的处理：\n\n```c\nif (is->paused != is->last_paused) {\n    //更新paused状态\n    is->last_paused = is->paused;\n    if (is->paused)\n        //暂停\n        is->read_pause_return = av_read_pause(ic);\n    else\n        //恢复播放\n        av_read_play(ic);\n}\n```\n\nffmpeg有专门针对暂停和恢复的函数，所以直接调用就可以了。\n\n> av_read_pause和av_read_play对于URLProtocol，会调用其url_read_pause，通过参数区分是要暂停还是恢复。对于AVInputFormat会调用其read_pause和read_play.  \n> 一般情况下URLProtocol和AVInputFormat都不需要专门处理暂停和恢复，但对于像rtsp/rtmp这种在通讯协议上支持(需要)暂停、恢复的就特别有用了。\n\n对于seek的处理，会比暂停/恢复略微复杂一些：\n\n```c\nif (is->seek_req) {\n    //处理seek操作\n    int64_t seek_target = is->seek_pos;\n    int64_t seek_min    = is->seek_rel > 0 ? seek_target - is->seek_rel + 2: INT64_MIN;\n    int64_t seek_max    = is->seek_rel < 0 ? seek_target - is->seek_rel - 2: INT64_MAX;\n// FIXME the +-2 is due to rounding being not done in the correct direction in generation\n//      of the seek_pos/seek_rel variables\n    //seek到正确的位置\n    ret = avformat_seek_file(is->ic, -1, seek_min, seek_target, seek_max, is->seek_flags);\n    if (ret < 0) {\n        av_log(NULL, AV_LOG_ERROR,\n               \"%s: error while seeking\\n\", is->ic->url);\n    } else {\n        if (is->audio_stream >= 0)\n            //清空音频帧队列\n            packet_queue_flush(&is->audioq);\n        if (is->subtitle_stream >= 0)\n            //清空字幕帧队列\n            packet_queue_flush(&is->subtitleq);\n        if (is->video_stream >= 0)\n            //清空视频帧队列\n            packet_queue_flush(&is->videoq);\n        //更新clock\n        if (is->seek_flags & AVSEEK_FLAG_BYTE) {\n           set_clock(&is->extclk, NAN, 0);\n        } else {\n           set_clock(&is->extclk, seek_target / (double)AV_TIME_BASE, 0);\n        }\n    }\n    is->seek_req = 0;\n    is->queue_attachments_req = 1;\n    is->eof = 0;\n    if (is->paused)\n        step_to_next_frame(is);\n}\n```\n\n主要的seek操作通过avformat_seek_file完成。根据avformat_seek_file的返回值，如果seek成功，需要：\n\n1. 清除PacketQueue的缓存，并放入一个flush_pkt。放入的flush_pkt可以让PacketQueue的serial增1，以区分seek前后的数据\n2. 同步外部时钟。在后续音视频同步的文章中再具体分析。\n\n最后清理一些变量，并：\n\n1. 设置queue_attachments_req以显示attachment画面\n2. 如果当前是暂停状态，就跳到seek后的下一帧，以直观体现seek成功了\n\nstep_to_next_frame\n\n```\nstatic void step_to_next_frame(VideoState *is)\n{\n    /* if the stream is paused unpause it, then step */\n    if (is->paused)\n        stream_toggle_pause(is);\n    is->step = 1;\n}\n```\n\n原代码的注释比较清晰了——先取消暂停，然后执行step。当设置step为1后，显示线程会显示出一帧画面，然后再次进入暂停：\n\n```\n//in video_refresh\nif (is->step && !is->paused)\n    stream_toggle_pause(is);\n```\n\n这样seek的处理就完成了。\n\n前面seek、暂停、恢复都可以通过调用ffmpeg的函数，辅助一些流程控制完成封装。\n\n而读取缓冲区的控制可以说是ffplay原生的特性了。\n\n是否需要控制缓冲区大小由变量infinite_buffer决定。infinite_buffer为1表示当前buffer无限大，不需要使用缓冲区限制策略。\n\ninfinite_buffer是可选选项，但在文件是实时协议时，且用户未指定时，这个值会被强制为1：\n\n```c\nstatic int is_realtime(AVFormatContext *s)\n{\n    if(   !strcmp(s->iformat->name, \"rtp\")\n       || !strcmp(s->iformat->name, \"rtsp\")\n       || !strcmp(s->iformat->name, \"sdp\")\n    )\n        return 1;\n\n    if(s->pb && (   !strncmp(s->url, \"rtp:\", 4)\n                 || !strncmp(s->url, \"udp:\", 4)\n                )\n    )\n        return 1;\n    return 0;\n}\n\n……\nis->realtime = is_realtime(ic);\n……\nif (infinite_buffer < 0 && is->realtime)\n    infinite_buffer = 1;\n```\n\n我们看下需控制缓冲区大小的情况：\n\n```c\nif (infinite_buffer<1 &&\n    (is->audioq.size + is->videoq.size + is->subtitleq.size > MAX_QUEUE_SIZE\n    || (stream_has_enough_packets(is->audio_st, is->audio_stream, &is->audioq) &&\n        stream_has_enough_packets(is->video_st, is->video_stream, &is->videoq) &&\n        stream_has_enough_packets(is->subtitle_st, is->subtitle_stream, &is->subtitleq)))) {\n    /* wait 10 ms */\n    SDL_LockMutex(wait_mutex);\n    SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n    SDL_UnlockMutex(wait_mutex);\n    continue;\n}\n```\n\n缓冲区满有两种可能：\n\n1. audioq，videoq，subtitleq三个PacketQueue的总字节数达到了MAX_QUEUE_SIZE（15M）\n2. 音频、视频、字幕流都已有够用的包（stream_has_enough_packets）\n\n第一种好理解，看下第二种中的stream_has_enough_packets：\n\n```c\nstatic int stream_has_enough_packets(AVStream *st, int stream_id, PacketQueue *queue) {\n    return stream_id < 0 ||\n           queue->abort_request ||\n           (st->disposition & AV_DISPOSITION_ATTACHED_PIC) ||\n           queue->nb_packets > MIN_FRAMES && (!queue->duration || av_q2d(st->time_base) * queue->duration > 1.0);\n}\n```\n\n在满足PacketQueue总时长为0，或总时长超过1s的前提下：\n\n有这么几种情况包是够用的：\n\n1. 流没有打开（stream_id < 0）\n2. 有退出请求（queue->abort_request）\n3. 配置了AV_DISPOSITION_ATTACHED_PIC？（这个还不理解，后续分析attachement时回头看看）\n4. 队列内包个数大于MIN_FRAMES（=25）\n\n挺饶地，没有深刻体会其设计用意，不评论。\n\n上述的几种处理都还是在正常播放流程内，接下来是对播放已完成情况的处理。\n\n```c\nif (!is->paused &&\n    (!is->audio_st || (is->auddec.finished == is->audioq.serial && frame_queue_nb_remaining(&is->sampq) == 0)) &&\n    (!is->video_st || (is->viddec.finished == is->videoq.serial && frame_queue_nb_remaining(&is->pictq) == 0))) {\n    if (loop != 1 && (!loop || --loop)) {\n        stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0);\n    } else if (autoexit) {\n        ret = AVERROR_EOF;\n        goto fail;\n    }\n}\n```\n\n这里判断播放已完成的条件依然很“ffplay”，需要满足：\n\n1. 不在暂停状态\n2. 音频未打开，或者打开了，但是解码已解码完毕，serial等于PacketQueue的serial，并且PacketQueue中没有节点了\n3. 视频未打开，或者打开了，但是解码已解码完毕，serial等于PacketQueue的serial，并且PacketQueue中没有节点了\n\n在确认已结束的情况下，用户有两个变量可以控制播放器行为：\n\n1. loop: 控制播放次数（当前这次也算在内，也就是最小就是1次了），0表示无限次\n2. autoexit：自动退出，也就是播放完成后自动退出。\n\nloop条件简化的非常不友好，其意思是：如果loop==1，那么已经播了1次了，无需再seek重新播放；如果loop不是1，==0，随意，无限次循环；减1后还大于0（--loop），也允许循环。也就是：\n\n```c\nstatic int allow_loop() {\n    if (loop == 1)\n        return 0;\n\n    if (loop == 0)\n        return 1;\n\n    --loop;\n    if (loop > 0)\n        return 1;\n\n    return 0;\n}\n```\n\n前面讲了很多读线程主循环内的处理，比如暂停、seek、结束loop处理等，接下来就看看真正读的代码：\n\n```c\nret = av_read_frame(ic, pkt);\nif (ret < 0) {\n    //文件读取完了，调用packet_queue_put_nullpacket通知解码线程\n    if ((ret == AVERROR_EOF || avio_feof(ic->pb)) && !is->eof) {\n        if (is->video_stream >= 0)\n            packet_queue_put_nullpacket(&is->videoq, is->video_stream);\n        if (is->audio_stream >= 0)\n            packet_queue_put_nullpacket(&is->audioq, is->audio_stream);\n        if (is->subtitle_stream >= 0)\n            packet_queue_put_nullpacket(&is->subtitleq, is->subtitle_stream);\n        is->eof = 1;\n    }\n    //发生错误了，退出主循环\n    if (ic->pb && ic->pb->error)\n        break;\n\n    //如果都不是，可能只是要等一等\n    SDL_LockMutex(wait_mutex);\n    SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n    SDL_UnlockMutex(wait_mutex);\n    continue;\n} else {\n    is->eof = 0;\n}\n\n/* check if packet is in play range specified by user, then queue, otherwise discard */\nstream_start_time = ic->streams[pkt->stream_index]->start_time;\npkt_ts = pkt->pts == AV_NOPTS_VALUE ? pkt->dts : pkt->pts;\npkt_in_play_range = duration == AV_NOPTS_VALUE ||\n        (pkt_ts - (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : 0)) *\n        av_q2d(ic->streams[pkt->stream_index]->time_base) -\n        (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000\n        <= ((double)duration / 1000000);\n\n//如果在时间范围内，那么根据stream_index，放入到视频、音频、会字幕的PacketQueue中\nif (pkt->stream_index == is->audio_stream && pkt_in_play_range) {\n    packet_queue_put(&is->audioq, pkt);\n} else if (pkt->stream_index == is->video_stream && pkt_in_play_range\n           && !(is->video_st->disposition & AV_DISPOSITION_ATTACHED_PIC)) {\n    packet_queue_put(&is->videoq, pkt);\n} else if (pkt->stream_index == is->subtitle_stream && pkt_in_play_range) {\n    packet_queue_put(&is->subtitleq, pkt);\n} else {\n    av_packet_unref(pkt);\n}\n```\n\n看起来很长，实际比上述各种特殊流程的处理都直白，主要为：\n\n1. av_read_frame读取一个包(AVPacket)\n2. 返回值处理\n3. pkt_in_play_range计算\n4. packet_queue_put放入各自队列，或者丢弃\n\n步骤1、步骤2、步骤4，都比较直接，看注释即可。\n\n这里看下pkt_in_play_range的计算，我们把以上代码分解下：\n\n```c\nint64_t get_stream_start_time(AVFormatContext* ic, int index) {\n    int64_t stream_start_time = ic->streams[index]->start_time;\n    return stream_start_time != AV_NOPTS_VALUE ? stream_start_time : 0;\n}\n\nint64_t get_pkt_ts(AVPacket* pkt) {//ts: timestamp（时间戳）的缩写\n    return pkt->pts == AV_NOPTS_VALUE ? pkt->dts : pkt->pts;\n}\n\ndouble ts_as_second(int64_t ts，AVFormatContext* ic，int index) {\n    return ts * av_q2d(ic->streams[index]->time_base);\n} \n\ndouble get_ic_start_time(AVFormatContext* ic) {//ic中的时间单位是us\n    return (start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000;\n}\n```\n\n有了这些函数，就可以计算pkt_in_play_range了：\n\n```c\nint is_pkt_in_play_range(AVFormatContext* ic, AVPacket* pkt) {\n    if (duration == AV_NOPTS_VALUE) //如果当前流无法计算总时长，按无限时长处理\n        return 1;\n\n    //计算pkt相对stream位置\n    int64_t stream_ts = get_pkt_ts(pkt) - get_stream_start_time(ic, pkt->stream_index);\n    double stream_ts_s = ts_as_second(stream_ts, ic, pkt->stream_index);\n\n    //计算pkt相对ic位置\n    double ic_ts = stream_ts_s - get_ic_start_time(ic);\n\n    //是否在时间范围内\n    return ic_ts <= ((double)duration / 1000000);\n}\n```\n","source":"_posts/ffmpeg/2022-03-20-ffplay read_thread 分析.md","raw":"---\nlayout: post\ntitle: \"ffplay read_thread 分析\"\ndate: 2022-03-20\ntag: ffmpeg\n\n---\n\n\n参考： [ffplay read线程分析](https://zhuanlan.zhihu.com/p/43672062)\n\n> ffplay main 函数 做了什么\n\n1. 参数验证与解析\n\n2. 注册codecs， demux， protocols\n\n3. sdl 初始化，创建窗口\n\n4. 调用stream_open打开流\n\n5. 调用event_loop进入运行循环\n\n> stream_open 做了什么\n\n    主要是初始化VideoState *is，填充关键信息\n\n1. 初始化，分配内存`is = av_mallocz(sizeof(VideoState));`\n\n2. 调用frame_queue_init给VideoState对应的音频，视频，字幕对应Frame队列初始化分配内存\n\n3. 调用packet_queue_init给VideoState对应的音频，视频，字幕对应Packet队列初始化分配内存\n\n4. 创建条件变量continue_read_thread， 用于控制是否继续读取或者等待\n\n5. 调用init_clock 初始化音频，视频，外部时钟\n\n6. 设置同步类型av_sync_type\n\n7. 创建并开启read_thread\n\n## read_thread\n\n分为两个阶段：\n\n1. 准备阶段\n\n2. 循环读pkt\n\n准备阶段：\n\nstream_open 对VideoState *is 做了初始化关键参数的填充。read_thread 在这个基础上，打开输入的流，解封装，读取流的信息，找到音频，视频，字幕对应的stream，读取解码参数，创建解码器，开启解码器。分别为音频，视频，字幕开启创建解码线程。\n\n循环读pkt：\n\n然后进入循环，从流中读取pkt，根据同步时钟，放入pkt队列或者丢弃。如果读结束，给pkt队列放入空包，用于冲洗解码器。\n\n循环中还要处理终止暂停恢复事件，seek事件，根据队列的状态（是否有足够的数据）控制等待还是继续读取新的pkt。\n\n### 准备阶段\n\n打开文件，解封装，获取文件信息\n\n```c\nVideoState *is = arg;\nAVFormatContext *ic = NULL;\n//创建AVFormatContext\nic = avformat_alloc_context();\n//interrupt_callback用于ffmpeg内部在执行耗时操作时检查是否有退出请求，并提前中断，避免用户退出请求没有及时响应\nic->interrupt_callback.callback = decode_interrupt_cb;\nic->interrupt_callback.opaque = is;\n//特定选项处理\nif (!av_dict_get(format_opts, \"scan_all_pmts\", NULL, AV_DICT_MATCH_CASE)) {\n    av_dict_set(&format_opts, \"scan_all_pmts\", \"1\", AV_DICT_DONT_OVERWRITE);\n    scan_all_pmts_set = 1;\n}\n//打开输入的流，读取流的头部信息\nerr = avformat_open_input(&ic, is->filename, is->iformat, &format_opts);\n//保存AVFormatContext\nis->ic = ic;\nif (find_stream_info) {\n    //如果文件不包含头部信息(如ts)，通过读取一段文件分析后得到流信息\n    err = avformat_find_stream_info(ic, opts);\n}\n```\n\n判断是否是实时流\n\n```c\n//是否是实时流rtp/rtsp/sdp等\nis->realtime = is_realtime(ic);\n```\n\nis_realtime 函数\n\n```c\nstatic int is_realtime(AVFormatContext *s)\n{\n    if(   !strcmp(s->iformat->name, \"rtp\")\n       || !strcmp(s->iformat->name, \"rtsp\")\n       || !strcmp(s->iformat->name, \"sdp\")\n    )\n        return 1;\n\n    if(s->pb && (   !strncmp(s->url, \"rtp:\", 4)\n                 || !strncmp(s->url, \"udp:\", 4)\n                )\n    )\n        return 1;\n    return 0;\n}\n```\n\n选择音频，视频，字幕流。实际操作中，选择的策略很多，一般根据具体需求来定——比如可以是选择最高清的视频流；选择本地语言的音频流；直接选择第一条视频、音频轨道；等等。\n\nffplay主要是通过`av_find_best_stream`来选择：\n\n```c\n    //如果用户通过wanted_stream_spec指定了流，找到用户选择的流\n    for (i = 0; i < ic->nb_streams; i++) {\n        AVStream *st = ic->streams[i];\n        enum AVMediaType type = st->codecpar->codec_type;\n        st->discard = AVDISCARD_ALL;\n        if (type >= 0 && wanted_stream_spec[type] && st_index[type] == -1)\n            if (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) > 0)\n                st_index[type] = i;\n    }\n    for (i = 0; i < AVMEDIA_TYPE_NB; i++) {\n        if (wanted_stream_spec[i] && st_index[i] == -1) {\n            //处理找不到用户选择的流的情况\n            av_log(NULL, AV_LOG_ERROR, \"Stream specifier %s does not match any %s stream\\n\", wanted_stream_spec[i], av_get_media_type_string(i));\n            st_index[i] = INT_MAX;\n        }\n    }\n\n    //获取video stream\n    if (!video_disable)\n        st_index[AVMEDIA_TYPE_VIDEO] =\n            av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,\n                                st_index[AVMEDIA_TYPE_VIDEO], -1, NULL, 0);\n    //获取audio stream，参考视频流选择\n    if (!audio_disable)\n        st_index[AVMEDIA_TYPE_AUDIO] =\n            av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,\n                                st_index[AVMEDIA_TYPE_AUDIO],\n                                st_index[AVMEDIA_TYPE_VIDEO],\n                                NULL, 0);\n    //获取subtitle stream，优先参考音频流\n    if (!video_disable && !subtitle_disable)\n        st_index[AVMEDIA_TYPE_SUBTITLE] =\n            av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,\n                                st_index[AVMEDIA_TYPE_SUBTITLE],\n                                (st_index[AVMEDIA_TYPE_AUDIO] >= 0 ?\n                                 st_index[AVMEDIA_TYPE_AUDIO] :\n                                 st_index[AVMEDIA_TYPE_VIDEO]),\n                                NULL, 0);\n```\n\nwanted_stream_spec通过main函数传参设定，格式可以有很多种，参考[官方文档](https://www.ffmpeg.org/ffplay.html#Stream-specifiers-1)\n\n如果用户没有指定流，或指定部分流，或指定流不存在，则主要由av_find_best_stream发挥作用。\n\n```c\nint av_find_best_stream(AVFormatContext *ic,\n                        enum AVMediaType type,//要选择的流类型\n                        int wanted_stream_nb,//目标流索引\n                        int related_stream,//参考流索引\n                        AVCodec **decoder_ret,\n                        int flags);\n```\n\n如果指定了正确的wanted_stream_nb，一般情况都是直接返回该指定流，即用户选择的流。如果指定了参考流，且未指定目标流的情况，会根据参考流去查找所需类型的流，但一般结果，都是返回该类型第一个流。\n\n已经获取了流信息，下一步就是创建解码器，开启解码线程。 \n\n主要在`stream_component_open`方法中实现, 简化代码如下\n\n```c\nstatic int stream_component_open(VideoState *is, int stream_index)\n{\n    //创建解码器上下文\n    avctx = avcodec_alloc_context3(NULL);        \n    //填充解码参数\n    ret = avcodec_parameters_to_context(avctx, ic->streams[stream_index]->codecpar);\n    //设置解码器的时间基，等于stream的时间基\n    avctx->pkt_timebase = ic->streams[stream_index]->time_base;\n    //找解码器\n    codec = avcodec_find_decoder(avctx->codec_id);\n    if (forced_codec_name)\n        //如果用户指定了解码器，使用用户指定的解码器\n        codec = avcodec_find_decoder_by_name(forced_codec_name);\n    //打开解码器\n    if ((ret = avcodec_open2(avctx, codec, &opts)) < 0) {\n        goto fail;\n    }\n    switch (avctx->codec_type) {\n    case AVMEDIA_TYPE_AUDIO:\n        //打开音频播放器\n        if ((ret = audio_open(is, channel_layout, nb_channels, sample_rate, &is->audio_tgt)) < 0)\n            goto fail;\n        //给is->auddec初始化\n        if ((ret = decoder_init(&is->auddec, avctx, &is->audioq, is->continue_read_thread)) < 0)\n            goto fail;\n        //开启音频解码线程\n        if ((ret = decoder_start(&is->auddec, audio_thread, \"audio_decoder\", is)) < 0)\n            goto out;\n        //暂停音频播放器\n        SDL_PauseAudioDevice(audio_dev, 0);\n        break;\n    case AVMEDIA_TYPE_VIDEO:\n        is->video_stream = stream_index;\n        is->video_st = ic->streams[stream_index];\n        //给is->viddec初始化\n        if ((ret = decoder_init(&is->viddec, avctx, &is->videoq, is->continue_read_thread)) < 0)\n            goto fail;\n        //开启视频解码线程\n        if ((ret = decoder_start(&is->viddec, video_thread, \"video_decoder\", is)) < 0)\n            goto out;\n        is->queue_attachments_req = 1;\n        break;\n    case AVMEDIA_TYPE_SUBTITLE:\n        is->subtitle_stream = stream_index;\n        is->subtitle_st = ic->streams[stream_index];\n        //初始化字幕解码\n        if ((ret = decoder_init(&is->subdec, avctx, &is->subtitleq, is->continue_read_thread)) < 0)\n            goto fail;\n        //开启字幕解码线程\n        if ((ret = decoder_start(&is->subdec, subtitle_thread, \"subtitle_decoder\", is)) < 0)\n            goto out;\n        break;\n    }\n    //....\n    return ret;\n}\n```\n\n针对音频，需要另外处理音频播放器的初始化，暂停状态。\n\n对音频，视频，字幕，调用`decoder_init`初始化Decoder， 调用`decoder_start`开启对应的解码线程。\n\ndecoder_init\n\n```\nstatic int decoder_init(Decoder *d, AVCodecContext *avctx, PacketQueue *queue, SDL_cond *empty_queue_cond) {\n    memset(d, 0, sizeof(Decoder));\n    d->pkt = av_packet_alloc();\n    if (!d->pkt)\n        return AVERROR(ENOMEM);\n    d->avctx = avctx;\n    d->queue = queue;\n    d->empty_queue_cond = empty_queue_cond;\n    d->start_pts = AV_NOPTS_VALUE;\n    d->pkt_serial = -1;\n    return 0;\n}\n```\n\ndecoder_start\n\n```\nstatic int decoder_start(Decoder *d, int (*fn)(void *), const char *thread_name, void* arg)\n{\n    //开启packet queue\n    packet_queue_start(d->queue);\n    //开启解码线程\n    d->decoder_tid = SDL_CreateThread(fn, thread_name, arg);\n    if (!d->decoder_tid) {\n        av_log(NULL, AV_LOG_ERROR, \"SDL_CreateThread(): %s\\n\", SDL_GetError());\n        return AVERROR(ENOMEM);\n    }\n    return 0;\n}\n```\n\n### 主循环读包\n\n简化一下如下\n\n```\nfor (;;) {\n        if (is->abort_request)\n            break;//处理退出消息\n        if (is->paused != is->last_paused) {\n            //处理暂停与恢复\n            //.......\n        }\n\n        if (is->seek_req) {\n            //处理seek操作\n            ret = avformat_seek_file(is->ic, -1, seek_min, seek_target, seek_max, is->seek_flags);\n        }\n        /*\n        控制队列大小\n        */\n        if (infinite_buffer<1 &&\n              (is->audioq.size + is->videoq.size + is->subtitleq.size > MAX_QUEUE_SIZE\n            || (stream_has_enough_packets(is->audio_st, is->audio_stream, &is->audioq) &&\n                stream_has_enough_packets(is->video_st, is->video_stream, &is->videoq) &&\n                stream_has_enough_packets(is->subtitle_st, is->subtitle_stream, &is->subtitleq)))) {\n            /* wait 10 ms */\n            SDL_LockMutex(wait_mutex);\n            SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n            SDL_UnlockMutex(wait_mutex);\n            continue;\n        }\n        //处理循环播放\n        if (!is->paused &&\n            (!is->audio_st || (is->auddec.finished == is->audioq.serial && frame_queue_nb_remaining(&is->sampq) == 0)) &&\n            (!is->video_st || (is->viddec.finished == is->videoq.serial && frame_queue_nb_remaining(&is->pictq) == 0))) {\n            if (loop != 1 && (!loop || --loop)) {\n                stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0);\n            } else if (autoexit) {\n                ret = AVERROR_EOF;\n                goto fail;\n            }\n        }\n        //读pkt\n        ret = av_read_frame(ic, pkt);\n\n        //在播放区间，放入队列\n        packet_queue_put(&is->videoq, pkt);\n        //不在播放区间，丢弃\n        av_packet_unref(pkt);\n\n    }\n```\n\n主要的代码就`av_read_frame`和`packet_queue_put`，`av_read_frame`从文件中读取视频数据，并获取一个AVPacket，`packet_queue_put`把它放入到对应的PacketQueue中。\n\n当然，读取过程还会有seek、pause、resume、abort等事件，所以有专门的分支处理这些请求。\n\nPacketQueue默认情况下会有大小限制，达到这个大小后，就需要等待10ms，以让消费者——解码线程能有时间消耗。\n\n播放完成后，会根据loop的设置决定是否循环。\n\n暂停/恢复的处理：\n\n```c\nif (is->paused != is->last_paused) {\n    //更新paused状态\n    is->last_paused = is->paused;\n    if (is->paused)\n        //暂停\n        is->read_pause_return = av_read_pause(ic);\n    else\n        //恢复播放\n        av_read_play(ic);\n}\n```\n\nffmpeg有专门针对暂停和恢复的函数，所以直接调用就可以了。\n\n> av_read_pause和av_read_play对于URLProtocol，会调用其url_read_pause，通过参数区分是要暂停还是恢复。对于AVInputFormat会调用其read_pause和read_play.  \n> 一般情况下URLProtocol和AVInputFormat都不需要专门处理暂停和恢复，但对于像rtsp/rtmp这种在通讯协议上支持(需要)暂停、恢复的就特别有用了。\n\n对于seek的处理，会比暂停/恢复略微复杂一些：\n\n```c\nif (is->seek_req) {\n    //处理seek操作\n    int64_t seek_target = is->seek_pos;\n    int64_t seek_min    = is->seek_rel > 0 ? seek_target - is->seek_rel + 2: INT64_MIN;\n    int64_t seek_max    = is->seek_rel < 0 ? seek_target - is->seek_rel - 2: INT64_MAX;\n// FIXME the +-2 is due to rounding being not done in the correct direction in generation\n//      of the seek_pos/seek_rel variables\n    //seek到正确的位置\n    ret = avformat_seek_file(is->ic, -1, seek_min, seek_target, seek_max, is->seek_flags);\n    if (ret < 0) {\n        av_log(NULL, AV_LOG_ERROR,\n               \"%s: error while seeking\\n\", is->ic->url);\n    } else {\n        if (is->audio_stream >= 0)\n            //清空音频帧队列\n            packet_queue_flush(&is->audioq);\n        if (is->subtitle_stream >= 0)\n            //清空字幕帧队列\n            packet_queue_flush(&is->subtitleq);\n        if (is->video_stream >= 0)\n            //清空视频帧队列\n            packet_queue_flush(&is->videoq);\n        //更新clock\n        if (is->seek_flags & AVSEEK_FLAG_BYTE) {\n           set_clock(&is->extclk, NAN, 0);\n        } else {\n           set_clock(&is->extclk, seek_target / (double)AV_TIME_BASE, 0);\n        }\n    }\n    is->seek_req = 0;\n    is->queue_attachments_req = 1;\n    is->eof = 0;\n    if (is->paused)\n        step_to_next_frame(is);\n}\n```\n\n主要的seek操作通过avformat_seek_file完成。根据avformat_seek_file的返回值，如果seek成功，需要：\n\n1. 清除PacketQueue的缓存，并放入一个flush_pkt。放入的flush_pkt可以让PacketQueue的serial增1，以区分seek前后的数据\n2. 同步外部时钟。在后续音视频同步的文章中再具体分析。\n\n最后清理一些变量，并：\n\n1. 设置queue_attachments_req以显示attachment画面\n2. 如果当前是暂停状态，就跳到seek后的下一帧，以直观体现seek成功了\n\nstep_to_next_frame\n\n```\nstatic void step_to_next_frame(VideoState *is)\n{\n    /* if the stream is paused unpause it, then step */\n    if (is->paused)\n        stream_toggle_pause(is);\n    is->step = 1;\n}\n```\n\n原代码的注释比较清晰了——先取消暂停，然后执行step。当设置step为1后，显示线程会显示出一帧画面，然后再次进入暂停：\n\n```\n//in video_refresh\nif (is->step && !is->paused)\n    stream_toggle_pause(is);\n```\n\n这样seek的处理就完成了。\n\n前面seek、暂停、恢复都可以通过调用ffmpeg的函数，辅助一些流程控制完成封装。\n\n而读取缓冲区的控制可以说是ffplay原生的特性了。\n\n是否需要控制缓冲区大小由变量infinite_buffer决定。infinite_buffer为1表示当前buffer无限大，不需要使用缓冲区限制策略。\n\ninfinite_buffer是可选选项，但在文件是实时协议时，且用户未指定时，这个值会被强制为1：\n\n```c\nstatic int is_realtime(AVFormatContext *s)\n{\n    if(   !strcmp(s->iformat->name, \"rtp\")\n       || !strcmp(s->iformat->name, \"rtsp\")\n       || !strcmp(s->iformat->name, \"sdp\")\n    )\n        return 1;\n\n    if(s->pb && (   !strncmp(s->url, \"rtp:\", 4)\n                 || !strncmp(s->url, \"udp:\", 4)\n                )\n    )\n        return 1;\n    return 0;\n}\n\n……\nis->realtime = is_realtime(ic);\n……\nif (infinite_buffer < 0 && is->realtime)\n    infinite_buffer = 1;\n```\n\n我们看下需控制缓冲区大小的情况：\n\n```c\nif (infinite_buffer<1 &&\n    (is->audioq.size + is->videoq.size + is->subtitleq.size > MAX_QUEUE_SIZE\n    || (stream_has_enough_packets(is->audio_st, is->audio_stream, &is->audioq) &&\n        stream_has_enough_packets(is->video_st, is->video_stream, &is->videoq) &&\n        stream_has_enough_packets(is->subtitle_st, is->subtitle_stream, &is->subtitleq)))) {\n    /* wait 10 ms */\n    SDL_LockMutex(wait_mutex);\n    SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n    SDL_UnlockMutex(wait_mutex);\n    continue;\n}\n```\n\n缓冲区满有两种可能：\n\n1. audioq，videoq，subtitleq三个PacketQueue的总字节数达到了MAX_QUEUE_SIZE（15M）\n2. 音频、视频、字幕流都已有够用的包（stream_has_enough_packets）\n\n第一种好理解，看下第二种中的stream_has_enough_packets：\n\n```c\nstatic int stream_has_enough_packets(AVStream *st, int stream_id, PacketQueue *queue) {\n    return stream_id < 0 ||\n           queue->abort_request ||\n           (st->disposition & AV_DISPOSITION_ATTACHED_PIC) ||\n           queue->nb_packets > MIN_FRAMES && (!queue->duration || av_q2d(st->time_base) * queue->duration > 1.0);\n}\n```\n\n在满足PacketQueue总时长为0，或总时长超过1s的前提下：\n\n有这么几种情况包是够用的：\n\n1. 流没有打开（stream_id < 0）\n2. 有退出请求（queue->abort_request）\n3. 配置了AV_DISPOSITION_ATTACHED_PIC？（这个还不理解，后续分析attachement时回头看看）\n4. 队列内包个数大于MIN_FRAMES（=25）\n\n挺饶地，没有深刻体会其设计用意，不评论。\n\n上述的几种处理都还是在正常播放流程内，接下来是对播放已完成情况的处理。\n\n```c\nif (!is->paused &&\n    (!is->audio_st || (is->auddec.finished == is->audioq.serial && frame_queue_nb_remaining(&is->sampq) == 0)) &&\n    (!is->video_st || (is->viddec.finished == is->videoq.serial && frame_queue_nb_remaining(&is->pictq) == 0))) {\n    if (loop != 1 && (!loop || --loop)) {\n        stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0);\n    } else if (autoexit) {\n        ret = AVERROR_EOF;\n        goto fail;\n    }\n}\n```\n\n这里判断播放已完成的条件依然很“ffplay”，需要满足：\n\n1. 不在暂停状态\n2. 音频未打开，或者打开了，但是解码已解码完毕，serial等于PacketQueue的serial，并且PacketQueue中没有节点了\n3. 视频未打开，或者打开了，但是解码已解码完毕，serial等于PacketQueue的serial，并且PacketQueue中没有节点了\n\n在确认已结束的情况下，用户有两个变量可以控制播放器行为：\n\n1. loop: 控制播放次数（当前这次也算在内，也就是最小就是1次了），0表示无限次\n2. autoexit：自动退出，也就是播放完成后自动退出。\n\nloop条件简化的非常不友好，其意思是：如果loop==1，那么已经播了1次了，无需再seek重新播放；如果loop不是1，==0，随意，无限次循环；减1后还大于0（--loop），也允许循环。也就是：\n\n```c\nstatic int allow_loop() {\n    if (loop == 1)\n        return 0;\n\n    if (loop == 0)\n        return 1;\n\n    --loop;\n    if (loop > 0)\n        return 1;\n\n    return 0;\n}\n```\n\n前面讲了很多读线程主循环内的处理，比如暂停、seek、结束loop处理等，接下来就看看真正读的代码：\n\n```c\nret = av_read_frame(ic, pkt);\nif (ret < 0) {\n    //文件读取完了，调用packet_queue_put_nullpacket通知解码线程\n    if ((ret == AVERROR_EOF || avio_feof(ic->pb)) && !is->eof) {\n        if (is->video_stream >= 0)\n            packet_queue_put_nullpacket(&is->videoq, is->video_stream);\n        if (is->audio_stream >= 0)\n            packet_queue_put_nullpacket(&is->audioq, is->audio_stream);\n        if (is->subtitle_stream >= 0)\n            packet_queue_put_nullpacket(&is->subtitleq, is->subtitle_stream);\n        is->eof = 1;\n    }\n    //发生错误了，退出主循环\n    if (ic->pb && ic->pb->error)\n        break;\n\n    //如果都不是，可能只是要等一等\n    SDL_LockMutex(wait_mutex);\n    SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n    SDL_UnlockMutex(wait_mutex);\n    continue;\n} else {\n    is->eof = 0;\n}\n\n/* check if packet is in play range specified by user, then queue, otherwise discard */\nstream_start_time = ic->streams[pkt->stream_index]->start_time;\npkt_ts = pkt->pts == AV_NOPTS_VALUE ? pkt->dts : pkt->pts;\npkt_in_play_range = duration == AV_NOPTS_VALUE ||\n        (pkt_ts - (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : 0)) *\n        av_q2d(ic->streams[pkt->stream_index]->time_base) -\n        (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000\n        <= ((double)duration / 1000000);\n\n//如果在时间范围内，那么根据stream_index，放入到视频、音频、会字幕的PacketQueue中\nif (pkt->stream_index == is->audio_stream && pkt_in_play_range) {\n    packet_queue_put(&is->audioq, pkt);\n} else if (pkt->stream_index == is->video_stream && pkt_in_play_range\n           && !(is->video_st->disposition & AV_DISPOSITION_ATTACHED_PIC)) {\n    packet_queue_put(&is->videoq, pkt);\n} else if (pkt->stream_index == is->subtitle_stream && pkt_in_play_range) {\n    packet_queue_put(&is->subtitleq, pkt);\n} else {\n    av_packet_unref(pkt);\n}\n```\n\n看起来很长，实际比上述各种特殊流程的处理都直白，主要为：\n\n1. av_read_frame读取一个包(AVPacket)\n2. 返回值处理\n3. pkt_in_play_range计算\n4. packet_queue_put放入各自队列，或者丢弃\n\n步骤1、步骤2、步骤4，都比较直接，看注释即可。\n\n这里看下pkt_in_play_range的计算，我们把以上代码分解下：\n\n```c\nint64_t get_stream_start_time(AVFormatContext* ic, int index) {\n    int64_t stream_start_time = ic->streams[index]->start_time;\n    return stream_start_time != AV_NOPTS_VALUE ? stream_start_time : 0;\n}\n\nint64_t get_pkt_ts(AVPacket* pkt) {//ts: timestamp（时间戳）的缩写\n    return pkt->pts == AV_NOPTS_VALUE ? pkt->dts : pkt->pts;\n}\n\ndouble ts_as_second(int64_t ts，AVFormatContext* ic，int index) {\n    return ts * av_q2d(ic->streams[index]->time_base);\n} \n\ndouble get_ic_start_time(AVFormatContext* ic) {//ic中的时间单位是us\n    return (start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000;\n}\n```\n\n有了这些函数，就可以计算pkt_in_play_range了：\n\n```c\nint is_pkt_in_play_range(AVFormatContext* ic, AVPacket* pkt) {\n    if (duration == AV_NOPTS_VALUE) //如果当前流无法计算总时长，按无限时长处理\n        return 1;\n\n    //计算pkt相对stream位置\n    int64_t stream_ts = get_pkt_ts(pkt) - get_stream_start_time(ic, pkt->stream_index);\n    double stream_ts_s = ts_as_second(stream_ts, ic, pkt->stream_index);\n\n    //计算pkt相对ic位置\n    double ic_ts = stream_ts_s - get_ic_start_time(ic);\n\n    //是否在时间范围内\n    return ic_ts <= ((double)duration / 1000000);\n}\n```\n","slug":"ffmpeg/2022-03-20-ffplay read_thread 分析","published":1,"updated":"2024-03-06T11:53:13.566Z","comments":1,"photos":[],"_id":"cltgopene0023qywhe4skah5s","content":"<p>参考： <a href=\"https://zhuanlan.zhihu.com/p/43672062\">ffplay read线程分析</a></p>\n<blockquote>\n<p>ffplay main 函数 做了什么</p>\n</blockquote>\n<ol>\n<li><p>参数验证与解析</p>\n</li>\n<li><p>注册codecs， demux， protocols</p>\n</li>\n<li><p>sdl 初始化，创建窗口</p>\n</li>\n<li><p>调用stream_open打开流</p>\n</li>\n<li><p>调用event_loop进入运行循环</p>\n</li>\n</ol>\n<blockquote>\n<p>stream_open 做了什么</p>\n</blockquote>\n<p>    主要是初始化VideoState *is，填充关键信息</p>\n<ol>\n<li><p>初始化，分配内存<code>is = av_mallocz(sizeof(VideoState));</code></p>\n</li>\n<li><p>调用frame_queue_init给VideoState对应的音频，视频，字幕对应Frame队列初始化分配内存</p>\n</li>\n<li><p>调用packet_queue_init给VideoState对应的音频，视频，字幕对应Packet队列初始化分配内存</p>\n</li>\n<li><p>创建条件变量continue_read_thread， 用于控制是否继续读取或者等待</p>\n</li>\n<li><p>调用init_clock 初始化音频，视频，外部时钟</p>\n</li>\n<li><p>设置同步类型av_sync_type</p>\n</li>\n<li><p>创建并开启read_thread</p>\n</li>\n</ol>\n<h2 id=\"read-thread\"><a href=\"#read-thread\" class=\"headerlink\" title=\"read_thread\"></a>read_thread</h2><p>分为两个阶段：</p>\n<ol>\n<li><p>准备阶段</p>\n</li>\n<li><p>循环读pkt</p>\n</li>\n</ol>\n<p>准备阶段：</p>\n<p>stream_open 对VideoState *is 做了初始化关键参数的填充。read_thread 在这个基础上，打开输入的流，解封装，读取流的信息，找到音频，视频，字幕对应的stream，读取解码参数，创建解码器，开启解码器。分别为音频，视频，字幕开启创建解码线程。</p>\n<p>循环读pkt：</p>\n<p>然后进入循环，从流中读取pkt，根据同步时钟，放入pkt队列或者丢弃。如果读结束，给pkt队列放入空包，用于冲洗解码器。</p>\n<p>循环中还要处理终止暂停恢复事件，seek事件，根据队列的状态（是否有足够的数据）控制等待还是继续读取新的pkt。</p>\n<h3 id=\"准备阶段\"><a href=\"#准备阶段\" class=\"headerlink\" title=\"准备阶段\"></a>准备阶段</h3><p>打开文件，解封装，获取文件信息</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">VideoState *is = arg;<br>AVFormatContext *ic = <span class=\"hljs-literal\">NULL</span>;<br><span class=\"hljs-comment\">//创建AVFormatContext</span><br>ic = avformat_alloc_context();<br><span class=\"hljs-comment\">//interrupt_callback用于ffmpeg内部在执行耗时操作时检查是否有退出请求，并提前中断，避免用户退出请求没有及时响应</span><br>ic-&gt;interrupt_callback.callback = decode_interrupt_cb;<br>ic-&gt;interrupt_callback.opaque = is;<br><span class=\"hljs-comment\">//特定选项处理</span><br><span class=\"hljs-keyword\">if</span> (!av_dict_get(format_opts, <span class=\"hljs-string\">&quot;scan_all_pmts&quot;</span>, <span class=\"hljs-literal\">NULL</span>, AV_DICT_MATCH_CASE)) &#123;<br>    av_dict_set(&amp;format_opts, <span class=\"hljs-string\">&quot;scan_all_pmts&quot;</span>, <span class=\"hljs-string\">&quot;1&quot;</span>, AV_DICT_DONT_OVERWRITE);<br>    scan_all_pmts_set = <span class=\"hljs-number\">1</span>;<br>&#125;<br><span class=\"hljs-comment\">//打开输入的流，读取流的头部信息</span><br>err = avformat_open_input(&amp;ic, is-&gt;filename, is-&gt;iformat, &amp;format_opts);<br><span class=\"hljs-comment\">//保存AVFormatContext</span><br>is-&gt;ic = ic;<br><span class=\"hljs-keyword\">if</span> (find_stream_info) &#123;<br>    <span class=\"hljs-comment\">//如果文件不包含头部信息(如ts)，通过读取一段文件分析后得到流信息</span><br>    err = avformat_find_stream_info(ic, opts);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>判断是否是实时流</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//是否是实时流rtp/rtsp/sdp等</span><br>is-&gt;realtime = is_realtime(ic);<br></code></pre></td></tr></table></figure>\n\n<p>is_realtime 函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">is_realtime</span><span class=\"hljs-params\">(AVFormatContext *s)</span><br>&#123;<br>    <span class=\"hljs-keyword\">if</span>(   !<span class=\"hljs-built_in\">strcmp</span>(s-&gt;iformat-&gt;name, <span class=\"hljs-string\">&quot;rtp&quot;</span>)<br>       || !<span class=\"hljs-built_in\">strcmp</span>(s-&gt;iformat-&gt;name, <span class=\"hljs-string\">&quot;rtsp&quot;</span>)<br>       || !<span class=\"hljs-built_in\">strcmp</span>(s-&gt;iformat-&gt;name, <span class=\"hljs-string\">&quot;sdp&quot;</span>)<br>    )<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br><br>    <span class=\"hljs-keyword\">if</span>(s-&gt;pb &amp;&amp; (   !<span class=\"hljs-built_in\">strncmp</span>(s-&gt;url, <span class=\"hljs-string\">&quot;rtp:&quot;</span>, <span class=\"hljs-number\">4</span>)<br>                 || !<span class=\"hljs-built_in\">strncmp</span>(s-&gt;url, <span class=\"hljs-string\">&quot;udp:&quot;</span>, <span class=\"hljs-number\">4</span>)<br>                )<br>    )<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>选择音频，视频，字幕流。实际操作中，选择的策略很多，一般根据具体需求来定——比如可以是选择最高清的视频流；选择本地语言的音频流；直接选择第一条视频、音频轨道；等等。</p>\n<p>ffplay主要是通过<code>av_find_best_stream</code>来选择：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//如果用户通过wanted_stream_spec指定了流，找到用户选择的流</span><br><span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;<br>    AVStream *st = ic-&gt;streams[i];<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">AVMediaType</span> <span class=\"hljs-title\">type</span> =</span> st-&gt;codecpar-&gt;codec_type;<br>    st-&gt;discard = AVDISCARD_ALL;<br>    <span class=\"hljs-keyword\">if</span> (type &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; wanted_stream_spec[type] &amp;&amp; st_index[type] == <span class=\"hljs-number\">-1</span>)<br>        <span class=\"hljs-keyword\">if</span> (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) &gt; <span class=\"hljs-number\">0</span>)<br>            st_index[type] = i;<br>&#125;<br><span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; AVMEDIA_TYPE_NB; i++) &#123;<br>    <span class=\"hljs-keyword\">if</span> (wanted_stream_spec[i] &amp;&amp; st_index[i] == <span class=\"hljs-number\">-1</span>) &#123;<br>        <span class=\"hljs-comment\">//处理找不到用户选择的流的情况</span><br>        av_log(<span class=\"hljs-literal\">NULL</span>, AV_LOG_ERROR, <span class=\"hljs-string\">&quot;Stream specifier %s does not match any %s stream\\n&quot;</span>, wanted_stream_spec[i], av_get_media_type_string(i));<br>        st_index[i] = INT_MAX;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">//获取video stream</span><br><span class=\"hljs-keyword\">if</span> (!video_disable)<br>    st_index[AVMEDIA_TYPE_VIDEO] =<br>        av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,<br>                            st_index[AVMEDIA_TYPE_VIDEO], <span class=\"hljs-number\">-1</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>);<br><span class=\"hljs-comment\">//获取audio stream，参考视频流选择</span><br><span class=\"hljs-keyword\">if</span> (!audio_disable)<br>    st_index[AVMEDIA_TYPE_AUDIO] =<br>        av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,<br>                            st_index[AVMEDIA_TYPE_AUDIO],<br>                            st_index[AVMEDIA_TYPE_VIDEO],<br>                            <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>);<br><span class=\"hljs-comment\">//获取subtitle stream，优先参考音频流</span><br><span class=\"hljs-keyword\">if</span> (!video_disable &amp;&amp; !subtitle_disable)<br>    st_index[AVMEDIA_TYPE_SUBTITLE] =<br>        av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,<br>                            st_index[AVMEDIA_TYPE_SUBTITLE],<br>                            (st_index[AVMEDIA_TYPE_AUDIO] &gt;= <span class=\"hljs-number\">0</span> ?<br>                             st_index[AVMEDIA_TYPE_AUDIO] :<br>                             st_index[AVMEDIA_TYPE_VIDEO]),<br>                            <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<p>wanted_stream_spec通过main函数传参设定，格式可以有很多种，参考<a href=\"https://www.ffmpeg.org/ffplay.html#Stream-specifiers-1\">官方文档</a></p>\n<p>如果用户没有指定流，或指定部分流，或指定流不存在，则主要由av_find_best_stream发挥作用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">av_find_best_stream</span><span class=\"hljs-params\">(AVFormatContext *ic,</span><br><span class=\"hljs-params\">                        <span class=\"hljs-keyword\">enum</span> AVMediaType type,<span class=\"hljs-comment\">//要选择的流类型</span></span><br><span class=\"hljs-params\">                        <span class=\"hljs-type\">int</span> wanted_stream_nb,<span class=\"hljs-comment\">//目标流索引</span></span><br><span class=\"hljs-params\">                        <span class=\"hljs-type\">int</span> related_stream,<span class=\"hljs-comment\">//参考流索引</span></span><br><span class=\"hljs-params\">                        AVCodec **decoder_ret,</span><br><span class=\"hljs-params\">                        <span class=\"hljs-type\">int</span> flags)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>如果指定了正确的wanted_stream_nb，一般情况都是直接返回该指定流，即用户选择的流。如果指定了参考流，且未指定目标流的情况，会根据参考流去查找所需类型的流，但一般结果，都是返回该类型第一个流。</p>\n<p>已经获取了流信息，下一步就是创建解码器，开启解码线程。 </p>\n<p>主要在<code>stream_component_open</code>方法中实现, 简化代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">stream_component_open</span><span class=\"hljs-params\">(VideoState *is, <span class=\"hljs-type\">int</span> stream_index)</span><br>&#123;<br>    <span class=\"hljs-comment\">//创建解码器上下文</span><br>    avctx = avcodec_alloc_context3(<span class=\"hljs-literal\">NULL</span>);        <br>    <span class=\"hljs-comment\">//填充解码参数</span><br>    ret = avcodec_parameters_to_context(avctx, ic-&gt;streams[stream_index]-&gt;codecpar);<br>    <span class=\"hljs-comment\">//设置解码器的时间基，等于stream的时间基</span><br>    avctx-&gt;pkt_timebase = ic-&gt;streams[stream_index]-&gt;time_base;<br>    <span class=\"hljs-comment\">//找解码器</span><br>    codec = avcodec_find_decoder(avctx-&gt;codec_id);<br>    <span class=\"hljs-keyword\">if</span> (forced_codec_name)<br>        <span class=\"hljs-comment\">//如果用户指定了解码器，使用用户指定的解码器</span><br>        codec = avcodec_find_decoder_by_name(forced_codec_name);<br>    <span class=\"hljs-comment\">//打开解码器</span><br>    <span class=\"hljs-keyword\">if</span> ((ret = avcodec_open2(avctx, codec, &amp;opts)) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">goto</span> fail;<br>    &#125;<br>    <span class=\"hljs-keyword\">switch</span> (avctx-&gt;codec_type) &#123;<br>    <span class=\"hljs-keyword\">case</span> AVMEDIA_TYPE_AUDIO:<br>        <span class=\"hljs-comment\">//打开音频播放器</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = audio_open(is, channel_layout, nb_channels, sample_rate, &amp;is-&gt;audio_tgt)) &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">goto</span> fail;<br>        <span class=\"hljs-comment\">//给is-&gt;auddec初始化</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = decoder_init(&amp;is-&gt;auddec, avctx, &amp;is-&gt;audioq, is-&gt;continue_read_thread)) &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">goto</span> fail;<br>        <span class=\"hljs-comment\">//开启音频解码线程</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = decoder_start(&amp;is-&gt;auddec, audio_thread, <span class=\"hljs-string\">&quot;audio_decoder&quot;</span>, is)) &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">goto</span> out;<br>        <span class=\"hljs-comment\">//暂停音频播放器</span><br>        SDL_PauseAudioDevice(audio_dev, <span class=\"hljs-number\">0</span>);<br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> AVMEDIA_TYPE_VIDEO:<br>        is-&gt;video_stream = stream_index;<br>        is-&gt;video_st = ic-&gt;streams[stream_index];<br>        <span class=\"hljs-comment\">//给is-&gt;viddec初始化</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = decoder_init(&amp;is-&gt;viddec, avctx, &amp;is-&gt;videoq, is-&gt;continue_read_thread)) &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">goto</span> fail;<br>        <span class=\"hljs-comment\">//开启视频解码线程</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = decoder_start(&amp;is-&gt;viddec, video_thread, <span class=\"hljs-string\">&quot;video_decoder&quot;</span>, is)) &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">goto</span> out;<br>        is-&gt;queue_attachments_req = <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> AVMEDIA_TYPE_SUBTITLE:<br>        is-&gt;subtitle_stream = stream_index;<br>        is-&gt;subtitle_st = ic-&gt;streams[stream_index];<br>        <span class=\"hljs-comment\">//初始化字幕解码</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = decoder_init(&amp;is-&gt;subdec, avctx, &amp;is-&gt;subtitleq, is-&gt;continue_read_thread)) &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">goto</span> fail;<br>        <span class=\"hljs-comment\">//开启字幕解码线程</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = decoder_start(&amp;is-&gt;subdec, subtitle_thread, <span class=\"hljs-string\">&quot;subtitle_decoder&quot;</span>, is)) &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">goto</span> out;<br>        <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">//....</span><br>    <span class=\"hljs-keyword\">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>针对音频，需要另外处理音频播放器的初始化，暂停状态。</p>\n<p>对音频，视频，字幕，调用<code>decoder_init</code>初始化Decoder， 调用<code>decoder_start</code>开启对应的解码线程。</p>\n<p>decoder_init</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">static int decoder_init(Decoder *d, AVCodecContext *avctx, PacketQueue *queue, SDL_cond *empty_queue_cond) &#123;<br>    memset(d, <span class=\"hljs-number\">0</span>, sizeof(Decoder));<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">d</span>-&gt;</span>pkt = av_packet_alloc();<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (!d-&gt;</span>pkt)<br>        return AVERROR(ENOMEM);<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">d</span>-&gt;</span>avctx = avctx;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">d</span>-&gt;</span>queue = queue;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">d</span>-&gt;</span>empty_queue_cond = empty_queue_cond;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">d</span>-&gt;</span>start_pts = AV_NOPTS_VALUE;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">d</span>-&gt;</span>pkt_serial = -<span class=\"hljs-number\">1</span>;<br>    return <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>decoder_start</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">decoder_start</span><span class=\"hljs-params\">(Decoder *d, <span class=\"hljs-type\">int</span> (*fn)(<span class=\"hljs-type\">void</span> *), <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *thread_name, <span class=\"hljs-type\">void</span>* arg)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//开启packet queue</span><br>    <span class=\"hljs-built_in\">packet_queue_start</span>(d-&gt;queue);<br>    <span class=\"hljs-comment\">//开启解码线程</span><br>    d-&gt;decoder_tid = <span class=\"hljs-built_in\">SDL_CreateThread</span>(fn, thread_name, arg);<br>    <span class=\"hljs-keyword\">if</span> (!d-&gt;decoder_tid) &#123;<br>        <span class=\"hljs-built_in\">av_log</span>(<span class=\"hljs-literal\">NULL</span>, AV_LOG_ERROR, <span class=\"hljs-string\">&quot;SDL_CreateThread(): %s\\n&quot;</span>, <span class=\"hljs-built_in\">SDL_GetError</span>());<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">AVERROR</span>(ENOMEM);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"主循环读包\"><a href=\"#主循环读包\" class=\"headerlink\" title=\"主循环读包\"></a>主循环读包</h3><p>简化一下如下</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"><span class=\"hljs-keyword\">for</span> (;;) &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (<span class=\"hljs-keyword\">is</span>-&gt;</span>abort_request)<br>            break;<span class=\"hljs-comment\">//处理退出消息</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (<span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">paused</span> != <span class=\"hljs-keyword\">is</span>-&gt;</span>last_paused) &#123;<br>            <span class=\"hljs-comment\">//处理暂停与恢复</span><br>            <span class=\"hljs-comment\">//.......</span><br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (<span class=\"hljs-keyword\">is</span>-&gt;</span>seek_req) &#123;<br>            <span class=\"hljs-comment\">//处理seek操作</span><br>            <span class=\"hljs-function\"><span class=\"hljs-title\">ret</span> = avformat_seek_file(<span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">ic</span>, -1, seek_min, seek_target, seek_max, <span class=\"hljs-keyword\">is</span>-&gt;</span>seek_flags);<br>        &#125;<br>        <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">        控制队列大小</span><br><span class=\"hljs-comment\">        */</span><br>        <span class=\"hljs-keyword\">if</span> (infinite_buffer&lt;<span class=\"hljs-number\">1</span> &amp;&amp;<br>              (<span class=\"hljs-function\"><span class=\"hljs-title\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">audioq</span>.size + <span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">videoq</span>.size + <span class=\"hljs-keyword\">is</span>-&gt;</span>subtitleq.size &gt; MAX_QUEUE_SIZE<br>            || (<span class=\"hljs-function\"><span class=\"hljs-title\">stream_has_enough_packets</span>(<span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">audio_st</span>, <span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">audio_stream</span>, &amp;<span class=\"hljs-keyword\">is</span>-&gt;</span>audioq) &amp;&amp;<br>                <span class=\"hljs-function\"><span class=\"hljs-title\">stream_has_enough_packets</span>(<span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">video_st</span>, <span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">video_stream</span>, &amp;<span class=\"hljs-keyword\">is</span>-&gt;</span>videoq) &amp;&amp;<br>                <span class=\"hljs-function\"><span class=\"hljs-title\">stream_has_enough_packets</span>(<span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">subtitle_st</span>, <span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">subtitle_stream</span>, &amp;<span class=\"hljs-keyword\">is</span>-&gt;</span>subtitleq)))) &#123;<br>            <span class=\"hljs-comment\">/* wait 10 ms */</span><br>            SDL_LockMutex(wait_mutex);<br>            SDL_C<span class=\"hljs-function\"><span class=\"hljs-title\">ondWaitTimeout</span>(<span class=\"hljs-keyword\">is</span>-&gt;</span>continue_read_thread, wait_mutex, <span class=\"hljs-number\">10</span>);<br>            SDL_UnlockMutex(wait_mutex);<br>            continue;<br>        &#125;<br>        <span class=\"hljs-comment\">//处理循环播放</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (!<span class=\"hljs-keyword\">is</span>-&gt;</span>paused &amp;&amp;<br>            (!<span class=\"hljs-function\"><span class=\"hljs-title\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">audio_st</span> || (<span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">auddec</span>.finished == <span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">audioq</span>.serial &amp;&amp; frame_queue_nb_remaining(&amp;<span class=\"hljs-keyword\">is</span>-&gt;</span>sampq) == <span class=\"hljs-number\">0</span>)) &amp;&amp;<br>            (!<span class=\"hljs-function\"><span class=\"hljs-title\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">video_st</span> || (<span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">viddec</span>.finished == <span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">videoq</span>.serial &amp;&amp; frame_queue_nb_remaining(&amp;<span class=\"hljs-keyword\">is</span>-&gt;</span>pictq) == <span class=\"hljs-number\">0</span>))) &#123;<br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">loop</span> != <span class=\"hljs-number\">1</span> &amp;&amp; (!<span class=\"hljs-keyword\">loop</span> || --<span class=\"hljs-keyword\">loop</span>)) &#123;<br>                stream_seek(<span class=\"hljs-keyword\">is</span>, start_time != AV_NOPTS_VALUE ? start_time : <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (autoexit) &#123;<br>                ret = AVERROR_EOF;<br>                goto fail;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-comment\">//读pkt</span><br>        ret = av_read_frame(ic, pkt);<br><br>        <span class=\"hljs-comment\">//在播放区间，放入队列</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">packet_queue_put</span>(&amp;<span class=\"hljs-keyword\">is</span>-&gt;</span>videoq, pkt);<br>        <span class=\"hljs-comment\">//不在播放区间，丢弃</span><br>        av_packet_unref(pkt);<br><br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>主要的代码就<code>av_read_frame</code>和<code>packet_queue_put</code>，<code>av_read_frame</code>从文件中读取视频数据，并获取一个AVPacket，<code>packet_queue_put</code>把它放入到对应的PacketQueue中。</p>\n<p>当然，读取过程还会有seek、pause、resume、abort等事件，所以有专门的分支处理这些请求。</p>\n<p>PacketQueue默认情况下会有大小限制，达到这个大小后，就需要等待10ms，以让消费者——解码线程能有时间消耗。</p>\n<p>播放完成后，会根据loop的设置决定是否循环。</p>\n<p>暂停&#x2F;恢复的处理：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">if</span> (is-&gt;paused != is-&gt;last_paused) &#123;<br>    <span class=\"hljs-comment\">//更新paused状态</span><br>    is-&gt;last_paused = is-&gt;paused;<br>    <span class=\"hljs-keyword\">if</span> (is-&gt;paused)<br>        <span class=\"hljs-comment\">//暂停</span><br>        is-&gt;read_pause_return = av_read_pause(ic);<br>    <span class=\"hljs-keyword\">else</span><br>        <span class=\"hljs-comment\">//恢复播放</span><br>        av_read_play(ic);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>ffmpeg有专门针对暂停和恢复的函数，所以直接调用就可以了。</p>\n<blockquote>\n<p>av_read_pause和av_read_play对于URLProtocol，会调用其url_read_pause，通过参数区分是要暂停还是恢复。对于AVInputFormat会调用其read_pause和read_play.<br>一般情况下URLProtocol和AVInputFormat都不需要专门处理暂停和恢复，但对于像rtsp&#x2F;rtmp这种在通讯协议上支持(需要)暂停、恢复的就特别有用了。</p>\n</blockquote>\n<p>对于seek的处理，会比暂停&#x2F;恢复略微复杂一些：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">if</span> (is-&gt;seek_req) &#123;<br>    <span class=\"hljs-comment\">//处理seek操作</span><br>    <span class=\"hljs-type\">int64_t</span> seek_target = is-&gt;seek_pos;<br>    <span class=\"hljs-type\">int64_t</span> seek_min    = is-&gt;seek_rel &gt; <span class=\"hljs-number\">0</span> ? seek_target - is-&gt;seek_rel + <span class=\"hljs-number\">2</span>: INT64_MIN;<br>    <span class=\"hljs-type\">int64_t</span> seek_max    = is-&gt;seek_rel &lt; <span class=\"hljs-number\">0</span> ? seek_target - is-&gt;seek_rel - <span class=\"hljs-number\">2</span>: INT64_MAX;<br><span class=\"hljs-comment\">// FIXME the +-2 is due to rounding being not done in the correct direction in generation</span><br><span class=\"hljs-comment\">//      of the seek_pos/seek_rel variables</span><br>    <span class=\"hljs-comment\">//seek到正确的位置</span><br>    ret = avformat_seek_file(is-&gt;ic, <span class=\"hljs-number\">-1</span>, seek_min, seek_target, seek_max, is-&gt;seek_flags);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        av_log(<span class=\"hljs-literal\">NULL</span>, AV_LOG_ERROR,<br>               <span class=\"hljs-string\">&quot;%s: error while seeking\\n&quot;</span>, is-&gt;ic-&gt;url);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (is-&gt;audio_stream &gt;= <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-comment\">//清空音频帧队列</span><br>            packet_queue_flush(&amp;is-&gt;audioq);<br>        <span class=\"hljs-keyword\">if</span> (is-&gt;subtitle_stream &gt;= <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-comment\">//清空字幕帧队列</span><br>            packet_queue_flush(&amp;is-&gt;subtitleq);<br>        <span class=\"hljs-keyword\">if</span> (is-&gt;video_stream &gt;= <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-comment\">//清空视频帧队列</span><br>            packet_queue_flush(&amp;is-&gt;videoq);<br>        <span class=\"hljs-comment\">//更新clock</span><br>        <span class=\"hljs-keyword\">if</span> (is-&gt;seek_flags &amp; AVSEEK_FLAG_BYTE) &#123;<br>           set_clock(&amp;is-&gt;extclk, NAN, <span class=\"hljs-number\">0</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>           set_clock(&amp;is-&gt;extclk, seek_target / (<span class=\"hljs-type\">double</span>)AV_TIME_BASE, <span class=\"hljs-number\">0</span>);<br>        &#125;<br>    &#125;<br>    is-&gt;seek_req = <span class=\"hljs-number\">0</span>;<br>    is-&gt;queue_attachments_req = <span class=\"hljs-number\">1</span>;<br>    is-&gt;eof = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">if</span> (is-&gt;paused)<br>        step_to_next_frame(is);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>主要的seek操作通过avformat_seek_file完成。根据avformat_seek_file的返回值，如果seek成功，需要：</p>\n<ol>\n<li>清除PacketQueue的缓存，并放入一个flush_pkt。放入的flush_pkt可以让PacketQueue的serial增1，以区分seek前后的数据</li>\n<li>同步外部时钟。在后续音视频同步的文章中再具体分析。</li>\n</ol>\n<p>最后清理一些变量，并：</p>\n<ol>\n<li>设置queue_attachments_req以显示attachment画面</li>\n<li>如果当前是暂停状态，就跳到seek后的下一帧，以直观体现seek成功了</li>\n</ol>\n<p>step_to_next_frame</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livescript\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-literal\">void</span> step_to_next_frame(VideoState *<span class=\"hljs-keyword\">is</span>)<br>&#123;<br>    <span class=\"hljs-comment\">/* if the stream is paused unpause it, then step */</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">is</span>-&gt;paused)<br>        stream_toggle_pause(<span class=\"hljs-keyword\">is</span>);<br>    <span class=\"hljs-keyword\">is</span>-&gt;step = <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>原代码的注释比较清晰了——先取消暂停，然后执行step。当设置step为1后，显示线程会显示出一帧画面，然后再次进入暂停：</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"><span class=\"hljs-comment\">//in video_refresh</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (<span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">step</span> &amp;&amp; !<span class=\"hljs-keyword\">is</span>-&gt;</span>paused)<br>    stream_toggle_pause(<span class=\"hljs-keyword\">is</span>);<br></code></pre></td></tr></table></figure>\n\n<p>这样seek的处理就完成了。</p>\n<p>前面seek、暂停、恢复都可以通过调用ffmpeg的函数，辅助一些流程控制完成封装。</p>\n<p>而读取缓冲区的控制可以说是ffplay原生的特性了。</p>\n<p>是否需要控制缓冲区大小由变量infinite_buffer决定。infinite_buffer为1表示当前buffer无限大，不需要使用缓冲区限制策略。</p>\n<p>infinite_buffer是可选选项，但在文件是实时协议时，且用户未指定时，这个值会被强制为1：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">is_realtime</span><span class=\"hljs-params\">(AVFormatContext *s)</span><br>&#123;<br>    <span class=\"hljs-keyword\">if</span>(   !<span class=\"hljs-built_in\">strcmp</span>(s-&gt;iformat-&gt;name, <span class=\"hljs-string\">&quot;rtp&quot;</span>)<br>       || !<span class=\"hljs-built_in\">strcmp</span>(s-&gt;iformat-&gt;name, <span class=\"hljs-string\">&quot;rtsp&quot;</span>)<br>       || !<span class=\"hljs-built_in\">strcmp</span>(s-&gt;iformat-&gt;name, <span class=\"hljs-string\">&quot;sdp&quot;</span>)<br>    )<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br><br>    <span class=\"hljs-keyword\">if</span>(s-&gt;pb &amp;&amp; (   !<span class=\"hljs-built_in\">strncmp</span>(s-&gt;url, <span class=\"hljs-string\">&quot;rtp:&quot;</span>, <span class=\"hljs-number\">4</span>)<br>                 || !<span class=\"hljs-built_in\">strncmp</span>(s-&gt;url, <span class=\"hljs-string\">&quot;udp:&quot;</span>, <span class=\"hljs-number\">4</span>)<br>                )<br>    )<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br>……<br>is-&gt;realtime = is_realtime(ic);<br>……<br><span class=\"hljs-keyword\">if</span> (infinite_buffer &lt; <span class=\"hljs-number\">0</span> &amp;&amp; is-&gt;realtime)<br>    infinite_buffer = <span class=\"hljs-number\">1</span>;<br></code></pre></td></tr></table></figure>\n\n<p>我们看下需控制缓冲区大小的情况：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">if</span> (infinite_buffer&lt;<span class=\"hljs-number\">1</span> &amp;&amp;<br>    (is-&gt;audioq.size + is-&gt;videoq.size + is-&gt;subtitleq.size &gt; MAX_QUEUE_SIZE<br>    || (stream_has_enough_packets(is-&gt;audio_st, is-&gt;audio_stream, &amp;is-&gt;audioq) &amp;&amp;<br>        stream_has_enough_packets(is-&gt;video_st, is-&gt;video_stream, &amp;is-&gt;videoq) &amp;&amp;<br>        stream_has_enough_packets(is-&gt;subtitle_st, is-&gt;subtitle_stream, &amp;is-&gt;subtitleq)))) &#123;<br>    <span class=\"hljs-comment\">/* wait 10 ms */</span><br>    SDL_LockMutex(wait_mutex);<br>    SDL_CondWaitTimeout(is-&gt;continue_read_thread, wait_mutex, <span class=\"hljs-number\">10</span>);<br>    SDL_UnlockMutex(wait_mutex);<br>    <span class=\"hljs-keyword\">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>缓冲区满有两种可能：</p>\n<ol>\n<li>audioq，videoq，subtitleq三个PacketQueue的总字节数达到了MAX_QUEUE_SIZE（15M）</li>\n<li>音频、视频、字幕流都已有够用的包（stream_has_enough_packets）</li>\n</ol>\n<p>第一种好理解，看下第二种中的stream_has_enough_packets：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">stream_has_enough_packets</span><span class=\"hljs-params\">(AVStream *st, <span class=\"hljs-type\">int</span> stream_id, PacketQueue *<span class=\"hljs-built_in\">queue</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> stream_id &lt; <span class=\"hljs-number\">0</span> ||<br>           <span class=\"hljs-built_in\">queue</span>-&gt;abort_request ||<br>           (st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC) ||<br>           <span class=\"hljs-built_in\">queue</span>-&gt;nb_packets &gt; MIN_FRAMES &amp;&amp; (!<span class=\"hljs-built_in\">queue</span>-&gt;duration || av_q2d(st-&gt;time_base) * <span class=\"hljs-built_in\">queue</span>-&gt;duration &gt; <span class=\"hljs-number\">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在满足PacketQueue总时长为0，或总时长超过1s的前提下：</p>\n<p>有这么几种情况包是够用的：</p>\n<ol>\n<li>流没有打开（stream_id &lt; 0）</li>\n<li>有退出请求（queue-&gt;abort_request）</li>\n<li>配置了AV_DISPOSITION_ATTACHED_PIC？（这个还不理解，后续分析attachement时回头看看）</li>\n<li>队列内包个数大于MIN_FRAMES（&#x3D;25）</li>\n</ol>\n<p>挺饶地，没有深刻体会其设计用意，不评论。</p>\n<p>上述的几种处理都还是在正常播放流程内，接下来是对播放已完成情况的处理。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">if</span> (!is-&gt;paused &amp;&amp;<br>    (!is-&gt;audio_st || (is-&gt;auddec.finished == is-&gt;audioq.serial &amp;&amp; frame_queue_nb_remaining(&amp;is-&gt;sampq) == <span class=\"hljs-number\">0</span>)) &amp;&amp;<br>    (!is-&gt;video_st || (is-&gt;viddec.finished == is-&gt;videoq.serial &amp;&amp; frame_queue_nb_remaining(&amp;is-&gt;pictq) == <span class=\"hljs-number\">0</span>))) &#123;<br>    <span class=\"hljs-keyword\">if</span> (loop != <span class=\"hljs-number\">1</span> &amp;&amp; (!loop || --loop)) &#123;<br>        stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (autoexit) &#123;<br>        ret = AVERROR_EOF;<br>        <span class=\"hljs-keyword\">goto</span> fail;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里判断播放已完成的条件依然很“ffplay”，需要满足：</p>\n<ol>\n<li>不在暂停状态</li>\n<li>音频未打开，或者打开了，但是解码已解码完毕，serial等于PacketQueue的serial，并且PacketQueue中没有节点了</li>\n<li>视频未打开，或者打开了，但是解码已解码完毕，serial等于PacketQueue的serial，并且PacketQueue中没有节点了</li>\n</ol>\n<p>在确认已结束的情况下，用户有两个变量可以控制播放器行为：</p>\n<ol>\n<li>loop: 控制播放次数（当前这次也算在内，也就是最小就是1次了），0表示无限次</li>\n<li>autoexit：自动退出，也就是播放完成后自动退出。</li>\n</ol>\n<p>loop条件简化的非常不友好，其意思是：如果loop&#x3D;&#x3D;1，那么已经播了1次了，无需再seek重新播放；如果loop不是1，&#x3D;&#x3D;0，随意，无限次循环；减1后还大于0（–loop），也允许循环。也就是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">allow_loop</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (loop == <span class=\"hljs-number\">1</span>)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">if</span> (loop == <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br><br>    --loop;<br>    <span class=\"hljs-keyword\">if</span> (loop &gt; <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>前面讲了很多读线程主循环内的处理，比如暂停、seek、结束loop处理等，接下来就看看真正读的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">ret = av_read_frame(ic, pkt);<br><span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>    <span class=\"hljs-comment\">//文件读取完了，调用packet_queue_put_nullpacket通知解码线程</span><br>    <span class=\"hljs-keyword\">if</span> ((ret == AVERROR_EOF || avio_feof(ic-&gt;pb)) &amp;&amp; !is-&gt;eof) &#123;<br>        <span class=\"hljs-keyword\">if</span> (is-&gt;video_stream &gt;= <span class=\"hljs-number\">0</span>)<br>            packet_queue_put_nullpacket(&amp;is-&gt;videoq, is-&gt;video_stream);<br>        <span class=\"hljs-keyword\">if</span> (is-&gt;audio_stream &gt;= <span class=\"hljs-number\">0</span>)<br>            packet_queue_put_nullpacket(&amp;is-&gt;audioq, is-&gt;audio_stream);<br>        <span class=\"hljs-keyword\">if</span> (is-&gt;subtitle_stream &gt;= <span class=\"hljs-number\">0</span>)<br>            packet_queue_put_nullpacket(&amp;is-&gt;subtitleq, is-&gt;subtitle_stream);<br>        is-&gt;eof = <span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">//发生错误了，退出主循环</span><br>    <span class=\"hljs-keyword\">if</span> (ic-&gt;pb &amp;&amp; ic-&gt;pb-&gt;error)<br>        <span class=\"hljs-keyword\">break</span>;<br><br>    <span class=\"hljs-comment\">//如果都不是，可能只是要等一等</span><br>    SDL_LockMutex(wait_mutex);<br>    SDL_CondWaitTimeout(is-&gt;continue_read_thread, wait_mutex, <span class=\"hljs-number\">10</span>);<br>    SDL_UnlockMutex(wait_mutex);<br>    <span class=\"hljs-keyword\">continue</span>;<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    is-&gt;eof = <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* check if packet is in play range specified by user, then queue, otherwise discard */</span><br>stream_start_time = ic-&gt;streams[pkt-&gt;stream_index]-&gt;start_time;<br>pkt_ts = pkt-&gt;pts == AV_NOPTS_VALUE ? pkt-&gt;dts : pkt-&gt;pts;<br>pkt_in_play_range = duration == AV_NOPTS_VALUE ||<br>        (pkt_ts - (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : <span class=\"hljs-number\">0</span>)) *<br>        av_q2d(ic-&gt;streams[pkt-&gt;stream_index]-&gt;time_base) -<br>        (<span class=\"hljs-type\">double</span>)(start_time != AV_NOPTS_VALUE ? start_time : <span class=\"hljs-number\">0</span>) / <span class=\"hljs-number\">1000000</span><br>        &lt;= ((<span class=\"hljs-type\">double</span>)duration / <span class=\"hljs-number\">1000000</span>);<br><br><span class=\"hljs-comment\">//如果在时间范围内，那么根据stream_index，放入到视频、音频、会字幕的PacketQueue中</span><br><span class=\"hljs-keyword\">if</span> (pkt-&gt;stream_index == is-&gt;audio_stream &amp;&amp; pkt_in_play_range) &#123;<br>    packet_queue_put(&amp;is-&gt;audioq, pkt);<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pkt-&gt;stream_index == is-&gt;video_stream &amp;&amp; pkt_in_play_range<br>           &amp;&amp; !(is-&gt;video_st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC)) &#123;<br>    packet_queue_put(&amp;is-&gt;videoq, pkt);<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pkt-&gt;stream_index == is-&gt;subtitle_stream &amp;&amp; pkt_in_play_range) &#123;<br>    packet_queue_put(&amp;is-&gt;subtitleq, pkt);<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    av_packet_unref(pkt);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>看起来很长，实际比上述各种特殊流程的处理都直白，主要为：</p>\n<ol>\n<li>av_read_frame读取一个包(AVPacket)</li>\n<li>返回值处理</li>\n<li>pkt_in_play_range计算</li>\n<li>packet_queue_put放入各自队列，或者丢弃</li>\n</ol>\n<p>步骤1、步骤2、步骤4，都比较直接，看注释即可。</p>\n<p>这里看下pkt_in_play_range的计算，我们把以上代码分解下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title function_\">get_stream_start_time</span><span class=\"hljs-params\">(AVFormatContext* ic, <span class=\"hljs-type\">int</span> index)</span> &#123;<br>    <span class=\"hljs-type\">int64_t</span> stream_start_time = ic-&gt;streams[index]-&gt;start_time;<br>    <span class=\"hljs-keyword\">return</span> stream_start_time != AV_NOPTS_VALUE ? stream_start_time : <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title function_\">get_pkt_ts</span><span class=\"hljs-params\">(AVPacket* pkt)</span> &#123;<span class=\"hljs-comment\">//ts: timestamp（时间戳）的缩写</span><br>    <span class=\"hljs-keyword\">return</span> pkt-&gt;pts == AV_NOPTS_VALUE ? pkt-&gt;dts : pkt-&gt;pts;<br>&#125;<br><br><span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">ts_as_second</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> ts，AVFormatContext* ic，<span class=\"hljs-type\">int</span> index)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> ts * av_q2d(ic-&gt;streams[index]-&gt;time_base);<br>&#125; <br><br><span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">get_ic_start_time</span><span class=\"hljs-params\">(AVFormatContext* ic)</span> &#123;<span class=\"hljs-comment\">//ic中的时间单位是us</span><br>    <span class=\"hljs-keyword\">return</span> (start_time != AV_NOPTS_VALUE ? start_time : <span class=\"hljs-number\">0</span>) / <span class=\"hljs-number\">1000000</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>有了这些函数，就可以计算pkt_in_play_range了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">is_pkt_in_play_range</span><span class=\"hljs-params\">(AVFormatContext* ic, AVPacket* pkt)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (duration == AV_NOPTS_VALUE) <span class=\"hljs-comment\">//如果当前流无法计算总时长，按无限时长处理</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br><br>    <span class=\"hljs-comment\">//计算pkt相对stream位置</span><br>    <span class=\"hljs-type\">int64_t</span> stream_ts = get_pkt_ts(pkt) - get_stream_start_time(ic, pkt-&gt;stream_index);<br>    <span class=\"hljs-type\">double</span> stream_ts_s = ts_as_second(stream_ts, ic, pkt-&gt;stream_index);<br><br>    <span class=\"hljs-comment\">//计算pkt相对ic位置</span><br>    <span class=\"hljs-type\">double</span> ic_ts = stream_ts_s - get_ic_start_time(ic);<br><br>    <span class=\"hljs-comment\">//是否在时间范围内</span><br>    <span class=\"hljs-keyword\">return</span> ic_ts &lt;= ((<span class=\"hljs-type\">double</span>)duration / <span class=\"hljs-number\">1000000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>参考： <a href=\"https://zhuanlan.zhihu.com/p/43672062\">ffplay read线程分析</a></p>\n<blockquote>\n<p>ffplay main 函数 做了什么</p>\n</blockquote>\n<ol>\n<li><p>参数验证与解析</p>\n</li>\n<li><p>注册codecs， demux， protocols</p>\n</li>\n<li><p>sdl 初始化，创建窗口</p>\n</li>\n<li><p>调用stream_open打开流</p>\n</li>\n<li><p>调用event_loop进入运行循环</p>\n</li>\n</ol>\n<blockquote>\n<p>stream_open 做了什么</p>\n</blockquote>\n<p>    主要是初始化VideoState *is，填充关键信息</p>\n<ol>\n<li><p>初始化，分配内存<code>is = av_mallocz(sizeof(VideoState));</code></p>\n</li>\n<li><p>调用frame_queue_init给VideoState对应的音频，视频，字幕对应Frame队列初始化分配内存</p>\n</li>\n<li><p>调用packet_queue_init给VideoState对应的音频，视频，字幕对应Packet队列初始化分配内存</p>\n</li>\n<li><p>创建条件变量continue_read_thread， 用于控制是否继续读取或者等待</p>\n</li>\n<li><p>调用init_clock 初始化音频，视频，外部时钟</p>\n</li>\n<li><p>设置同步类型av_sync_type</p>\n</li>\n<li><p>创建并开启read_thread</p>\n</li>\n</ol>\n<h2 id=\"read-thread\"><a href=\"#read-thread\" class=\"headerlink\" title=\"read_thread\"></a>read_thread</h2><p>分为两个阶段：</p>\n<ol>\n<li><p>准备阶段</p>\n</li>\n<li><p>循环读pkt</p>\n</li>\n</ol>\n<p>准备阶段：</p>\n<p>stream_open 对VideoState *is 做了初始化关键参数的填充。read_thread 在这个基础上，打开输入的流，解封装，读取流的信息，找到音频，视频，字幕对应的stream，读取解码参数，创建解码器，开启解码器。分别为音频，视频，字幕开启创建解码线程。</p>\n<p>循环读pkt：</p>\n<p>然后进入循环，从流中读取pkt，根据同步时钟，放入pkt队列或者丢弃。如果读结束，给pkt队列放入空包，用于冲洗解码器。</p>\n<p>循环中还要处理终止暂停恢复事件，seek事件，根据队列的状态（是否有足够的数据）控制等待还是继续读取新的pkt。</p>\n<h3 id=\"准备阶段\"><a href=\"#准备阶段\" class=\"headerlink\" title=\"准备阶段\"></a>准备阶段</h3><p>打开文件，解封装，获取文件信息</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">VideoState *is = arg;<br>AVFormatContext *ic = <span class=\"hljs-literal\">NULL</span>;<br><span class=\"hljs-comment\">//创建AVFormatContext</span><br>ic = avformat_alloc_context();<br><span class=\"hljs-comment\">//interrupt_callback用于ffmpeg内部在执行耗时操作时检查是否有退出请求，并提前中断，避免用户退出请求没有及时响应</span><br>ic-&gt;interrupt_callback.callback = decode_interrupt_cb;<br>ic-&gt;interrupt_callback.opaque = is;<br><span class=\"hljs-comment\">//特定选项处理</span><br><span class=\"hljs-keyword\">if</span> (!av_dict_get(format_opts, <span class=\"hljs-string\">&quot;scan_all_pmts&quot;</span>, <span class=\"hljs-literal\">NULL</span>, AV_DICT_MATCH_CASE)) &#123;<br>    av_dict_set(&amp;format_opts, <span class=\"hljs-string\">&quot;scan_all_pmts&quot;</span>, <span class=\"hljs-string\">&quot;1&quot;</span>, AV_DICT_DONT_OVERWRITE);<br>    scan_all_pmts_set = <span class=\"hljs-number\">1</span>;<br>&#125;<br><span class=\"hljs-comment\">//打开输入的流，读取流的头部信息</span><br>err = avformat_open_input(&amp;ic, is-&gt;filename, is-&gt;iformat, &amp;format_opts);<br><span class=\"hljs-comment\">//保存AVFormatContext</span><br>is-&gt;ic = ic;<br><span class=\"hljs-keyword\">if</span> (find_stream_info) &#123;<br>    <span class=\"hljs-comment\">//如果文件不包含头部信息(如ts)，通过读取一段文件分析后得到流信息</span><br>    err = avformat_find_stream_info(ic, opts);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>判断是否是实时流</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//是否是实时流rtp/rtsp/sdp等</span><br>is-&gt;realtime = is_realtime(ic);<br></code></pre></td></tr></table></figure>\n\n<p>is_realtime 函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">is_realtime</span><span class=\"hljs-params\">(AVFormatContext *s)</span><br>&#123;<br>    <span class=\"hljs-keyword\">if</span>(   !<span class=\"hljs-built_in\">strcmp</span>(s-&gt;iformat-&gt;name, <span class=\"hljs-string\">&quot;rtp&quot;</span>)<br>       || !<span class=\"hljs-built_in\">strcmp</span>(s-&gt;iformat-&gt;name, <span class=\"hljs-string\">&quot;rtsp&quot;</span>)<br>       || !<span class=\"hljs-built_in\">strcmp</span>(s-&gt;iformat-&gt;name, <span class=\"hljs-string\">&quot;sdp&quot;</span>)<br>    )<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br><br>    <span class=\"hljs-keyword\">if</span>(s-&gt;pb &amp;&amp; (   !<span class=\"hljs-built_in\">strncmp</span>(s-&gt;url, <span class=\"hljs-string\">&quot;rtp:&quot;</span>, <span class=\"hljs-number\">4</span>)<br>                 || !<span class=\"hljs-built_in\">strncmp</span>(s-&gt;url, <span class=\"hljs-string\">&quot;udp:&quot;</span>, <span class=\"hljs-number\">4</span>)<br>                )<br>    )<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>选择音频，视频，字幕流。实际操作中，选择的策略很多，一般根据具体需求来定——比如可以是选择最高清的视频流；选择本地语言的音频流；直接选择第一条视频、音频轨道；等等。</p>\n<p>ffplay主要是通过<code>av_find_best_stream</code>来选择：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//如果用户通过wanted_stream_spec指定了流，找到用户选择的流</span><br><span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;<br>    AVStream *st = ic-&gt;streams[i];<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">AVMediaType</span> <span class=\"hljs-title\">type</span> =</span> st-&gt;codecpar-&gt;codec_type;<br>    st-&gt;discard = AVDISCARD_ALL;<br>    <span class=\"hljs-keyword\">if</span> (type &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; wanted_stream_spec[type] &amp;&amp; st_index[type] == <span class=\"hljs-number\">-1</span>)<br>        <span class=\"hljs-keyword\">if</span> (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) &gt; <span class=\"hljs-number\">0</span>)<br>            st_index[type] = i;<br>&#125;<br><span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; AVMEDIA_TYPE_NB; i++) &#123;<br>    <span class=\"hljs-keyword\">if</span> (wanted_stream_spec[i] &amp;&amp; st_index[i] == <span class=\"hljs-number\">-1</span>) &#123;<br>        <span class=\"hljs-comment\">//处理找不到用户选择的流的情况</span><br>        av_log(<span class=\"hljs-literal\">NULL</span>, AV_LOG_ERROR, <span class=\"hljs-string\">&quot;Stream specifier %s does not match any %s stream\\n&quot;</span>, wanted_stream_spec[i], av_get_media_type_string(i));<br>        st_index[i] = INT_MAX;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">//获取video stream</span><br><span class=\"hljs-keyword\">if</span> (!video_disable)<br>    st_index[AVMEDIA_TYPE_VIDEO] =<br>        av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,<br>                            st_index[AVMEDIA_TYPE_VIDEO], <span class=\"hljs-number\">-1</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>);<br><span class=\"hljs-comment\">//获取audio stream，参考视频流选择</span><br><span class=\"hljs-keyword\">if</span> (!audio_disable)<br>    st_index[AVMEDIA_TYPE_AUDIO] =<br>        av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,<br>                            st_index[AVMEDIA_TYPE_AUDIO],<br>                            st_index[AVMEDIA_TYPE_VIDEO],<br>                            <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>);<br><span class=\"hljs-comment\">//获取subtitle stream，优先参考音频流</span><br><span class=\"hljs-keyword\">if</span> (!video_disable &amp;&amp; !subtitle_disable)<br>    st_index[AVMEDIA_TYPE_SUBTITLE] =<br>        av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,<br>                            st_index[AVMEDIA_TYPE_SUBTITLE],<br>                            (st_index[AVMEDIA_TYPE_AUDIO] &gt;= <span class=\"hljs-number\">0</span> ?<br>                             st_index[AVMEDIA_TYPE_AUDIO] :<br>                             st_index[AVMEDIA_TYPE_VIDEO]),<br>                            <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<p>wanted_stream_spec通过main函数传参设定，格式可以有很多种，参考<a href=\"https://www.ffmpeg.org/ffplay.html#Stream-specifiers-1\">官方文档</a></p>\n<p>如果用户没有指定流，或指定部分流，或指定流不存在，则主要由av_find_best_stream发挥作用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">av_find_best_stream</span><span class=\"hljs-params\">(AVFormatContext *ic,</span><br><span class=\"hljs-params\">                        <span class=\"hljs-keyword\">enum</span> AVMediaType type,<span class=\"hljs-comment\">//要选择的流类型</span></span><br><span class=\"hljs-params\">                        <span class=\"hljs-type\">int</span> wanted_stream_nb,<span class=\"hljs-comment\">//目标流索引</span></span><br><span class=\"hljs-params\">                        <span class=\"hljs-type\">int</span> related_stream,<span class=\"hljs-comment\">//参考流索引</span></span><br><span class=\"hljs-params\">                        AVCodec **decoder_ret,</span><br><span class=\"hljs-params\">                        <span class=\"hljs-type\">int</span> flags)</span>;<br></code></pre></td></tr></table></figure>\n\n<p>如果指定了正确的wanted_stream_nb，一般情况都是直接返回该指定流，即用户选择的流。如果指定了参考流，且未指定目标流的情况，会根据参考流去查找所需类型的流，但一般结果，都是返回该类型第一个流。</p>\n<p>已经获取了流信息，下一步就是创建解码器，开启解码线程。 </p>\n<p>主要在<code>stream_component_open</code>方法中实现, 简化代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">stream_component_open</span><span class=\"hljs-params\">(VideoState *is, <span class=\"hljs-type\">int</span> stream_index)</span><br>&#123;<br>    <span class=\"hljs-comment\">//创建解码器上下文</span><br>    avctx = avcodec_alloc_context3(<span class=\"hljs-literal\">NULL</span>);        <br>    <span class=\"hljs-comment\">//填充解码参数</span><br>    ret = avcodec_parameters_to_context(avctx, ic-&gt;streams[stream_index]-&gt;codecpar);<br>    <span class=\"hljs-comment\">//设置解码器的时间基，等于stream的时间基</span><br>    avctx-&gt;pkt_timebase = ic-&gt;streams[stream_index]-&gt;time_base;<br>    <span class=\"hljs-comment\">//找解码器</span><br>    codec = avcodec_find_decoder(avctx-&gt;codec_id);<br>    <span class=\"hljs-keyword\">if</span> (forced_codec_name)<br>        <span class=\"hljs-comment\">//如果用户指定了解码器，使用用户指定的解码器</span><br>        codec = avcodec_find_decoder_by_name(forced_codec_name);<br>    <span class=\"hljs-comment\">//打开解码器</span><br>    <span class=\"hljs-keyword\">if</span> ((ret = avcodec_open2(avctx, codec, &amp;opts)) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">goto</span> fail;<br>    &#125;<br>    <span class=\"hljs-keyword\">switch</span> (avctx-&gt;codec_type) &#123;<br>    <span class=\"hljs-keyword\">case</span> AVMEDIA_TYPE_AUDIO:<br>        <span class=\"hljs-comment\">//打开音频播放器</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = audio_open(is, channel_layout, nb_channels, sample_rate, &amp;is-&gt;audio_tgt)) &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">goto</span> fail;<br>        <span class=\"hljs-comment\">//给is-&gt;auddec初始化</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = decoder_init(&amp;is-&gt;auddec, avctx, &amp;is-&gt;audioq, is-&gt;continue_read_thread)) &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">goto</span> fail;<br>        <span class=\"hljs-comment\">//开启音频解码线程</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = decoder_start(&amp;is-&gt;auddec, audio_thread, <span class=\"hljs-string\">&quot;audio_decoder&quot;</span>, is)) &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">goto</span> out;<br>        <span class=\"hljs-comment\">//暂停音频播放器</span><br>        SDL_PauseAudioDevice(audio_dev, <span class=\"hljs-number\">0</span>);<br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> AVMEDIA_TYPE_VIDEO:<br>        is-&gt;video_stream = stream_index;<br>        is-&gt;video_st = ic-&gt;streams[stream_index];<br>        <span class=\"hljs-comment\">//给is-&gt;viddec初始化</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = decoder_init(&amp;is-&gt;viddec, avctx, &amp;is-&gt;videoq, is-&gt;continue_read_thread)) &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">goto</span> fail;<br>        <span class=\"hljs-comment\">//开启视频解码线程</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = decoder_start(&amp;is-&gt;viddec, video_thread, <span class=\"hljs-string\">&quot;video_decoder&quot;</span>, is)) &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">goto</span> out;<br>        is-&gt;queue_attachments_req = <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> AVMEDIA_TYPE_SUBTITLE:<br>        is-&gt;subtitle_stream = stream_index;<br>        is-&gt;subtitle_st = ic-&gt;streams[stream_index];<br>        <span class=\"hljs-comment\">//初始化字幕解码</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = decoder_init(&amp;is-&gt;subdec, avctx, &amp;is-&gt;subtitleq, is-&gt;continue_read_thread)) &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">goto</span> fail;<br>        <span class=\"hljs-comment\">//开启字幕解码线程</span><br>        <span class=\"hljs-keyword\">if</span> ((ret = decoder_start(&amp;is-&gt;subdec, subtitle_thread, <span class=\"hljs-string\">&quot;subtitle_decoder&quot;</span>, is)) &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">goto</span> out;<br>        <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">//....</span><br>    <span class=\"hljs-keyword\">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>针对音频，需要另外处理音频播放器的初始化，暂停状态。</p>\n<p>对音频，视频，字幕，调用<code>decoder_init</code>初始化Decoder， 调用<code>decoder_start</code>开启对应的解码线程。</p>\n<p>decoder_init</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">static int decoder_init(Decoder *d, AVCodecContext *avctx, PacketQueue *queue, SDL_cond *empty_queue_cond) &#123;<br>    memset(d, <span class=\"hljs-number\">0</span>, sizeof(Decoder));<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">d</span>-&gt;</span>pkt = av_packet_alloc();<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (!d-&gt;</span>pkt)<br>        return AVERROR(ENOMEM);<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">d</span>-&gt;</span>avctx = avctx;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">d</span>-&gt;</span>queue = queue;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">d</span>-&gt;</span>empty_queue_cond = empty_queue_cond;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">d</span>-&gt;</span>start_pts = AV_NOPTS_VALUE;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">d</span>-&gt;</span>pkt_serial = -<span class=\"hljs-number\">1</span>;<br>    return <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>decoder_start</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">decoder_start</span><span class=\"hljs-params\">(Decoder *d, <span class=\"hljs-type\">int</span> (*fn)(<span class=\"hljs-type\">void</span> *), <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *thread_name, <span class=\"hljs-type\">void</span>* arg)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//开启packet queue</span><br>    <span class=\"hljs-built_in\">packet_queue_start</span>(d-&gt;queue);<br>    <span class=\"hljs-comment\">//开启解码线程</span><br>    d-&gt;decoder_tid = <span class=\"hljs-built_in\">SDL_CreateThread</span>(fn, thread_name, arg);<br>    <span class=\"hljs-keyword\">if</span> (!d-&gt;decoder_tid) &#123;<br>        <span class=\"hljs-built_in\">av_log</span>(<span class=\"hljs-literal\">NULL</span>, AV_LOG_ERROR, <span class=\"hljs-string\">&quot;SDL_CreateThread(): %s\\n&quot;</span>, <span class=\"hljs-built_in\">SDL_GetError</span>());<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">AVERROR</span>(ENOMEM);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"主循环读包\"><a href=\"#主循环读包\" class=\"headerlink\" title=\"主循环读包\"></a>主循环读包</h3><p>简化一下如下</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"><span class=\"hljs-keyword\">for</span> (;;) &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (<span class=\"hljs-keyword\">is</span>-&gt;</span>abort_request)<br>            break;<span class=\"hljs-comment\">//处理退出消息</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (<span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">paused</span> != <span class=\"hljs-keyword\">is</span>-&gt;</span>last_paused) &#123;<br>            <span class=\"hljs-comment\">//处理暂停与恢复</span><br>            <span class=\"hljs-comment\">//.......</span><br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (<span class=\"hljs-keyword\">is</span>-&gt;</span>seek_req) &#123;<br>            <span class=\"hljs-comment\">//处理seek操作</span><br>            <span class=\"hljs-function\"><span class=\"hljs-title\">ret</span> = avformat_seek_file(<span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">ic</span>, -1, seek_min, seek_target, seek_max, <span class=\"hljs-keyword\">is</span>-&gt;</span>seek_flags);<br>        &#125;<br>        <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">        控制队列大小</span><br><span class=\"hljs-comment\">        */</span><br>        <span class=\"hljs-keyword\">if</span> (infinite_buffer&lt;<span class=\"hljs-number\">1</span> &amp;&amp;<br>              (<span class=\"hljs-function\"><span class=\"hljs-title\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">audioq</span>.size + <span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">videoq</span>.size + <span class=\"hljs-keyword\">is</span>-&gt;</span>subtitleq.size &gt; MAX_QUEUE_SIZE<br>            || (<span class=\"hljs-function\"><span class=\"hljs-title\">stream_has_enough_packets</span>(<span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">audio_st</span>, <span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">audio_stream</span>, &amp;<span class=\"hljs-keyword\">is</span>-&gt;</span>audioq) &amp;&amp;<br>                <span class=\"hljs-function\"><span class=\"hljs-title\">stream_has_enough_packets</span>(<span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">video_st</span>, <span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">video_stream</span>, &amp;<span class=\"hljs-keyword\">is</span>-&gt;</span>videoq) &amp;&amp;<br>                <span class=\"hljs-function\"><span class=\"hljs-title\">stream_has_enough_packets</span>(<span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">subtitle_st</span>, <span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">subtitle_stream</span>, &amp;<span class=\"hljs-keyword\">is</span>-&gt;</span>subtitleq)))) &#123;<br>            <span class=\"hljs-comment\">/* wait 10 ms */</span><br>            SDL_LockMutex(wait_mutex);<br>            SDL_C<span class=\"hljs-function\"><span class=\"hljs-title\">ondWaitTimeout</span>(<span class=\"hljs-keyword\">is</span>-&gt;</span>continue_read_thread, wait_mutex, <span class=\"hljs-number\">10</span>);<br>            SDL_UnlockMutex(wait_mutex);<br>            continue;<br>        &#125;<br>        <span class=\"hljs-comment\">//处理循环播放</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (!<span class=\"hljs-keyword\">is</span>-&gt;</span>paused &amp;&amp;<br>            (!<span class=\"hljs-function\"><span class=\"hljs-title\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">audio_st</span> || (<span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">auddec</span>.finished == <span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">audioq</span>.serial &amp;&amp; frame_queue_nb_remaining(&amp;<span class=\"hljs-keyword\">is</span>-&gt;</span>sampq) == <span class=\"hljs-number\">0</span>)) &amp;&amp;<br>            (!<span class=\"hljs-function\"><span class=\"hljs-title\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">video_st</span> || (<span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">viddec</span>.finished == <span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">videoq</span>.serial &amp;&amp; frame_queue_nb_remaining(&amp;<span class=\"hljs-keyword\">is</span>-&gt;</span>pictq) == <span class=\"hljs-number\">0</span>))) &#123;<br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">loop</span> != <span class=\"hljs-number\">1</span> &amp;&amp; (!<span class=\"hljs-keyword\">loop</span> || --<span class=\"hljs-keyword\">loop</span>)) &#123;<br>                stream_seek(<span class=\"hljs-keyword\">is</span>, start_time != AV_NOPTS_VALUE ? start_time : <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (autoexit) &#123;<br>                ret = AVERROR_EOF;<br>                goto fail;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-comment\">//读pkt</span><br>        ret = av_read_frame(ic, pkt);<br><br>        <span class=\"hljs-comment\">//在播放区间，放入队列</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">packet_queue_put</span>(&amp;<span class=\"hljs-keyword\">is</span>-&gt;</span>videoq, pkt);<br>        <span class=\"hljs-comment\">//不在播放区间，丢弃</span><br>        av_packet_unref(pkt);<br><br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>主要的代码就<code>av_read_frame</code>和<code>packet_queue_put</code>，<code>av_read_frame</code>从文件中读取视频数据，并获取一个AVPacket，<code>packet_queue_put</code>把它放入到对应的PacketQueue中。</p>\n<p>当然，读取过程还会有seek、pause、resume、abort等事件，所以有专门的分支处理这些请求。</p>\n<p>PacketQueue默认情况下会有大小限制，达到这个大小后，就需要等待10ms，以让消费者——解码线程能有时间消耗。</p>\n<p>播放完成后，会根据loop的设置决定是否循环。</p>\n<p>暂停&#x2F;恢复的处理：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">if</span> (is-&gt;paused != is-&gt;last_paused) &#123;<br>    <span class=\"hljs-comment\">//更新paused状态</span><br>    is-&gt;last_paused = is-&gt;paused;<br>    <span class=\"hljs-keyword\">if</span> (is-&gt;paused)<br>        <span class=\"hljs-comment\">//暂停</span><br>        is-&gt;read_pause_return = av_read_pause(ic);<br>    <span class=\"hljs-keyword\">else</span><br>        <span class=\"hljs-comment\">//恢复播放</span><br>        av_read_play(ic);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>ffmpeg有专门针对暂停和恢复的函数，所以直接调用就可以了。</p>\n<blockquote>\n<p>av_read_pause和av_read_play对于URLProtocol，会调用其url_read_pause，通过参数区分是要暂停还是恢复。对于AVInputFormat会调用其read_pause和read_play.<br>一般情况下URLProtocol和AVInputFormat都不需要专门处理暂停和恢复，但对于像rtsp&#x2F;rtmp这种在通讯协议上支持(需要)暂停、恢复的就特别有用了。</p>\n</blockquote>\n<p>对于seek的处理，会比暂停&#x2F;恢复略微复杂一些：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">if</span> (is-&gt;seek_req) &#123;<br>    <span class=\"hljs-comment\">//处理seek操作</span><br>    <span class=\"hljs-type\">int64_t</span> seek_target = is-&gt;seek_pos;<br>    <span class=\"hljs-type\">int64_t</span> seek_min    = is-&gt;seek_rel &gt; <span class=\"hljs-number\">0</span> ? seek_target - is-&gt;seek_rel + <span class=\"hljs-number\">2</span>: INT64_MIN;<br>    <span class=\"hljs-type\">int64_t</span> seek_max    = is-&gt;seek_rel &lt; <span class=\"hljs-number\">0</span> ? seek_target - is-&gt;seek_rel - <span class=\"hljs-number\">2</span>: INT64_MAX;<br><span class=\"hljs-comment\">// FIXME the +-2 is due to rounding being not done in the correct direction in generation</span><br><span class=\"hljs-comment\">//      of the seek_pos/seek_rel variables</span><br>    <span class=\"hljs-comment\">//seek到正确的位置</span><br>    ret = avformat_seek_file(is-&gt;ic, <span class=\"hljs-number\">-1</span>, seek_min, seek_target, seek_max, is-&gt;seek_flags);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        av_log(<span class=\"hljs-literal\">NULL</span>, AV_LOG_ERROR,<br>               <span class=\"hljs-string\">&quot;%s: error while seeking\\n&quot;</span>, is-&gt;ic-&gt;url);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (is-&gt;audio_stream &gt;= <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-comment\">//清空音频帧队列</span><br>            packet_queue_flush(&amp;is-&gt;audioq);<br>        <span class=\"hljs-keyword\">if</span> (is-&gt;subtitle_stream &gt;= <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-comment\">//清空字幕帧队列</span><br>            packet_queue_flush(&amp;is-&gt;subtitleq);<br>        <span class=\"hljs-keyword\">if</span> (is-&gt;video_stream &gt;= <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-comment\">//清空视频帧队列</span><br>            packet_queue_flush(&amp;is-&gt;videoq);<br>        <span class=\"hljs-comment\">//更新clock</span><br>        <span class=\"hljs-keyword\">if</span> (is-&gt;seek_flags &amp; AVSEEK_FLAG_BYTE) &#123;<br>           set_clock(&amp;is-&gt;extclk, NAN, <span class=\"hljs-number\">0</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>           set_clock(&amp;is-&gt;extclk, seek_target / (<span class=\"hljs-type\">double</span>)AV_TIME_BASE, <span class=\"hljs-number\">0</span>);<br>        &#125;<br>    &#125;<br>    is-&gt;seek_req = <span class=\"hljs-number\">0</span>;<br>    is-&gt;queue_attachments_req = <span class=\"hljs-number\">1</span>;<br>    is-&gt;eof = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">if</span> (is-&gt;paused)<br>        step_to_next_frame(is);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>主要的seek操作通过avformat_seek_file完成。根据avformat_seek_file的返回值，如果seek成功，需要：</p>\n<ol>\n<li>清除PacketQueue的缓存，并放入一个flush_pkt。放入的flush_pkt可以让PacketQueue的serial增1，以区分seek前后的数据</li>\n<li>同步外部时钟。在后续音视频同步的文章中再具体分析。</li>\n</ol>\n<p>最后清理一些变量，并：</p>\n<ol>\n<li>设置queue_attachments_req以显示attachment画面</li>\n<li>如果当前是暂停状态，就跳到seek后的下一帧，以直观体现seek成功了</li>\n</ol>\n<p>step_to_next_frame</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livescript\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-literal\">void</span> step_to_next_frame(VideoState *<span class=\"hljs-keyword\">is</span>)<br>&#123;<br>    <span class=\"hljs-comment\">/* if the stream is paused unpause it, then step */</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">is</span>-&gt;paused)<br>        stream_toggle_pause(<span class=\"hljs-keyword\">is</span>);<br>    <span class=\"hljs-keyword\">is</span>-&gt;step = <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>原代码的注释比较清晰了——先取消暂停，然后执行step。当设置step为1后，显示线程会显示出一帧画面，然后再次进入暂停：</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\"><span class=\"hljs-comment\">//in video_refresh</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (<span class=\"hljs-keyword\">is</span>-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">step</span> &amp;&amp; !<span class=\"hljs-keyword\">is</span>-&gt;</span>paused)<br>    stream_toggle_pause(<span class=\"hljs-keyword\">is</span>);<br></code></pre></td></tr></table></figure>\n\n<p>这样seek的处理就完成了。</p>\n<p>前面seek、暂停、恢复都可以通过调用ffmpeg的函数，辅助一些流程控制完成封装。</p>\n<p>而读取缓冲区的控制可以说是ffplay原生的特性了。</p>\n<p>是否需要控制缓冲区大小由变量infinite_buffer决定。infinite_buffer为1表示当前buffer无限大，不需要使用缓冲区限制策略。</p>\n<p>infinite_buffer是可选选项，但在文件是实时协议时，且用户未指定时，这个值会被强制为1：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">is_realtime</span><span class=\"hljs-params\">(AVFormatContext *s)</span><br>&#123;<br>    <span class=\"hljs-keyword\">if</span>(   !<span class=\"hljs-built_in\">strcmp</span>(s-&gt;iformat-&gt;name, <span class=\"hljs-string\">&quot;rtp&quot;</span>)<br>       || !<span class=\"hljs-built_in\">strcmp</span>(s-&gt;iformat-&gt;name, <span class=\"hljs-string\">&quot;rtsp&quot;</span>)<br>       || !<span class=\"hljs-built_in\">strcmp</span>(s-&gt;iformat-&gt;name, <span class=\"hljs-string\">&quot;sdp&quot;</span>)<br>    )<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br><br>    <span class=\"hljs-keyword\">if</span>(s-&gt;pb &amp;&amp; (   !<span class=\"hljs-built_in\">strncmp</span>(s-&gt;url, <span class=\"hljs-string\">&quot;rtp:&quot;</span>, <span class=\"hljs-number\">4</span>)<br>                 || !<span class=\"hljs-built_in\">strncmp</span>(s-&gt;url, <span class=\"hljs-string\">&quot;udp:&quot;</span>, <span class=\"hljs-number\">4</span>)<br>                )<br>    )<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br>……<br>is-&gt;realtime = is_realtime(ic);<br>……<br><span class=\"hljs-keyword\">if</span> (infinite_buffer &lt; <span class=\"hljs-number\">0</span> &amp;&amp; is-&gt;realtime)<br>    infinite_buffer = <span class=\"hljs-number\">1</span>;<br></code></pre></td></tr></table></figure>\n\n<p>我们看下需控制缓冲区大小的情况：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">if</span> (infinite_buffer&lt;<span class=\"hljs-number\">1</span> &amp;&amp;<br>    (is-&gt;audioq.size + is-&gt;videoq.size + is-&gt;subtitleq.size &gt; MAX_QUEUE_SIZE<br>    || (stream_has_enough_packets(is-&gt;audio_st, is-&gt;audio_stream, &amp;is-&gt;audioq) &amp;&amp;<br>        stream_has_enough_packets(is-&gt;video_st, is-&gt;video_stream, &amp;is-&gt;videoq) &amp;&amp;<br>        stream_has_enough_packets(is-&gt;subtitle_st, is-&gt;subtitle_stream, &amp;is-&gt;subtitleq)))) &#123;<br>    <span class=\"hljs-comment\">/* wait 10 ms */</span><br>    SDL_LockMutex(wait_mutex);<br>    SDL_CondWaitTimeout(is-&gt;continue_read_thread, wait_mutex, <span class=\"hljs-number\">10</span>);<br>    SDL_UnlockMutex(wait_mutex);<br>    <span class=\"hljs-keyword\">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>缓冲区满有两种可能：</p>\n<ol>\n<li>audioq，videoq，subtitleq三个PacketQueue的总字节数达到了MAX_QUEUE_SIZE（15M）</li>\n<li>音频、视频、字幕流都已有够用的包（stream_has_enough_packets）</li>\n</ol>\n<p>第一种好理解，看下第二种中的stream_has_enough_packets：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">stream_has_enough_packets</span><span class=\"hljs-params\">(AVStream *st, <span class=\"hljs-type\">int</span> stream_id, PacketQueue *<span class=\"hljs-built_in\">queue</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> stream_id &lt; <span class=\"hljs-number\">0</span> ||<br>           <span class=\"hljs-built_in\">queue</span>-&gt;abort_request ||<br>           (st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC) ||<br>           <span class=\"hljs-built_in\">queue</span>-&gt;nb_packets &gt; MIN_FRAMES &amp;&amp; (!<span class=\"hljs-built_in\">queue</span>-&gt;duration || av_q2d(st-&gt;time_base) * <span class=\"hljs-built_in\">queue</span>-&gt;duration &gt; <span class=\"hljs-number\">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在满足PacketQueue总时长为0，或总时长超过1s的前提下：</p>\n<p>有这么几种情况包是够用的：</p>\n<ol>\n<li>流没有打开（stream_id &lt; 0）</li>\n<li>有退出请求（queue-&gt;abort_request）</li>\n<li>配置了AV_DISPOSITION_ATTACHED_PIC？（这个还不理解，后续分析attachement时回头看看）</li>\n<li>队列内包个数大于MIN_FRAMES（&#x3D;25）</li>\n</ol>\n<p>挺饶地，没有深刻体会其设计用意，不评论。</p>\n<p>上述的几种处理都还是在正常播放流程内，接下来是对播放已完成情况的处理。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">if</span> (!is-&gt;paused &amp;&amp;<br>    (!is-&gt;audio_st || (is-&gt;auddec.finished == is-&gt;audioq.serial &amp;&amp; frame_queue_nb_remaining(&amp;is-&gt;sampq) == <span class=\"hljs-number\">0</span>)) &amp;&amp;<br>    (!is-&gt;video_st || (is-&gt;viddec.finished == is-&gt;videoq.serial &amp;&amp; frame_queue_nb_remaining(&amp;is-&gt;pictq) == <span class=\"hljs-number\">0</span>))) &#123;<br>    <span class=\"hljs-keyword\">if</span> (loop != <span class=\"hljs-number\">1</span> &amp;&amp; (!loop || --loop)) &#123;<br>        stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (autoexit) &#123;<br>        ret = AVERROR_EOF;<br>        <span class=\"hljs-keyword\">goto</span> fail;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里判断播放已完成的条件依然很“ffplay”，需要满足：</p>\n<ol>\n<li>不在暂停状态</li>\n<li>音频未打开，或者打开了，但是解码已解码完毕，serial等于PacketQueue的serial，并且PacketQueue中没有节点了</li>\n<li>视频未打开，或者打开了，但是解码已解码完毕，serial等于PacketQueue的serial，并且PacketQueue中没有节点了</li>\n</ol>\n<p>在确认已结束的情况下，用户有两个变量可以控制播放器行为：</p>\n<ol>\n<li>loop: 控制播放次数（当前这次也算在内，也就是最小就是1次了），0表示无限次</li>\n<li>autoexit：自动退出，也就是播放完成后自动退出。</li>\n</ol>\n<p>loop条件简化的非常不友好，其意思是：如果loop&#x3D;&#x3D;1，那么已经播了1次了，无需再seek重新播放；如果loop不是1，&#x3D;&#x3D;0，随意，无限次循环；减1后还大于0（–loop），也允许循环。也就是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">allow_loop</span><span class=\"hljs-params\">()</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (loop == <span class=\"hljs-number\">1</span>)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">if</span> (loop == <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br><br>    --loop;<br>    <span class=\"hljs-keyword\">if</span> (loop &gt; <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>前面讲了很多读线程主循环内的处理，比如暂停、seek、结束loop处理等，接下来就看看真正读的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">ret = av_read_frame(ic, pkt);<br><span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>    <span class=\"hljs-comment\">//文件读取完了，调用packet_queue_put_nullpacket通知解码线程</span><br>    <span class=\"hljs-keyword\">if</span> ((ret == AVERROR_EOF || avio_feof(ic-&gt;pb)) &amp;&amp; !is-&gt;eof) &#123;<br>        <span class=\"hljs-keyword\">if</span> (is-&gt;video_stream &gt;= <span class=\"hljs-number\">0</span>)<br>            packet_queue_put_nullpacket(&amp;is-&gt;videoq, is-&gt;video_stream);<br>        <span class=\"hljs-keyword\">if</span> (is-&gt;audio_stream &gt;= <span class=\"hljs-number\">0</span>)<br>            packet_queue_put_nullpacket(&amp;is-&gt;audioq, is-&gt;audio_stream);<br>        <span class=\"hljs-keyword\">if</span> (is-&gt;subtitle_stream &gt;= <span class=\"hljs-number\">0</span>)<br>            packet_queue_put_nullpacket(&amp;is-&gt;subtitleq, is-&gt;subtitle_stream);<br>        is-&gt;eof = <span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">//发生错误了，退出主循环</span><br>    <span class=\"hljs-keyword\">if</span> (ic-&gt;pb &amp;&amp; ic-&gt;pb-&gt;error)<br>        <span class=\"hljs-keyword\">break</span>;<br><br>    <span class=\"hljs-comment\">//如果都不是，可能只是要等一等</span><br>    SDL_LockMutex(wait_mutex);<br>    SDL_CondWaitTimeout(is-&gt;continue_read_thread, wait_mutex, <span class=\"hljs-number\">10</span>);<br>    SDL_UnlockMutex(wait_mutex);<br>    <span class=\"hljs-keyword\">continue</span>;<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    is-&gt;eof = <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* check if packet is in play range specified by user, then queue, otherwise discard */</span><br>stream_start_time = ic-&gt;streams[pkt-&gt;stream_index]-&gt;start_time;<br>pkt_ts = pkt-&gt;pts == AV_NOPTS_VALUE ? pkt-&gt;dts : pkt-&gt;pts;<br>pkt_in_play_range = duration == AV_NOPTS_VALUE ||<br>        (pkt_ts - (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : <span class=\"hljs-number\">0</span>)) *<br>        av_q2d(ic-&gt;streams[pkt-&gt;stream_index]-&gt;time_base) -<br>        (<span class=\"hljs-type\">double</span>)(start_time != AV_NOPTS_VALUE ? start_time : <span class=\"hljs-number\">0</span>) / <span class=\"hljs-number\">1000000</span><br>        &lt;= ((<span class=\"hljs-type\">double</span>)duration / <span class=\"hljs-number\">1000000</span>);<br><br><span class=\"hljs-comment\">//如果在时间范围内，那么根据stream_index，放入到视频、音频、会字幕的PacketQueue中</span><br><span class=\"hljs-keyword\">if</span> (pkt-&gt;stream_index == is-&gt;audio_stream &amp;&amp; pkt_in_play_range) &#123;<br>    packet_queue_put(&amp;is-&gt;audioq, pkt);<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pkt-&gt;stream_index == is-&gt;video_stream &amp;&amp; pkt_in_play_range<br>           &amp;&amp; !(is-&gt;video_st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC)) &#123;<br>    packet_queue_put(&amp;is-&gt;videoq, pkt);<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pkt-&gt;stream_index == is-&gt;subtitle_stream &amp;&amp; pkt_in_play_range) &#123;<br>    packet_queue_put(&amp;is-&gt;subtitleq, pkt);<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    av_packet_unref(pkt);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>看起来很长，实际比上述各种特殊流程的处理都直白，主要为：</p>\n<ol>\n<li>av_read_frame读取一个包(AVPacket)</li>\n<li>返回值处理</li>\n<li>pkt_in_play_range计算</li>\n<li>packet_queue_put放入各自队列，或者丢弃</li>\n</ol>\n<p>步骤1、步骤2、步骤4，都比较直接，看注释即可。</p>\n<p>这里看下pkt_in_play_range的计算，我们把以上代码分解下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title function_\">get_stream_start_time</span><span class=\"hljs-params\">(AVFormatContext* ic, <span class=\"hljs-type\">int</span> index)</span> &#123;<br>    <span class=\"hljs-type\">int64_t</span> stream_start_time = ic-&gt;streams[index]-&gt;start_time;<br>    <span class=\"hljs-keyword\">return</span> stream_start_time != AV_NOPTS_VALUE ? stream_start_time : <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title function_\">get_pkt_ts</span><span class=\"hljs-params\">(AVPacket* pkt)</span> &#123;<span class=\"hljs-comment\">//ts: timestamp（时间戳）的缩写</span><br>    <span class=\"hljs-keyword\">return</span> pkt-&gt;pts == AV_NOPTS_VALUE ? pkt-&gt;dts : pkt-&gt;pts;<br>&#125;<br><br><span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">ts_as_second</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> ts，AVFormatContext* ic，<span class=\"hljs-type\">int</span> index)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> ts * av_q2d(ic-&gt;streams[index]-&gt;time_base);<br>&#125; <br><br><span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">get_ic_start_time</span><span class=\"hljs-params\">(AVFormatContext* ic)</span> &#123;<span class=\"hljs-comment\">//ic中的时间单位是us</span><br>    <span class=\"hljs-keyword\">return</span> (start_time != AV_NOPTS_VALUE ? start_time : <span class=\"hljs-number\">0</span>) / <span class=\"hljs-number\">1000000</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>有了这些函数，就可以计算pkt_in_play_range了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">is_pkt_in_play_range</span><span class=\"hljs-params\">(AVFormatContext* ic, AVPacket* pkt)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (duration == AV_NOPTS_VALUE) <span class=\"hljs-comment\">//如果当前流无法计算总时长，按无限时长处理</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br><br>    <span class=\"hljs-comment\">//计算pkt相对stream位置</span><br>    <span class=\"hljs-type\">int64_t</span> stream_ts = get_pkt_ts(pkt) - get_stream_start_time(ic, pkt-&gt;stream_index);<br>    <span class=\"hljs-type\">double</span> stream_ts_s = ts_as_second(stream_ts, ic, pkt-&gt;stream_index);<br><br>    <span class=\"hljs-comment\">//计算pkt相对ic位置</span><br>    <span class=\"hljs-type\">double</span> ic_ts = stream_ts_s - get_ic_start_time(ic);<br><br>    <span class=\"hljs-comment\">//是否在时间范围内</span><br>    <span class=\"hljs-keyword\">return</span> ic_ts &lt;= ((<span class=\"hljs-type\">double</span>)duration / <span class=\"hljs-number\">1000000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"layout":"post","title":"ffplay video_thread 分析","date":"2022-03-21T16:00:00.000Z","_content":"\n去除滤镜相关，简化为\n\n```\nstatic int video_thread(void *arg)\n{\n    for (;;) {\n        //获取解码后的frame\n        ret = get_video_frame(is, frame);\n        if (ret < 0) //收到了退出请求，结束循环\n            goto the_end;\n        if (!ret)\n            continue;\n        //根据帧率，计算frame的播放持续时间\n        duration = (frame_rate.num && frame_rate.den ? av_q2d((AVRational){frame_rate.den, frame_rate.num}) : 0);\n        //根据视频流时间基计算pts\n        pts = (frame->pts == AV_NOPTS_VALUE) ? NAN : frame->pts * av_q2d(tb);\n        //放入frame队列\n        ret = queue_picture(is, frame, pts, duration, frame->pkt_pos, is->viddec.pkt_serial);\n        //取消引用frame\n        av_frame_unref(frame);\n     }\n}\n```\n\n整体就是一个循环，调用get_video_frame 获取解码后frame， 调用queue_picture 将frame放入解码后的队列。\n\n## get_video_frame\n\n```c\nstatic int get_video_frame(VideoState *is, AVFrame *frame)\n{\n    int got_picture;\n    //解码，将解码后的数据放入frame中\n    if ((got_picture = decoder_decode_frame(&is->viddec, frame, NULL)) < 0)\n        return -1;//处理abort\n\n    if (got_picture) {\n        double dpts = NAN;\n\n        if (frame->pts != AV_NOPTS_VALUE)\n            dpts = av_q2d(is->video_st->time_base) * frame->pts;\n\n        frame->sample_aspect_ratio = av_guess_sample_aspect_ratio(is->ic, is->video_st, frame);\n        //处理丢帧\n        if (framedrop>0 || (framedrop && get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) {\n            if (frame->pts != AV_NOPTS_VALUE) {\n                double diff = dpts - get_master_clock(is);\n                if (!isnan(diff) && fabs(diff) < AV_NOSYNC_THRESHOLD &&\n                    diff - is->frame_last_filter_delay < 0 &&\n                    is->viddec.pkt_serial == is->vidclk.serial &&\n                    is->videoq.nb_packets) {\n                    is->frame_drops_early++;\n                    av_frame_unref(frame);\n                    got_picture = 0;\n                }\n            }\n        }\n    }\n    return got_picture;\n}\n```\n\nget_video_frame 调用decoder_decode_frame 获取解码后的一帧数据。\n\n获取frame后，判断是否需要处理丢帧，做丢帧处理。\n\n返回值: 成功获取frame(>0)， 被丢帧（=0），收到了退出请求（-1）\n\n## decoder_decode_frame\n\n需要先关注一个结构体Decoder\n\n```\ntypedef struct Decoder {\n    //解码前数据\n    AVPacket *pkt;\n    //pkt队列\n    PacketQueue *queue;\n    //解码器上下文\n    AVCodecContext *avctx;\n    int pkt_serial;\n    int finished;\n    int packet_pending; //标记当前pkt未被成功消费，后续需要重新处理\n    SDL_cond *empty_queue_cond; //绑定read_thread线程的continue_read_thread\n    int64_t start_pts;\n    AVRational start_pts_tb;\n    int64_t next_pts;\n    AVRational next_pts_tb;\n    SDL_Thread *decoder_tid;\n} Decoder;\n```\n\n在VideoState 结构体中,保存了音频，视频，字幕解码相关的Decoder实例。\n\n```\nDecoder auddec;\nDecoder viddec;\nDecoder subdec;\n```\n\ndecoder_decode_frame 根据 Decoder， 实现音频，视频，字幕解码的主要逻辑。\n\n```\nstatic int decoder_decode_frame(Decoder *d, AVFrame *frame, AVSubtitle *sub) {\n    int ret = AVERROR(EAGAIN);\n    for (;;) {\n       //.....\n    }    \n}\n```\n\n整体又是一个大循环， 我们把它拆开看\n\n```c\nif (d->queue->serial == d->pkt_serial) {\n    //判断packetqueue的序列号等于Decoder的序列号\n    //packetqueue的序列号，在发生seek操作后，会+1\n    do {\n        if (d->queue->abort_request)\n            //如果收到了退出请求，返回-1\n            return -1;\n\n        switch (d->avctx->codec_type) {\n            case AVMEDIA_TYPE_VIDEO:\n                //从解码器读frame\n                ret = avcodec_receive_frame(d->avctx, frame);\n                if (ret >= 0) {\n                    //读到了frame, 设置frame的pts\n                    //decoder_reorder_pts: let decoder reorder pts 0=off 1=on -1=auto\n                    if (decoder_reorder_pts == -1) {\n                        frame->pts = frame->best_effort_timestamp;\n                    } else if (!decoder_reorder_pts) {\n                        frame->pts = frame->pkt_dts;\n                    }\n                }\n                break;\n            case AVMEDIA_TYPE_AUDIO:\n                //从解码器读frame\n                ret = avcodec_receive_frame(d->avctx, frame);\n                if (ret >= 0) {\n                    //读到了frame，设置frame的pts\n                    AVRational tb = (AVRational){1, frame->sample_rate};\n                    if (frame->pts != AV_NOPTS_VALUE)\n                        //pts转换，从编码器的时间基，转换为tb作为时间基\n                        frame->pts = av_rescale_q(frame->pts, d->avctx->pkt_timebase, tb);\n                    else if (d->next_pts != AV_NOPTS_VALUE)\n                        //frame的pts没有值，参考d->next_pts，并做时间基的转化\n                        frame->pts = av_rescale_q(d->next_pts, d->next_pts_tb, tb);\n                    if (frame->pts != AV_NOPTS_VALUE) {\n                        //计算next_pts，会被没有pts的Frame参考\n                        //保存next_pts_tb\n                        d->next_pts = frame->pts + frame->nb_samples;\n                        d->next_pts_tb = tb;\n                    }\n                }\n                break;\n        }\n        if (ret == AVERROR_EOF) {\n            //解码器结束，所有的帧已经被读出\n            d->finished = d->pkt_serial;\n            //重置解码器内部状态\n            avcodec_flush_buffers(d->avctx);\n            return 0;\n        }\n        if (ret >= 0)\n            return 1;\n    } while (ret != AVERROR(EAGAIN)); //需要送入更多的pkts\n}\n```\n\n一个if条件，内嵌一个do.while循环。\n\n首先 if 判断`d->queue->serial == d->pkt_serial`，保证当前要处理的pkt与pkt->queue的序列号一致。如果不一致，证明是该pkt和pkt->queue中元素，是两段不连续的数据，进入后续流程，做丢帧处理。\n\n如果序列号一致，进入循环，尝试从解码器获取frame。\n\n我们看下这个循环\n\n1. 判断是否收到退出请求\n\n2. switch判断解码器的类型，处理audio 和 video 的情况。 调用avcodec_receive_frame 尝试从解码器获取frame。 返回值>=0 代表获取成功，转换frame的pts\n\n3. 处理avcodec_receive_frame的返回值。\n   \n   - ret = AVERROR_EOF 解码器所有的帧已被读出，解码结束，返回0.\n   \n   - ret >= 0,  成功获取了frame， 直接返回 1\n   \n   - ret = AVERROR(EAGAIN)， 解码器需要接受更多pkt才可以输出frame，跳出do.while循环。\n\n上一阶段尝试从解码器中读取frame， 但是解码器报告AVERROR(EAGAIN)，需要更多的pkt 才能产出frame。 那么下一阶段处理获取pkt，给解码发送pkt。\n\n```c\ndo {\n    if (d->queue->nb_packets == 0)\n        //pkt队列为空，通知read_thread去获取更多数据\n        SDL_CondSignal(d->empty_queue_cond);\n    if (d->packet_pending) {\n        d->packet_pending = 0;\n    } else {\n        int old_serial = d->pkt_serial;\n        if (packet_queue_get(d->queue, d->pkt, 1, &d->pkt_serial) < 0)\n            return -1;\n        //如果新的pkt的序列号，和之前的不一致。可能是发生了seek操作，两段数据不连续了\n        //冲洗解码器\n        if (old_serial != d->pkt_serial) {\n            //冲洗解码器内部的buffer\n            avcodec_flush_buffers(d->avctx);\n            d->finished = 0;\n            //更新pts， timebase\n            d->next_pts = d->start_pts;\n            d->next_pts_tb = d->start_pts_tb;\n        }\n    }\n    //判断序列号是否满足\n    if (d->queue->serial == d->pkt_serial)\n        break;\n    //过滤掉序列号不满足条件的pkt\n    av_packet_unref(d->pkt);\n} while (1);\n```\n\n又是一个do.while 循环。\n\n1. 如果pkt-queue为空，调用SDL_CondSignal，通知read_thread去获取更多的pkt\n\n2. 如果d->packet_pending为true,  将d->packet_pending标记为false。在下一阶段，将pkt发送给解码器时，如果解码器的pkt队列已满，无法接受d- >pkt。 通过将d->packet_pending设置为1， 标记d- >pkt 为待处理，下次重新将d->pkt发送给解码器。\n\n3. 没有待处理pkt，调用packet_queue_get从d->queue中获取一个pkt。其中 packet_queue_get 的第三个参数block 被设置为1， 在获取ptk的时候，如果没有ptk queue 为空，内部调用SDL_CondWait将线程置于等待状态。\n\n4. 如果从队列里获得了pkt，pkt的序列号和Decoder之前保存的pkt的序列号不一致。例如发生了seek，中间数据不连续了，此时调用avcodec_flush_buffers冲洗解码器内部buffer，让解码器准备好从seek位置开始解码。\n\n5. 循环将pkt序列号不一致的pkt调用av_packet_unref(d->pkt);丢弃，直到`d->queue->serial == d->pkt_serial`,此时获取了一个pkt。\n\n前面解码器要更多的ptk才可以输出frame, 然后第二阶段我们从pkt queue中也获取到了一个pkt，下一步将获取的pkt发送给解码器了\n\n```c\nif (d->avctx->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n    int got_frame = 0;\n    //Return a negative value on error, otherwise return the number of bytes used\n    ret = avcodec_decode_subtitle2(d->avctx, sub, &got_frame, d->pkt);\n    if (ret < 0) {\n        //解码发生了错误，为了和avcodec_send_packet的错误码一起处理，转换为AVERROR(EAGAIN)，尝试继续发送pkt\n        ret = AVERROR(EAGAIN);\n    } else {\n        if (got_frame && !d->pkt->data) {\n            //d->pkt->data = NULL 代表给解码器发送flush消息，\n            //需要持续给解码器flush消息，直到无法继续读取到新的frame, \n            //因此将packet_pending设置为1,标记当前pkt为待处理，直到flush完成\n            d->packet_pending = 1;\n        }\n        ret = got_frame ? 0 : (d->pkt->data ? AVERROR(EAGAIN) : AVERROR_EOF);\n    }\n    av_packet_unref(d->pkt);\n} else {\n    //给音视频解码器发送pkt\n    if (avcodec_send_packet(d->avctx, d->pkt) == AVERROR(EAGAIN)) {\n        //报错AVERROR(EAGAIN)，解码器此时不能接受更多了pkt\n        //需要调用avcodec_receive_frame将解码器中的frame读出才可以继续send pkt\n        av_log(d->avctx, AV_LOG_ERROR, \"Receive_frame and send_packet both returned EAGAIN, which is an API violation.\\n\");\n        //比较当前pkt未被成功消费，后续需要重新处理\n        d->packet_pending = 1;\n    } else {\n        //send pkt 成功，引用计数-1\n        av_packet_unref(d->pkt);\n    }\n}\n```\n\n这里字幕解码器发送pkt 调用的是 avcodec_decode_subtitle2 \n\n给音视频解码器发送pkt 调用的是 avcodec_send_packet。\n\n注意发送pkt返回AVERROR(EAGAIN)， 此时解码器无法接受当前pkt（可能是内部的pkt的队列满了）。通过`d->packet_pending = 1`将pkt标记为待处理，下次循环，重新尝试发送给解码器解码。\n\n\n\n如果解码器成功消费了pkt，继续进入循环。回到读frame的阶段，读到了frame，就返回给上层去加入队列。\n\n\n\n\n\n## 总结\n\n video_thread的工作是循环从pkt queue 取出pkt，送给解码器解码，将解码后的frame 放入frame queue。\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16479425075661647942506708.png)\n\n\n\n\n","source":"_posts/ffmpeg/2022-03-22-ffplay video_thread 分析.md","raw":"---\nlayout: post\ntitle: \"ffplay video_thread 分析\"\ndate: 2022-03-22\ntag: ffmpeg\n\n---\n\n去除滤镜相关，简化为\n\n```\nstatic int video_thread(void *arg)\n{\n    for (;;) {\n        //获取解码后的frame\n        ret = get_video_frame(is, frame);\n        if (ret < 0) //收到了退出请求，结束循环\n            goto the_end;\n        if (!ret)\n            continue;\n        //根据帧率，计算frame的播放持续时间\n        duration = (frame_rate.num && frame_rate.den ? av_q2d((AVRational){frame_rate.den, frame_rate.num}) : 0);\n        //根据视频流时间基计算pts\n        pts = (frame->pts == AV_NOPTS_VALUE) ? NAN : frame->pts * av_q2d(tb);\n        //放入frame队列\n        ret = queue_picture(is, frame, pts, duration, frame->pkt_pos, is->viddec.pkt_serial);\n        //取消引用frame\n        av_frame_unref(frame);\n     }\n}\n```\n\n整体就是一个循环，调用get_video_frame 获取解码后frame， 调用queue_picture 将frame放入解码后的队列。\n\n## get_video_frame\n\n```c\nstatic int get_video_frame(VideoState *is, AVFrame *frame)\n{\n    int got_picture;\n    //解码，将解码后的数据放入frame中\n    if ((got_picture = decoder_decode_frame(&is->viddec, frame, NULL)) < 0)\n        return -1;//处理abort\n\n    if (got_picture) {\n        double dpts = NAN;\n\n        if (frame->pts != AV_NOPTS_VALUE)\n            dpts = av_q2d(is->video_st->time_base) * frame->pts;\n\n        frame->sample_aspect_ratio = av_guess_sample_aspect_ratio(is->ic, is->video_st, frame);\n        //处理丢帧\n        if (framedrop>0 || (framedrop && get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) {\n            if (frame->pts != AV_NOPTS_VALUE) {\n                double diff = dpts - get_master_clock(is);\n                if (!isnan(diff) && fabs(diff) < AV_NOSYNC_THRESHOLD &&\n                    diff - is->frame_last_filter_delay < 0 &&\n                    is->viddec.pkt_serial == is->vidclk.serial &&\n                    is->videoq.nb_packets) {\n                    is->frame_drops_early++;\n                    av_frame_unref(frame);\n                    got_picture = 0;\n                }\n            }\n        }\n    }\n    return got_picture;\n}\n```\n\nget_video_frame 调用decoder_decode_frame 获取解码后的一帧数据。\n\n获取frame后，判断是否需要处理丢帧，做丢帧处理。\n\n返回值: 成功获取frame(>0)， 被丢帧（=0），收到了退出请求（-1）\n\n## decoder_decode_frame\n\n需要先关注一个结构体Decoder\n\n```\ntypedef struct Decoder {\n    //解码前数据\n    AVPacket *pkt;\n    //pkt队列\n    PacketQueue *queue;\n    //解码器上下文\n    AVCodecContext *avctx;\n    int pkt_serial;\n    int finished;\n    int packet_pending; //标记当前pkt未被成功消费，后续需要重新处理\n    SDL_cond *empty_queue_cond; //绑定read_thread线程的continue_read_thread\n    int64_t start_pts;\n    AVRational start_pts_tb;\n    int64_t next_pts;\n    AVRational next_pts_tb;\n    SDL_Thread *decoder_tid;\n} Decoder;\n```\n\n在VideoState 结构体中,保存了音频，视频，字幕解码相关的Decoder实例。\n\n```\nDecoder auddec;\nDecoder viddec;\nDecoder subdec;\n```\n\ndecoder_decode_frame 根据 Decoder， 实现音频，视频，字幕解码的主要逻辑。\n\n```\nstatic int decoder_decode_frame(Decoder *d, AVFrame *frame, AVSubtitle *sub) {\n    int ret = AVERROR(EAGAIN);\n    for (;;) {\n       //.....\n    }    \n}\n```\n\n整体又是一个大循环， 我们把它拆开看\n\n```c\nif (d->queue->serial == d->pkt_serial) {\n    //判断packetqueue的序列号等于Decoder的序列号\n    //packetqueue的序列号，在发生seek操作后，会+1\n    do {\n        if (d->queue->abort_request)\n            //如果收到了退出请求，返回-1\n            return -1;\n\n        switch (d->avctx->codec_type) {\n            case AVMEDIA_TYPE_VIDEO:\n                //从解码器读frame\n                ret = avcodec_receive_frame(d->avctx, frame);\n                if (ret >= 0) {\n                    //读到了frame, 设置frame的pts\n                    //decoder_reorder_pts: let decoder reorder pts 0=off 1=on -1=auto\n                    if (decoder_reorder_pts == -1) {\n                        frame->pts = frame->best_effort_timestamp;\n                    } else if (!decoder_reorder_pts) {\n                        frame->pts = frame->pkt_dts;\n                    }\n                }\n                break;\n            case AVMEDIA_TYPE_AUDIO:\n                //从解码器读frame\n                ret = avcodec_receive_frame(d->avctx, frame);\n                if (ret >= 0) {\n                    //读到了frame，设置frame的pts\n                    AVRational tb = (AVRational){1, frame->sample_rate};\n                    if (frame->pts != AV_NOPTS_VALUE)\n                        //pts转换，从编码器的时间基，转换为tb作为时间基\n                        frame->pts = av_rescale_q(frame->pts, d->avctx->pkt_timebase, tb);\n                    else if (d->next_pts != AV_NOPTS_VALUE)\n                        //frame的pts没有值，参考d->next_pts，并做时间基的转化\n                        frame->pts = av_rescale_q(d->next_pts, d->next_pts_tb, tb);\n                    if (frame->pts != AV_NOPTS_VALUE) {\n                        //计算next_pts，会被没有pts的Frame参考\n                        //保存next_pts_tb\n                        d->next_pts = frame->pts + frame->nb_samples;\n                        d->next_pts_tb = tb;\n                    }\n                }\n                break;\n        }\n        if (ret == AVERROR_EOF) {\n            //解码器结束，所有的帧已经被读出\n            d->finished = d->pkt_serial;\n            //重置解码器内部状态\n            avcodec_flush_buffers(d->avctx);\n            return 0;\n        }\n        if (ret >= 0)\n            return 1;\n    } while (ret != AVERROR(EAGAIN)); //需要送入更多的pkts\n}\n```\n\n一个if条件，内嵌一个do.while循环。\n\n首先 if 判断`d->queue->serial == d->pkt_serial`，保证当前要处理的pkt与pkt->queue的序列号一致。如果不一致，证明是该pkt和pkt->queue中元素，是两段不连续的数据，进入后续流程，做丢帧处理。\n\n如果序列号一致，进入循环，尝试从解码器获取frame。\n\n我们看下这个循环\n\n1. 判断是否收到退出请求\n\n2. switch判断解码器的类型，处理audio 和 video 的情况。 调用avcodec_receive_frame 尝试从解码器获取frame。 返回值>=0 代表获取成功，转换frame的pts\n\n3. 处理avcodec_receive_frame的返回值。\n   \n   - ret = AVERROR_EOF 解码器所有的帧已被读出，解码结束，返回0.\n   \n   - ret >= 0,  成功获取了frame， 直接返回 1\n   \n   - ret = AVERROR(EAGAIN)， 解码器需要接受更多pkt才可以输出frame，跳出do.while循环。\n\n上一阶段尝试从解码器中读取frame， 但是解码器报告AVERROR(EAGAIN)，需要更多的pkt 才能产出frame。 那么下一阶段处理获取pkt，给解码发送pkt。\n\n```c\ndo {\n    if (d->queue->nb_packets == 0)\n        //pkt队列为空，通知read_thread去获取更多数据\n        SDL_CondSignal(d->empty_queue_cond);\n    if (d->packet_pending) {\n        d->packet_pending = 0;\n    } else {\n        int old_serial = d->pkt_serial;\n        if (packet_queue_get(d->queue, d->pkt, 1, &d->pkt_serial) < 0)\n            return -1;\n        //如果新的pkt的序列号，和之前的不一致。可能是发生了seek操作，两段数据不连续了\n        //冲洗解码器\n        if (old_serial != d->pkt_serial) {\n            //冲洗解码器内部的buffer\n            avcodec_flush_buffers(d->avctx);\n            d->finished = 0;\n            //更新pts， timebase\n            d->next_pts = d->start_pts;\n            d->next_pts_tb = d->start_pts_tb;\n        }\n    }\n    //判断序列号是否满足\n    if (d->queue->serial == d->pkt_serial)\n        break;\n    //过滤掉序列号不满足条件的pkt\n    av_packet_unref(d->pkt);\n} while (1);\n```\n\n又是一个do.while 循环。\n\n1. 如果pkt-queue为空，调用SDL_CondSignal，通知read_thread去获取更多的pkt\n\n2. 如果d->packet_pending为true,  将d->packet_pending标记为false。在下一阶段，将pkt发送给解码器时，如果解码器的pkt队列已满，无法接受d- >pkt。 通过将d->packet_pending设置为1， 标记d- >pkt 为待处理，下次重新将d->pkt发送给解码器。\n\n3. 没有待处理pkt，调用packet_queue_get从d->queue中获取一个pkt。其中 packet_queue_get 的第三个参数block 被设置为1， 在获取ptk的时候，如果没有ptk queue 为空，内部调用SDL_CondWait将线程置于等待状态。\n\n4. 如果从队列里获得了pkt，pkt的序列号和Decoder之前保存的pkt的序列号不一致。例如发生了seek，中间数据不连续了，此时调用avcodec_flush_buffers冲洗解码器内部buffer，让解码器准备好从seek位置开始解码。\n\n5. 循环将pkt序列号不一致的pkt调用av_packet_unref(d->pkt);丢弃，直到`d->queue->serial == d->pkt_serial`,此时获取了一个pkt。\n\n前面解码器要更多的ptk才可以输出frame, 然后第二阶段我们从pkt queue中也获取到了一个pkt，下一步将获取的pkt发送给解码器了\n\n```c\nif (d->avctx->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n    int got_frame = 0;\n    //Return a negative value on error, otherwise return the number of bytes used\n    ret = avcodec_decode_subtitle2(d->avctx, sub, &got_frame, d->pkt);\n    if (ret < 0) {\n        //解码发生了错误，为了和avcodec_send_packet的错误码一起处理，转换为AVERROR(EAGAIN)，尝试继续发送pkt\n        ret = AVERROR(EAGAIN);\n    } else {\n        if (got_frame && !d->pkt->data) {\n            //d->pkt->data = NULL 代表给解码器发送flush消息，\n            //需要持续给解码器flush消息，直到无法继续读取到新的frame, \n            //因此将packet_pending设置为1,标记当前pkt为待处理，直到flush完成\n            d->packet_pending = 1;\n        }\n        ret = got_frame ? 0 : (d->pkt->data ? AVERROR(EAGAIN) : AVERROR_EOF);\n    }\n    av_packet_unref(d->pkt);\n} else {\n    //给音视频解码器发送pkt\n    if (avcodec_send_packet(d->avctx, d->pkt) == AVERROR(EAGAIN)) {\n        //报错AVERROR(EAGAIN)，解码器此时不能接受更多了pkt\n        //需要调用avcodec_receive_frame将解码器中的frame读出才可以继续send pkt\n        av_log(d->avctx, AV_LOG_ERROR, \"Receive_frame and send_packet both returned EAGAIN, which is an API violation.\\n\");\n        //比较当前pkt未被成功消费，后续需要重新处理\n        d->packet_pending = 1;\n    } else {\n        //send pkt 成功，引用计数-1\n        av_packet_unref(d->pkt);\n    }\n}\n```\n\n这里字幕解码器发送pkt 调用的是 avcodec_decode_subtitle2 \n\n给音视频解码器发送pkt 调用的是 avcodec_send_packet。\n\n注意发送pkt返回AVERROR(EAGAIN)， 此时解码器无法接受当前pkt（可能是内部的pkt的队列满了）。通过`d->packet_pending = 1`将pkt标记为待处理，下次循环，重新尝试发送给解码器解码。\n\n\n\n如果解码器成功消费了pkt，继续进入循环。回到读frame的阶段，读到了frame，就返回给上层去加入队列。\n\n\n\n\n\n## 总结\n\n video_thread的工作是循环从pkt queue 取出pkt，送给解码器解码，将解码后的frame 放入frame queue。\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16479425075661647942506708.png)\n\n\n\n\n","slug":"ffmpeg/2022-03-22-ffplay video_thread 分析","published":1,"updated":"2024-03-06T11:53:13.566Z","comments":1,"photos":[],"_id":"cltgopene0025qywhfs0dc1rd","content":"<p>去除滤镜相关，简化为</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">static int video_thread(void *arg)<br>&#123;<br>    <span class=\"hljs-keyword\">for</span> (;;) &#123;<br>        <span class=\"hljs-comment\">//获取解码后的frame</span><br>        ret = get_video_frame(<span class=\"hljs-keyword\">is</span>, frame);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//收到了退出请求，结束循环</span><br>            goto the_end;<br>        <span class=\"hljs-keyword\">if</span> (!ret)<br>            continue;<br>        <span class=\"hljs-comment\">//根据帧率，计算frame的播放持续时间</span><br>        duration = (frame_rate.num &amp;&amp; frame_rate.den ? av_q2d((AVRational)&#123;frame_rate.den, frame_rate.num&#125;) : <span class=\"hljs-number\">0</span>);<br>        <span class=\"hljs-comment\">//根据视频流时间基计算pts</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">pts</span> = (frame-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">pts</span> == AV_NOPTS_VALUE) ? NAN : frame-&gt;</span>pts * av_q2d(tb);<br>        <span class=\"hljs-comment\">//放入frame队列</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">ret</span> = queue_picture(<span class=\"hljs-keyword\">is</span>, frame, pts, duration, frame-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">pkt_pos</span>, <span class=\"hljs-keyword\">is</span>-&gt;</span>viddec.pkt_serial);<br>        <span class=\"hljs-comment\">//取消引用frame</span><br>        av_frame_unref(frame);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>整体就是一个循环，调用get_video_frame 获取解码后frame， 调用queue_picture 将frame放入解码后的队列。</p>\n<h2 id=\"get-video-frame\"><a href=\"#get-video-frame\" class=\"headerlink\" title=\"get_video_frame\"></a>get_video_frame</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">get_video_frame</span><span class=\"hljs-params\">(VideoState *is, AVFrame *frame)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> got_picture;<br>    <span class=\"hljs-comment\">//解码，将解码后的数据放入frame中</span><br>    <span class=\"hljs-keyword\">if</span> ((got_picture = decoder_decode_frame(&amp;is-&gt;viddec, frame, <span class=\"hljs-literal\">NULL</span>)) &lt; <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<span class=\"hljs-comment\">//处理abort</span><br><br>    <span class=\"hljs-keyword\">if</span> (got_picture) &#123;<br>        <span class=\"hljs-type\">double</span> dpts = NAN;<br><br>        <span class=\"hljs-keyword\">if</span> (frame-&gt;pts != AV_NOPTS_VALUE)<br>            dpts = av_q2d(is-&gt;video_st-&gt;time_base) * frame-&gt;pts;<br><br>        frame-&gt;sample_aspect_ratio = av_guess_sample_aspect_ratio(is-&gt;ic, is-&gt;video_st, frame);<br>        <span class=\"hljs-comment\">//处理丢帧</span><br>        <span class=\"hljs-keyword\">if</span> (framedrop&gt;<span class=\"hljs-number\">0</span> || (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &#123;<br>            <span class=\"hljs-keyword\">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;<br>                <span class=\"hljs-type\">double</span> diff = dpts - get_master_clock(is);<br>                <span class=\"hljs-keyword\">if</span> (!isnan(diff) &amp;&amp; <span class=\"hljs-built_in\">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD &amp;&amp;<br>                    diff - is-&gt;frame_last_filter_delay &lt; <span class=\"hljs-number\">0</span> &amp;&amp;<br>                    is-&gt;viddec.pkt_serial == is-&gt;vidclk.serial &amp;&amp;<br>                    is-&gt;videoq.nb_packets) &#123;<br>                    is-&gt;frame_drops_early++;<br>                    av_frame_unref(frame);<br>                    got_picture = <span class=\"hljs-number\">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> got_picture;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>get_video_frame 调用decoder_decode_frame 获取解码后的一帧数据。</p>\n<p>获取frame后，判断是否需要处理丢帧，做丢帧处理。</p>\n<p>返回值: 成功获取frame(&gt;0)， 被丢帧（&#x3D;0），收到了退出请求（-1）</p>\n<h2 id=\"decoder-decode-frame\"><a href=\"#decoder-decode-frame\" class=\"headerlink\" title=\"decoder_decode_frame\"></a>decoder_decode_frame</h2><p>需要先关注一个结构体Decoder</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> Decoder &#123;<br>    <span class=\"hljs-comment\">//解码前数据</span><br>    <span class=\"hljs-built_in\">AVPacket</span> *pkt;<br>    <span class=\"hljs-comment\">//pkt队列</span><br>    PacketQueue *queue;<br>    <span class=\"hljs-comment\">//解码器上下文</span><br>    <span class=\"hljs-built_in\">AVCodecContext</span> *avctx;<br>    <span class=\"hljs-type\">int</span> pkt_serial;<br>    <span class=\"hljs-type\">int</span> finished;<br>    <span class=\"hljs-type\">int</span> packet_pending; <span class=\"hljs-comment\">//标记当前pkt未被成功消费，后续需要重新处理</span><br>    SDL_cond *empty_queue_cond; <span class=\"hljs-comment\">//绑定read_thread线程的continue_read_thread</span><br>    int64_t start_pts;<br>    <span class=\"hljs-built_in\">AVRational</span> start_pts_tb;<br>    int64_t next_pts;<br>    <span class=\"hljs-built_in\">AVRational</span> next_pts_tb;<br>    SDL_Thread *decoder_tid;<br>&#125; Decoder;<br></code></pre></td></tr></table></figure>\n\n<p>在VideoState 结构体中,保存了音频，视频，字幕解码相关的Decoder实例。</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">Decoder auddec<span class=\"hljs-comment\">;</span><br>Decoder viddec<span class=\"hljs-comment\">;</span><br>Decoder subdec<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>decoder_decode_frame 根据 Decoder， 实现音频，视频，字幕解码的主要逻辑。</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\">static <span class=\"hljs-keyword\">int</span> decoder_decode_frame(Decoder *d, AVFrame *frame, AVSubtitle *<span class=\"hljs-function\"><span class=\"hljs-keyword\">sub</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> ret = AVERROR(EAGAIN);<br>    <span class=\"hljs-keyword\">for</span> (;;) &#123;<br>       <span class=\"hljs-regexp\">//</span>.....<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>整体又是一个大循环， 我们把它拆开看</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">if</span> (d-&gt;<span class=\"hljs-built_in\">queue</span>-&gt;serial == d-&gt;pkt_serial) &#123;<br>    <span class=\"hljs-comment\">//判断packetqueue的序列号等于Decoder的序列号</span><br>    <span class=\"hljs-comment\">//packetqueue的序列号，在发生seek操作后，会+1</span><br>    <span class=\"hljs-keyword\">do</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (d-&gt;<span class=\"hljs-built_in\">queue</span>-&gt;abort_request)<br>            <span class=\"hljs-comment\">//如果收到了退出请求，返回-1</span><br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br><br>        <span class=\"hljs-keyword\">switch</span> (d-&gt;avctx-&gt;codec_type) &#123;<br>            <span class=\"hljs-keyword\">case</span> AVMEDIA_TYPE_VIDEO:<br>                <span class=\"hljs-comment\">//从解码器读frame</span><br>                ret = avcodec_receive_frame(d-&gt;avctx, frame);<br>                <span class=\"hljs-keyword\">if</span> (ret &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>                    <span class=\"hljs-comment\">//读到了frame, 设置frame的pts</span><br>                    <span class=\"hljs-comment\">//decoder_reorder_pts: let decoder reorder pts 0=off 1=on -1=auto</span><br>                    <span class=\"hljs-keyword\">if</span> (decoder_reorder_pts == <span class=\"hljs-number\">-1</span>) &#123;<br>                        frame-&gt;pts = frame-&gt;best_effort_timestamp;<br>                    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!decoder_reorder_pts) &#123;<br>                        frame-&gt;pts = frame-&gt;pkt_dts;<br>                    &#125;<br>                &#125;<br>                <span class=\"hljs-keyword\">break</span>;<br>            <span class=\"hljs-keyword\">case</span> AVMEDIA_TYPE_AUDIO:<br>                <span class=\"hljs-comment\">//从解码器读frame</span><br>                ret = avcodec_receive_frame(d-&gt;avctx, frame);<br>                <span class=\"hljs-keyword\">if</span> (ret &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>                    <span class=\"hljs-comment\">//读到了frame，设置frame的pts</span><br>                    AVRational tb = (AVRational)&#123;<span class=\"hljs-number\">1</span>, frame-&gt;sample_rate&#125;;<br>                    <span class=\"hljs-keyword\">if</span> (frame-&gt;pts != AV_NOPTS_VALUE)<br>                        <span class=\"hljs-comment\">//pts转换，从编码器的时间基，转换为tb作为时间基</span><br>                        frame-&gt;pts = av_rescale_q(frame-&gt;pts, d-&gt;avctx-&gt;pkt_timebase, tb);<br>                    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (d-&gt;next_pts != AV_NOPTS_VALUE)<br>                        <span class=\"hljs-comment\">//frame的pts没有值，参考d-&gt;next_pts，并做时间基的转化</span><br>                        frame-&gt;pts = av_rescale_q(d-&gt;next_pts, d-&gt;next_pts_tb, tb);<br>                    <span class=\"hljs-keyword\">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;<br>                        <span class=\"hljs-comment\">//计算next_pts，会被没有pts的Frame参考</span><br>                        <span class=\"hljs-comment\">//保存next_pts_tb</span><br>                        d-&gt;next_pts = frame-&gt;pts + frame-&gt;nb_samples;<br>                        d-&gt;next_pts_tb = tb;<br>                    &#125;<br>                &#125;<br>                <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (ret == AVERROR_EOF) &#123;<br>            <span class=\"hljs-comment\">//解码器结束，所有的帧已经被读出</span><br>            d-&gt;finished = d-&gt;pkt_serial;<br>            <span class=\"hljs-comment\">//重置解码器内部状态</span><br>            avcodec_flush_buffers(d-&gt;avctx);<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (ret &gt;= <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    &#125; <span class=\"hljs-keyword\">while</span> (ret != AVERROR(EAGAIN)); <span class=\"hljs-comment\">//需要送入更多的pkts</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>一个if条件，内嵌一个do.while循环。</p>\n<p>首先 if 判断<code>d-&gt;queue-&gt;serial == d-&gt;pkt_serial</code>，保证当前要处理的pkt与pkt-&gt;queue的序列号一致。如果不一致，证明是该pkt和pkt-&gt;queue中元素，是两段不连续的数据，进入后续流程，做丢帧处理。</p>\n<p>如果序列号一致，进入循环，尝试从解码器获取frame。</p>\n<p>我们看下这个循环</p>\n<ol>\n<li><p>判断是否收到退出请求</p>\n</li>\n<li><p>switch判断解码器的类型，处理audio 和 video 的情况。 调用avcodec_receive_frame 尝试从解码器获取frame。 返回值&gt;&#x3D;0 代表获取成功，转换frame的pts</p>\n</li>\n<li><p>处理avcodec_receive_frame的返回值。</p>\n<ul>\n<li><p>ret &#x3D; AVERROR_EOF 解码器所有的帧已被读出，解码结束，返回0.</p>\n</li>\n<li><p>ret &gt;&#x3D; 0,  成功获取了frame， 直接返回 1</p>\n</li>\n<li><p>ret &#x3D; AVERROR(EAGAIN)， 解码器需要接受更多pkt才可以输出frame，跳出do.while循环。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>上一阶段尝试从解码器中读取frame， 但是解码器报告AVERROR(EAGAIN)，需要更多的pkt 才能产出frame。 那么下一阶段处理获取pkt，给解码发送pkt。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">do</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (d-&gt;<span class=\"hljs-built_in\">queue</span>-&gt;nb_packets == <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-comment\">//pkt队列为空，通知read_thread去获取更多数据</span><br>        SDL_CondSignal(d-&gt;empty_queue_cond);<br>    <span class=\"hljs-keyword\">if</span> (d-&gt;packet_pending) &#123;<br>        d-&gt;packet_pending = <span class=\"hljs-number\">0</span>;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-type\">int</span> old_serial = d-&gt;pkt_serial;<br>        <span class=\"hljs-keyword\">if</span> (packet_queue_get(d-&gt;<span class=\"hljs-built_in\">queue</span>, d-&gt;pkt, <span class=\"hljs-number\">1</span>, &amp;d-&gt;pkt_serial) &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-comment\">//如果新的pkt的序列号，和之前的不一致。可能是发生了seek操作，两段数据不连续了</span><br>        <span class=\"hljs-comment\">//冲洗解码器</span><br>        <span class=\"hljs-keyword\">if</span> (old_serial != d-&gt;pkt_serial) &#123;<br>            <span class=\"hljs-comment\">//冲洗解码器内部的buffer</span><br>            avcodec_flush_buffers(d-&gt;avctx);<br>            d-&gt;finished = <span class=\"hljs-number\">0</span>;<br>            <span class=\"hljs-comment\">//更新pts， timebase</span><br>            d-&gt;next_pts = d-&gt;start_pts;<br>            d-&gt;next_pts_tb = d-&gt;start_pts_tb;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">//判断序列号是否满足</span><br>    <span class=\"hljs-keyword\">if</span> (d-&gt;<span class=\"hljs-built_in\">queue</span>-&gt;serial == d-&gt;pkt_serial)<br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-comment\">//过滤掉序列号不满足条件的pkt</span><br>    av_packet_unref(d-&gt;pkt);<br>&#125; <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>);<br></code></pre></td></tr></table></figure>\n\n<p>又是一个do.while 循环。</p>\n<ol>\n<li><p>如果pkt-queue为空，调用SDL_CondSignal，通知read_thread去获取更多的pkt</p>\n</li>\n<li><p>如果d-&gt;packet_pending为true,  将d-&gt;packet_pending标记为false。在下一阶段，将pkt发送给解码器时，如果解码器的pkt队列已满，无法接受d- &gt;pkt。 通过将d-&gt;packet_pending设置为1， 标记d- &gt;pkt 为待处理，下次重新将d-&gt;pkt发送给解码器。</p>\n</li>\n<li><p>没有待处理pkt，调用packet_queue_get从d-&gt;queue中获取一个pkt。其中 packet_queue_get 的第三个参数block 被设置为1， 在获取ptk的时候，如果没有ptk queue 为空，内部调用SDL_CondWait将线程置于等待状态。</p>\n</li>\n<li><p>如果从队列里获得了pkt，pkt的序列号和Decoder之前保存的pkt的序列号不一致。例如发生了seek，中间数据不连续了，此时调用avcodec_flush_buffers冲洗解码器内部buffer，让解码器准备好从seek位置开始解码。</p>\n</li>\n<li><p>循环将pkt序列号不一致的pkt调用av_packet_unref(d-&gt;pkt);丢弃，直到<code>d-&gt;queue-&gt;serial == d-&gt;pkt_serial</code>,此时获取了一个pkt。</p>\n</li>\n</ol>\n<p>前面解码器要更多的ptk才可以输出frame, 然后第二阶段我们从pkt queue中也获取到了一个pkt，下一步将获取的pkt发送给解码器了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">if</span> (d-&gt;avctx-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) &#123;<br>    <span class=\"hljs-type\">int</span> got_frame = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-comment\">//Return a negative value on error, otherwise return the number of bytes used</span><br>    ret = avcodec_decode_subtitle2(d-&gt;avctx, sub, &amp;got_frame, d-&gt;pkt);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-comment\">//解码发生了错误，为了和avcodec_send_packet的错误码一起处理，转换为AVERROR(EAGAIN)，尝试继续发送pkt</span><br>        ret = AVERROR(EAGAIN);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (got_frame &amp;&amp; !d-&gt;pkt-&gt;data) &#123;<br>            <span class=\"hljs-comment\">//d-&gt;pkt-&gt;data = NULL 代表给解码器发送flush消息，</span><br>            <span class=\"hljs-comment\">//需要持续给解码器flush消息，直到无法继续读取到新的frame, </span><br>            <span class=\"hljs-comment\">//因此将packet_pending设置为1,标记当前pkt为待处理，直到flush完成</span><br>            d-&gt;packet_pending = <span class=\"hljs-number\">1</span>;<br>        &#125;<br>        ret = got_frame ? <span class=\"hljs-number\">0</span> : (d-&gt;pkt-&gt;data ? AVERROR(EAGAIN) : AVERROR_EOF);<br>    &#125;<br>    av_packet_unref(d-&gt;pkt);<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-comment\">//给音视频解码器发送pkt</span><br>    <span class=\"hljs-keyword\">if</span> (avcodec_send_packet(d-&gt;avctx, d-&gt;pkt) == AVERROR(EAGAIN)) &#123;<br>        <span class=\"hljs-comment\">//报错AVERROR(EAGAIN)，解码器此时不能接受更多了pkt</span><br>        <span class=\"hljs-comment\">//需要调用avcodec_receive_frame将解码器中的frame读出才可以继续send pkt</span><br>        av_log(d-&gt;avctx, AV_LOG_ERROR, <span class=\"hljs-string\">&quot;Receive_frame and send_packet both returned EAGAIN, which is an API violation.\\n&quot;</span>);<br>        <span class=\"hljs-comment\">//比较当前pkt未被成功消费，后续需要重新处理</span><br>        d-&gt;packet_pending = <span class=\"hljs-number\">1</span>;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-comment\">//send pkt 成功，引用计数-1</span><br>        av_packet_unref(d-&gt;pkt);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里字幕解码器发送pkt 调用的是 avcodec_decode_subtitle2 </p>\n<p>给音视频解码器发送pkt 调用的是 avcodec_send_packet。</p>\n<p>注意发送pkt返回AVERROR(EAGAIN)， 此时解码器无法接受当前pkt（可能是内部的pkt的队列满了）。通过<code>d-&gt;packet_pending = 1</code>将pkt标记为待处理，下次循环，重新尝试发送给解码器解码。</p>\n<p>如果解码器成功消费了pkt，继续进入循环。回到读frame的阶段，读到了frame，就返回给上层去加入队列。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p> video_thread的工作是循环从pkt queue 取出pkt，送给解码器解码，将解码后的frame 放入frame queue。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16479425075661647942506708.png\"></p>\n","excerpt":"","more":"<p>去除滤镜相关，简化为</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xl\">static int video_thread(void *arg)<br>&#123;<br>    <span class=\"hljs-keyword\">for</span> (;;) &#123;<br>        <span class=\"hljs-comment\">//获取解码后的frame</span><br>        ret = get_video_frame(<span class=\"hljs-keyword\">is</span>, frame);<br>        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//收到了退出请求，结束循环</span><br>            goto the_end;<br>        <span class=\"hljs-keyword\">if</span> (!ret)<br>            continue;<br>        <span class=\"hljs-comment\">//根据帧率，计算frame的播放持续时间</span><br>        duration = (frame_rate.num &amp;&amp; frame_rate.den ? av_q2d((AVRational)&#123;frame_rate.den, frame_rate.num&#125;) : <span class=\"hljs-number\">0</span>);<br>        <span class=\"hljs-comment\">//根据视频流时间基计算pts</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">pts</span> = (frame-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">pts</span> == AV_NOPTS_VALUE) ? NAN : frame-&gt;</span>pts * av_q2d(tb);<br>        <span class=\"hljs-comment\">//放入frame队列</span><br>        <span class=\"hljs-function\"><span class=\"hljs-title\">ret</span> = queue_picture(<span class=\"hljs-keyword\">is</span>, frame, pts, duration, frame-&gt;</span><span class=\"hljs-function\"><span class=\"hljs-title\">pkt_pos</span>, <span class=\"hljs-keyword\">is</span>-&gt;</span>viddec.pkt_serial);<br>        <span class=\"hljs-comment\">//取消引用frame</span><br>        av_frame_unref(frame);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>整体就是一个循环，调用get_video_frame 获取解码后frame， 调用queue_picture 将frame放入解码后的队列。</p>\n<h2 id=\"get-video-frame\"><a href=\"#get-video-frame\" class=\"headerlink\" title=\"get_video_frame\"></a>get_video_frame</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">get_video_frame</span><span class=\"hljs-params\">(VideoState *is, AVFrame *frame)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> got_picture;<br>    <span class=\"hljs-comment\">//解码，将解码后的数据放入frame中</span><br>    <span class=\"hljs-keyword\">if</span> ((got_picture = decoder_decode_frame(&amp;is-&gt;viddec, frame, <span class=\"hljs-literal\">NULL</span>)) &lt; <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<span class=\"hljs-comment\">//处理abort</span><br><br>    <span class=\"hljs-keyword\">if</span> (got_picture) &#123;<br>        <span class=\"hljs-type\">double</span> dpts = NAN;<br><br>        <span class=\"hljs-keyword\">if</span> (frame-&gt;pts != AV_NOPTS_VALUE)<br>            dpts = av_q2d(is-&gt;video_st-&gt;time_base) * frame-&gt;pts;<br><br>        frame-&gt;sample_aspect_ratio = av_guess_sample_aspect_ratio(is-&gt;ic, is-&gt;video_st, frame);<br>        <span class=\"hljs-comment\">//处理丢帧</span><br>        <span class=\"hljs-keyword\">if</span> (framedrop&gt;<span class=\"hljs-number\">0</span> || (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &#123;<br>            <span class=\"hljs-keyword\">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;<br>                <span class=\"hljs-type\">double</span> diff = dpts - get_master_clock(is);<br>                <span class=\"hljs-keyword\">if</span> (!isnan(diff) &amp;&amp; <span class=\"hljs-built_in\">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD &amp;&amp;<br>                    diff - is-&gt;frame_last_filter_delay &lt; <span class=\"hljs-number\">0</span> &amp;&amp;<br>                    is-&gt;viddec.pkt_serial == is-&gt;vidclk.serial &amp;&amp;<br>                    is-&gt;videoq.nb_packets) &#123;<br>                    is-&gt;frame_drops_early++;<br>                    av_frame_unref(frame);<br>                    got_picture = <span class=\"hljs-number\">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> got_picture;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>get_video_frame 调用decoder_decode_frame 获取解码后的一帧数据。</p>\n<p>获取frame后，判断是否需要处理丢帧，做丢帧处理。</p>\n<p>返回值: 成功获取frame(&gt;0)， 被丢帧（&#x3D;0），收到了退出请求（-1）</p>\n<h2 id=\"decoder-decode-frame\"><a href=\"#decoder-decode-frame\" class=\"headerlink\" title=\"decoder_decode_frame\"></a>decoder_decode_frame</h2><p>需要先关注一个结构体Decoder</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> Decoder &#123;<br>    <span class=\"hljs-comment\">//解码前数据</span><br>    <span class=\"hljs-built_in\">AVPacket</span> *pkt;<br>    <span class=\"hljs-comment\">//pkt队列</span><br>    PacketQueue *queue;<br>    <span class=\"hljs-comment\">//解码器上下文</span><br>    <span class=\"hljs-built_in\">AVCodecContext</span> *avctx;<br>    <span class=\"hljs-type\">int</span> pkt_serial;<br>    <span class=\"hljs-type\">int</span> finished;<br>    <span class=\"hljs-type\">int</span> packet_pending; <span class=\"hljs-comment\">//标记当前pkt未被成功消费，后续需要重新处理</span><br>    SDL_cond *empty_queue_cond; <span class=\"hljs-comment\">//绑定read_thread线程的continue_read_thread</span><br>    int64_t start_pts;<br>    <span class=\"hljs-built_in\">AVRational</span> start_pts_tb;<br>    int64_t next_pts;<br>    <span class=\"hljs-built_in\">AVRational</span> next_pts_tb;<br>    SDL_Thread *decoder_tid;<br>&#125; Decoder;<br></code></pre></td></tr></table></figure>\n\n<p>在VideoState 结构体中,保存了音频，视频，字幕解码相关的Decoder实例。</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">Decoder auddec<span class=\"hljs-comment\">;</span><br>Decoder viddec<span class=\"hljs-comment\">;</span><br>Decoder subdec<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>decoder_decode_frame 根据 Decoder， 实现音频，视频，字幕解码的主要逻辑。</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\">static <span class=\"hljs-keyword\">int</span> decoder_decode_frame(Decoder *d, AVFrame *frame, AVSubtitle *<span class=\"hljs-function\"><span class=\"hljs-keyword\">sub</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> ret = AVERROR(EAGAIN);<br>    <span class=\"hljs-keyword\">for</span> (;;) &#123;<br>       <span class=\"hljs-regexp\">//</span>.....<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>整体又是一个大循环， 我们把它拆开看</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">if</span> (d-&gt;<span class=\"hljs-built_in\">queue</span>-&gt;serial == d-&gt;pkt_serial) &#123;<br>    <span class=\"hljs-comment\">//判断packetqueue的序列号等于Decoder的序列号</span><br>    <span class=\"hljs-comment\">//packetqueue的序列号，在发生seek操作后，会+1</span><br>    <span class=\"hljs-keyword\">do</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (d-&gt;<span class=\"hljs-built_in\">queue</span>-&gt;abort_request)<br>            <span class=\"hljs-comment\">//如果收到了退出请求，返回-1</span><br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br><br>        <span class=\"hljs-keyword\">switch</span> (d-&gt;avctx-&gt;codec_type) &#123;<br>            <span class=\"hljs-keyword\">case</span> AVMEDIA_TYPE_VIDEO:<br>                <span class=\"hljs-comment\">//从解码器读frame</span><br>                ret = avcodec_receive_frame(d-&gt;avctx, frame);<br>                <span class=\"hljs-keyword\">if</span> (ret &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>                    <span class=\"hljs-comment\">//读到了frame, 设置frame的pts</span><br>                    <span class=\"hljs-comment\">//decoder_reorder_pts: let decoder reorder pts 0=off 1=on -1=auto</span><br>                    <span class=\"hljs-keyword\">if</span> (decoder_reorder_pts == <span class=\"hljs-number\">-1</span>) &#123;<br>                        frame-&gt;pts = frame-&gt;best_effort_timestamp;<br>                    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!decoder_reorder_pts) &#123;<br>                        frame-&gt;pts = frame-&gt;pkt_dts;<br>                    &#125;<br>                &#125;<br>                <span class=\"hljs-keyword\">break</span>;<br>            <span class=\"hljs-keyword\">case</span> AVMEDIA_TYPE_AUDIO:<br>                <span class=\"hljs-comment\">//从解码器读frame</span><br>                ret = avcodec_receive_frame(d-&gt;avctx, frame);<br>                <span class=\"hljs-keyword\">if</span> (ret &gt;= <span class=\"hljs-number\">0</span>) &#123;<br>                    <span class=\"hljs-comment\">//读到了frame，设置frame的pts</span><br>                    AVRational tb = (AVRational)&#123;<span class=\"hljs-number\">1</span>, frame-&gt;sample_rate&#125;;<br>                    <span class=\"hljs-keyword\">if</span> (frame-&gt;pts != AV_NOPTS_VALUE)<br>                        <span class=\"hljs-comment\">//pts转换，从编码器的时间基，转换为tb作为时间基</span><br>                        frame-&gt;pts = av_rescale_q(frame-&gt;pts, d-&gt;avctx-&gt;pkt_timebase, tb);<br>                    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (d-&gt;next_pts != AV_NOPTS_VALUE)<br>                        <span class=\"hljs-comment\">//frame的pts没有值，参考d-&gt;next_pts，并做时间基的转化</span><br>                        frame-&gt;pts = av_rescale_q(d-&gt;next_pts, d-&gt;next_pts_tb, tb);<br>                    <span class=\"hljs-keyword\">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;<br>                        <span class=\"hljs-comment\">//计算next_pts，会被没有pts的Frame参考</span><br>                        <span class=\"hljs-comment\">//保存next_pts_tb</span><br>                        d-&gt;next_pts = frame-&gt;pts + frame-&gt;nb_samples;<br>                        d-&gt;next_pts_tb = tb;<br>                    &#125;<br>                &#125;<br>                <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (ret == AVERROR_EOF) &#123;<br>            <span class=\"hljs-comment\">//解码器结束，所有的帧已经被读出</span><br>            d-&gt;finished = d-&gt;pkt_serial;<br>            <span class=\"hljs-comment\">//重置解码器内部状态</span><br>            avcodec_flush_buffers(d-&gt;avctx);<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (ret &gt;= <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    &#125; <span class=\"hljs-keyword\">while</span> (ret != AVERROR(EAGAIN)); <span class=\"hljs-comment\">//需要送入更多的pkts</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>一个if条件，内嵌一个do.while循环。</p>\n<p>首先 if 判断<code>d-&gt;queue-&gt;serial == d-&gt;pkt_serial</code>，保证当前要处理的pkt与pkt-&gt;queue的序列号一致。如果不一致，证明是该pkt和pkt-&gt;queue中元素，是两段不连续的数据，进入后续流程，做丢帧处理。</p>\n<p>如果序列号一致，进入循环，尝试从解码器获取frame。</p>\n<p>我们看下这个循环</p>\n<ol>\n<li><p>判断是否收到退出请求</p>\n</li>\n<li><p>switch判断解码器的类型，处理audio 和 video 的情况。 调用avcodec_receive_frame 尝试从解码器获取frame。 返回值&gt;&#x3D;0 代表获取成功，转换frame的pts</p>\n</li>\n<li><p>处理avcodec_receive_frame的返回值。</p>\n<ul>\n<li><p>ret &#x3D; AVERROR_EOF 解码器所有的帧已被读出，解码结束，返回0.</p>\n</li>\n<li><p>ret &gt;&#x3D; 0,  成功获取了frame， 直接返回 1</p>\n</li>\n<li><p>ret &#x3D; AVERROR(EAGAIN)， 解码器需要接受更多pkt才可以输出frame，跳出do.while循环。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>上一阶段尝试从解码器中读取frame， 但是解码器报告AVERROR(EAGAIN)，需要更多的pkt 才能产出frame。 那么下一阶段处理获取pkt，给解码发送pkt。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">do</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (d-&gt;<span class=\"hljs-built_in\">queue</span>-&gt;nb_packets == <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-comment\">//pkt队列为空，通知read_thread去获取更多数据</span><br>        SDL_CondSignal(d-&gt;empty_queue_cond);<br>    <span class=\"hljs-keyword\">if</span> (d-&gt;packet_pending) &#123;<br>        d-&gt;packet_pending = <span class=\"hljs-number\">0</span>;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-type\">int</span> old_serial = d-&gt;pkt_serial;<br>        <span class=\"hljs-keyword\">if</span> (packet_queue_get(d-&gt;<span class=\"hljs-built_in\">queue</span>, d-&gt;pkt, <span class=\"hljs-number\">1</span>, &amp;d-&gt;pkt_serial) &lt; <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-comment\">//如果新的pkt的序列号，和之前的不一致。可能是发生了seek操作，两段数据不连续了</span><br>        <span class=\"hljs-comment\">//冲洗解码器</span><br>        <span class=\"hljs-keyword\">if</span> (old_serial != d-&gt;pkt_serial) &#123;<br>            <span class=\"hljs-comment\">//冲洗解码器内部的buffer</span><br>            avcodec_flush_buffers(d-&gt;avctx);<br>            d-&gt;finished = <span class=\"hljs-number\">0</span>;<br>            <span class=\"hljs-comment\">//更新pts， timebase</span><br>            d-&gt;next_pts = d-&gt;start_pts;<br>            d-&gt;next_pts_tb = d-&gt;start_pts_tb;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">//判断序列号是否满足</span><br>    <span class=\"hljs-keyword\">if</span> (d-&gt;<span class=\"hljs-built_in\">queue</span>-&gt;serial == d-&gt;pkt_serial)<br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-comment\">//过滤掉序列号不满足条件的pkt</span><br>    av_packet_unref(d-&gt;pkt);<br>&#125; <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>);<br></code></pre></td></tr></table></figure>\n\n<p>又是一个do.while 循环。</p>\n<ol>\n<li><p>如果pkt-queue为空，调用SDL_CondSignal，通知read_thread去获取更多的pkt</p>\n</li>\n<li><p>如果d-&gt;packet_pending为true,  将d-&gt;packet_pending标记为false。在下一阶段，将pkt发送给解码器时，如果解码器的pkt队列已满，无法接受d- &gt;pkt。 通过将d-&gt;packet_pending设置为1， 标记d- &gt;pkt 为待处理，下次重新将d-&gt;pkt发送给解码器。</p>\n</li>\n<li><p>没有待处理pkt，调用packet_queue_get从d-&gt;queue中获取一个pkt。其中 packet_queue_get 的第三个参数block 被设置为1， 在获取ptk的时候，如果没有ptk queue 为空，内部调用SDL_CondWait将线程置于等待状态。</p>\n</li>\n<li><p>如果从队列里获得了pkt，pkt的序列号和Decoder之前保存的pkt的序列号不一致。例如发生了seek，中间数据不连续了，此时调用avcodec_flush_buffers冲洗解码器内部buffer，让解码器准备好从seek位置开始解码。</p>\n</li>\n<li><p>循环将pkt序列号不一致的pkt调用av_packet_unref(d-&gt;pkt);丢弃，直到<code>d-&gt;queue-&gt;serial == d-&gt;pkt_serial</code>,此时获取了一个pkt。</p>\n</li>\n</ol>\n<p>前面解码器要更多的ptk才可以输出frame, 然后第二阶段我们从pkt queue中也获取到了一个pkt，下一步将获取的pkt发送给解码器了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">if</span> (d-&gt;avctx-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) &#123;<br>    <span class=\"hljs-type\">int</span> got_frame = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-comment\">//Return a negative value on error, otherwise return the number of bytes used</span><br>    ret = avcodec_decode_subtitle2(d-&gt;avctx, sub, &amp;got_frame, d-&gt;pkt);<br>    <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-comment\">//解码发生了错误，为了和avcodec_send_packet的错误码一起处理，转换为AVERROR(EAGAIN)，尝试继续发送pkt</span><br>        ret = AVERROR(EAGAIN);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (got_frame &amp;&amp; !d-&gt;pkt-&gt;data) &#123;<br>            <span class=\"hljs-comment\">//d-&gt;pkt-&gt;data = NULL 代表给解码器发送flush消息，</span><br>            <span class=\"hljs-comment\">//需要持续给解码器flush消息，直到无法继续读取到新的frame, </span><br>            <span class=\"hljs-comment\">//因此将packet_pending设置为1,标记当前pkt为待处理，直到flush完成</span><br>            d-&gt;packet_pending = <span class=\"hljs-number\">1</span>;<br>        &#125;<br>        ret = got_frame ? <span class=\"hljs-number\">0</span> : (d-&gt;pkt-&gt;data ? AVERROR(EAGAIN) : AVERROR_EOF);<br>    &#125;<br>    av_packet_unref(d-&gt;pkt);<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-comment\">//给音视频解码器发送pkt</span><br>    <span class=\"hljs-keyword\">if</span> (avcodec_send_packet(d-&gt;avctx, d-&gt;pkt) == AVERROR(EAGAIN)) &#123;<br>        <span class=\"hljs-comment\">//报错AVERROR(EAGAIN)，解码器此时不能接受更多了pkt</span><br>        <span class=\"hljs-comment\">//需要调用avcodec_receive_frame将解码器中的frame读出才可以继续send pkt</span><br>        av_log(d-&gt;avctx, AV_LOG_ERROR, <span class=\"hljs-string\">&quot;Receive_frame and send_packet both returned EAGAIN, which is an API violation.\\n&quot;</span>);<br>        <span class=\"hljs-comment\">//比较当前pkt未被成功消费，后续需要重新处理</span><br>        d-&gt;packet_pending = <span class=\"hljs-number\">1</span>;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-comment\">//send pkt 成功，引用计数-1</span><br>        av_packet_unref(d-&gt;pkt);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里字幕解码器发送pkt 调用的是 avcodec_decode_subtitle2 </p>\n<p>给音视频解码器发送pkt 调用的是 avcodec_send_packet。</p>\n<p>注意发送pkt返回AVERROR(EAGAIN)， 此时解码器无法接受当前pkt（可能是内部的pkt的队列满了）。通过<code>d-&gt;packet_pending = 1</code>将pkt标记为待处理，下次循环，重新尝试发送给解码器解码。</p>\n<p>如果解码器成功消费了pkt，继续进入循环。回到读frame的阶段，读到了frame，就返回给上层去加入队列。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p> video_thread的工作是循环从pkt queue 取出pkt，送给解码器解码，将解码后的frame 放入frame queue。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16479425075661647942506708.png\"></p>\n"},{"layout":"post","title":"mac上通过 doxygen + graphviz生成函数调用图","date":"2022-03-25T16:00:00.000Z","_content":"\n\n\n安装[Doxygen](https://www.doxygen.nl/index.html)\n\n```\nbrew install doxygen\nbrew install doxygen --cask\n```\n\n安装[Graphviz](https://graphviz.org/)\n\n```\nbrew install graphviz\n```\n\n## 配置doxygen\n\n配置工作目录，源码目录，生成文档目录\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482609835051648260982959.png)\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482610615021648261060637.png)\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482621994932022-03-26-10-18-39-image.png)\n\n配置DOT_PATH\n\n```\n➜  ~ which dot\n/opt/homebrew/bin/dot\n```\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482622484922022-03-26-10-19-09-image.png)\n\n生成文档和函数调用图\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482622864902022-03-26-10-19-27-image.png)\n\n## 查看函数调用图\n\n```\n➜  ff_doc ls\nhtml  latex\n➜  ff_doc cd html\n➜  html open index.html\n```\n\n文档生成目录下，打开`html/index.html`\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482623074922022-03-26-10-26-47-image.png)\n\n可以看到生成的函数调用图\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482623224912022-03-26-10-28-07-image.png)\n","source":"_posts/ffmpeg/2022-03-26-mac上通过 doxygen + graphviz生成函数调用图.md","raw":"---\nlayout: post\ntitle: \"mac上通过 doxygen + graphviz生成函数调用图\"\ndate: 2022-03-26\ntag: ffmpeg\n---\n\n\n\n安装[Doxygen](https://www.doxygen.nl/index.html)\n\n```\nbrew install doxygen\nbrew install doxygen --cask\n```\n\n安装[Graphviz](https://graphviz.org/)\n\n```\nbrew install graphviz\n```\n\n## 配置doxygen\n\n配置工作目录，源码目录，生成文档目录\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482609835051648260982959.png)\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482610615021648261060637.png)\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482621994932022-03-26-10-18-39-image.png)\n\n配置DOT_PATH\n\n```\n➜  ~ which dot\n/opt/homebrew/bin/dot\n```\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482622484922022-03-26-10-19-09-image.png)\n\n生成文档和函数调用图\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482622864902022-03-26-10-19-27-image.png)\n\n## 查看函数调用图\n\n```\n➜  ff_doc ls\nhtml  latex\n➜  ff_doc cd html\n➜  html open index.html\n```\n\n文档生成目录下，打开`html/index.html`\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482623074922022-03-26-10-26-47-image.png)\n\n可以看到生成的函数调用图\n\n![](https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482623224912022-03-26-10-28-07-image.png)\n","slug":"ffmpeg/2022-03-26-mac上通过 doxygen + graphviz生成函数调用图","published":1,"updated":"2024-03-06T11:53:13.566Z","comments":1,"photos":[],"_id":"cltgopene0027qywhe476f7pe","content":"<p>安装<a href=\"https://www.doxygen.nl/index.html\">Doxygen</a></p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">brew </span><span class=\"hljs-keyword\">install </span>doxygen<br><span class=\"hljs-keyword\">brew </span><span class=\"hljs-keyword\">install </span>doxygen --cask<br></code></pre></td></tr></table></figure>\n\n<p>安装<a href=\"https://graphviz.org/\">Graphviz</a></p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">brew </span><span class=\"hljs-keyword\">install </span>graphviz<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"配置doxygen\"><a href=\"#配置doxygen\" class=\"headerlink\" title=\"配置doxygen\"></a>配置doxygen</h2><p>配置工作目录，源码目录，生成文档目录</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482609835051648260982959.png\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482610615021648261060637.png\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482621994932022-03-26-10-18-39-image.png\"></p>\n<p>配置DOT_PATH</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">➜  ~ which dot<br><span class=\"hljs-regexp\">/opt/</span>homebrew<span class=\"hljs-regexp\">/bin/</span>dot<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482622484922022-03-26-10-19-09-image.png\"></p>\n<p>生成文档和函数调用图</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482622864902022-03-26-10-19-27-image.png\"></p>\n<h2 id=\"查看函数调用图\"><a href=\"#查看函数调用图\" class=\"headerlink\" title=\"查看函数调用图\"></a>查看函数调用图</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">➜  ff_doc <span class=\"hljs-keyword\">ls</span><br>html  latex<br>➜  ff_doc <span class=\"hljs-keyword\">cd</span> html<br>➜  html <span class=\"hljs-keyword\">open</span> <span class=\"hljs-built_in\">index</span>.html<br></code></pre></td></tr></table></figure>\n\n<p>文档生成目录下，打开<code>html/index.html</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482623074922022-03-26-10-26-47-image.png\"></p>\n<p>可以看到生成的函数调用图</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482623224912022-03-26-10-28-07-image.png\"></p>\n","excerpt":"","more":"<p>安装<a href=\"https://www.doxygen.nl/index.html\">Doxygen</a></p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">brew </span><span class=\"hljs-keyword\">install </span>doxygen<br><span class=\"hljs-keyword\">brew </span><span class=\"hljs-keyword\">install </span>doxygen --cask<br></code></pre></td></tr></table></figure>\n\n<p>安装<a href=\"https://graphviz.org/\">Graphviz</a></p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">brew </span><span class=\"hljs-keyword\">install </span>graphviz<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"配置doxygen\"><a href=\"#配置doxygen\" class=\"headerlink\" title=\"配置doxygen\"></a>配置doxygen</h2><p>配置工作目录，源码目录，生成文档目录</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482609835051648260982959.png\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482610615021648261060637.png\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482621994932022-03-26-10-18-39-image.png\"></p>\n<p>配置DOT_PATH</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">➜  ~ which dot<br><span class=\"hljs-regexp\">/opt/</span>homebrew<span class=\"hljs-regexp\">/bin/</span>dot<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482622484922022-03-26-10-19-09-image.png\"></p>\n<p>生成文档和函数调用图</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482622864902022-03-26-10-19-27-image.png\"></p>\n<h2 id=\"查看函数调用图\"><a href=\"#查看函数调用图\" class=\"headerlink\" title=\"查看函数调用图\"></a>查看函数调用图</h2><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vim\">➜  ff_doc <span class=\"hljs-keyword\">ls</span><br>html  latex<br>➜  ff_doc <span class=\"hljs-keyword\">cd</span> html<br>➜  html <span class=\"hljs-keyword\">open</span> <span class=\"hljs-built_in\">index</span>.html<br></code></pre></td></tr></table></figure>\n\n<p>文档生成目录下，打开<code>html/index.html</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482623074922022-03-26-10-26-47-image.png\"></p>\n<p>可以看到生成的函数调用图</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16482623224912022-03-26-10-28-07-image.png\"></p>\n"},{"layout":"post","title":"ffplay 代码结构与总结","date":"2022-03-26T16:00:00.000Z","_content":"\n## ffplay 源码分析系列 - CSDN\n\n[ffplay源码分析1-概述 - 叶余 - 博客园](https://www.cnblogs.com/leisure_chn/p/10301215.html)\n\n[ffplay源码分析2-数据结构 - 叶余 - 博客园](https://www.cnblogs.com/leisure_chn/p/10301253.html)\n\n[ffplay源码分析3-代码框架 - 叶余 - 博客园](https://www.cnblogs.com/leisure_chn/p/10301831.html)\n\n[ffplay源码分析4-音视频同步 - 叶余 - 博客园](https://www.cnblogs.com/leisure_chn/p/10307089.html)\n\n[ffplay源码分析5-图像格式转换 - 叶余 - 博客园](https://www.cnblogs.com/leisure_chn/p/10311376.html)\n\n[ffplay源码分析6-音频重采样 - 叶余 - 博客园](https://www.cnblogs.com/leisure_chn/p/10312713.html)\n\n[ffplay源码分析7-播放控制 - 叶余 - 博客园](https://www.cnblogs.com/leisure_chn/p/10316225.html)\n\n## ffplay 源码分析系列 - 知乎\n\n [ffplay packet queue分析](https://zhuanlan.zhihu.com/p/43295650)\n\n [ffplay frame queue分析](https://zhuanlan.zhihu.com/p/43564980)\n\n [ffplay read线程分析](https://zhuanlan.zhihu.com/p/43672062)\n\n [ffplay解码线程分析](https://zhuanlan.zhihu.com/p/43948483)\n\n [ffplay video显示线程分析](https://zhuanlan.zhihu.com/p/44122324)\n\n [ffplay audio输出线程分析](https://zhuanlan.zhihu.com/p/44139512)\n\n [ffplay subtitle显示线程分析](https://zhuanlan.zhihu.com/p/44207804)\n\n[ffplay音视频同步分析——基础概念](https://zhuanlan.zhihu.com/p/44615185)\n\n[ffplay音视频同步分析——视频同步音频](https://zhuanlan.zhihu.com/p/44615401)\n\n[ffplay音视频同步分析——音频同步视频](https://zhuanlan.zhihu.com/p/44680734)\n\n[ffplay音视频同步分析——同步到外部时钟](https://zhuanlan.zhihu.com/p/44684432)\n\n[ffplay 分析概述](https://zhuanlan.zhihu.com/p/44694286)\n\n## ffplay 思维导图\n\n<img title=\"\" src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/1648385500340ffplay.png\" alt=\"\" width=\"821\">\n\n![](https://mmbiz.qpic.cn/mmbiz_png/GjBg4Rhq9j3NR2cp5nxibjIKz83QIicCQLV5SloO4tGdhWEdOgtkC7xJyRtspkhAeicqE3s39Lv90evp2WJbibg3cA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\nffmpeg数据流向\n\n1. 从文件或者直播流中获取AVPacket存入Packet queue， \n\n2. 从paket queue 获取 AVPacket ， 发送给解码器解码，得到AVFrame 存入frame queue\n\n3. SDL音频播放器从frame queue 中获取 AVFrame 进行播放，同时更新音频时钟\n\n4. 视频播放，从frame queue 中获取 AVFrame，根据音频时钟进行播放。\n\n### Packet 获取\n\nread_thead\n\n```\nfor (;;) {\n    //解封装，将解封装得到的pkt放入pkt queue\n    ret = av_read_frame(ic, pkt);\n    packet_queue_put(&is->subtitleq, pkt);\n}\n```\n\n### 视频解码\n\nvideo_thread\n\n```\n for (;;) {\n    //解码\n    packet_queue_get()\n    avcodec_send_packet()\n    avcodec_receive_frame()\n    //将解码后的数据放入 frame queue\n    frame_queue_peek_writable();\n    frame_queue_push();\n }\n```\n\n### 视频绘制\n\nvideo_refresh\n\n```\nframe_queue_peek();\nframe_queue_next();\n```\n\n### 音频解码\n\naudio_thread\n\n```\n for (;;) {\n    //解码\n    packet_queue_get()\n    avcodec_send_packet()\n    avcodec_receive_frame()\n    //将解码后的数据放入 frame queue\n    frame_queue_peek_writable();\n    frame_queue_push();\n }\n```\n\n### 音频播放\n\nsdl_audio_callback\n\n```\nframe_queue_peek_readable();\nframe_queue_next();\n```\n","source":"_posts/ffmpeg/2022-03-27-ffplay 代码结构与总结.md","raw":"---\nlayout: post\ntitle: \"ffplay 代码结构与总结\"\ndate: 2022-03-27\ntag: ffmpeg\n---\n\n## ffplay 源码分析系列 - CSDN\n\n[ffplay源码分析1-概述 - 叶余 - 博客园](https://www.cnblogs.com/leisure_chn/p/10301215.html)\n\n[ffplay源码分析2-数据结构 - 叶余 - 博客园](https://www.cnblogs.com/leisure_chn/p/10301253.html)\n\n[ffplay源码分析3-代码框架 - 叶余 - 博客园](https://www.cnblogs.com/leisure_chn/p/10301831.html)\n\n[ffplay源码分析4-音视频同步 - 叶余 - 博客园](https://www.cnblogs.com/leisure_chn/p/10307089.html)\n\n[ffplay源码分析5-图像格式转换 - 叶余 - 博客园](https://www.cnblogs.com/leisure_chn/p/10311376.html)\n\n[ffplay源码分析6-音频重采样 - 叶余 - 博客园](https://www.cnblogs.com/leisure_chn/p/10312713.html)\n\n[ffplay源码分析7-播放控制 - 叶余 - 博客园](https://www.cnblogs.com/leisure_chn/p/10316225.html)\n\n## ffplay 源码分析系列 - 知乎\n\n [ffplay packet queue分析](https://zhuanlan.zhihu.com/p/43295650)\n\n [ffplay frame queue分析](https://zhuanlan.zhihu.com/p/43564980)\n\n [ffplay read线程分析](https://zhuanlan.zhihu.com/p/43672062)\n\n [ffplay解码线程分析](https://zhuanlan.zhihu.com/p/43948483)\n\n [ffplay video显示线程分析](https://zhuanlan.zhihu.com/p/44122324)\n\n [ffplay audio输出线程分析](https://zhuanlan.zhihu.com/p/44139512)\n\n [ffplay subtitle显示线程分析](https://zhuanlan.zhihu.com/p/44207804)\n\n[ffplay音视频同步分析——基础概念](https://zhuanlan.zhihu.com/p/44615185)\n\n[ffplay音视频同步分析——视频同步音频](https://zhuanlan.zhihu.com/p/44615401)\n\n[ffplay音视频同步分析——音频同步视频](https://zhuanlan.zhihu.com/p/44680734)\n\n[ffplay音视频同步分析——同步到外部时钟](https://zhuanlan.zhihu.com/p/44684432)\n\n[ffplay 分析概述](https://zhuanlan.zhihu.com/p/44694286)\n\n## ffplay 思维导图\n\n<img title=\"\" src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/1648385500340ffplay.png\" alt=\"\" width=\"821\">\n\n![](https://mmbiz.qpic.cn/mmbiz_png/GjBg4Rhq9j3NR2cp5nxibjIKz83QIicCQLV5SloO4tGdhWEdOgtkC7xJyRtspkhAeicqE3s39Lv90evp2WJbibg3cA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\nffmpeg数据流向\n\n1. 从文件或者直播流中获取AVPacket存入Packet queue， \n\n2. 从paket queue 获取 AVPacket ， 发送给解码器解码，得到AVFrame 存入frame queue\n\n3. SDL音频播放器从frame queue 中获取 AVFrame 进行播放，同时更新音频时钟\n\n4. 视频播放，从frame queue 中获取 AVFrame，根据音频时钟进行播放。\n\n### Packet 获取\n\nread_thead\n\n```\nfor (;;) {\n    //解封装，将解封装得到的pkt放入pkt queue\n    ret = av_read_frame(ic, pkt);\n    packet_queue_put(&is->subtitleq, pkt);\n}\n```\n\n### 视频解码\n\nvideo_thread\n\n```\n for (;;) {\n    //解码\n    packet_queue_get()\n    avcodec_send_packet()\n    avcodec_receive_frame()\n    //将解码后的数据放入 frame queue\n    frame_queue_peek_writable();\n    frame_queue_push();\n }\n```\n\n### 视频绘制\n\nvideo_refresh\n\n```\nframe_queue_peek();\nframe_queue_next();\n```\n\n### 音频解码\n\naudio_thread\n\n```\n for (;;) {\n    //解码\n    packet_queue_get()\n    avcodec_send_packet()\n    avcodec_receive_frame()\n    //将解码后的数据放入 frame queue\n    frame_queue_peek_writable();\n    frame_queue_push();\n }\n```\n\n### 音频播放\n\nsdl_audio_callback\n\n```\nframe_queue_peek_readable();\nframe_queue_next();\n```\n","slug":"ffmpeg/2022-03-27-ffplay 代码结构与总结","published":1,"updated":"2024-03-06T11:53:13.566Z","comments":1,"photos":[],"_id":"cltgopene0029qywh0t7b24xp","content":"<h2 id=\"ffplay-源码分析系列-CSDN\"><a href=\"#ffplay-源码分析系列-CSDN\" class=\"headerlink\" title=\"ffplay 源码分析系列 - CSDN\"></a>ffplay 源码分析系列 - CSDN</h2><p><a href=\"https://www.cnblogs.com/leisure_chn/p/10301215.html\">ffplay源码分析1-概述 - 叶余 - 博客园</a></p>\n<p><a href=\"https://www.cnblogs.com/leisure_chn/p/10301253.html\">ffplay源码分析2-数据结构 - 叶余 - 博客园</a></p>\n<p><a href=\"https://www.cnblogs.com/leisure_chn/p/10301831.html\">ffplay源码分析3-代码框架 - 叶余 - 博客园</a></p>\n<p><a href=\"https://www.cnblogs.com/leisure_chn/p/10307089.html\">ffplay源码分析4-音视频同步 - 叶余 - 博客园</a></p>\n<p><a href=\"https://www.cnblogs.com/leisure_chn/p/10311376.html\">ffplay源码分析5-图像格式转换 - 叶余 - 博客园</a></p>\n<p><a href=\"https://www.cnblogs.com/leisure_chn/p/10312713.html\">ffplay源码分析6-音频重采样 - 叶余 - 博客园</a></p>\n<p><a href=\"https://www.cnblogs.com/leisure_chn/p/10316225.html\">ffplay源码分析7-播放控制 - 叶余 - 博客园</a></p>\n<h2 id=\"ffplay-源码分析系列-知乎\"><a href=\"#ffplay-源码分析系列-知乎\" class=\"headerlink\" title=\"ffplay 源码分析系列 - 知乎\"></a>ffplay 源码分析系列 - 知乎</h2><p> <a href=\"https://zhuanlan.zhihu.com/p/43295650\">ffplay packet queue分析</a></p>\n<p> <a href=\"https://zhuanlan.zhihu.com/p/43564980\">ffplay frame queue分析</a></p>\n<p> <a href=\"https://zhuanlan.zhihu.com/p/43672062\">ffplay read线程分析</a></p>\n<p> <a href=\"https://zhuanlan.zhihu.com/p/43948483\">ffplay解码线程分析</a></p>\n<p> <a href=\"https://zhuanlan.zhihu.com/p/44122324\">ffplay video显示线程分析</a></p>\n<p> <a href=\"https://zhuanlan.zhihu.com/p/44139512\">ffplay audio输出线程分析</a></p>\n<p> <a href=\"https://zhuanlan.zhihu.com/p/44207804\">ffplay subtitle显示线程分析</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/44615185\">ffplay音视频同步分析——基础概念</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/44615401\">ffplay音视频同步分析——视频同步音频</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/44680734\">ffplay音视频同步分析——音频同步视频</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/44684432\">ffplay音视频同步分析——同步到外部时钟</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/44694286\">ffplay 分析概述</a></p>\n<h2 id=\"ffplay-思维导图\"><a href=\"#ffplay-思维导图\" class=\"headerlink\" title=\"ffplay 思维导图\"></a>ffplay 思维导图</h2><img title=\"\" src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/1648385500340ffplay.png\" alt=\"\" width=\"821\">\n\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/GjBg4Rhq9j3NR2cp5nxibjIKz83QIicCQLV5SloO4tGdhWEdOgtkC7xJyRtspkhAeicqE3s39Lv90evp2WJbibg3cA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\"></p>\n<p>ffmpeg数据流向</p>\n<ol>\n<li><p>从文件或者直播流中获取AVPacket存入Packet queue， </p>\n</li>\n<li><p>从paket queue 获取 AVPacket ， 发送给解码器解码，得到AVFrame 存入frame queue</p>\n</li>\n<li><p>SDL音频播放器从frame queue 中获取 AVFrame 进行播放，同时更新音频时钟</p>\n</li>\n<li><p>视频播放，从frame queue 中获取 AVFrame，根据音频时钟进行播放。</p>\n</li>\n</ol>\n<h3 id=\"Packet-获取\"><a href=\"#Packet-获取\" class=\"headerlink\" title=\"Packet 获取\"></a>Packet 获取</h3><p>read_thead</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\">for <span class=\"hljs-comment\">(;;)</span> &#123;<br>    <span class=\"hljs-comment\">//解封装，将解封装得到的pkt放入pkt queue</span><br>    ret = av_read_frame<span class=\"hljs-comment\">(ic, pkt)</span>;<br>    packet_queue_put<span class=\"hljs-comment\">(&amp;is-&gt;subtitleq, pkt)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"视频解码\"><a href=\"#视频解码\" class=\"headerlink\" title=\"视频解码\"></a>视频解码</h3><p>video_thread</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">for (;;) &#123;<br>   <span class=\"hljs-comment\">//解码</span><br>    <span class=\"hljs-built_in\">packet_queue_get</span>()<br>    <span class=\"hljs-built_in\">avcodec_send_packet</span>()<br>    <span class=\"hljs-built_in\">avcodec_receive_frame</span>()<br>   <span class=\"hljs-comment\">//将解码后的数据放入 frame queue</span><br>    <span class=\"hljs-built_in\">frame_queue_peek_writable</span>();<br>    <span class=\"hljs-built_in\">frame_queue_push</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"视频绘制\"><a href=\"#视频绘制\" class=\"headerlink\" title=\"视频绘制\"></a>视频绘制</h3><p>video_refresh</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">frame_queue_peek</span>();<br><span class=\"hljs-built_in\">frame_queue_next</span>();<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"音频解码\"><a href=\"#音频解码\" class=\"headerlink\" title=\"音频解码\"></a>音频解码</h3><p>audio_thread</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">for (;;) &#123;<br>   <span class=\"hljs-comment\">//解码</span><br>    <span class=\"hljs-built_in\">packet_queue_get</span>()<br>    <span class=\"hljs-built_in\">avcodec_send_packet</span>()<br>    <span class=\"hljs-built_in\">avcodec_receive_frame</span>()<br>   <span class=\"hljs-comment\">//将解码后的数据放入 frame queue</span><br>    <span class=\"hljs-built_in\">frame_queue_peek_writable</span>();<br>    <span class=\"hljs-built_in\">frame_queue_push</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"音频播放\"><a href=\"#音频播放\" class=\"headerlink\" title=\"音频播放\"></a>音频播放</h3><p>sdl_audio_callback</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">frame_queue_peek_readable</span>();<br><span class=\"hljs-built_in\">frame_queue_next</span>();<br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"ffplay-源码分析系列-CSDN\"><a href=\"#ffplay-源码分析系列-CSDN\" class=\"headerlink\" title=\"ffplay 源码分析系列 - CSDN\"></a>ffplay 源码分析系列 - CSDN</h2><p><a href=\"https://www.cnblogs.com/leisure_chn/p/10301215.html\">ffplay源码分析1-概述 - 叶余 - 博客园</a></p>\n<p><a href=\"https://www.cnblogs.com/leisure_chn/p/10301253.html\">ffplay源码分析2-数据结构 - 叶余 - 博客园</a></p>\n<p><a href=\"https://www.cnblogs.com/leisure_chn/p/10301831.html\">ffplay源码分析3-代码框架 - 叶余 - 博客园</a></p>\n<p><a href=\"https://www.cnblogs.com/leisure_chn/p/10307089.html\">ffplay源码分析4-音视频同步 - 叶余 - 博客园</a></p>\n<p><a href=\"https://www.cnblogs.com/leisure_chn/p/10311376.html\">ffplay源码分析5-图像格式转换 - 叶余 - 博客园</a></p>\n<p><a href=\"https://www.cnblogs.com/leisure_chn/p/10312713.html\">ffplay源码分析6-音频重采样 - 叶余 - 博客园</a></p>\n<p><a href=\"https://www.cnblogs.com/leisure_chn/p/10316225.html\">ffplay源码分析7-播放控制 - 叶余 - 博客园</a></p>\n<h2 id=\"ffplay-源码分析系列-知乎\"><a href=\"#ffplay-源码分析系列-知乎\" class=\"headerlink\" title=\"ffplay 源码分析系列 - 知乎\"></a>ffplay 源码分析系列 - 知乎</h2><p> <a href=\"https://zhuanlan.zhihu.com/p/43295650\">ffplay packet queue分析</a></p>\n<p> <a href=\"https://zhuanlan.zhihu.com/p/43564980\">ffplay frame queue分析</a></p>\n<p> <a href=\"https://zhuanlan.zhihu.com/p/43672062\">ffplay read线程分析</a></p>\n<p> <a href=\"https://zhuanlan.zhihu.com/p/43948483\">ffplay解码线程分析</a></p>\n<p> <a href=\"https://zhuanlan.zhihu.com/p/44122324\">ffplay video显示线程分析</a></p>\n<p> <a href=\"https://zhuanlan.zhihu.com/p/44139512\">ffplay audio输出线程分析</a></p>\n<p> <a href=\"https://zhuanlan.zhihu.com/p/44207804\">ffplay subtitle显示线程分析</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/44615185\">ffplay音视频同步分析——基础概念</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/44615401\">ffplay音视频同步分析——视频同步音频</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/44680734\">ffplay音视频同步分析——音频同步视频</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/44684432\">ffplay音视频同步分析——同步到外部时钟</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/44694286\">ffplay 分析概述</a></p>\n<h2 id=\"ffplay-思维导图\"><a href=\"#ffplay-思维导图\" class=\"headerlink\" title=\"ffplay 思维导图\"></a>ffplay 思维导图</h2><img title=\"\" src=\"https://cdn.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/1648385500340ffplay.png\" alt=\"\" width=\"821\">\n\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/GjBg4Rhq9j3NR2cp5nxibjIKz83QIicCQLV5SloO4tGdhWEdOgtkC7xJyRtspkhAeicqE3s39Lv90evp2WJbibg3cA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\"></p>\n<p>ffmpeg数据流向</p>\n<ol>\n<li><p>从文件或者直播流中获取AVPacket存入Packet queue， </p>\n</li>\n<li><p>从paket queue 获取 AVPacket ， 发送给解码器解码，得到AVFrame 存入frame queue</p>\n</li>\n<li><p>SDL音频播放器从frame queue 中获取 AVFrame 进行播放，同时更新音频时钟</p>\n</li>\n<li><p>视频播放，从frame queue 中获取 AVFrame，根据音频时钟进行播放。</p>\n</li>\n</ol>\n<h3 id=\"Packet-获取\"><a href=\"#Packet-获取\" class=\"headerlink\" title=\"Packet 获取\"></a>Packet 获取</h3><p>read_thead</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\">for <span class=\"hljs-comment\">(;;)</span> &#123;<br>    <span class=\"hljs-comment\">//解封装，将解封装得到的pkt放入pkt queue</span><br>    ret = av_read_frame<span class=\"hljs-comment\">(ic, pkt)</span>;<br>    packet_queue_put<span class=\"hljs-comment\">(&amp;is-&gt;subtitleq, pkt)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"视频解码\"><a href=\"#视频解码\" class=\"headerlink\" title=\"视频解码\"></a>视频解码</h3><p>video_thread</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">for (;;) &#123;<br>   <span class=\"hljs-comment\">//解码</span><br>    <span class=\"hljs-built_in\">packet_queue_get</span>()<br>    <span class=\"hljs-built_in\">avcodec_send_packet</span>()<br>    <span class=\"hljs-built_in\">avcodec_receive_frame</span>()<br>   <span class=\"hljs-comment\">//将解码后的数据放入 frame queue</span><br>    <span class=\"hljs-built_in\">frame_queue_peek_writable</span>();<br>    <span class=\"hljs-built_in\">frame_queue_push</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"视频绘制\"><a href=\"#视频绘制\" class=\"headerlink\" title=\"视频绘制\"></a>视频绘制</h3><p>video_refresh</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">frame_queue_peek</span>();<br><span class=\"hljs-built_in\">frame_queue_next</span>();<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"音频解码\"><a href=\"#音频解码\" class=\"headerlink\" title=\"音频解码\"></a>音频解码</h3><p>audio_thread</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">for (;;) &#123;<br>   <span class=\"hljs-comment\">//解码</span><br>    <span class=\"hljs-built_in\">packet_queue_get</span>()<br>    <span class=\"hljs-built_in\">avcodec_send_packet</span>()<br>    <span class=\"hljs-built_in\">avcodec_receive_frame</span>()<br>   <span class=\"hljs-comment\">//将解码后的数据放入 frame queue</span><br>    <span class=\"hljs-built_in\">frame_queue_peek_writable</span>();<br>    <span class=\"hljs-built_in\">frame_queue_push</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"音频播放\"><a href=\"#音频播放\" class=\"headerlink\" title=\"音频播放\"></a>音频播放</h3><p>sdl_audio_callback</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">frame_queue_peek_readable</span>();<br><span class=\"hljs-built_in\">frame_queue_next</span>();<br></code></pre></td></tr></table></figure>\n"},{"layout":"post","title":"ffmpeg 命令","date":"2022-09-22T16:00:00.000Z","_content":"\n\n## ffmpeg \n```\nusage: ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}...\n```\n\n音频转码\n```\n#转码生成新的文件，目标为 \n- ar 采样率 44100，\n- ac 双声道，编码格式 aac\n- acodec 编码器 aac\nffmpeg -i source.mp3 -ar 44100 -ac 2 -acodec aac -y output.m4a\n\n# 转换为 pcm\nffmpeg -i source.mp3 -f s16le -acodec pcm_s16le output.raw\n```\n\n从 mp4 中提取 yuv\n\n```\nffmpeg -i xx.mp4 -s 960x540 -pix_fmt yuv420p xx.yuv\n```\n\n- `-s` 来设置 yuv 数据的分辨率\n- `-pix_fmt` 设置 yuv 的颜色格式\n\n从mp4或flv文件中提取h264\n```\nffmpeg -i test.flv -vcodec copy -an -bsf:v h264_mp4toannexb test.h264\n```\n从mp4文件中提取aac\n```\nffmpeg -i input.mp4 -vn -c:a copy output.aac\n```\n\n把一个 non-fragment MP4 转换成 fragment MP4，可以使用 FFmpeg 的 -movflags 来转换。参考：[fragment mp4 转换](https://shangxin.me/2017/08/11/fragment-mp4-%E8%BD%AC%E6%8D%A2/)\n\n对于原始文件为非 MP4 文件\n```\nffmpeg -i trailer_1080p.mov -c:v copy -c:a copy -movflags frag_keyframe+empty_moov bunny_fragmented.mp4\n\n```\n对于原始文件已经是 MP4 文件\n```\nffmpeg -i non_fragmented.mp4 -strict -2 -movflags frag_keyframe+empty_moov fragmented.mp4\n\n```\n\n将 yuv 编码成 mp4\n```\nffmpeg -f rawvideo -pix_fmt yuv420p -s:v 1920x1080 -r 25 -i input.yuv \\\n-c:v libx264 output.mp4\n```\n\n将 yuv 编码成 h264, 参考 [Using ffmpeg to encode a raw video to H.264 format](https://superuser.com/questions/322354/using-ffmpeg-to-encode-a-raw-video-to-h-264-format)\n\n```\nffmpeg -f rawvideo -pix_fmt yuv420p -s:v 1920x1080 -r 25 -i input.yuv \\\n-c:v libx264 -f rawvideo output.264\n```\n\n## ffplay\n\n播放yuv\n```\nffplay -f rawvideo -video_size 1280x720 -pixel_format nv12 xxx.yuv\nffplay -f rawvideo -video_size 1280x720 -pixel_format yuv420p xxx.yuv\n```\n\n播放pcm\n```\nffplay -ar 16000 -ac 1 -f s16le -i xxx.pcm\n```\n\nffplay 字幕， 参考https://www.pianshen.com/article/9580874222/\n\n使用自带的第0个字幕流\n\n```\nffplay -vf subtitles=infile:si=0 infile\n```\n","source":"_posts/ffmpeg/2022-09-23-ffmpeg-命令.md","raw":"---\nlayout: post\ntitle: \"ffmpeg 命令\"\ndate: 2022-09-23\ntag: ffmpeg\n---\n\n\n## ffmpeg \n```\nusage: ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}...\n```\n\n音频转码\n```\n#转码生成新的文件，目标为 \n- ar 采样率 44100，\n- ac 双声道，编码格式 aac\n- acodec 编码器 aac\nffmpeg -i source.mp3 -ar 44100 -ac 2 -acodec aac -y output.m4a\n\n# 转换为 pcm\nffmpeg -i source.mp3 -f s16le -acodec pcm_s16le output.raw\n```\n\n从 mp4 中提取 yuv\n\n```\nffmpeg -i xx.mp4 -s 960x540 -pix_fmt yuv420p xx.yuv\n```\n\n- `-s` 来设置 yuv 数据的分辨率\n- `-pix_fmt` 设置 yuv 的颜色格式\n\n从mp4或flv文件中提取h264\n```\nffmpeg -i test.flv -vcodec copy -an -bsf:v h264_mp4toannexb test.h264\n```\n从mp4文件中提取aac\n```\nffmpeg -i input.mp4 -vn -c:a copy output.aac\n```\n\n把一个 non-fragment MP4 转换成 fragment MP4，可以使用 FFmpeg 的 -movflags 来转换。参考：[fragment mp4 转换](https://shangxin.me/2017/08/11/fragment-mp4-%E8%BD%AC%E6%8D%A2/)\n\n对于原始文件为非 MP4 文件\n```\nffmpeg -i trailer_1080p.mov -c:v copy -c:a copy -movflags frag_keyframe+empty_moov bunny_fragmented.mp4\n\n```\n对于原始文件已经是 MP4 文件\n```\nffmpeg -i non_fragmented.mp4 -strict -2 -movflags frag_keyframe+empty_moov fragmented.mp4\n\n```\n\n将 yuv 编码成 mp4\n```\nffmpeg -f rawvideo -pix_fmt yuv420p -s:v 1920x1080 -r 25 -i input.yuv \\\n-c:v libx264 output.mp4\n```\n\n将 yuv 编码成 h264, 参考 [Using ffmpeg to encode a raw video to H.264 format](https://superuser.com/questions/322354/using-ffmpeg-to-encode-a-raw-video-to-h-264-format)\n\n```\nffmpeg -f rawvideo -pix_fmt yuv420p -s:v 1920x1080 -r 25 -i input.yuv \\\n-c:v libx264 -f rawvideo output.264\n```\n\n## ffplay\n\n播放yuv\n```\nffplay -f rawvideo -video_size 1280x720 -pixel_format nv12 xxx.yuv\nffplay -f rawvideo -video_size 1280x720 -pixel_format yuv420p xxx.yuv\n```\n\n播放pcm\n```\nffplay -ar 16000 -ac 1 -f s16le -i xxx.pcm\n```\n\nffplay 字幕， 参考https://www.pianshen.com/article/9580874222/\n\n使用自带的第0个字幕流\n\n```\nffplay -vf subtitles=infile:si=0 infile\n```\n","slug":"ffmpeg/2022-09-23-ffmpeg-命令","published":1,"updated":"2024-03-06T11:53:13.566Z","comments":1,"photos":[],"_id":"cltgopene002aqywhhib2fmj1","content":"<h2 id=\"ffmpeg\"><a href=\"#ffmpeg\" class=\"headerlink\" title=\"ffmpeg\"></a>ffmpeg</h2><figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs prolog\">usage: ffmpeg [options] [[infile options] -i infile]... &#123;[outfile options] outfile&#125;...<br></code></pre></td></tr></table></figure>\n\n<p>音频转码</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-section\">#转码生成新的文件，目标为 </span><br><span class=\"hljs-bullet\">-</span> ar 采样率 44100，<br><span class=\"hljs-bullet\">-</span> ac 双声道，编码格式 aac<br><span class=\"hljs-bullet\">-</span> acodec 编码器 aac<br>ffmpeg -i source.mp3 -ar 44100 -ac 2 -acodec aac -y output.m4a<br><br><span class=\"hljs-section\"># 转换为 pcm</span><br>ffmpeg -i source.mp3 -f s16le -acodec pcm<span class=\"hljs-emphasis\">_s16le output.raw</span><br></code></pre></td></tr></table></figure>\n\n<p>从 mp4 中提取 yuv</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs smali\">ffmpeg -i xx.mp4 -s 960x540 -pix_fmt yuv420p xx.yuv<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>-s</code> 来设置 yuv 数据的分辨率</li>\n<li><code>-pix_fmt</code> 设置 yuv 的颜色格式</li>\n</ul>\n<p>从mp4或flv文件中提取h264</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\">ffmpeg -i <span class=\"hljs-keyword\">test</span>.flv -vcodec <span class=\"hljs-keyword\">copy</span> -<span class=\"hljs-keyword\">an</span> -bsf:v h264_mp4toannexb <span class=\"hljs-keyword\">test</span>.h264<br></code></pre></td></tr></table></figure>\n<p>从mp4文件中提取aac</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">ffmpeg -<span class=\"hljs-selector-tag\">i</span> <span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-class\">.mp4</span> -vn -c:<span class=\"hljs-selector-tag\">a</span> copy output.aac<br></code></pre></td></tr></table></figure>\n\n<p>把一个 non-fragment MP4 转换成 fragment MP4，可以使用 FFmpeg 的 -movflags 来转换。参考：<a href=\"https://shangxin.me/2017/08/11/fragment-mp4-%E8%BD%AC%E6%8D%A2/\">fragment mp4 转换</a></p>\n<p>对于原始文件为非 MP4 文件</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">ffmpeg -<span class=\"hljs-selector-tag\">i</span> trailer_1080p<span class=\"hljs-selector-class\">.mov</span> -c:v copy -c:<span class=\"hljs-selector-tag\">a</span> copy -movflags frag_keyframe+empty_moov bunny_fragmented<span class=\"hljs-selector-class\">.mp4</span><br><br></code></pre></td></tr></table></figure>\n<p>对于原始文件已经是 MP4 文件</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">ffmpeg -<span class=\"hljs-selector-tag\">i</span> non_fragmented<span class=\"hljs-selector-class\">.mp4</span> -strict -<span class=\"hljs-number\">2</span> -movflags frag_keyframe+empty_moov fragmented<span class=\"hljs-selector-class\">.mp4</span><br><br></code></pre></td></tr></table></figure>\n\n<p>将 yuv 编码成 mp4</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">ffmpeg -f rawvideo -pix_fmt yuv420p -s:v <span class=\"hljs-number\">1920</span>x1080 -r <span class=\"hljs-number\">25</span> -<span class=\"hljs-selector-tag\">i</span> <span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-class\">.yuv</span> \\<br>-c:v libx264 output.mp4<br></code></pre></td></tr></table></figure>\n\n<p>将 yuv 编码成 h264, 参考 <a href=\"https://superuser.com/questions/322354/using-ffmpeg-to-encode-a-raw-video-to-h-264-format\">Using ffmpeg to encode a raw video to H.264 format</a></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">ffmpeg -f rawvideo -pix_fmt yuv420p -s:v <span class=\"hljs-number\">1920</span>x1080 -r <span class=\"hljs-number\">25</span> -<span class=\"hljs-selector-tag\">i</span> <span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-class\">.yuv</span> \\<br>-c:v libx264 -f rawvideo output.<span class=\"hljs-number\">264</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"ffplay\"><a href=\"#ffplay\" class=\"headerlink\" title=\"ffplay\"></a>ffplay</h2><p>播放yuv</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">ffplay</span> -f rawvideo -video_size <span class=\"hljs-number\">1280</span>x720 -pixel_format nv12 xxx.yuv<br><span class=\"hljs-attribute\">ffplay</span> -f rawvideo -video_size <span class=\"hljs-number\">1280</span>x720 -pixel_format yuv420p xxx.yuv<br></code></pre></td></tr></table></figure>\n\n<p>播放pcm</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">ffplay</span> -ar <span class=\"hljs-number\">16000</span> -ac <span class=\"hljs-number\">1</span> -f s16le -i xxx.pcm<br></code></pre></td></tr></table></figure>\n\n<p>ffplay 字幕， 参考<a href=\"https://www.pianshen.com/article/9580874222/\">https://www.pianshen.com/article/9580874222/</a></p>\n<p>使用自带的第0个字幕流</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">ffplay -vf <span class=\"hljs-attribute\">subtitles</span>=infile:si=0 infile<br></code></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"ffmpeg\"><a href=\"#ffmpeg\" class=\"headerlink\" title=\"ffmpeg\"></a>ffmpeg</h2><figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs prolog\">usage: ffmpeg [options] [[infile options] -i infile]... &#123;[outfile options] outfile&#125;...<br></code></pre></td></tr></table></figure>\n\n<p>音频转码</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-section\">#转码生成新的文件，目标为 </span><br><span class=\"hljs-bullet\">-</span> ar 采样率 44100，<br><span class=\"hljs-bullet\">-</span> ac 双声道，编码格式 aac<br><span class=\"hljs-bullet\">-</span> acodec 编码器 aac<br>ffmpeg -i source.mp3 -ar 44100 -ac 2 -acodec aac -y output.m4a<br><br><span class=\"hljs-section\"># 转换为 pcm</span><br>ffmpeg -i source.mp3 -f s16le -acodec pcm<span class=\"hljs-emphasis\">_s16le output.raw</span><br></code></pre></td></tr></table></figure>\n\n<p>从 mp4 中提取 yuv</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs smali\">ffmpeg -i xx.mp4 -s 960x540 -pix_fmt yuv420p xx.yuv<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>-s</code> 来设置 yuv 数据的分辨率</li>\n<li><code>-pix_fmt</code> 设置 yuv 的颜色格式</li>\n</ul>\n<p>从mp4或flv文件中提取h264</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\">ffmpeg -i <span class=\"hljs-keyword\">test</span>.flv -vcodec <span class=\"hljs-keyword\">copy</span> -<span class=\"hljs-keyword\">an</span> -bsf:v h264_mp4toannexb <span class=\"hljs-keyword\">test</span>.h264<br></code></pre></td></tr></table></figure>\n<p>从mp4文件中提取aac</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">ffmpeg -<span class=\"hljs-selector-tag\">i</span> <span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-class\">.mp4</span> -vn -c:<span class=\"hljs-selector-tag\">a</span> copy output.aac<br></code></pre></td></tr></table></figure>\n\n<p>把一个 non-fragment MP4 转换成 fragment MP4，可以使用 FFmpeg 的 -movflags 来转换。参考：<a href=\"https://shangxin.me/2017/08/11/fragment-mp4-%E8%BD%AC%E6%8D%A2/\">fragment mp4 转换</a></p>\n<p>对于原始文件为非 MP4 文件</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">ffmpeg -<span class=\"hljs-selector-tag\">i</span> trailer_1080p<span class=\"hljs-selector-class\">.mov</span> -c:v copy -c:<span class=\"hljs-selector-tag\">a</span> copy -movflags frag_keyframe+empty_moov bunny_fragmented<span class=\"hljs-selector-class\">.mp4</span><br><br></code></pre></td></tr></table></figure>\n<p>对于原始文件已经是 MP4 文件</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">ffmpeg -<span class=\"hljs-selector-tag\">i</span> non_fragmented<span class=\"hljs-selector-class\">.mp4</span> -strict -<span class=\"hljs-number\">2</span> -movflags frag_keyframe+empty_moov fragmented<span class=\"hljs-selector-class\">.mp4</span><br><br></code></pre></td></tr></table></figure>\n\n<p>将 yuv 编码成 mp4</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">ffmpeg -f rawvideo -pix_fmt yuv420p -s:v <span class=\"hljs-number\">1920</span>x1080 -r <span class=\"hljs-number\">25</span> -<span class=\"hljs-selector-tag\">i</span> <span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-class\">.yuv</span> \\<br>-c:v libx264 output.mp4<br></code></pre></td></tr></table></figure>\n\n<p>将 yuv 编码成 h264, 参考 <a href=\"https://superuser.com/questions/322354/using-ffmpeg-to-encode-a-raw-video-to-h-264-format\">Using ffmpeg to encode a raw video to H.264 format</a></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">ffmpeg -f rawvideo -pix_fmt yuv420p -s:v <span class=\"hljs-number\">1920</span>x1080 -r <span class=\"hljs-number\">25</span> -<span class=\"hljs-selector-tag\">i</span> <span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-class\">.yuv</span> \\<br>-c:v libx264 -f rawvideo output.<span class=\"hljs-number\">264</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"ffplay\"><a href=\"#ffplay\" class=\"headerlink\" title=\"ffplay\"></a>ffplay</h2><p>播放yuv</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">ffplay</span> -f rawvideo -video_size <span class=\"hljs-number\">1280</span>x720 -pixel_format nv12 xxx.yuv<br><span class=\"hljs-attribute\">ffplay</span> -f rawvideo -video_size <span class=\"hljs-number\">1280</span>x720 -pixel_format yuv420p xxx.yuv<br></code></pre></td></tr></table></figure>\n\n<p>播放pcm</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">ffplay</span> -ar <span class=\"hljs-number\">16000</span> -ac <span class=\"hljs-number\">1</span> -f s16le -i xxx.pcm<br></code></pre></td></tr></table></figure>\n\n<p>ffplay 字幕， 参考<a href=\"https://www.pianshen.com/article/9580874222/\">https://www.pianshen.com/article/9580874222/</a></p>\n<p>使用自带的第0个字幕流</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">ffplay -vf <span class=\"hljs-attribute\">subtitles</span>=infile:si=0 infile<br></code></pre></td></tr></table></figure>\n"},{"layout":"post","title":"使用 Apple Configurator 获取 ipa 文件","date":"2023-03-13T16:00:00.000Z","_content":"\n\n参考：[Apple Configuration 2 获取ipa文件](https://www.jianshu.com/p/86f35a6a64a7)\n\n\n# 工具 Apple Configurator\n\n可以在 Mac 的 App Store 中下载\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16787776997821678777699715.png)\n\n\n\n# 操作\n\n1. 连接手机\n\n2. 点击 Add -> Apps -> 输入 app 名字 -> 点击添加\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16787779407831678777940467.png)\n\n3. 等待下载完成, 不要操作\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16787783759431678778375920.png)\n\n4. 去目录里找 ipa 文件\n\n```\n~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/36244314-7400-420B-BC2A-AC3C4988F115/414478124/WeChat 8.0.33.ipa\n```\n\n","source":"_posts/ios/2023-03-14-使用Apple Configurator 获取 ipa 文件.md","raw":"\n---\n\nlayout: post\ntitle: \"使用 Apple Configurator 获取 ipa 文件\"\ndate: 2023-03-14\ntag: iOS\n\n---\n\n\n参考：[Apple Configuration 2 获取ipa文件](https://www.jianshu.com/p/86f35a6a64a7)\n\n\n# 工具 Apple Configurator\n\n可以在 Mac 的 App Store 中下载\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16787776997821678777699715.png)\n\n\n\n# 操作\n\n1. 连接手机\n\n2. 点击 Add -> Apps -> 输入 app 名字 -> 点击添加\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16787779407831678777940467.png)\n\n3. 等待下载完成, 不要操作\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16787783759431678778375920.png)\n\n4. 去目录里找 ipa 文件\n\n```\n~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/36244314-7400-420B-BC2A-AC3C4988F115/414478124/WeChat 8.0.33.ipa\n```\n\n","slug":"ios/2023-03-14-使用Apple Configurator 获取 ipa 文件","published":1,"updated":"2024-03-06T11:53:13.567Z","comments":1,"photos":[],"_id":"cltgopene002dqywhdrio0w5v","content":"<p>参考：<a href=\"https://www.jianshu.com/p/86f35a6a64a7\">Apple Configuration 2 获取ipa文件</a></p>\n<h1 id=\"工具-Apple-Configurator\"><a href=\"#工具-Apple-Configurator\" class=\"headerlink\" title=\"工具 Apple Configurator\"></a>工具 Apple Configurator</h1><p>可以在 Mac 的 App Store 中下载</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16787776997821678777699715.png\"></p>\n<h1 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h1><ol>\n<li><p>连接手机</p>\n</li>\n<li><p>点击 Add -&gt; Apps -&gt; 输入 app 名字 -&gt; 点击添加</p>\n</li>\n</ol>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16787779407831678777940467.png\"></p>\n<ol start=\"3\">\n<li>等待下载完成, 不要操作</li>\n</ol>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16787783759431678778375920.png\"></p>\n<ol start=\"4\">\n<li>去目录里找 ipa 文件</li>\n</ol>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/Library/</span>Group Containers<span class=\"hljs-regexp\">/K36BKF7T3D.group.com.apple.configurator/</span>Library<span class=\"hljs-regexp\">/Caches/</span>Assets<span class=\"hljs-regexp\">/TemporaryItems/</span>MobileApps<span class=\"hljs-regexp\">/36244314-7400-420B-BC2A-AC3C4988F115/</span><span class=\"hljs-number\">414478124</span>/WeChat <span class=\"hljs-number\">8.0</span>.<span class=\"hljs-number\">33</span>.ipa<br></code></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<p>参考：<a href=\"https://www.jianshu.com/p/86f35a6a64a7\">Apple Configuration 2 获取ipa文件</a></p>\n<h1 id=\"工具-Apple-Configurator\"><a href=\"#工具-Apple-Configurator\" class=\"headerlink\" title=\"工具 Apple Configurator\"></a>工具 Apple Configurator</h1><p>可以在 Mac 的 App Store 中下载</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16787776997821678777699715.png\"></p>\n<h1 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h1><ol>\n<li><p>连接手机</p>\n</li>\n<li><p>点击 Add -&gt; Apps -&gt; 输入 app 名字 -&gt; 点击添加</p>\n</li>\n</ol>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16787779407831678777940467.png\"></p>\n<ol start=\"3\">\n<li>等待下载完成, 不要操作</li>\n</ol>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16787783759431678778375920.png\"></p>\n<ol start=\"4\">\n<li>去目录里找 ipa 文件</li>\n</ol>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">~<span class=\"hljs-regexp\">/Library/</span>Group Containers<span class=\"hljs-regexp\">/K36BKF7T3D.group.com.apple.configurator/</span>Library<span class=\"hljs-regexp\">/Caches/</span>Assets<span class=\"hljs-regexp\">/TemporaryItems/</span>MobileApps<span class=\"hljs-regexp\">/36244314-7400-420B-BC2A-AC3C4988F115/</span><span class=\"hljs-number\">414478124</span>/WeChat <span class=\"hljs-number\">8.0</span>.<span class=\"hljs-number\">33</span>.ipa<br></code></pre></td></tr></table></figure>\n\n"},{"layout":"post","title":"ios keychain 总结","date":"2022-11-25T16:00:00.000Z","_content":"\n\n# Keychain  是什么\n\n一个加密的数据库， 可以用来存储小的用户数据， 包括\n- kSecClassGenericPassword：通用密码（可以用来存自定义数据）\n- kSecClassInternetPassword：互联网密码\n- kSecClassCertificate：证书\n- kSecClassKey：秘钥\n- kSecClassIdentity：证书+秘钥\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16692950150511669295014987.png)\nFigure 1 Securing the user's secrets in a keychain\n\n打开 mac 系统的 keychain 观察一下， 发现系统有多个keychain，每个keychain都有上图对应的项目\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16694375672261669437566402.png)\n\n\n# 如何管理数据，增删查改\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16692963470741669296346746.png)\nFigure 1 Putting data and attributes into a keychain\n\n\nkeychain 将要存储的数据封装为 SecKeychainItemRef，通过存取 SecKeychainItem 来达到对数据的管理。\n\nSecKeychainItemRef 包含\n- data， CFData， 要存取的数据\n- attributes, 该条目的属性，存取权限，查询标签等\n\n提供的api\n\n```\n//添加\nOSStatus SecItemAdd(CFDictionaryRef attributes, CFTypeRef  _Nullable *result);\n//查询\nOSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef  _Nullable *result);\n//更新\nOSStatus SecItemUpdate(CFDictionaryRef query, CFDictionaryRef attributesToUpdate);\n//删除\nOSStatus SecItemDelete(CFDictionaryRef query);\n\n```\n\n## SecItemAdd\n\n```\nOSStatus SecItemAdd(CFDictionaryRef attributes, CFTypeRef  _Nullable *result);\n```\n\n### 参数\n**attributes**\n\n一个字典，描述要添加的数据：\n- 要添加数据类型，对应的 key 为`kSecClass`, value 可以是\n\t- kSecClassGenericPassword：通用密码（可以用来存自定义数据）\n\t- kSecClassInternetPassword：互联网密码\n\t- kSecClassCertificate：证书\n\t- kSecClassKey：秘钥\n\t- kSecClassIdentity：证书+秘钥\n- 数添加的数据本身, key 为 ` kSecValueData`, value 为 `CFDataRef` 类型\n- 关联的属性, 参考：[Item Attribute Keys and Values](https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_attribute_keys_and_values?language=objc)\n\t- 每种类型关联的属性可以不同，例如 kSecClassInternetPassword 可以关联 `kSecAttrServer`, `kSecAttrPort`, `kSecAttrProtocol`， 而 `kSecClassGenericPassword`就没有这些选项\n\t-  `kSecAttrAccessGroup` 可以指定存入的keychain group，这个会影响到查询范围\n- 添加后，返回添加结果的类型，指定类型的数据会存入 result 字段。参考：[ Item Return Result Keys](https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_return_result_keys?language=objc)\n\n**result**\n\n添加结束，函数返回，指向新添加的条目。根据 attributes 中指定的类型，返回对应的值。参考： [ Item Return Result Keys](https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_return_result_keys?language=objc)\n\n一般添加不关心新条目，传nil\n\n### 返回值\n\n成功或者错误码。参考：[Security Framework Result Codes](https://developer.apple.com/documentation/security/1542001-security_framework_result_codes?language=objc)\n\n### 注意\n\n1. kSecAttrAccessGroup 可以指定添加到 钥匙串分组，该分组中的成员共享该条目\n2. 一次添加多条，可以使用`kSecUseItemList `传入字典数组，但是不能用于密码类型\n3. 添加是同步执行，放到主线程可能会卡界面，可以用异步方式\n\n```\n- (void)addKeychainItemWithAttributes:(CFDictionaryRef)attrs completion:(void(^)(OSStatus status, CFTypeRef item))completion {\n    dispatch_async(backgroundQueue, ^{\n        CFTypeRef item = NULL;\n        OSStatus addResult = SecItemAdd(attrs, &item);\n        completion(addResult, item);\n        if (item) {\n            CFRelease(item);\n        }\n    });\n}\n```\n\n## SecItemCopyMatching\n\n```\nOSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef  _Nullable *result);\n```\n\n通过 query 指定查询条件，将查询结果存入 result 中。\n\n### 参数\n\n**query**\n用于指定查询条件\n- 查询的数据类型，通过 `kSecClass` 指定\n- 关联的属性， 用于缩小查询范围\n- 查询参数，返回一条还是多条匹配项，是否大消息敏感，或者从特定项中搜索。参考： [ Search Attribute Keys and Values](https://developer.apple.com/documentation/security/keychain_services/keychain_items/search_attribute_keys_and_values?language=objc)\n- 指定返回类型，指定的类型不同，result 中返回的类型就不同。 参考： [Item Return Result Keys ](https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_return_result_keys?language=objc)\n\n**result **\n\n保存查询结果。\n例如： 指定  `kSecReturnData: kCFBooleanTrue`  ，result 中存的就是`CFDataRef `类型的数据。参考： [Item Return Result Keys](https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_return_result_keys?language=objc)\n\n### 返回值\n\n成功或者错误码。参考：[Security Framework Result Codes](https://developer.apple.com/documentation/security/1542001-security_framework_result_codes?language=objc)\n\n### 注意\n\n1. 默认返回第一个匹配项，如果想查询多条匹配，指定 `kSecMatchLimit`  大于1， 此时 result 为 `CFArrayRef`  类型\n2. 当类型为`kSecInternetPasswordItemClass` 或 `kSecGenericPasswordItemClass`时， 不能同时指定`kSecReturnData` 和 `kSecMatchLimitAll`, 原因是拷贝每个密码时，需要额外的授权验证。\n3. 默认情况下，会搜索当前keychain 以及所有加入的 keychain group， 通过 `kSecAttrAccessGroup` 可以指定要在哪个 keychain group 查询\n4. 主线程同步执行会卡UI， 可以异步执行\n\n```\n- (void)findKeychainItemWithAttributes:(NSDictionary *)attributes completion:(void(^)(OSStatus status, CFTypeRef item))completion {\n    dispatch_async(backgroundQueue, ^{\n        CFDictionaryRef attrs = (__bridge CFDictionaryRef)attributes;\n        CFTypeRef item = NULL;\n        OSStatus result = SecItemCopyMatching(attrs, &item);\n        completion(result, item);\n        CFRelease(item);\n    });\n}\n```\n\n\n## SecItemUpdate\n\n```\nOSStatus SecItemUpdate(CFDictionaryRef query, CFDictionaryRef attributesToUpdate);\n```\n\n### 参数\n\n**query**\n\n用来指定要更新的条目, 执行更新，需要先查询到要更新的条目。\n参考 SecItemCopyMatching 如何指定查询条件。\n\n**attributesToUpdate**\n\n指定需要更新的属性。\n\n### 返回值\n\n成功或者错误码。参考：[Security Framework Result Codes](https://developer.apple.com/documentation/security/1542001-security_framework_result_codes?language=objc)\n\n### 注意\n\n主线程同步执行会卡UI， 可以异步执行\n```\n- (void)updateKeyChainItemWithAttributes:(CFDictionaryRef)attrs update:(CFDictionaryRef)update completion:(void(^)(OSStatus status))completion {\n    dispatch_async(backgroundQueue, ^{\n        OSStatus updateResult = SecItemUpdate(attrs, update);\n        completion(updateResult);\n    });\n}\n```\n\n## SecItemDelete\n\n```\nOSStatus SecItemDelete(CFDictionaryRef query);\n```\n\n### 参数\n\n**query**\n\n用来指定要删除的的条目， 参考SecItemCopyMatching 如何指定查询条件。\n\n### 返回值\n\n成功或者错误码。参考：[Security Framework Result Codes](https://developer.apple.com/documentation/security/1542001-security_framework_result_codes?language=objc)\n\n### 注意\n\n1. 默认删除所有的匹配项，\n2. 可以通过指定`kSecMatchItemList `来限定删除范围， `kSecMatchItemList`对应的值的类型为`CFArrayRef `, 数组中每一项的类型必须相同，\n\t- 针对临时引用，每一项是一个引用，引用的类型可以是\n\t\t- SecKeychainItemRef,\n\t\t-  SecKeyRef\n\t\t-   SecCertificateRef\n\t\t-   SecIdentityRef\n\t\t-   CFDataRef\n\t- 针对持久化引用, 引用的必须是类型是 `CFDataRef`\n3. 主线程同步执行会卡UI， 可以异步执行\n\n```\n- (void)deleteKeychainItemWithAttributes:(CFDictionaryRef)attrs completion:(void(^)(OSStatus status))completion {\n    dispatch_async(backgroundQueue, ^{\n        OSStatus deleteResult = SecItemDelete(attrs);\n        completion(deleteResult);\n    });\n}\n```\n\n### 什么是临时引用，持久化引用又是什么？\n\n**临时引用**\n\n对应的 key  值是`kSecReturnRef`\n\n> The corresponding value is of type `CFBooleanRef`. A value of `kCFBooleanTrue` indicates that a reference should be returned. Depending on the item class requested, the returned references may be of type `SecKeychainItemRef`, `SecKeyRef`, `SecCertificateRef`, `SecIdentityRef`, or `CFDataRef`.\n\n\n示例 ：SecCertificateRef 证书对象的引用在keychain中存取\n\n创建SecCertificateRef\n\n```\nSecCertificateRef certificate =\n    SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certData);\n\t\t \nif (certificate)  { CFRelease(certificate); } // After you are done with it\n```\n\n将证书存入keychain\n```\nNSDictionary* addquery = @{ (id)kSecValueRef:   (__bridge id)certificate,\n                            (id)kSecClass:      (id)kSecClassCertificate,\n                            (id)kSecAttrLabel:  @\"My Certificate\",\n                           };\n\t\t\t\t\t\t   \n\t\t\t\t\t\t   \nOSStatus status = SecItemAdd((__bridge CFDictionaryRef)addquery, NULL);\nif (status != errSecSuccess) {\n    // Handle the error\n}\t\t\t\t\t\t   \n```\n\n从keychain读取证书\n```\nNSDictionary *getquery = @{ (id)kSecClass:     (id)kSecClassCertificate,\n                            (id)kSecAttrLabel: @\"My Certificate\",\n                            (id)kSecReturnRef: @YES,\n                            };\nSecCertificateRef certificate = NULL;\nOSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)getquery,\n                                      (CFTypeRef *)&certificate);\nif (status != errSecSuccess) { <# Handle error #> }\nelse                         { <# Use certificate #> }\n \nif (certificate) { CFRelease(certificate); } // After you are done with it\n```\n\n观察到这里用的就是 `kSecReturnRef`, 代表临时引用。\n\n- SecKeychainItemRef,\n- SecKeyRef\n-  SecCertificateRef\n-  SecIdentityRef\n-  CFDataRef\n\n**持久化引用**\n\nkey 为 kSecReturnPersistentRef。\n> The corresponding value is of type `CFBooleanRef`. A value of kCFBooleanTrue indicates that a persistent reference to an item should be returned as a `CFDataRef` object. Unlike normal references, a persistent reference may be stored on disk or passed between processes.\n\n1. 一个持久化引用，引用的对象必须是`CFDataRef`\n2. 持久化引用可以存储在磁盘，可以跨进程传递\n\n\n# 示例\n\n##  [Adding a Password to the Keychain](https://developer.apple.com/documentation/security/keychain_services/keychain_items/adding_a_password_to_the_keychain?language=objc)\n\n```\nstruct Credentials {\n    var username: String\n    var password: String\n}\n\nenum KeychainError: Error {\n    case noPassword\n    case unexpectedPasswordData\n    case unhandledError(status: OSStatus)\n}\n\nstatic let server = \"www.example.com\"\n\nlet account = credentials.username\nlet password = credentials.password.data(using: String.Encoding.utf8)!\nvar query: [String: Any] = [kSecClass as String: kSecClassInternetPassword,\n                            kSecAttrAccount as String: account,\n                            kSecAttrServer as String: server,\n                            kSecValueData as String: password]\nlet status = SecItemAdd(query as CFDictionary, nil)\nguard status == errSecSuccess else { throw KeychainError.unhandledError(status: status) }\n\n```\n\n## [Searching for Keychain Items](https://developer.apple.com/documentation/security/keychain_services/keychain_items/searching_for_keychain_items?language=objc)\n\n```\nlet query: [String: Any] = [kSecClass as String: kSecClassInternetPassword,\n                            kSecAttrServer as String: server,\n                            kSecMatchLimit as String: kSecMatchLimitOne,\n                            kSecReturnAttributes as String: true,\n                            kSecReturnData as String: true]\n\nvar item: CFTypeRef?\nlet status = SecItemCopyMatching(query as CFDictionary, &item)\nguard status != errSecItemNotFound else { throw KeychainError.noPassword }\nguard status == errSecSuccess else { throw KeychainError.unhandledError(status: status) }\n\nguard let existingItem = item as? [String : Any],\n    let passwordData = existingItem[kSecValueData as String] as? Data,\n    let password = String(data: passwordData, encoding: String.Encoding.utf8),\n    let account = existingItem[kSecAttrAccount as String] as? String\nelse {\n    throw KeychainError.unexpectedPasswordData\n}\nlet credentials = Credentials(username: account, password: password)\n\n```\n\n## [Updating and Deleting Keychain Items](https://developer.apple.com/documentation/security/keychain_services/keychain_items/updating_and_deleting_keychain_items?language=objc)\n\n```\nlet query: [String: Any] = [kSecClass as String: kSecClassInternetPassword,\n                            kSecAttrServer as String: server]\n\t\t\t\t\t\t\t\nlet account = credentials.username\nlet password = credentials.password.data(using: String.Encoding.utf8)!\nlet attributes: [String: Any] = [kSecAttrAccount as String: account,\n                                 kSecValueData as String: password]\n\n//update\t\t\t\t\t\t\t\t \t\t\t\t\t\t\t\t \nlet status = SecItemUpdate(query as CFDictionary, attributes as CFDictionary)\nguard status != errSecItemNotFound else { throw KeychainError.noPassword }\nguard status == errSecSuccess else { throw KeychainError.unhandledError(status: status) }\t\n\n//delete\nlet status = SecItemDelete(query as CFDictionary)\nguard status == errSecSuccess || status == errSecItemNotFound else { throw KeychainError.unhandledError(status: status) }\n```\n\n# keychain group & app group\n\n参考：[Sharing Access to Keychain Items Among a Collection of Apps](https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps?language=objc)\n\n\n> Enable apps to share keychain items with each other by adding the apps to an access group.\n\n通过keychain group 可以在 app 间共享keychain item。\n\n> An access group is a logical collection of apps tagged with a particular group name string. Any app in a given group can share keychain items with all the other apps in the same group. You can add an app to any number of groups, but the app is always part of at least one group that contains only itself. That is, an app can always store and retrieve private keychain items, regardless of whether it also participates in any other groups. Keychain items, on the other hand, are always part of exactly one group.\n\n默认情况下，app 加入了以自身id 为标记的分组中，这个分组中的所有 keychain item 仅限app 自身访问。\n\n通过加入其他分组，app 间可以通过 keychain group 共享 keychain item。\n\n ## keychain group 类型\n\nYou control the groups that your app belongs to by manipulating its entitlements. In particular, an app belongs to all the groups named in a virtual array of strings that the system forms for each app as the concatenation of the following items, evaluated in this order:\n\n**Keychain access groups**\nThe optional Keychain Access Groups Entitlement holds an array of strings, each of which names an access group.\n\n\n显示指定加入的 keychain group， group id为 `[$(teamID).$(keychain group id)]`\n\n**Application identifier**\nXcode automatically adds the application-identifier entitlement (or the com.apple.application-identifier entitlement in macOS) to every app during code signing, formed as the team identifier (team ID) plus the bundle identifier (bundle ID).\n\n隐式的加入了以自身为组的 keychain group,  group id为 `[$(teamID).$(bundle ID)]`\n\n**Application groups**\nWhen you collect related apps into an application group using the App Groups Entitlement, they share access to a group container, and gain the ability to message each other in certain ways. Starting in iOS 8, the array of strings given by this entitlement also extends the list of keychain access groups.\n\n由于加入了app group， 隐式的加入了以 app group 为组的 keychain group,  group id为 `[$(app group id)]`\n\nXcode handles the application identifier (app ID) for you when you set the bundle ID. You set the others by manipulating capabilities in Xcode.\n\n添加keychain group 和 app group 可以在xcode 中通过操作capabilities来实现。\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16694538450341669453844996.png)\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16694538730181669453872352.png)\n\n## app group 和 keychain group 区别\nApp groups and keychain access groups aren’t mutually exclusive—you can use both in the same app—but they do differ in several important ways that may help you decide which to use for a given situation.\n\n两者不是互相排斥的， 一个app可以同时加入keychain group 和 app group。\n\n\nFirst, as described above, using an app group enables additional data sharing beyond keychain items. You might want this extra sharing, or might already be using an app group for this purpose, and thus not need to add keychain access groups. On the other hand, you might not want to enable this additional sharing at all, and prefer keychain access groups instead.\n\napp group 除了共享 keychain item 之外，还能共享其他内容，例如共享偏好设置\n```\nlet userDefualts = UserDefaults.init(suiteName: \"$(group_Id)\")\nuserDefualts?.setValue(data, forKey: key)\nuserDefualts?.synchronize()\n```\n\n\nSecond, order matters. The system considers the first item in the list of access groups to be the app’s default access group. This is the access group that keychain services assumes if you don’t otherwise specify one when adding keychain items. An app group can’t ever be the default, because the app ID is always present and appears earlier in the list. However, a keychain access group can be the default, because it appears before the app ID. In particular, the first keychain access group, if any, that you specify in the corresponding capability becomes the app’s default access group. If you don’t specify any keychain access groups, then the app ID is the default.\n\n\n关于默认 group， 当添加，查询，更新，删除 keychain item 时，不指定`kSecAttrAccessGroup `时，默认操作的是哪个group ？\n\n1.  系统以 group list 数组中的第一个为默认 group\n2.  默认group 不会是app group， 因为它不会是第一个\n3.  如果加入keychain group， 该 keychain group 可能为默认的 keychain group\n4.  想限定keychain item 只在 app 内访问，不能被keychain group 访问，需要将 bundle id 所在的keychain group 置顶，或者明确指定使用 bundle id 标记的keychain group\n","source":"_posts/ios/2022-11-26-ios keychain 总结.md","raw":"\n---\n\nlayout: post\ntitle: \"ios keychain 总结\"\ndate: 2022-11-26 \ntag: iOS\n\n---\n\n\n# Keychain  是什么\n\n一个加密的数据库， 可以用来存储小的用户数据， 包括\n- kSecClassGenericPassword：通用密码（可以用来存自定义数据）\n- kSecClassInternetPassword：互联网密码\n- kSecClassCertificate：证书\n- kSecClassKey：秘钥\n- kSecClassIdentity：证书+秘钥\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16692950150511669295014987.png)\nFigure 1 Securing the user's secrets in a keychain\n\n打开 mac 系统的 keychain 观察一下， 发现系统有多个keychain，每个keychain都有上图对应的项目\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16694375672261669437566402.png)\n\n\n# 如何管理数据，增删查改\n\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16692963470741669296346746.png)\nFigure 1 Putting data and attributes into a keychain\n\n\nkeychain 将要存储的数据封装为 SecKeychainItemRef，通过存取 SecKeychainItem 来达到对数据的管理。\n\nSecKeychainItemRef 包含\n- data， CFData， 要存取的数据\n- attributes, 该条目的属性，存取权限，查询标签等\n\n提供的api\n\n```\n//添加\nOSStatus SecItemAdd(CFDictionaryRef attributes, CFTypeRef  _Nullable *result);\n//查询\nOSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef  _Nullable *result);\n//更新\nOSStatus SecItemUpdate(CFDictionaryRef query, CFDictionaryRef attributesToUpdate);\n//删除\nOSStatus SecItemDelete(CFDictionaryRef query);\n\n```\n\n## SecItemAdd\n\n```\nOSStatus SecItemAdd(CFDictionaryRef attributes, CFTypeRef  _Nullable *result);\n```\n\n### 参数\n**attributes**\n\n一个字典，描述要添加的数据：\n- 要添加数据类型，对应的 key 为`kSecClass`, value 可以是\n\t- kSecClassGenericPassword：通用密码（可以用来存自定义数据）\n\t- kSecClassInternetPassword：互联网密码\n\t- kSecClassCertificate：证书\n\t- kSecClassKey：秘钥\n\t- kSecClassIdentity：证书+秘钥\n- 数添加的数据本身, key 为 ` kSecValueData`, value 为 `CFDataRef` 类型\n- 关联的属性, 参考：[Item Attribute Keys and Values](https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_attribute_keys_and_values?language=objc)\n\t- 每种类型关联的属性可以不同，例如 kSecClassInternetPassword 可以关联 `kSecAttrServer`, `kSecAttrPort`, `kSecAttrProtocol`， 而 `kSecClassGenericPassword`就没有这些选项\n\t-  `kSecAttrAccessGroup` 可以指定存入的keychain group，这个会影响到查询范围\n- 添加后，返回添加结果的类型，指定类型的数据会存入 result 字段。参考：[ Item Return Result Keys](https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_return_result_keys?language=objc)\n\n**result**\n\n添加结束，函数返回，指向新添加的条目。根据 attributes 中指定的类型，返回对应的值。参考： [ Item Return Result Keys](https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_return_result_keys?language=objc)\n\n一般添加不关心新条目，传nil\n\n### 返回值\n\n成功或者错误码。参考：[Security Framework Result Codes](https://developer.apple.com/documentation/security/1542001-security_framework_result_codes?language=objc)\n\n### 注意\n\n1. kSecAttrAccessGroup 可以指定添加到 钥匙串分组，该分组中的成员共享该条目\n2. 一次添加多条，可以使用`kSecUseItemList `传入字典数组，但是不能用于密码类型\n3. 添加是同步执行，放到主线程可能会卡界面，可以用异步方式\n\n```\n- (void)addKeychainItemWithAttributes:(CFDictionaryRef)attrs completion:(void(^)(OSStatus status, CFTypeRef item))completion {\n    dispatch_async(backgroundQueue, ^{\n        CFTypeRef item = NULL;\n        OSStatus addResult = SecItemAdd(attrs, &item);\n        completion(addResult, item);\n        if (item) {\n            CFRelease(item);\n        }\n    });\n}\n```\n\n## SecItemCopyMatching\n\n```\nOSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef  _Nullable *result);\n```\n\n通过 query 指定查询条件，将查询结果存入 result 中。\n\n### 参数\n\n**query**\n用于指定查询条件\n- 查询的数据类型，通过 `kSecClass` 指定\n- 关联的属性， 用于缩小查询范围\n- 查询参数，返回一条还是多条匹配项，是否大消息敏感，或者从特定项中搜索。参考： [ Search Attribute Keys and Values](https://developer.apple.com/documentation/security/keychain_services/keychain_items/search_attribute_keys_and_values?language=objc)\n- 指定返回类型，指定的类型不同，result 中返回的类型就不同。 参考： [Item Return Result Keys ](https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_return_result_keys?language=objc)\n\n**result **\n\n保存查询结果。\n例如： 指定  `kSecReturnData: kCFBooleanTrue`  ，result 中存的就是`CFDataRef `类型的数据。参考： [Item Return Result Keys](https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_return_result_keys?language=objc)\n\n### 返回值\n\n成功或者错误码。参考：[Security Framework Result Codes](https://developer.apple.com/documentation/security/1542001-security_framework_result_codes?language=objc)\n\n### 注意\n\n1. 默认返回第一个匹配项，如果想查询多条匹配，指定 `kSecMatchLimit`  大于1， 此时 result 为 `CFArrayRef`  类型\n2. 当类型为`kSecInternetPasswordItemClass` 或 `kSecGenericPasswordItemClass`时， 不能同时指定`kSecReturnData` 和 `kSecMatchLimitAll`, 原因是拷贝每个密码时，需要额外的授权验证。\n3. 默认情况下，会搜索当前keychain 以及所有加入的 keychain group， 通过 `kSecAttrAccessGroup` 可以指定要在哪个 keychain group 查询\n4. 主线程同步执行会卡UI， 可以异步执行\n\n```\n- (void)findKeychainItemWithAttributes:(NSDictionary *)attributes completion:(void(^)(OSStatus status, CFTypeRef item))completion {\n    dispatch_async(backgroundQueue, ^{\n        CFDictionaryRef attrs = (__bridge CFDictionaryRef)attributes;\n        CFTypeRef item = NULL;\n        OSStatus result = SecItemCopyMatching(attrs, &item);\n        completion(result, item);\n        CFRelease(item);\n    });\n}\n```\n\n\n## SecItemUpdate\n\n```\nOSStatus SecItemUpdate(CFDictionaryRef query, CFDictionaryRef attributesToUpdate);\n```\n\n### 参数\n\n**query**\n\n用来指定要更新的条目, 执行更新，需要先查询到要更新的条目。\n参考 SecItemCopyMatching 如何指定查询条件。\n\n**attributesToUpdate**\n\n指定需要更新的属性。\n\n### 返回值\n\n成功或者错误码。参考：[Security Framework Result Codes](https://developer.apple.com/documentation/security/1542001-security_framework_result_codes?language=objc)\n\n### 注意\n\n主线程同步执行会卡UI， 可以异步执行\n```\n- (void)updateKeyChainItemWithAttributes:(CFDictionaryRef)attrs update:(CFDictionaryRef)update completion:(void(^)(OSStatus status))completion {\n    dispatch_async(backgroundQueue, ^{\n        OSStatus updateResult = SecItemUpdate(attrs, update);\n        completion(updateResult);\n    });\n}\n```\n\n## SecItemDelete\n\n```\nOSStatus SecItemDelete(CFDictionaryRef query);\n```\n\n### 参数\n\n**query**\n\n用来指定要删除的的条目， 参考SecItemCopyMatching 如何指定查询条件。\n\n### 返回值\n\n成功或者错误码。参考：[Security Framework Result Codes](https://developer.apple.com/documentation/security/1542001-security_framework_result_codes?language=objc)\n\n### 注意\n\n1. 默认删除所有的匹配项，\n2. 可以通过指定`kSecMatchItemList `来限定删除范围， `kSecMatchItemList`对应的值的类型为`CFArrayRef `, 数组中每一项的类型必须相同，\n\t- 针对临时引用，每一项是一个引用，引用的类型可以是\n\t\t- SecKeychainItemRef,\n\t\t-  SecKeyRef\n\t\t-   SecCertificateRef\n\t\t-   SecIdentityRef\n\t\t-   CFDataRef\n\t- 针对持久化引用, 引用的必须是类型是 `CFDataRef`\n3. 主线程同步执行会卡UI， 可以异步执行\n\n```\n- (void)deleteKeychainItemWithAttributes:(CFDictionaryRef)attrs completion:(void(^)(OSStatus status))completion {\n    dispatch_async(backgroundQueue, ^{\n        OSStatus deleteResult = SecItemDelete(attrs);\n        completion(deleteResult);\n    });\n}\n```\n\n### 什么是临时引用，持久化引用又是什么？\n\n**临时引用**\n\n对应的 key  值是`kSecReturnRef`\n\n> The corresponding value is of type `CFBooleanRef`. A value of `kCFBooleanTrue` indicates that a reference should be returned. Depending on the item class requested, the returned references may be of type `SecKeychainItemRef`, `SecKeyRef`, `SecCertificateRef`, `SecIdentityRef`, or `CFDataRef`.\n\n\n示例 ：SecCertificateRef 证书对象的引用在keychain中存取\n\n创建SecCertificateRef\n\n```\nSecCertificateRef certificate =\n    SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certData);\n\t\t \nif (certificate)  { CFRelease(certificate); } // After you are done with it\n```\n\n将证书存入keychain\n```\nNSDictionary* addquery = @{ (id)kSecValueRef:   (__bridge id)certificate,\n                            (id)kSecClass:      (id)kSecClassCertificate,\n                            (id)kSecAttrLabel:  @\"My Certificate\",\n                           };\n\t\t\t\t\t\t   \n\t\t\t\t\t\t   \nOSStatus status = SecItemAdd((__bridge CFDictionaryRef)addquery, NULL);\nif (status != errSecSuccess) {\n    // Handle the error\n}\t\t\t\t\t\t   \n```\n\n从keychain读取证书\n```\nNSDictionary *getquery = @{ (id)kSecClass:     (id)kSecClassCertificate,\n                            (id)kSecAttrLabel: @\"My Certificate\",\n                            (id)kSecReturnRef: @YES,\n                            };\nSecCertificateRef certificate = NULL;\nOSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)getquery,\n                                      (CFTypeRef *)&certificate);\nif (status != errSecSuccess) { <# Handle error #> }\nelse                         { <# Use certificate #> }\n \nif (certificate) { CFRelease(certificate); } // After you are done with it\n```\n\n观察到这里用的就是 `kSecReturnRef`, 代表临时引用。\n\n- SecKeychainItemRef,\n- SecKeyRef\n-  SecCertificateRef\n-  SecIdentityRef\n-  CFDataRef\n\n**持久化引用**\n\nkey 为 kSecReturnPersistentRef。\n> The corresponding value is of type `CFBooleanRef`. A value of kCFBooleanTrue indicates that a persistent reference to an item should be returned as a `CFDataRef` object. Unlike normal references, a persistent reference may be stored on disk or passed between processes.\n\n1. 一个持久化引用，引用的对象必须是`CFDataRef`\n2. 持久化引用可以存储在磁盘，可以跨进程传递\n\n\n# 示例\n\n##  [Adding a Password to the Keychain](https://developer.apple.com/documentation/security/keychain_services/keychain_items/adding_a_password_to_the_keychain?language=objc)\n\n```\nstruct Credentials {\n    var username: String\n    var password: String\n}\n\nenum KeychainError: Error {\n    case noPassword\n    case unexpectedPasswordData\n    case unhandledError(status: OSStatus)\n}\n\nstatic let server = \"www.example.com\"\n\nlet account = credentials.username\nlet password = credentials.password.data(using: String.Encoding.utf8)!\nvar query: [String: Any] = [kSecClass as String: kSecClassInternetPassword,\n                            kSecAttrAccount as String: account,\n                            kSecAttrServer as String: server,\n                            kSecValueData as String: password]\nlet status = SecItemAdd(query as CFDictionary, nil)\nguard status == errSecSuccess else { throw KeychainError.unhandledError(status: status) }\n\n```\n\n## [Searching for Keychain Items](https://developer.apple.com/documentation/security/keychain_services/keychain_items/searching_for_keychain_items?language=objc)\n\n```\nlet query: [String: Any] = [kSecClass as String: kSecClassInternetPassword,\n                            kSecAttrServer as String: server,\n                            kSecMatchLimit as String: kSecMatchLimitOne,\n                            kSecReturnAttributes as String: true,\n                            kSecReturnData as String: true]\n\nvar item: CFTypeRef?\nlet status = SecItemCopyMatching(query as CFDictionary, &item)\nguard status != errSecItemNotFound else { throw KeychainError.noPassword }\nguard status == errSecSuccess else { throw KeychainError.unhandledError(status: status) }\n\nguard let existingItem = item as? [String : Any],\n    let passwordData = existingItem[kSecValueData as String] as? Data,\n    let password = String(data: passwordData, encoding: String.Encoding.utf8),\n    let account = existingItem[kSecAttrAccount as String] as? String\nelse {\n    throw KeychainError.unexpectedPasswordData\n}\nlet credentials = Credentials(username: account, password: password)\n\n```\n\n## [Updating and Deleting Keychain Items](https://developer.apple.com/documentation/security/keychain_services/keychain_items/updating_and_deleting_keychain_items?language=objc)\n\n```\nlet query: [String: Any] = [kSecClass as String: kSecClassInternetPassword,\n                            kSecAttrServer as String: server]\n\t\t\t\t\t\t\t\nlet account = credentials.username\nlet password = credentials.password.data(using: String.Encoding.utf8)!\nlet attributes: [String: Any] = [kSecAttrAccount as String: account,\n                                 kSecValueData as String: password]\n\n//update\t\t\t\t\t\t\t\t \t\t\t\t\t\t\t\t \nlet status = SecItemUpdate(query as CFDictionary, attributes as CFDictionary)\nguard status != errSecItemNotFound else { throw KeychainError.noPassword }\nguard status == errSecSuccess else { throw KeychainError.unhandledError(status: status) }\t\n\n//delete\nlet status = SecItemDelete(query as CFDictionary)\nguard status == errSecSuccess || status == errSecItemNotFound else { throw KeychainError.unhandledError(status: status) }\n```\n\n# keychain group & app group\n\n参考：[Sharing Access to Keychain Items Among a Collection of Apps](https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps?language=objc)\n\n\n> Enable apps to share keychain items with each other by adding the apps to an access group.\n\n通过keychain group 可以在 app 间共享keychain item。\n\n> An access group is a logical collection of apps tagged with a particular group name string. Any app in a given group can share keychain items with all the other apps in the same group. You can add an app to any number of groups, but the app is always part of at least one group that contains only itself. That is, an app can always store and retrieve private keychain items, regardless of whether it also participates in any other groups. Keychain items, on the other hand, are always part of exactly one group.\n\n默认情况下，app 加入了以自身id 为标记的分组中，这个分组中的所有 keychain item 仅限app 自身访问。\n\n通过加入其他分组，app 间可以通过 keychain group 共享 keychain item。\n\n ## keychain group 类型\n\nYou control the groups that your app belongs to by manipulating its entitlements. In particular, an app belongs to all the groups named in a virtual array of strings that the system forms for each app as the concatenation of the following items, evaluated in this order:\n\n**Keychain access groups**\nThe optional Keychain Access Groups Entitlement holds an array of strings, each of which names an access group.\n\n\n显示指定加入的 keychain group， group id为 `[$(teamID).$(keychain group id)]`\n\n**Application identifier**\nXcode automatically adds the application-identifier entitlement (or the com.apple.application-identifier entitlement in macOS) to every app during code signing, formed as the team identifier (team ID) plus the bundle identifier (bundle ID).\n\n隐式的加入了以自身为组的 keychain group,  group id为 `[$(teamID).$(bundle ID)]`\n\n**Application groups**\nWhen you collect related apps into an application group using the App Groups Entitlement, they share access to a group container, and gain the ability to message each other in certain ways. Starting in iOS 8, the array of strings given by this entitlement also extends the list of keychain access groups.\n\n由于加入了app group， 隐式的加入了以 app group 为组的 keychain group,  group id为 `[$(app group id)]`\n\nXcode handles the application identifier (app ID) for you when you set the bundle ID. You set the others by manipulating capabilities in Xcode.\n\n添加keychain group 和 app group 可以在xcode 中通过操作capabilities来实现。\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16694538450341669453844996.png)\n![](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16694538730181669453872352.png)\n\n## app group 和 keychain group 区别\nApp groups and keychain access groups aren’t mutually exclusive—you can use both in the same app—but they do differ in several important ways that may help you decide which to use for a given situation.\n\n两者不是互相排斥的， 一个app可以同时加入keychain group 和 app group。\n\n\nFirst, as described above, using an app group enables additional data sharing beyond keychain items. You might want this extra sharing, or might already be using an app group for this purpose, and thus not need to add keychain access groups. On the other hand, you might not want to enable this additional sharing at all, and prefer keychain access groups instead.\n\napp group 除了共享 keychain item 之外，还能共享其他内容，例如共享偏好设置\n```\nlet userDefualts = UserDefaults.init(suiteName: \"$(group_Id)\")\nuserDefualts?.setValue(data, forKey: key)\nuserDefualts?.synchronize()\n```\n\n\nSecond, order matters. The system considers the first item in the list of access groups to be the app’s default access group. This is the access group that keychain services assumes if you don’t otherwise specify one when adding keychain items. An app group can’t ever be the default, because the app ID is always present and appears earlier in the list. However, a keychain access group can be the default, because it appears before the app ID. In particular, the first keychain access group, if any, that you specify in the corresponding capability becomes the app’s default access group. If you don’t specify any keychain access groups, then the app ID is the default.\n\n\n关于默认 group， 当添加，查询，更新，删除 keychain item 时，不指定`kSecAttrAccessGroup `时，默认操作的是哪个group ？\n\n1.  系统以 group list 数组中的第一个为默认 group\n2.  默认group 不会是app group， 因为它不会是第一个\n3.  如果加入keychain group， 该 keychain group 可能为默认的 keychain group\n4.  想限定keychain item 只在 app 内访问，不能被keychain group 访问，需要将 bundle id 所在的keychain group 置顶，或者明确指定使用 bundle id 标记的keychain group\n","slug":"ios/2022-11-26-ios keychain 总结","published":1,"updated":"2024-03-06T11:53:13.567Z","comments":1,"photos":[],"_id":"cltgopenf002eqywh5q3w0oza","content":"<h1 id=\"Keychain-是什么\"><a href=\"#Keychain-是什么\" class=\"headerlink\" title=\"Keychain  是什么\"></a>Keychain  是什么</h1><p>一个加密的数据库， 可以用来存储小的用户数据， 包括</p>\n<ul>\n<li>kSecClassGenericPassword：通用密码（可以用来存自定义数据）</li>\n<li>kSecClassInternetPassword：互联网密码</li>\n<li>kSecClassCertificate：证书</li>\n<li>kSecClassKey：秘钥</li>\n<li>kSecClassIdentity：证书+秘钥</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16692950150511669295014987.png\"><br>Figure 1 Securing the user’s secrets in a keychain</p>\n<p>打开 mac 系统的 keychain 观察一下， 发现系统有多个keychain，每个keychain都有上图对应的项目<br><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16694375672261669437566402.png\"></p>\n<h1 id=\"如何管理数据，增删查改\"><a href=\"#如何管理数据，增删查改\" class=\"headerlink\" title=\"如何管理数据，增删查改\"></a>如何管理数据，增删查改</h1><p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16692963470741669296346746.png\"><br>Figure 1 Putting data and attributes into a keychain</p>\n<p>keychain 将要存储的数据封装为 SecKeychainItemRef，通过存取 SecKeychainItem 来达到对数据的管理。</p>\n<p>SecKeychainItemRef 包含</p>\n<ul>\n<li>data， CFData， 要存取的数据</li>\n<li>attributes, 该条目的属性，存取权限，查询标签等</li>\n</ul>\n<p>提供的api</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//添加</span><br>OSStatus <span class=\"hljs-built_in\">SecItemAdd</span>(CFDictionaryRef attributes, CFTypeRef  _Nullable *result);<br><span class=\"hljs-comment\">//查询</span><br>OSStatus <span class=\"hljs-built_in\">SecItemCopyMatching</span>(CFDictionaryRef query, CFTypeRef  _Nullable *result);<br><span class=\"hljs-comment\">//更新</span><br>OSStatus <span class=\"hljs-built_in\">SecItemUpdate</span>(CFDictionaryRef query, CFDictionaryRef attributesToUpdate);<br><span class=\"hljs-comment\">//删除</span><br>OSStatus <span class=\"hljs-built_in\">SecItemDelete</span>(CFDictionaryRef query);<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"SecItemAdd\"><a href=\"#SecItemAdd\" class=\"headerlink\" title=\"SecItemAdd\"></a>SecItemAdd</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\">OSStatus SecItemAdd(<span class=\"hljs-built_in\">CFDictionaryRef</span> attributes, <span class=\"hljs-built_in\">CFTypeRef</span>  _Nullable *result);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p><strong>attributes</strong></p>\n<p>一个字典，描述要添加的数据：</p>\n<ul>\n<li>要添加数据类型，对应的 key 为<code>kSecClass</code>, value 可以是<ul>\n<li>kSecClassGenericPassword：通用密码（可以用来存自定义数据）</li>\n<li>kSecClassInternetPassword：互联网密码</li>\n<li>kSecClassCertificate：证书</li>\n<li>kSecClassKey：秘钥</li>\n<li>kSecClassIdentity：证书+秘钥</li>\n</ul>\n</li>\n<li>数添加的数据本身, key 为 <code> kSecValueData</code>, value 为 <code>CFDataRef</code> 类型</li>\n<li>关联的属性, 参考：<a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_attribute_keys_and_values?language=objc\">Item Attribute Keys and Values</a><ul>\n<li>每种类型关联的属性可以不同，例如 kSecClassInternetPassword 可以关联 <code>kSecAttrServer</code>, <code>kSecAttrPort</code>, <code>kSecAttrProtocol</code>， 而 <code>kSecClassGenericPassword</code>就没有这些选项</li>\n<li><code>kSecAttrAccessGroup</code> 可以指定存入的keychain group，这个会影响到查询范围</li>\n</ul>\n</li>\n<li>添加后，返回添加结果的类型，指定类型的数据会存入 result 字段。参考：<a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_return_result_keys?language=objc\"> Item Return Result Keys</a></li>\n</ul>\n<p><strong>result</strong></p>\n<p>添加结束，函数返回，指向新添加的条目。根据 attributes 中指定的类型，返回对应的值。参考： <a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_return_result_keys?language=objc\"> Item Return Result Keys</a></p>\n<p>一般添加不关心新条目，传nil</p>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>成功或者错误码。参考：<a href=\"https://developer.apple.com/documentation/security/1542001-security_framework_result_codes?language=objc\">Security Framework Result Codes</a></p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ol>\n<li>kSecAttrAccessGroup 可以指定添加到 钥匙串分组，该分组中的成员共享该条目</li>\n<li>一次添加多条，可以使用<code>kSecUseItemList </code>传入字典数组，但是不能用于密码类型</li>\n<li>添加是同步执行，放到主线程可能会卡界面，可以用异步方式</li>\n</ol>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">- (void)addKeychainItemWithAttributes:(CFDictionaryRef)attrs completion:(<span class=\"hljs-built_in\">void</span>(^)(OSStatus status, CFTypeRef item))completion &#123;<br>    <span class=\"hljs-built_in\">dispatch_async</span>(backgroundQueue, ^&#123;<br>        CFTypeRef item = NULL;<br>        OSStatus addResult = SecItemAdd(attrs, &amp;item);<br>        <span class=\"hljs-built_in\">completion</span>(addResult, item);<br>        if (item) &#123;<br>            <span class=\"hljs-built_in\">CFRelease</span>(item);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"SecItemCopyMatching\"><a href=\"#SecItemCopyMatching\" class=\"headerlink\" title=\"SecItemCopyMatching\"></a>SecItemCopyMatching</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\">OSStatus SecItemCopyMatching(<span class=\"hljs-built_in\">CFDictionaryRef</span> query, <span class=\"hljs-built_in\">CFTypeRef</span>  _Nullable *result);<br></code></pre></td></tr></table></figure>\n\n<p>通过 query 指定查询条件，将查询结果存入 result 中。</p>\n<h3 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p><strong>query</strong><br>用于指定查询条件</p>\n<ul>\n<li>查询的数据类型，通过 <code>kSecClass</code> 指定</li>\n<li>关联的属性， 用于缩小查询范围</li>\n<li>查询参数，返回一条还是多条匹配项，是否大消息敏感，或者从特定项中搜索。参考： <a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/search_attribute_keys_and_values?language=objc\"> Search Attribute Keys and Values</a></li>\n<li>指定返回类型，指定的类型不同，result 中返回的类型就不同。 参考： <a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_return_result_keys?language=objc\">Item Return Result Keys </a></li>\n</ul>\n<p>**result **</p>\n<p>保存查询结果。<br>例如： 指定  <code>kSecReturnData: kCFBooleanTrue</code>  ，result 中存的就是<code>CFDataRef </code>类型的数据。参考： <a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_return_result_keys?language=objc\">Item Return Result Keys</a></p>\n<h3 id=\"返回值-1\"><a href=\"#返回值-1\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>成功或者错误码。参考：<a href=\"https://developer.apple.com/documentation/security/1542001-security_framework_result_codes?language=objc\">Security Framework Result Codes</a></p>\n<h3 id=\"注意-1\"><a href=\"#注意-1\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ol>\n<li>默认返回第一个匹配项，如果想查询多条匹配，指定 <code>kSecMatchLimit</code>  大于1， 此时 result 为 <code>CFArrayRef</code>  类型</li>\n<li>当类型为<code>kSecInternetPasswordItemClass</code> 或 <code>kSecGenericPasswordItemClass</code>时， 不能同时指定<code>kSecReturnData</code> 和 <code>kSecMatchLimitAll</code>, 原因是拷贝每个密码时，需要额外的授权验证。</li>\n<li>默认情况下，会搜索当前keychain 以及所有加入的 keychain group， 通过 <code>kSecAttrAccessGroup</code> 可以指定要在哪个 keychain group 查询</li>\n<li>主线程同步执行会卡UI， 可以异步执行</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\">- (<span class=\"hljs-type\">void</span>)findKeychainItemWithAttributes:(<span class=\"hljs-built_in\">NSDictionary</span> *)attributes completion:(<span class=\"hljs-type\">void</span>(^)(OSStatus status, <span class=\"hljs-built_in\">CFTypeRef</span> item))completion &#123;<br>    <span class=\"hljs-built_in\">dispatch_async</span>(backgroundQueue, ^&#123;<br>        <span class=\"hljs-built_in\">CFDictionaryRef</span> attrs = (__bridge <span class=\"hljs-built_in\">CFDictionaryRef</span>)attributes;<br>        <span class=\"hljs-built_in\">CFTypeRef</span> item = <span class=\"hljs-literal\">NULL</span>;<br>        OSStatus result = SecItemCopyMatching(attrs, &amp;item);<br>        completion(result, item);<br>        <span class=\"hljs-built_in\">CFRelease</span>(item);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"SecItemUpdate\"><a href=\"#SecItemUpdate\" class=\"headerlink\" title=\"SecItemUpdate\"></a>SecItemUpdate</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\">OSStatus SecItemUpdate(<span class=\"hljs-built_in\">CFDictionaryRef</span> query, <span class=\"hljs-built_in\">CFDictionaryRef</span> attributesToUpdate);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"参数-2\"><a href=\"#参数-2\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p><strong>query</strong></p>\n<p>用来指定要更新的条目, 执行更新，需要先查询到要更新的条目。<br>参考 SecItemCopyMatching 如何指定查询条件。</p>\n<p><strong>attributesToUpdate</strong></p>\n<p>指定需要更新的属性。</p>\n<h3 id=\"返回值-2\"><a href=\"#返回值-2\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>成功或者错误码。参考：<a href=\"https://developer.apple.com/documentation/security/1542001-security_framework_result_codes?language=objc\">Security Framework Result Codes</a></p>\n<h3 id=\"注意-2\"><a href=\"#注意-2\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>主线程同步执行会卡UI， 可以异步执行</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">- (void)updateKeyChainItemWithAttributes:(CFDictionaryRef)attrs update:(CFDictionaryRef)update completion:(<span class=\"hljs-built_in\">void</span>(^)(OSStatus status))completion &#123;<br>    <span class=\"hljs-built_in\">dispatch_async</span>(backgroundQueue, ^&#123;<br>        OSStatus updateResult = SecItemUpdate(attrs, update);<br>        <span class=\"hljs-built_in\">completion</span>(updateResult);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"SecItemDelete\"><a href=\"#SecItemDelete\" class=\"headerlink\" title=\"SecItemDelete\"></a>SecItemDelete</h2><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">OSStatus <span class=\"hljs-built_in\">SecItemDelete</span>(CFDictionaryRef query);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"参数-3\"><a href=\"#参数-3\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p><strong>query</strong></p>\n<p>用来指定要删除的的条目， 参考SecItemCopyMatching 如何指定查询条件。</p>\n<h3 id=\"返回值-3\"><a href=\"#返回值-3\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>成功或者错误码。参考：<a href=\"https://developer.apple.com/documentation/security/1542001-security_framework_result_codes?language=objc\">Security Framework Result Codes</a></p>\n<h3 id=\"注意-3\"><a href=\"#注意-3\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ol>\n<li>默认删除所有的匹配项，</li>\n<li>可以通过指定<code>kSecMatchItemList </code>来限定删除范围， <code>kSecMatchItemList</code>对应的值的类型为<code>CFArrayRef </code>, 数组中每一项的类型必须相同，<ul>\n<li>针对临时引用，每一项是一个引用，引用的类型可以是<ul>\n<li>SecKeychainItemRef,</li>\n<li>SecKeyRef</li>\n<li>SecCertificateRef</li>\n<li>SecIdentityRef</li>\n<li>CFDataRef</li>\n</ul>\n</li>\n<li>针对持久化引用, 引用的必须是类型是 <code>CFDataRef</code></li>\n</ul>\n</li>\n<li>主线程同步执行会卡UI， 可以异步执行</li>\n</ol>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">- (void)deleteKeychainItemWithAttributes:(CFDictionaryRef)attrs completion:(<span class=\"hljs-built_in\">void</span>(^)(OSStatus status))completion &#123;<br>    <span class=\"hljs-built_in\">dispatch_async</span>(backgroundQueue, ^&#123;<br>        OSStatus deleteResult = SecItemDelete(attrs);<br>        <span class=\"hljs-built_in\">completion</span>(deleteResult);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"什么是临时引用，持久化引用又是什么？\"><a href=\"#什么是临时引用，持久化引用又是什么？\" class=\"headerlink\" title=\"什么是临时引用，持久化引用又是什么？\"></a>什么是临时引用，持久化引用又是什么？</h3><p><strong>临时引用</strong></p>\n<p>对应的 key  值是<code>kSecReturnRef</code></p>\n<blockquote>\n<p>The corresponding value is of type <code>CFBooleanRef</code>. A value of <code>kCFBooleanTrue</code> indicates that a reference should be returned. Depending on the item class requested, the returned references may be of type <code>SecKeychainItemRef</code>, <code>SecKeyRef</code>, <code>SecCertificateRef</code>, <code>SecIdentityRef</code>, or <code>CFDataRef</code>.</p>\n</blockquote>\n<p>示例 ：SecCertificateRef 证书对象的引用在keychain中存取</p>\n<p>创建SecCertificateRef</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\">SecCertificateRef certificate =<br>    SecCertificateCreateWithData<span class=\"hljs-comment\">(NULL, (__bridge CFDataRef)</span>certData);<br>\t\t <br><span class=\"hljs-keyword\">if</span> <span class=\"hljs-comment\">(certificate)</span>  &#123; CFRelease<span class=\"hljs-comment\">(certificate)</span>; &#125; <span class=\"hljs-comment\">// After you are done with it</span><br></code></pre></td></tr></table></figure>\n\n<p>将证书存入keychain</p>\n<figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\">NSDictionary<span class=\"hljs-operator\">*</span> addquery <span class=\"hljs-operator\">=</span> <span class=\"hljs-operator\">@</span>&#123; (<span class=\"hljs-built_in\">id</span>)kSecValueRef<span class=\"hljs-operator\">:</span>   (__bridge <span class=\"hljs-built_in\">id</span>)certificate,<br>                            (<span class=\"hljs-built_in\">id</span>)kSecClass<span class=\"hljs-operator\">:</span>      (<span class=\"hljs-built_in\">id</span>)kSecClassCertificate,<br>                            (<span class=\"hljs-built_in\">id</span>)kSecAttrLabel<span class=\"hljs-operator\">:</span>  <span class=\"hljs-string\">@&quot;My Certificate&quot;</span>,<br>                           &#125;;<br>\t\t\t\t\t\t   <br>\t\t\t\t\t\t   <br>OSStatus status <span class=\"hljs-operator\">=</span> SecItemAdd((__bridge CFDictionaryRef)addquery, NULL);<br><span class=\"hljs-keyword\">if</span> (status <span class=\"hljs-operator\">!=</span> errSecSuccess) &#123;<br>    <span class=\"hljs-comment\">// Handle the error</span><br>&#125;\t\t\t\t\t\t   <br></code></pre></td></tr></table></figure>\n\n<p>从keychain读取证书</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\"><span class=\"hljs-built_in\">NSDictionary</span> *getquery = @&#123; (<span class=\"hljs-type\">id</span>)kSecClass:     (<span class=\"hljs-type\">id</span>)kSecClassCertificate,<br>                            (<span class=\"hljs-type\">id</span>)kSecAttrLabel: <span class=\"hljs-string\">@&quot;My Certificate&quot;</span>,<br>                            (<span class=\"hljs-type\">id</span>)kSecReturnRef: @YES,<br>                            &#125;;<br>SecCertificateRef certificate = <span class=\"hljs-literal\">NULL</span>;<br>OSStatus status = SecItemCopyMatching((__bridge <span class=\"hljs-built_in\">CFDictionaryRef</span>)getquery,<br>                                      (<span class=\"hljs-built_in\">CFTypeRef</span> *)&amp;certificate);<br><span class=\"hljs-keyword\">if</span> (status != errSecSuccess) &#123; &lt;# Handle error #&gt; &#125;<br><span class=\"hljs-keyword\">else</span>                         &#123; &lt;# Use certificate #&gt; &#125;<br> <br><span class=\"hljs-keyword\">if</span> (certificate) &#123; <span class=\"hljs-built_in\">CFRelease</span>(certificate); &#125; <span class=\"hljs-comment\">// After you are done with it</span><br></code></pre></td></tr></table></figure>\n\n<p>观察到这里用的就是 <code>kSecReturnRef</code>, 代表临时引用。</p>\n<ul>\n<li>SecKeychainItemRef,</li>\n<li>SecKeyRef</li>\n<li>SecCertificateRef</li>\n<li>SecIdentityRef</li>\n<li>CFDataRef</li>\n</ul>\n<p><strong>持久化引用</strong></p>\n<p>key 为 kSecReturnPersistentRef。</p>\n<blockquote>\n<p>The corresponding value is of type <code>CFBooleanRef</code>. A value of kCFBooleanTrue indicates that a persistent reference to an item should be returned as a <code>CFDataRef</code> object. Unlike normal references, a persistent reference may be stored on disk or passed between processes.</p>\n</blockquote>\n<ol>\n<li>一个持久化引用，引用的对象必须是<code>CFDataRef</code></li>\n<li>持久化引用可以存储在磁盘，可以跨进程传递</li>\n</ol>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><h2 id=\"Adding-a-Password-to-the-Keychain\"><a href=\"#Adding-a-Password-to-the-Keychain\" class=\"headerlink\" title=\"Adding a Password to the Keychain\"></a><a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/adding_a_password_to_the_keychain?language=objc\">Adding a Password to the Keychain</a></h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\">struct <span class=\"hljs-title class_\">Credentials</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">username</span>: <span class=\"hljs-title class_\">String</span><br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">password</span>: <span class=\"hljs-title class_\">String</span><br>&#125;<br><br><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">KeychainError</span>: <span class=\"hljs-title class_\">Error</span> &#123;<br>    <span class=\"hljs-keyword\">case</span> noPassword<br>    <span class=\"hljs-keyword\">case</span> unexpectedPasswordData<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title function_\">unhandledError</span>(<span class=\"hljs-attr\">status</span>: <span class=\"hljs-title class_\">OSStatus</span>)<br>&#125;<br><br><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">let</span> server = <span class=\"hljs-string\">&quot;www.example.com&quot;</span><br><br><span class=\"hljs-keyword\">let</span> account = credentials.<span class=\"hljs-property\">username</span><br><span class=\"hljs-keyword\">let</span> password = credentials.<span class=\"hljs-property\">password</span>.<span class=\"hljs-title function_\">data</span>(<span class=\"hljs-attr\">using</span>: <span class=\"hljs-title class_\">String</span>.<span class=\"hljs-property\">Encoding</span>.<span class=\"hljs-property\">utf8</span>)!<br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">query</span>: [<span class=\"hljs-title class_\">String</span>: <span class=\"hljs-title class_\">Any</span>] = [kSecClass <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">String</span>: kSecClassInternetPassword,<br>                            kSecAttrAccount <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">String</span>: account,<br>                            kSecAttrServer <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">String</span>: server,<br>                            kSecValueData <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">String</span>: password]<br><span class=\"hljs-keyword\">let</span> status = <span class=\"hljs-title class_\">SecItemAdd</span>(query <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">CFDictionary</span>, nil)<br>guard status == errSecSuccess <span class=\"hljs-keyword\">else</span> &#123; <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">KeychainError</span>.<span class=\"hljs-title function_\">unhandledError</span>(<span class=\"hljs-attr\">status</span>: status) &#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Searching-for-Keychain-Items\"><a href=\"#Searching-for-Keychain-Items\" class=\"headerlink\" title=\"Searching for Keychain Items\"></a><a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/searching_for_keychain_items?language=objc\">Searching for Keychain Items</a></h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">let</span> query: [<span class=\"hljs-type\">String</span>: <span class=\"hljs-keyword\">Any</span>] <span class=\"hljs-operator\">=</span> [kSecClass <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>: kSecClassInternetPassword,<br>                            kSecAttrServer <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>: server,<br>                            kSecMatchLimit <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>: kSecMatchLimitOne,<br>                            kSecReturnAttributes <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>: <span class=\"hljs-literal\">true</span>,<br>                            kSecReturnData <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>: <span class=\"hljs-literal\">true</span>]<br><br><span class=\"hljs-keyword\">var</span> item: <span class=\"hljs-type\">CFTypeRef</span>?<br><span class=\"hljs-keyword\">let</span> status <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">SecItemCopyMatching</span>(query <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">CFDictionary</span>, <span class=\"hljs-operator\">&amp;</span>item)<br><span class=\"hljs-keyword\">guard</span> status <span class=\"hljs-operator\">!=</span> errSecItemNotFound <span class=\"hljs-keyword\">else</span> &#123; <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-type\">KeychainError</span>.noPassword &#125;<br><span class=\"hljs-keyword\">guard</span> status <span class=\"hljs-operator\">==</span> errSecSuccess <span class=\"hljs-keyword\">else</span> &#123; <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-type\">KeychainError</span>.unhandledError(status: status) &#125;<br><br><span class=\"hljs-keyword\">guard</span> <span class=\"hljs-keyword\">let</span> existingItem <span class=\"hljs-operator\">=</span> item <span class=\"hljs-keyword\">as?</span> [<span class=\"hljs-type\">String</span> : <span class=\"hljs-keyword\">Any</span>],<br>    <span class=\"hljs-keyword\">let</span> passwordData <span class=\"hljs-operator\">=</span> existingItem[kSecValueData <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>] <span class=\"hljs-keyword\">as?</span> <span class=\"hljs-type\">Data</span>,<br>    <span class=\"hljs-keyword\">let</span> password <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">String</span>(data: passwordData, encoding: <span class=\"hljs-type\">String</span>.<span class=\"hljs-type\">Encoding</span>.utf8),<br>    <span class=\"hljs-keyword\">let</span> account <span class=\"hljs-operator\">=</span> existingItem[kSecAttrAccount <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>] <span class=\"hljs-keyword\">as?</span> <span class=\"hljs-type\">String</span><br><span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-type\">KeychainError</span>.unexpectedPasswordData<br>&#125;<br><span class=\"hljs-keyword\">let</span> credentials <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Credentials</span>(username: account, password: password)<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Updating-and-Deleting-Keychain-Items\"><a href=\"#Updating-and-Deleting-Keychain-Items\" class=\"headerlink\" title=\"Updating and Deleting Keychain Items\"></a><a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/updating_and_deleting_keychain_items?language=objc\">Updating and Deleting Keychain Items</a></h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">let</span> query: [<span class=\"hljs-type\">String</span>: <span class=\"hljs-keyword\">Any</span>] <span class=\"hljs-operator\">=</span> [kSecClass <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>: kSecClassInternetPassword,<br>                            kSecAttrServer <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>: server]<br>\t\t\t\t\t\t\t<br><span class=\"hljs-keyword\">let</span> account <span class=\"hljs-operator\">=</span> credentials.username<br><span class=\"hljs-keyword\">let</span> password <span class=\"hljs-operator\">=</span> credentials.password.data(using: <span class=\"hljs-type\">String</span>.<span class=\"hljs-type\">Encoding</span>.utf8)<span class=\"hljs-operator\">!</span><br><span class=\"hljs-keyword\">let</span> attributes: [<span class=\"hljs-type\">String</span>: <span class=\"hljs-keyword\">Any</span>] <span class=\"hljs-operator\">=</span> [kSecAttrAccount <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>: account,<br>                                 kSecValueData <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>: password]<br><br><span class=\"hljs-comment\">//update\t\t\t\t\t\t\t\t \t\t\t\t\t\t\t\t </span><br><span class=\"hljs-keyword\">let</span> status <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">SecItemUpdate</span>(query <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">CFDictionary</span>, attributes <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">CFDictionary</span>)<br><span class=\"hljs-keyword\">guard</span> status <span class=\"hljs-operator\">!=</span> errSecItemNotFound <span class=\"hljs-keyword\">else</span> &#123; <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-type\">KeychainError</span>.noPassword &#125;<br><span class=\"hljs-keyword\">guard</span> status <span class=\"hljs-operator\">==</span> errSecSuccess <span class=\"hljs-keyword\">else</span> &#123; <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-type\">KeychainError</span>.unhandledError(status: status) &#125;\t<br><br><span class=\"hljs-comment\">//delete</span><br><span class=\"hljs-keyword\">let</span> status <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">SecItemDelete</span>(query <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">CFDictionary</span>)<br><span class=\"hljs-keyword\">guard</span> status <span class=\"hljs-operator\">==</span> errSecSuccess <span class=\"hljs-operator\">||</span> status <span class=\"hljs-operator\">==</span> errSecItemNotFound <span class=\"hljs-keyword\">else</span> &#123; <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-type\">KeychainError</span>.unhandledError(status: status) &#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"keychain-group-app-group\"><a href=\"#keychain-group-app-group\" class=\"headerlink\" title=\"keychain group &amp; app group\"></a>keychain group &amp; app group</h1><p>参考：<a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps?language=objc\">Sharing Access to Keychain Items Among a Collection of Apps</a></p>\n<blockquote>\n<p>Enable apps to share keychain items with each other by adding the apps to an access group.</p>\n</blockquote>\n<p>通过keychain group 可以在 app 间共享keychain item。</p>\n<blockquote>\n<p>An access group is a logical collection of apps tagged with a particular group name string. Any app in a given group can share keychain items with all the other apps in the same group. You can add an app to any number of groups, but the app is always part of at least one group that contains only itself. That is, an app can always store and retrieve private keychain items, regardless of whether it also participates in any other groups. Keychain items, on the other hand, are always part of exactly one group.</p>\n</blockquote>\n<p>默认情况下，app 加入了以自身id 为标记的分组中，这个分组中的所有 keychain item 仅限app 自身访问。</p>\n<p>通过加入其他分组，app 间可以通过 keychain group 共享 keychain item。</p>\n<h2 id=\"keychain-group-类型\"><a href=\"#keychain-group-类型\" class=\"headerlink\" title=\"keychain group 类型\"></a>keychain group 类型</h2><p>You control the groups that your app belongs to by manipulating its entitlements. In particular, an app belongs to all the groups named in a virtual array of strings that the system forms for each app as the concatenation of the following items, evaluated in this order:</p>\n<p><strong>Keychain access groups</strong><br>The optional Keychain Access Groups Entitlement holds an array of strings, each of which names an access group.</p>\n<p>显示指定加入的 keychain group， group id为 <code>[$(teamID).$(keychain group id)]</code></p>\n<p><strong>Application identifier</strong><br>Xcode automatically adds the application-identifier entitlement (or the com.apple.application-identifier entitlement in macOS) to every app during code signing, formed as the team identifier (team ID) plus the bundle identifier (bundle ID).</p>\n<p>隐式的加入了以自身为组的 keychain group,  group id为 <code>[$(teamID).$(bundle ID)]</code></p>\n<p><strong>Application groups</strong><br>When you collect related apps into an application group using the App Groups Entitlement, they share access to a group container, and gain the ability to message each other in certain ways. Starting in iOS 8, the array of strings given by this entitlement also extends the list of keychain access groups.</p>\n<p>由于加入了app group， 隐式的加入了以 app group 为组的 keychain group,  group id为 <code>[$(app group id)]</code></p>\n<p>Xcode handles the application identifier (app ID) for you when you set the bundle ID. You set the others by manipulating capabilities in Xcode.</p>\n<p>添加keychain group 和 app group 可以在xcode 中通过操作capabilities来实现。<br><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16694538450341669453844996.png\"><br><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16694538730181669453872352.png\"></p>\n<h2 id=\"app-group-和-keychain-group-区别\"><a href=\"#app-group-和-keychain-group-区别\" class=\"headerlink\" title=\"app group 和 keychain group 区别\"></a>app group 和 keychain group 区别</h2><p>App groups and keychain access groups aren’t mutually exclusive—you can use both in the same app—but they do differ in several important ways that may help you decide which to use for a given situation.</p>\n<p>两者不是互相排斥的， 一个app可以同时加入keychain group 和 app group。</p>\n<p>First, as described above, using an app group enables additional data sharing beyond keychain items. You might want this extra sharing, or might already be using an app group for this purpose, and thus not need to add keychain access groups. On the other hand, you might not want to enable this additional sharing at all, and prefer keychain access groups instead.</p>\n<p>app group 除了共享 keychain item 之外，还能共享其他内容，例如共享偏好设置</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pf\">let <span class=\"hljs-keyword\">user</span>Defualts = UserDefaults.init(suiteName: <span class=\"hljs-string\">&quot;$(group_Id)&quot;</span>)<br><span class=\"hljs-keyword\">user</span>Defualts?.<span class=\"hljs-built_in\">set</span>Value(data, <span class=\"hljs-keyword\">for</span>Key: key)<br><span class=\"hljs-keyword\">user</span>Defualts?.synchronize()<br></code></pre></td></tr></table></figure>\n\n\n<p>Second, order matters. The system considers the first item in the list of access groups to be the app’s default access group. This is the access group that keychain services assumes if you don’t otherwise specify one when adding keychain items. An app group can’t ever be the default, because the app ID is always present and appears earlier in the list. However, a keychain access group can be the default, because it appears before the app ID. In particular, the first keychain access group, if any, that you specify in the corresponding capability becomes the app’s default access group. If you don’t specify any keychain access groups, then the app ID is the default.</p>\n<p>关于默认 group， 当添加，查询，更新，删除 keychain item 时，不指定<code>kSecAttrAccessGroup </code>时，默认操作的是哪个group ？</p>\n<ol>\n<li>系统以 group list 数组中的第一个为默认 group</li>\n<li>默认group 不会是app group， 因为它不会是第一个</li>\n<li>如果加入keychain group， 该 keychain group 可能为默认的 keychain group</li>\n<li>想限定keychain item 只在 app 内访问，不能被keychain group 访问，需要将 bundle id 所在的keychain group 置顶，或者明确指定使用 bundle id 标记的keychain group</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"Keychain-是什么\"><a href=\"#Keychain-是什么\" class=\"headerlink\" title=\"Keychain  是什么\"></a>Keychain  是什么</h1><p>一个加密的数据库， 可以用来存储小的用户数据， 包括</p>\n<ul>\n<li>kSecClassGenericPassword：通用密码（可以用来存自定义数据）</li>\n<li>kSecClassInternetPassword：互联网密码</li>\n<li>kSecClassCertificate：证书</li>\n<li>kSecClassKey：秘钥</li>\n<li>kSecClassIdentity：证书+秘钥</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16692950150511669295014987.png\"><br>Figure 1 Securing the user’s secrets in a keychain</p>\n<p>打开 mac 系统的 keychain 观察一下， 发现系统有多个keychain，每个keychain都有上图对应的项目<br><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16694375672261669437566402.png\"></p>\n<h1 id=\"如何管理数据，增删查改\"><a href=\"#如何管理数据，增删查改\" class=\"headerlink\" title=\"如何管理数据，增删查改\"></a>如何管理数据，增删查改</h1><p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16692963470741669296346746.png\"><br>Figure 1 Putting data and attributes into a keychain</p>\n<p>keychain 将要存储的数据封装为 SecKeychainItemRef，通过存取 SecKeychainItem 来达到对数据的管理。</p>\n<p>SecKeychainItemRef 包含</p>\n<ul>\n<li>data， CFData， 要存取的数据</li>\n<li>attributes, 该条目的属性，存取权限，查询标签等</li>\n</ul>\n<p>提供的api</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-comment\">//添加</span><br>OSStatus <span class=\"hljs-built_in\">SecItemAdd</span>(CFDictionaryRef attributes, CFTypeRef  _Nullable *result);<br><span class=\"hljs-comment\">//查询</span><br>OSStatus <span class=\"hljs-built_in\">SecItemCopyMatching</span>(CFDictionaryRef query, CFTypeRef  _Nullable *result);<br><span class=\"hljs-comment\">//更新</span><br>OSStatus <span class=\"hljs-built_in\">SecItemUpdate</span>(CFDictionaryRef query, CFDictionaryRef attributesToUpdate);<br><span class=\"hljs-comment\">//删除</span><br>OSStatus <span class=\"hljs-built_in\">SecItemDelete</span>(CFDictionaryRef query);<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"SecItemAdd\"><a href=\"#SecItemAdd\" class=\"headerlink\" title=\"SecItemAdd\"></a>SecItemAdd</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\">OSStatus SecItemAdd(<span class=\"hljs-built_in\">CFDictionaryRef</span> attributes, <span class=\"hljs-built_in\">CFTypeRef</span>  _Nullable *result);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p><strong>attributes</strong></p>\n<p>一个字典，描述要添加的数据：</p>\n<ul>\n<li>要添加数据类型，对应的 key 为<code>kSecClass</code>, value 可以是<ul>\n<li>kSecClassGenericPassword：通用密码（可以用来存自定义数据）</li>\n<li>kSecClassInternetPassword：互联网密码</li>\n<li>kSecClassCertificate：证书</li>\n<li>kSecClassKey：秘钥</li>\n<li>kSecClassIdentity：证书+秘钥</li>\n</ul>\n</li>\n<li>数添加的数据本身, key 为 <code> kSecValueData</code>, value 为 <code>CFDataRef</code> 类型</li>\n<li>关联的属性, 参考：<a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_attribute_keys_and_values?language=objc\">Item Attribute Keys and Values</a><ul>\n<li>每种类型关联的属性可以不同，例如 kSecClassInternetPassword 可以关联 <code>kSecAttrServer</code>, <code>kSecAttrPort</code>, <code>kSecAttrProtocol</code>， 而 <code>kSecClassGenericPassword</code>就没有这些选项</li>\n<li><code>kSecAttrAccessGroup</code> 可以指定存入的keychain group，这个会影响到查询范围</li>\n</ul>\n</li>\n<li>添加后，返回添加结果的类型，指定类型的数据会存入 result 字段。参考：<a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_return_result_keys?language=objc\"> Item Return Result Keys</a></li>\n</ul>\n<p><strong>result</strong></p>\n<p>添加结束，函数返回，指向新添加的条目。根据 attributes 中指定的类型，返回对应的值。参考： <a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_return_result_keys?language=objc\"> Item Return Result Keys</a></p>\n<p>一般添加不关心新条目，传nil</p>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>成功或者错误码。参考：<a href=\"https://developer.apple.com/documentation/security/1542001-security_framework_result_codes?language=objc\">Security Framework Result Codes</a></p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ol>\n<li>kSecAttrAccessGroup 可以指定添加到 钥匙串分组，该分组中的成员共享该条目</li>\n<li>一次添加多条，可以使用<code>kSecUseItemList </code>传入字典数组，但是不能用于密码类型</li>\n<li>添加是同步执行，放到主线程可能会卡界面，可以用异步方式</li>\n</ol>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">- (void)addKeychainItemWithAttributes:(CFDictionaryRef)attrs completion:(<span class=\"hljs-built_in\">void</span>(^)(OSStatus status, CFTypeRef item))completion &#123;<br>    <span class=\"hljs-built_in\">dispatch_async</span>(backgroundQueue, ^&#123;<br>        CFTypeRef item = NULL;<br>        OSStatus addResult = SecItemAdd(attrs, &amp;item);<br>        <span class=\"hljs-built_in\">completion</span>(addResult, item);<br>        if (item) &#123;<br>            <span class=\"hljs-built_in\">CFRelease</span>(item);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"SecItemCopyMatching\"><a href=\"#SecItemCopyMatching\" class=\"headerlink\" title=\"SecItemCopyMatching\"></a>SecItemCopyMatching</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\">OSStatus SecItemCopyMatching(<span class=\"hljs-built_in\">CFDictionaryRef</span> query, <span class=\"hljs-built_in\">CFTypeRef</span>  _Nullable *result);<br></code></pre></td></tr></table></figure>\n\n<p>通过 query 指定查询条件，将查询结果存入 result 中。</p>\n<h3 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p><strong>query</strong><br>用于指定查询条件</p>\n<ul>\n<li>查询的数据类型，通过 <code>kSecClass</code> 指定</li>\n<li>关联的属性， 用于缩小查询范围</li>\n<li>查询参数，返回一条还是多条匹配项，是否大消息敏感，或者从特定项中搜索。参考： <a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/search_attribute_keys_and_values?language=objc\"> Search Attribute Keys and Values</a></li>\n<li>指定返回类型，指定的类型不同，result 中返回的类型就不同。 参考： <a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_return_result_keys?language=objc\">Item Return Result Keys </a></li>\n</ul>\n<p>**result **</p>\n<p>保存查询结果。<br>例如： 指定  <code>kSecReturnData: kCFBooleanTrue</code>  ，result 中存的就是<code>CFDataRef </code>类型的数据。参考： <a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_return_result_keys?language=objc\">Item Return Result Keys</a></p>\n<h3 id=\"返回值-1\"><a href=\"#返回值-1\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>成功或者错误码。参考：<a href=\"https://developer.apple.com/documentation/security/1542001-security_framework_result_codes?language=objc\">Security Framework Result Codes</a></p>\n<h3 id=\"注意-1\"><a href=\"#注意-1\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ol>\n<li>默认返回第一个匹配项，如果想查询多条匹配，指定 <code>kSecMatchLimit</code>  大于1， 此时 result 为 <code>CFArrayRef</code>  类型</li>\n<li>当类型为<code>kSecInternetPasswordItemClass</code> 或 <code>kSecGenericPasswordItemClass</code>时， 不能同时指定<code>kSecReturnData</code> 和 <code>kSecMatchLimitAll</code>, 原因是拷贝每个密码时，需要额外的授权验证。</li>\n<li>默认情况下，会搜索当前keychain 以及所有加入的 keychain group， 通过 <code>kSecAttrAccessGroup</code> 可以指定要在哪个 keychain group 查询</li>\n<li>主线程同步执行会卡UI， 可以异步执行</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\">- (<span class=\"hljs-type\">void</span>)findKeychainItemWithAttributes:(<span class=\"hljs-built_in\">NSDictionary</span> *)attributes completion:(<span class=\"hljs-type\">void</span>(^)(OSStatus status, <span class=\"hljs-built_in\">CFTypeRef</span> item))completion &#123;<br>    <span class=\"hljs-built_in\">dispatch_async</span>(backgroundQueue, ^&#123;<br>        <span class=\"hljs-built_in\">CFDictionaryRef</span> attrs = (__bridge <span class=\"hljs-built_in\">CFDictionaryRef</span>)attributes;<br>        <span class=\"hljs-built_in\">CFTypeRef</span> item = <span class=\"hljs-literal\">NULL</span>;<br>        OSStatus result = SecItemCopyMatching(attrs, &amp;item);<br>        completion(result, item);<br>        <span class=\"hljs-built_in\">CFRelease</span>(item);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"SecItemUpdate\"><a href=\"#SecItemUpdate\" class=\"headerlink\" title=\"SecItemUpdate\"></a>SecItemUpdate</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\">OSStatus SecItemUpdate(<span class=\"hljs-built_in\">CFDictionaryRef</span> query, <span class=\"hljs-built_in\">CFDictionaryRef</span> attributesToUpdate);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"参数-2\"><a href=\"#参数-2\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p><strong>query</strong></p>\n<p>用来指定要更新的条目, 执行更新，需要先查询到要更新的条目。<br>参考 SecItemCopyMatching 如何指定查询条件。</p>\n<p><strong>attributesToUpdate</strong></p>\n<p>指定需要更新的属性。</p>\n<h3 id=\"返回值-2\"><a href=\"#返回值-2\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>成功或者错误码。参考：<a href=\"https://developer.apple.com/documentation/security/1542001-security_framework_result_codes?language=objc\">Security Framework Result Codes</a></p>\n<h3 id=\"注意-2\"><a href=\"#注意-2\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>主线程同步执行会卡UI， 可以异步执行</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">- (void)updateKeyChainItemWithAttributes:(CFDictionaryRef)attrs update:(CFDictionaryRef)update completion:(<span class=\"hljs-built_in\">void</span>(^)(OSStatus status))completion &#123;<br>    <span class=\"hljs-built_in\">dispatch_async</span>(backgroundQueue, ^&#123;<br>        OSStatus updateResult = SecItemUpdate(attrs, update);<br>        <span class=\"hljs-built_in\">completion</span>(updateResult);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"SecItemDelete\"><a href=\"#SecItemDelete\" class=\"headerlink\" title=\"SecItemDelete\"></a>SecItemDelete</h2><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">OSStatus <span class=\"hljs-built_in\">SecItemDelete</span>(CFDictionaryRef query);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"参数-3\"><a href=\"#参数-3\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p><strong>query</strong></p>\n<p>用来指定要删除的的条目， 参考SecItemCopyMatching 如何指定查询条件。</p>\n<h3 id=\"返回值-3\"><a href=\"#返回值-3\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>成功或者错误码。参考：<a href=\"https://developer.apple.com/documentation/security/1542001-security_framework_result_codes?language=objc\">Security Framework Result Codes</a></p>\n<h3 id=\"注意-3\"><a href=\"#注意-3\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ol>\n<li>默认删除所有的匹配项，</li>\n<li>可以通过指定<code>kSecMatchItemList </code>来限定删除范围， <code>kSecMatchItemList</code>对应的值的类型为<code>CFArrayRef </code>, 数组中每一项的类型必须相同，<ul>\n<li>针对临时引用，每一项是一个引用，引用的类型可以是<ul>\n<li>SecKeychainItemRef,</li>\n<li>SecKeyRef</li>\n<li>SecCertificateRef</li>\n<li>SecIdentityRef</li>\n<li>CFDataRef</li>\n</ul>\n</li>\n<li>针对持久化引用, 引用的必须是类型是 <code>CFDataRef</code></li>\n</ul>\n</li>\n<li>主线程同步执行会卡UI， 可以异步执行</li>\n</ol>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">- (void)deleteKeychainItemWithAttributes:(CFDictionaryRef)attrs completion:(<span class=\"hljs-built_in\">void</span>(^)(OSStatus status))completion &#123;<br>    <span class=\"hljs-built_in\">dispatch_async</span>(backgroundQueue, ^&#123;<br>        OSStatus deleteResult = SecItemDelete(attrs);<br>        <span class=\"hljs-built_in\">completion</span>(deleteResult);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"什么是临时引用，持久化引用又是什么？\"><a href=\"#什么是临时引用，持久化引用又是什么？\" class=\"headerlink\" title=\"什么是临时引用，持久化引用又是什么？\"></a>什么是临时引用，持久化引用又是什么？</h3><p><strong>临时引用</strong></p>\n<p>对应的 key  值是<code>kSecReturnRef</code></p>\n<blockquote>\n<p>The corresponding value is of type <code>CFBooleanRef</code>. A value of <code>kCFBooleanTrue</code> indicates that a reference should be returned. Depending on the item class requested, the returned references may be of type <code>SecKeychainItemRef</code>, <code>SecKeyRef</code>, <code>SecCertificateRef</code>, <code>SecIdentityRef</code>, or <code>CFDataRef</code>.</p>\n</blockquote>\n<p>示例 ：SecCertificateRef 证书对象的引用在keychain中存取</p>\n<p>创建SecCertificateRef</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gcode\">SecCertificateRef certificate =<br>    SecCertificateCreateWithData<span class=\"hljs-comment\">(NULL, (__bridge CFDataRef)</span>certData);<br>\t\t <br><span class=\"hljs-keyword\">if</span> <span class=\"hljs-comment\">(certificate)</span>  &#123; CFRelease<span class=\"hljs-comment\">(certificate)</span>; &#125; <span class=\"hljs-comment\">// After you are done with it</span><br></code></pre></td></tr></table></figure>\n\n<p>将证书存入keychain</p>\n<figure class=\"highlight fsharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs fsharp\">NSDictionary<span class=\"hljs-operator\">*</span> addquery <span class=\"hljs-operator\">=</span> <span class=\"hljs-operator\">@</span>&#123; (<span class=\"hljs-built_in\">id</span>)kSecValueRef<span class=\"hljs-operator\">:</span>   (__bridge <span class=\"hljs-built_in\">id</span>)certificate,<br>                            (<span class=\"hljs-built_in\">id</span>)kSecClass<span class=\"hljs-operator\">:</span>      (<span class=\"hljs-built_in\">id</span>)kSecClassCertificate,<br>                            (<span class=\"hljs-built_in\">id</span>)kSecAttrLabel<span class=\"hljs-operator\">:</span>  <span class=\"hljs-string\">@&quot;My Certificate&quot;</span>,<br>                           &#125;;<br>\t\t\t\t\t\t   <br>\t\t\t\t\t\t   <br>OSStatus status <span class=\"hljs-operator\">=</span> SecItemAdd((__bridge CFDictionaryRef)addquery, NULL);<br><span class=\"hljs-keyword\">if</span> (status <span class=\"hljs-operator\">!=</span> errSecSuccess) &#123;<br>    <span class=\"hljs-comment\">// Handle the error</span><br>&#125;\t\t\t\t\t\t   <br></code></pre></td></tr></table></figure>\n\n<p>从keychain读取证书</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs objectivec\"><span class=\"hljs-built_in\">NSDictionary</span> *getquery = @&#123; (<span class=\"hljs-type\">id</span>)kSecClass:     (<span class=\"hljs-type\">id</span>)kSecClassCertificate,<br>                            (<span class=\"hljs-type\">id</span>)kSecAttrLabel: <span class=\"hljs-string\">@&quot;My Certificate&quot;</span>,<br>                            (<span class=\"hljs-type\">id</span>)kSecReturnRef: @YES,<br>                            &#125;;<br>SecCertificateRef certificate = <span class=\"hljs-literal\">NULL</span>;<br>OSStatus status = SecItemCopyMatching((__bridge <span class=\"hljs-built_in\">CFDictionaryRef</span>)getquery,<br>                                      (<span class=\"hljs-built_in\">CFTypeRef</span> *)&amp;certificate);<br><span class=\"hljs-keyword\">if</span> (status != errSecSuccess) &#123; &lt;# Handle error #&gt; &#125;<br><span class=\"hljs-keyword\">else</span>                         &#123; &lt;# Use certificate #&gt; &#125;<br> <br><span class=\"hljs-keyword\">if</span> (certificate) &#123; <span class=\"hljs-built_in\">CFRelease</span>(certificate); &#125; <span class=\"hljs-comment\">// After you are done with it</span><br></code></pre></td></tr></table></figure>\n\n<p>观察到这里用的就是 <code>kSecReturnRef</code>, 代表临时引用。</p>\n<ul>\n<li>SecKeychainItemRef,</li>\n<li>SecKeyRef</li>\n<li>SecCertificateRef</li>\n<li>SecIdentityRef</li>\n<li>CFDataRef</li>\n</ul>\n<p><strong>持久化引用</strong></p>\n<p>key 为 kSecReturnPersistentRef。</p>\n<blockquote>\n<p>The corresponding value is of type <code>CFBooleanRef</code>. A value of kCFBooleanTrue indicates that a persistent reference to an item should be returned as a <code>CFDataRef</code> object. Unlike normal references, a persistent reference may be stored on disk or passed between processes.</p>\n</blockquote>\n<ol>\n<li>一个持久化引用，引用的对象必须是<code>CFDataRef</code></li>\n<li>持久化引用可以存储在磁盘，可以跨进程传递</li>\n</ol>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><h2 id=\"Adding-a-Password-to-the-Keychain\"><a href=\"#Adding-a-Password-to-the-Keychain\" class=\"headerlink\" title=\"Adding a Password to the Keychain\"></a><a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/adding_a_password_to_the_keychain?language=objc\">Adding a Password to the Keychain</a></h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\">struct <span class=\"hljs-title class_\">Credentials</span> &#123;<br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">username</span>: <span class=\"hljs-title class_\">String</span><br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">password</span>: <span class=\"hljs-title class_\">String</span><br>&#125;<br><br><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">KeychainError</span>: <span class=\"hljs-title class_\">Error</span> &#123;<br>    <span class=\"hljs-keyword\">case</span> noPassword<br>    <span class=\"hljs-keyword\">case</span> unexpectedPasswordData<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title function_\">unhandledError</span>(<span class=\"hljs-attr\">status</span>: <span class=\"hljs-title class_\">OSStatus</span>)<br>&#125;<br><br><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">let</span> server = <span class=\"hljs-string\">&quot;www.example.com&quot;</span><br><br><span class=\"hljs-keyword\">let</span> account = credentials.<span class=\"hljs-property\">username</span><br><span class=\"hljs-keyword\">let</span> password = credentials.<span class=\"hljs-property\">password</span>.<span class=\"hljs-title function_\">data</span>(<span class=\"hljs-attr\">using</span>: <span class=\"hljs-title class_\">String</span>.<span class=\"hljs-property\">Encoding</span>.<span class=\"hljs-property\">utf8</span>)!<br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">query</span>: [<span class=\"hljs-title class_\">String</span>: <span class=\"hljs-title class_\">Any</span>] = [kSecClass <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">String</span>: kSecClassInternetPassword,<br>                            kSecAttrAccount <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">String</span>: account,<br>                            kSecAttrServer <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">String</span>: server,<br>                            kSecValueData <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">String</span>: password]<br><span class=\"hljs-keyword\">let</span> status = <span class=\"hljs-title class_\">SecItemAdd</span>(query <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">CFDictionary</span>, nil)<br>guard status == errSecSuccess <span class=\"hljs-keyword\">else</span> &#123; <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">KeychainError</span>.<span class=\"hljs-title function_\">unhandledError</span>(<span class=\"hljs-attr\">status</span>: status) &#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Searching-for-Keychain-Items\"><a href=\"#Searching-for-Keychain-Items\" class=\"headerlink\" title=\"Searching for Keychain Items\"></a><a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/searching_for_keychain_items?language=objc\">Searching for Keychain Items</a></h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">let</span> query: [<span class=\"hljs-type\">String</span>: <span class=\"hljs-keyword\">Any</span>] <span class=\"hljs-operator\">=</span> [kSecClass <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>: kSecClassInternetPassword,<br>                            kSecAttrServer <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>: server,<br>                            kSecMatchLimit <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>: kSecMatchLimitOne,<br>                            kSecReturnAttributes <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>: <span class=\"hljs-literal\">true</span>,<br>                            kSecReturnData <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>: <span class=\"hljs-literal\">true</span>]<br><br><span class=\"hljs-keyword\">var</span> item: <span class=\"hljs-type\">CFTypeRef</span>?<br><span class=\"hljs-keyword\">let</span> status <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">SecItemCopyMatching</span>(query <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">CFDictionary</span>, <span class=\"hljs-operator\">&amp;</span>item)<br><span class=\"hljs-keyword\">guard</span> status <span class=\"hljs-operator\">!=</span> errSecItemNotFound <span class=\"hljs-keyword\">else</span> &#123; <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-type\">KeychainError</span>.noPassword &#125;<br><span class=\"hljs-keyword\">guard</span> status <span class=\"hljs-operator\">==</span> errSecSuccess <span class=\"hljs-keyword\">else</span> &#123; <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-type\">KeychainError</span>.unhandledError(status: status) &#125;<br><br><span class=\"hljs-keyword\">guard</span> <span class=\"hljs-keyword\">let</span> existingItem <span class=\"hljs-operator\">=</span> item <span class=\"hljs-keyword\">as?</span> [<span class=\"hljs-type\">String</span> : <span class=\"hljs-keyword\">Any</span>],<br>    <span class=\"hljs-keyword\">let</span> passwordData <span class=\"hljs-operator\">=</span> existingItem[kSecValueData <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>] <span class=\"hljs-keyword\">as?</span> <span class=\"hljs-type\">Data</span>,<br>    <span class=\"hljs-keyword\">let</span> password <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">String</span>(data: passwordData, encoding: <span class=\"hljs-type\">String</span>.<span class=\"hljs-type\">Encoding</span>.utf8),<br>    <span class=\"hljs-keyword\">let</span> account <span class=\"hljs-operator\">=</span> existingItem[kSecAttrAccount <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>] <span class=\"hljs-keyword\">as?</span> <span class=\"hljs-type\">String</span><br><span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-type\">KeychainError</span>.unexpectedPasswordData<br>&#125;<br><span class=\"hljs-keyword\">let</span> credentials <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Credentials</span>(username: account, password: password)<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Updating-and-Deleting-Keychain-Items\"><a href=\"#Updating-and-Deleting-Keychain-Items\" class=\"headerlink\" title=\"Updating and Deleting Keychain Items\"></a><a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/updating_and_deleting_keychain_items?language=objc\">Updating and Deleting Keychain Items</a></h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs swift\"><span class=\"hljs-keyword\">let</span> query: [<span class=\"hljs-type\">String</span>: <span class=\"hljs-keyword\">Any</span>] <span class=\"hljs-operator\">=</span> [kSecClass <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>: kSecClassInternetPassword,<br>                            kSecAttrServer <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>: server]<br>\t\t\t\t\t\t\t<br><span class=\"hljs-keyword\">let</span> account <span class=\"hljs-operator\">=</span> credentials.username<br><span class=\"hljs-keyword\">let</span> password <span class=\"hljs-operator\">=</span> credentials.password.data(using: <span class=\"hljs-type\">String</span>.<span class=\"hljs-type\">Encoding</span>.utf8)<span class=\"hljs-operator\">!</span><br><span class=\"hljs-keyword\">let</span> attributes: [<span class=\"hljs-type\">String</span>: <span class=\"hljs-keyword\">Any</span>] <span class=\"hljs-operator\">=</span> [kSecAttrAccount <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>: account,<br>                                 kSecValueData <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">String</span>: password]<br><br><span class=\"hljs-comment\">//update\t\t\t\t\t\t\t\t \t\t\t\t\t\t\t\t </span><br><span class=\"hljs-keyword\">let</span> status <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">SecItemUpdate</span>(query <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">CFDictionary</span>, attributes <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">CFDictionary</span>)<br><span class=\"hljs-keyword\">guard</span> status <span class=\"hljs-operator\">!=</span> errSecItemNotFound <span class=\"hljs-keyword\">else</span> &#123; <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-type\">KeychainError</span>.noPassword &#125;<br><span class=\"hljs-keyword\">guard</span> status <span class=\"hljs-operator\">==</span> errSecSuccess <span class=\"hljs-keyword\">else</span> &#123; <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-type\">KeychainError</span>.unhandledError(status: status) &#125;\t<br><br><span class=\"hljs-comment\">//delete</span><br><span class=\"hljs-keyword\">let</span> status <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">SecItemDelete</span>(query <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">CFDictionary</span>)<br><span class=\"hljs-keyword\">guard</span> status <span class=\"hljs-operator\">==</span> errSecSuccess <span class=\"hljs-operator\">||</span> status <span class=\"hljs-operator\">==</span> errSecItemNotFound <span class=\"hljs-keyword\">else</span> &#123; <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-type\">KeychainError</span>.unhandledError(status: status) &#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"keychain-group-app-group\"><a href=\"#keychain-group-app-group\" class=\"headerlink\" title=\"keychain group &amp; app group\"></a>keychain group &amp; app group</h1><p>参考：<a href=\"https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps?language=objc\">Sharing Access to Keychain Items Among a Collection of Apps</a></p>\n<blockquote>\n<p>Enable apps to share keychain items with each other by adding the apps to an access group.</p>\n</blockquote>\n<p>通过keychain group 可以在 app 间共享keychain item。</p>\n<blockquote>\n<p>An access group is a logical collection of apps tagged with a particular group name string. Any app in a given group can share keychain items with all the other apps in the same group. You can add an app to any number of groups, but the app is always part of at least one group that contains only itself. That is, an app can always store and retrieve private keychain items, regardless of whether it also participates in any other groups. Keychain items, on the other hand, are always part of exactly one group.</p>\n</blockquote>\n<p>默认情况下，app 加入了以自身id 为标记的分组中，这个分组中的所有 keychain item 仅限app 自身访问。</p>\n<p>通过加入其他分组，app 间可以通过 keychain group 共享 keychain item。</p>\n<h2 id=\"keychain-group-类型\"><a href=\"#keychain-group-类型\" class=\"headerlink\" title=\"keychain group 类型\"></a>keychain group 类型</h2><p>You control the groups that your app belongs to by manipulating its entitlements. In particular, an app belongs to all the groups named in a virtual array of strings that the system forms for each app as the concatenation of the following items, evaluated in this order:</p>\n<p><strong>Keychain access groups</strong><br>The optional Keychain Access Groups Entitlement holds an array of strings, each of which names an access group.</p>\n<p>显示指定加入的 keychain group， group id为 <code>[$(teamID).$(keychain group id)]</code></p>\n<p><strong>Application identifier</strong><br>Xcode automatically adds the application-identifier entitlement (or the com.apple.application-identifier entitlement in macOS) to every app during code signing, formed as the team identifier (team ID) plus the bundle identifier (bundle ID).</p>\n<p>隐式的加入了以自身为组的 keychain group,  group id为 <code>[$(teamID).$(bundle ID)]</code></p>\n<p><strong>Application groups</strong><br>When you collect related apps into an application group using the App Groups Entitlement, they share access to a group container, and gain the ability to message each other in certain ways. Starting in iOS 8, the array of strings given by this entitlement also extends the list of keychain access groups.</p>\n<p>由于加入了app group， 隐式的加入了以 app group 为组的 keychain group,  group id为 <code>[$(app group id)]</code></p>\n<p>Xcode handles the application identifier (app ID) for you when you set the bundle ID. You set the others by manipulating capabilities in Xcode.</p>\n<p>添加keychain group 和 app group 可以在xcode 中通过操作capabilities来实现。<br><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16694538450341669453844996.png\"><br><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16694538730181669453872352.png\"></p>\n<h2 id=\"app-group-和-keychain-group-区别\"><a href=\"#app-group-和-keychain-group-区别\" class=\"headerlink\" title=\"app group 和 keychain group 区别\"></a>app group 和 keychain group 区别</h2><p>App groups and keychain access groups aren’t mutually exclusive—you can use both in the same app—but they do differ in several important ways that may help you decide which to use for a given situation.</p>\n<p>两者不是互相排斥的， 一个app可以同时加入keychain group 和 app group。</p>\n<p>First, as described above, using an app group enables additional data sharing beyond keychain items. You might want this extra sharing, or might already be using an app group for this purpose, and thus not need to add keychain access groups. On the other hand, you might not want to enable this additional sharing at all, and prefer keychain access groups instead.</p>\n<p>app group 除了共享 keychain item 之外，还能共享其他内容，例如共享偏好设置</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pf\">let <span class=\"hljs-keyword\">user</span>Defualts = UserDefaults.init(suiteName: <span class=\"hljs-string\">&quot;$(group_Id)&quot;</span>)<br><span class=\"hljs-keyword\">user</span>Defualts?.<span class=\"hljs-built_in\">set</span>Value(data, <span class=\"hljs-keyword\">for</span>Key: key)<br><span class=\"hljs-keyword\">user</span>Defualts?.synchronize()<br></code></pre></td></tr></table></figure>\n\n\n<p>Second, order matters. The system considers the first item in the list of access groups to be the app’s default access group. This is the access group that keychain services assumes if you don’t otherwise specify one when adding keychain items. An app group can’t ever be the default, because the app ID is always present and appears earlier in the list. However, a keychain access group can be the default, because it appears before the app ID. In particular, the first keychain access group, if any, that you specify in the corresponding capability becomes the app’s default access group. If you don’t specify any keychain access groups, then the app ID is the default.</p>\n<p>关于默认 group， 当添加，查询，更新，删除 keychain item 时，不指定<code>kSecAttrAccessGroup </code>时，默认操作的是哪个group ？</p>\n<ol>\n<li>系统以 group list 数组中的第一个为默认 group</li>\n<li>默认group 不会是app group， 因为它不会是第一个</li>\n<li>如果加入keychain group， 该 keychain group 可能为默认的 keychain group</li>\n<li>想限定keychain item 只在 app 内访问，不能被keychain group 访问，需要将 bundle id 所在的keychain group 置顶，或者明确指定使用 bundle id 标记的keychain group</li>\n</ol>\n"},{"layout":"post","title":"GDB Examining Memory","date":"2023-05-22T16:00:00.000Z","_content":"参考：\n[gdb/Output-Formats](https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html)\n[gdb/Memory](https://sourceware.org/gdb/onlinedocs/gdb/Memory.html#Memory)\n\n\n# Output Formats\n\n- `x` : Print the binary representation of the value in hexadecimal.\n- `d`: Print the binary representation of the value in hexadecimal.\n- `u`: Print the binary representation of the value as an decimal, as if it were unsigned.\n- `o`: Print the binary representation of the value in octal.\n- `t`: Print the binary representation of the value in binary. The letter ‘t’ stands for “two”.\n- `a`: Print as an address, both absolute in hexadecimal and as an offset from the nearest preceding symbol. \n- `c`: Cast the value to an integer (unlike other formats, this does not just reinterpret the underlying bits) and print it as a character constant.\n- `f`: Regard the bits of the value as a floating point number and print using typical floating point syntax.\n- `s`:Regard as a string, if possible. With this format, pointers to single-byte data are displayed as null-terminated strings and arrays of single-byte data are displayed as fixed-length strings. Other values are displayed in their natural types.\n- `z`:Like ‘x’ formatting, the value is treated as an integer and printed as hexadecimal, but leading zeros are printed to pad the value to the size of the integer type.\n- `r`:Print using the ‘raw’ formatting. By default, GDB will use a Python-based pretty-printer, if one is available (see Pretty Printing). This typically results in a higher-level display of the value’s contents. The ‘r’ format bypasses any Python pretty-printer which might exist.\n\n\n示例：\n```\n(lldb) p/x 10\n(int) $0 = 0x0000000a\n(lldb) p/t 10\n(int) $1 = 0b00000000000000000000000000001010\n(lldb) p/d 0x0000000a\n(int) $2 = 10\n(lldb) p/u 0x0000000a\n(int) $3 = 10\n(lldb) p/o 0x0000000a\n(int) $4 = 012\n(lldb) p/o 0x0000000a\n```\n\n# Examining Memory\nYou can use the command x (for “examine”) to examine memory in any of several formats, independently of your program’s data types.\n```\nx/nfu addr\nx addr\n```\n\n- `n`: the repeat count\n\tThe repeat count is a decimal integer; the default is 1. It specifies how much memory (counting by units u) to display. If a negative number is specified, memory is examined backward from addr.\n- `f`: the display format\n\tThe display format is one of the formats used by print (‘x’, ‘d’, ‘u’, ‘o’, ‘t’, ‘a’, ‘c’, ‘f’, ‘s’), ‘i’ (for machine instructions) and ‘m’ (for displaying memory tags). The default is ‘x’ (hexadecimal) initially. The default changes each time you use either x or print.\n- `u`:the unit size\n\tThe unit size is any of:\n\t\t- `b`: Bytes\n\t\t- `h`: Halfwords (two bytes).\n\t\t- `w`: Words (four bytes). This is the initial default.\n\t\t- `g`:Giant words (eight bytes).\n- `addr`:starting display address\n\taddr is the address where you want GDB to begin displaying memory.\n\tYou can also specify a negative repeat count to examine memory backward from the given address. For example, ‘x/-3uh 0x54320’ prints three halfwords (h) at 0x5431a, 0x5431c, and 0x5431e.\n\t\n 示例：\n \n```\n# display three halfwords (h) of memory, formatted as unsigned decimal integers (‘u’), starting at address 0x54320\nx/3uh 0x54320\n\n# prints the four words (‘w’) of memory above the stack pointer in hexadecimal (‘x’)\n\nx/4xw $sp\n\n# prints three halfwords (h) at 0x5431a, 0x5431c, and 0x5431e.\n\nx/-3uh 0x54320\n\n```","source":"_posts/lldb/2023-05-23-GDB Examining Memory.md","raw":"---\nlayout: post\ntitle: \"GDB Examining Memory\"\ndate: 2023-05-23\ntag: lldb\n---\n参考：\n[gdb/Output-Formats](https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html)\n[gdb/Memory](https://sourceware.org/gdb/onlinedocs/gdb/Memory.html#Memory)\n\n\n# Output Formats\n\n- `x` : Print the binary representation of the value in hexadecimal.\n- `d`: Print the binary representation of the value in hexadecimal.\n- `u`: Print the binary representation of the value as an decimal, as if it were unsigned.\n- `o`: Print the binary representation of the value in octal.\n- `t`: Print the binary representation of the value in binary. The letter ‘t’ stands for “two”.\n- `a`: Print as an address, both absolute in hexadecimal and as an offset from the nearest preceding symbol. \n- `c`: Cast the value to an integer (unlike other formats, this does not just reinterpret the underlying bits) and print it as a character constant.\n- `f`: Regard the bits of the value as a floating point number and print using typical floating point syntax.\n- `s`:Regard as a string, if possible. With this format, pointers to single-byte data are displayed as null-terminated strings and arrays of single-byte data are displayed as fixed-length strings. Other values are displayed in their natural types.\n- `z`:Like ‘x’ formatting, the value is treated as an integer and printed as hexadecimal, but leading zeros are printed to pad the value to the size of the integer type.\n- `r`:Print using the ‘raw’ formatting. By default, GDB will use a Python-based pretty-printer, if one is available (see Pretty Printing). This typically results in a higher-level display of the value’s contents. The ‘r’ format bypasses any Python pretty-printer which might exist.\n\n\n示例：\n```\n(lldb) p/x 10\n(int) $0 = 0x0000000a\n(lldb) p/t 10\n(int) $1 = 0b00000000000000000000000000001010\n(lldb) p/d 0x0000000a\n(int) $2 = 10\n(lldb) p/u 0x0000000a\n(int) $3 = 10\n(lldb) p/o 0x0000000a\n(int) $4 = 012\n(lldb) p/o 0x0000000a\n```\n\n# Examining Memory\nYou can use the command x (for “examine”) to examine memory in any of several formats, independently of your program’s data types.\n```\nx/nfu addr\nx addr\n```\n\n- `n`: the repeat count\n\tThe repeat count is a decimal integer; the default is 1. It specifies how much memory (counting by units u) to display. If a negative number is specified, memory is examined backward from addr.\n- `f`: the display format\n\tThe display format is one of the formats used by print (‘x’, ‘d’, ‘u’, ‘o’, ‘t’, ‘a’, ‘c’, ‘f’, ‘s’), ‘i’ (for machine instructions) and ‘m’ (for displaying memory tags). The default is ‘x’ (hexadecimal) initially. The default changes each time you use either x or print.\n- `u`:the unit size\n\tThe unit size is any of:\n\t\t- `b`: Bytes\n\t\t- `h`: Halfwords (two bytes).\n\t\t- `w`: Words (four bytes). This is the initial default.\n\t\t- `g`:Giant words (eight bytes).\n- `addr`:starting display address\n\taddr is the address where you want GDB to begin displaying memory.\n\tYou can also specify a negative repeat count to examine memory backward from the given address. For example, ‘x/-3uh 0x54320’ prints three halfwords (h) at 0x5431a, 0x5431c, and 0x5431e.\n\t\n 示例：\n \n```\n# display three halfwords (h) of memory, formatted as unsigned decimal integers (‘u’), starting at address 0x54320\nx/3uh 0x54320\n\n# prints the four words (‘w’) of memory above the stack pointer in hexadecimal (‘x’)\n\nx/4xw $sp\n\n# prints three halfwords (h) at 0x5431a, 0x5431c, and 0x5431e.\n\nx/-3uh 0x54320\n\n```","slug":"lldb/2023-05-23-GDB Examining Memory","published":1,"updated":"2024-03-06T11:53:13.567Z","comments":1,"photos":[],"_id":"cltgopenf002gqywhhk69ac4v","content":"<p>参考：<br><a href=\"https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html\">gdb&#x2F;Output-Formats</a><br><a href=\"https://sourceware.org/gdb/onlinedocs/gdb/Memory.html#Memory\">gdb&#x2F;Memory</a></p>\n<h1 id=\"Output-Formats\"><a href=\"#Output-Formats\" class=\"headerlink\" title=\"Output Formats\"></a>Output Formats</h1><ul>\n<li><code>x</code> : Print the binary representation of the value in hexadecimal.</li>\n<li><code>d</code>: Print the binary representation of the value in hexadecimal.</li>\n<li><code>u</code>: Print the binary representation of the value as an decimal, as if it were unsigned.</li>\n<li><code>o</code>: Print the binary representation of the value in octal.</li>\n<li><code>t</code>: Print the binary representation of the value in binary. The letter ‘t’ stands for “two”.</li>\n<li><code>a</code>: Print as an address, both absolute in hexadecimal and as an offset from the nearest preceding symbol. </li>\n<li><code>c</code>: Cast the value to an integer (unlike other formats, this does not just reinterpret the underlying bits) and print it as a character constant.</li>\n<li><code>f</code>: Regard the bits of the value as a floating point number and print using typical floating point syntax.</li>\n<li><code>s</code>:Regard as a string, if possible. With this format, pointers to single-byte data are displayed as null-terminated strings and arrays of single-byte data are displayed as fixed-length strings. Other values are displayed in their natural types.</li>\n<li><code>z</code>:Like ‘x’ formatting, the value is treated as an integer and printed as hexadecimal, but leading zeros are printed to pad the value to the size of the integer type.</li>\n<li><code>r</code>:Print using the ‘raw’ formatting. By default, GDB will use a Python-based pretty-printer, if one is available (see Pretty Printing). This typically results in a higher-level display of the value’s contents. The ‘r’ format bypasses any Python pretty-printer which might exist.</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(lldb) p/x 10<br>(int) <span class=\"hljs-variable\">$0</span> = 0x0000000a<br>(lldb) p/t 10<br>(int) <span class=\"hljs-variable\">$1</span> = 0b00000000000000000000000000001010<br>(lldb) p/d 0x0000000a<br>(int) <span class=\"hljs-variable\">$2</span> = 10<br>(lldb) p/u 0x0000000a<br>(int) <span class=\"hljs-variable\">$3</span> = 10<br>(lldb) p/o 0x0000000a<br>(int) <span class=\"hljs-variable\">$4</span> = 012<br>(lldb) p/o 0x0000000a<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Examining-Memory\"><a href=\"#Examining-Memory\" class=\"headerlink\" title=\"Examining Memory\"></a>Examining Memory</h1><p>You can use the command x (for “examine”) to examine memory in any of several formats, independently of your program’s data types.</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\"><span class=\"hljs-keyword\">x</span>/nfu addr<br><span class=\"hljs-keyword\">x</span> addr<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>n</code>: the repeat count<br>  The repeat count is a decimal integer; the default is 1. It specifies how much memory (counting by units u) to display. If a negative number is specified, memory is examined backward from addr.</li>\n<li><code>f</code>: the display format<br>  The display format is one of the formats used by print (‘x’, ‘d’, ‘u’, ‘o’, ‘t’, ‘a’, ‘c’, ‘f’, ‘s’), ‘i’ (for machine instructions) and ‘m’ (for displaying memory tags). The default is ‘x’ (hexadecimal) initially. The default changes each time you use either x or print.</li>\n<li><code>u</code>:the unit size<br>  The unit size is any of:<br>  - <code>b</code>: Bytes<br>  - <code>h</code>: Halfwords (two bytes).<br>  - <code>w</code>: Words (four bytes). This is the initial default.<br>  - <code>g</code>:Giant words (eight bytes).</li>\n<li><code>addr</code>:starting display address<br>  addr is the address where you want GDB to begin displaying memory.<br>  You can also specify a negative repeat count to examine memory backward from the given address. For example, ‘x&#x2F;-3uh 0x54320’ prints three halfwords (h) at 0x5431a, 0x5431c, and 0x5431e.</li>\n</ul>\n<p> 示例：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-comment\"># display three halfwords (h) of memory, formatted as unsigned decimal integers (‘u’), starting at address 0x54320</span><br><span class=\"hljs-attribute\">x</span>/<span class=\"hljs-number\">3</span>uh <span class=\"hljs-number\">0</span>x54320<br><br><span class=\"hljs-comment\"># prints the four words (‘w’) of memory above the stack pointer in hexadecimal (‘x’)</span><br><br><span class=\"hljs-attribute\">x</span>/<span class=\"hljs-number\">4</span>xw $sp<br><br><span class=\"hljs-comment\"># prints three halfwords (h) at 0x5431a, 0x5431c, and 0x5431e.</span><br><br><span class=\"hljs-attribute\">x</span>/-<span class=\"hljs-number\">3</span>uh <span class=\"hljs-number\">0</span>x54320<br><br></code></pre></td></tr></table></figure>","excerpt":"","more":"<p>参考：<br><a href=\"https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html\">gdb&#x2F;Output-Formats</a><br><a href=\"https://sourceware.org/gdb/onlinedocs/gdb/Memory.html#Memory\">gdb&#x2F;Memory</a></p>\n<h1 id=\"Output-Formats\"><a href=\"#Output-Formats\" class=\"headerlink\" title=\"Output Formats\"></a>Output Formats</h1><ul>\n<li><code>x</code> : Print the binary representation of the value in hexadecimal.</li>\n<li><code>d</code>: Print the binary representation of the value in hexadecimal.</li>\n<li><code>u</code>: Print the binary representation of the value as an decimal, as if it were unsigned.</li>\n<li><code>o</code>: Print the binary representation of the value in octal.</li>\n<li><code>t</code>: Print the binary representation of the value in binary. The letter ‘t’ stands for “two”.</li>\n<li><code>a</code>: Print as an address, both absolute in hexadecimal and as an offset from the nearest preceding symbol. </li>\n<li><code>c</code>: Cast the value to an integer (unlike other formats, this does not just reinterpret the underlying bits) and print it as a character constant.</li>\n<li><code>f</code>: Regard the bits of the value as a floating point number and print using typical floating point syntax.</li>\n<li><code>s</code>:Regard as a string, if possible. With this format, pointers to single-byte data are displayed as null-terminated strings and arrays of single-byte data are displayed as fixed-length strings. Other values are displayed in their natural types.</li>\n<li><code>z</code>:Like ‘x’ formatting, the value is treated as an integer and printed as hexadecimal, but leading zeros are printed to pad the value to the size of the integer type.</li>\n<li><code>r</code>:Print using the ‘raw’ formatting. By default, GDB will use a Python-based pretty-printer, if one is available (see Pretty Printing). This typically results in a higher-level display of the value’s contents. The ‘r’ format bypasses any Python pretty-printer which might exist.</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">(lldb) p/x 10<br>(int) <span class=\"hljs-variable\">$0</span> = 0x0000000a<br>(lldb) p/t 10<br>(int) <span class=\"hljs-variable\">$1</span> = 0b00000000000000000000000000001010<br>(lldb) p/d 0x0000000a<br>(int) <span class=\"hljs-variable\">$2</span> = 10<br>(lldb) p/u 0x0000000a<br>(int) <span class=\"hljs-variable\">$3</span> = 10<br>(lldb) p/o 0x0000000a<br>(int) <span class=\"hljs-variable\">$4</span> = 012<br>(lldb) p/o 0x0000000a<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Examining-Memory\"><a href=\"#Examining-Memory\" class=\"headerlink\" title=\"Examining Memory\"></a>Examining Memory</h1><p>You can use the command x (for “examine”) to examine memory in any of several formats, independently of your program’s data types.</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\"><span class=\"hljs-keyword\">x</span>/nfu addr<br><span class=\"hljs-keyword\">x</span> addr<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>n</code>: the repeat count<br>  The repeat count is a decimal integer; the default is 1. It specifies how much memory (counting by units u) to display. If a negative number is specified, memory is examined backward from addr.</li>\n<li><code>f</code>: the display format<br>  The display format is one of the formats used by print (‘x’, ‘d’, ‘u’, ‘o’, ‘t’, ‘a’, ‘c’, ‘f’, ‘s’), ‘i’ (for machine instructions) and ‘m’ (for displaying memory tags). The default is ‘x’ (hexadecimal) initially. The default changes each time you use either x or print.</li>\n<li><code>u</code>:the unit size<br>  The unit size is any of:<br>  - <code>b</code>: Bytes<br>  - <code>h</code>: Halfwords (two bytes).<br>  - <code>w</code>: Words (four bytes). This is the initial default.<br>  - <code>g</code>:Giant words (eight bytes).</li>\n<li><code>addr</code>:starting display address<br>  addr is the address where you want GDB to begin displaying memory.<br>  You can also specify a negative repeat count to examine memory backward from the given address. For example, ‘x&#x2F;-3uh 0x54320’ prints three halfwords (h) at 0x5431a, 0x5431c, and 0x5431e.</li>\n</ul>\n<p> 示例：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-comment\"># display three halfwords (h) of memory, formatted as unsigned decimal integers (‘u’), starting at address 0x54320</span><br><span class=\"hljs-attribute\">x</span>/<span class=\"hljs-number\">3</span>uh <span class=\"hljs-number\">0</span>x54320<br><br><span class=\"hljs-comment\"># prints the four words (‘w’) of memory above the stack pointer in hexadecimal (‘x’)</span><br><br><span class=\"hljs-attribute\">x</span>/<span class=\"hljs-number\">4</span>xw $sp<br><br><span class=\"hljs-comment\"># prints three halfwords (h) at 0x5431a, 0x5431c, and 0x5431e.</span><br><br><span class=\"hljs-attribute\">x</span>/-<span class=\"hljs-number\">3</span>uh <span class=\"hljs-number\">0</span>x54320<br><br></code></pre></td></tr></table></figure>"},{"layout":"post","title":"webrtc iOS 源码调试","date":"2023-05-08T16:00:00.000Z","_content":"\n## 获取源码\n1. install [Chromium depot_tools](https://webrtc.github.io/webrtc-org/native-code/development/prerequisite-sw/)\n\n[install on Linux / Mac](https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html#_setting_up)\n\n```\n$ git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git\n$ export PATH=/path/to/depot_tools:$PATH\n```\n\n2. [fetch source code](https://webrtc.github.io/webrtc-org/native-code/ios/)\n\n```\nfetch --nohooks webrtc_ios\ngclient sync\n```\n## 生成可调试项目\n\nUsing Xcode\n\n```\ncd $src\ngn gen out/ios --args='target_os=\"ios\" target_cpu=\"arm64\" rtc_include_tests=false' --ide=xcode\nopen -a Xcode.app out/ios/all.xcodeproj \n```\n\n选择 target `AppRTCMobile` 添加签名，运行\n\n# 处理错误\n\n![16922434326171692243431723.png](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16922434326171692243431723.png)\n\n解决方案， 修改 `src/build/conifg/ios/ios_sdk.gni`\n```\n# `security find-identity -v -p codesigning`.\nios_code_signing_identity_description = \"Apple Development\"\n```\n执行命令 `security find-identity -v -p codesigning` \n\n将 `Apple Development` 改为命令给出的列表中的具体的一项， 例如\n\n```\n# `security find-identity -v -p codesigning`.\nios_code_signing_identity_description = \"Apple Development: xiaobing yao (24ZM6UP2MW)\"\n```\n\n之后重新执行上面的构建命令即可。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/webrtc/2023-05-09-webrtc-调试.md","raw":"---\nlayout: post\ntitle: \"webrtc iOS 源码调试\"\ndate: 2023-05-09\ntag: webrtc\n---\n\n## 获取源码\n1. install [Chromium depot_tools](https://webrtc.github.io/webrtc-org/native-code/development/prerequisite-sw/)\n\n[install on Linux / Mac](https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html#_setting_up)\n\n```\n$ git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git\n$ export PATH=/path/to/depot_tools:$PATH\n```\n\n2. [fetch source code](https://webrtc.github.io/webrtc-org/native-code/ios/)\n\n```\nfetch --nohooks webrtc_ios\ngclient sync\n```\n## 生成可调试项目\n\nUsing Xcode\n\n```\ncd $src\ngn gen out/ios --args='target_os=\"ios\" target_cpu=\"arm64\" rtc_include_tests=false' --ide=xcode\nopen -a Xcode.app out/ios/all.xcodeproj \n```\n\n选择 target `AppRTCMobile` 添加签名，运行\n\n# 处理错误\n\n![16922434326171692243431723.png](https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16922434326171692243431723.png)\n\n解决方案， 修改 `src/build/conifg/ios/ios_sdk.gni`\n```\n# `security find-identity -v -p codesigning`.\nios_code_signing_identity_description = \"Apple Development\"\n```\n执行命令 `security find-identity -v -p codesigning` \n\n将 `Apple Development` 改为命令给出的列表中的具体的一项， 例如\n\n```\n# `security find-identity -v -p codesigning`.\nios_code_signing_identity_description = \"Apple Development: xiaobing yao (24ZM6UP2MW)\"\n```\n\n之后重新执行上面的构建命令即可。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"webrtc/2023-05-09-webrtc-调试","published":1,"updated":"2024-03-06T11:53:13.567Z","comments":1,"photos":[],"_id":"cltgopenf002iqywh30ui7gk2","content":"<h2 id=\"获取源码\"><a href=\"#获取源码\" class=\"headerlink\" title=\"获取源码\"></a>获取源码</h2><ol>\n<li>install <a href=\"https://webrtc.github.io/webrtc-org/native-code/development/prerequisite-sw/\">Chromium depot_tools</a></li>\n</ol>\n<p><a href=\"https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html#_setting_up\">install on Linux &#x2F; Mac</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git <span class=\"hljs-built_in\">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">export</span> PATH=/path/to/depot_tools:<span class=\"hljs-variable\">$PATH</span></span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><a href=\"https://webrtc.github.io/webrtc-org/native-code/ios/\">fetch source code</a></li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">fetch</span> <span class=\"hljs-comment\">--nohooks webrtc_ios</span><br>gclient sync<br></code></pre></td></tr></table></figure>\n<h2 id=\"生成可调试项目\"><a href=\"#生成可调试项目\" class=\"headerlink\" title=\"生成可调试项目\"></a>生成可调试项目</h2><p>Using Xcode</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">cd</span> <span class=\"hljs-variable\">$src</span><br>gn <span class=\"hljs-keyword\">gen</span> <span class=\"hljs-keyword\">out</span>/ios --<span class=\"hljs-keyword\">args</span>=&#x27;target_os=<span class=\"hljs-string\">&quot;ios&quot;</span> target_cpu=<span class=\"hljs-string\">&quot;arm64&quot;</span> rtc_include_tests=false&#x27; --ide=xcode<br><span class=\"hljs-keyword\">open</span> -a Xcode.<span class=\"hljs-keyword\">app</span> <span class=\"hljs-keyword\">out</span>/ios/all.xcodeproj <br></code></pre></td></tr></table></figure>\n\n<p>选择 target <code>AppRTCMobile</code> 添加签名，运行</p>\n<h1 id=\"处理错误\"><a href=\"#处理错误\" class=\"headerlink\" title=\"处理错误\"></a>处理错误</h1><p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16922434326171692243431723.png\" alt=\"16922434326171692243431723.png\"></p>\n<p>解决方案， 修改 <code>src/build/conifg/ios/ios_sdk.gni</code></p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-comment\"># `security find-identity -v -p codesigning`.</span><br><span class=\"hljs-attr\">ios_code_signing_identity_description</span> = <span class=\"hljs-string\">&quot;Apple Development&quot;</span><br></code></pre></td></tr></table></figure>\n<p>执行命令 <code>security find-identity -v -p codesigning</code> </p>\n<p>将 <code>Apple Development</code> 改为命令给出的列表中的具体的一项， 例如</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-comment\"># `security find-identity -v -p codesigning`.</span><br><span class=\"hljs-attr\">ios_code_signing_identity_description</span> = <span class=\"hljs-string\">&quot;Apple Development: xiaobing yao (24ZM6UP2MW)&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>之后重新执行上面的构建命令即可。</p>\n","excerpt":"","more":"<h2 id=\"获取源码\"><a href=\"#获取源码\" class=\"headerlink\" title=\"获取源码\"></a>获取源码</h2><ol>\n<li>install <a href=\"https://webrtc.github.io/webrtc-org/native-code/development/prerequisite-sw/\">Chromium depot_tools</a></li>\n</ol>\n<p><a href=\"https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html#_setting_up\">install on Linux &#x2F; Mac</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git <span class=\"hljs-built_in\">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">export</span> PATH=/path/to/depot_tools:<span class=\"hljs-variable\">$PATH</span></span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><a href=\"https://webrtc.github.io/webrtc-org/native-code/ios/\">fetch source code</a></li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">fetch</span> <span class=\"hljs-comment\">--nohooks webrtc_ios</span><br>gclient sync<br></code></pre></td></tr></table></figure>\n<h2 id=\"生成可调试项目\"><a href=\"#生成可调试项目\" class=\"headerlink\" title=\"生成可调试项目\"></a>生成可调试项目</h2><p>Using Xcode</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stata\"><span class=\"hljs-keyword\">cd</span> <span class=\"hljs-variable\">$src</span><br>gn <span class=\"hljs-keyword\">gen</span> <span class=\"hljs-keyword\">out</span>/ios --<span class=\"hljs-keyword\">args</span>=&#x27;target_os=<span class=\"hljs-string\">&quot;ios&quot;</span> target_cpu=<span class=\"hljs-string\">&quot;arm64&quot;</span> rtc_include_tests=false&#x27; --ide=xcode<br><span class=\"hljs-keyword\">open</span> -a Xcode.<span class=\"hljs-keyword\">app</span> <span class=\"hljs-keyword\">out</span>/ios/all.xcodeproj <br></code></pre></td></tr></table></figure>\n\n<p>选择 target <code>AppRTCMobile</code> 添加签名，运行</p>\n<h1 id=\"处理错误\"><a href=\"#处理错误\" class=\"headerlink\" title=\"处理错误\"></a>处理错误</h1><p><img src=\"https://fastly.jsdelivr.net/gh/yxibng/filebed@main/img/images/blog/16922434326171692243431723.png\" alt=\"16922434326171692243431723.png\"></p>\n<p>解决方案， 修改 <code>src/build/conifg/ios/ios_sdk.gni</code></p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-comment\"># `security find-identity -v -p codesigning`.</span><br><span class=\"hljs-attr\">ios_code_signing_identity_description</span> = <span class=\"hljs-string\">&quot;Apple Development&quot;</span><br></code></pre></td></tr></table></figure>\n<p>执行命令 <code>security find-identity -v -p codesigning</code> </p>\n<p>将 <code>Apple Development</code> 改为命令给出的列表中的具体的一项， 例如</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-comment\"># `security find-identity -v -p codesigning`.</span><br><span class=\"hljs-attr\">ios_code_signing_identity_description</span> = <span class=\"hljs-string\">&quot;Apple Development: xiaobing yao (24ZM6UP2MW)&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>之后重新执行上面的构建命令即可。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cltgopen40005qywh8lpwfb2y","tag_id":"cltgopen40003qywh87jphwmx","_id":"cltgopen50008qywh0wud9j83"},{"post_id":"cltgopen20001qywh0n11gbkl","tag_id":"cltgopen40003qywh87jphwmx","_id":"cltgopen5000aqywhh3pk4y4v"},{"post_id":"cltgopen50006qywhdhai3mu5","tag_id":"cltgopen40003qywh87jphwmx","_id":"cltgopen6000dqywh35checmd"},{"post_id":"cltgopen50009qywhd2mg9cri","tag_id":"cltgopen40003qywh87jphwmx","_id":"cltgopen6000fqywhedjq0rt7"},{"post_id":"cltgopen30002qywh26c132ej","tag_id":"cltgopen50007qywh2vfqgney","_id":"cltgopen7000hqywh66ry128s"},{"post_id":"cltgopen6000bqywhbntoglll","tag_id":"cltgopen40003qywh87jphwmx","_id":"cltgopen7000jqywhfaok6d2q"},{"post_id":"cltgopen6000eqywh5438ce5k","tag_id":"cltgopen40003qywh87jphwmx","_id":"cltgopen7000lqywhae2k8enf"},{"post_id":"cltgopen40004qywhbvseg3wd","tag_id":"cltgopen6000cqywh3lqqeujh","_id":"cltgopen8000nqywhaogcepjv"},{"post_id":"cltgopen6000gqywh0uyaca39","tag_id":"cltgopen40003qywh87jphwmx","_id":"cltgopen8000pqywhde25abrv"},{"post_id":"cltgopen7000iqywh01h7h05y","tag_id":"cltgopen40003qywh87jphwmx","_id":"cltgopen8000rqywh0iieh41p"},{"post_id":"cltgopen7000kqywh30fl34ny","tag_id":"cltgopen40003qywh87jphwmx","_id":"cltgopen8000tqywh5dbdc66i"},{"post_id":"cltgopen7000mqywh80aa5bdx","tag_id":"cltgopen40003qywh87jphwmx","_id":"cltgopen9000wqywhem2k6cwu"},{"post_id":"cltgopen8000oqywhecwn2kzc","tag_id":"cltgopen40003qywh87jphwmx","_id":"cltgopen9000yqywh0ro50ru6"},{"post_id":"cltgopen8000qqywhhs31hnir","tag_id":"cltgopen40003qywh87jphwmx","_id":"cltgopen90010qywh0rwm8auc"},{"post_id":"cltgopen8000sqywhgj8t8047","tag_id":"cltgopen8000vqywh6u5106cj","_id":"cltgopena0013qywhas797er0"},{"post_id":"cltgopen8000uqywhhyxa98om","tag_id":"cltgopen8000vqywh6u5106cj","_id":"cltgopena0017qywh6j2qakap"},{"post_id":"cltgopen9000xqywhdz9p67rt","tag_id":"cltgopena0016qywh6uy2blgc","_id":"cltgopenb001cqywh30s1bc0z"},{"post_id":"cltgopen9000zqywh6fvg97yh","tag_id":"cltgopena0016qywh6uy2blgc","_id":"cltgopenb001gqywh05tu0xnk"},{"post_id":"cltgopen90011qywhfzv23w1t","tag_id":"cltgopena0016qywh6uy2blgc","_id":"cltgopenc001kqywh68pb2xhk"},{"post_id":"cltgopena0014qywhetrx82pw","tag_id":"cltgopena0016qywh6uy2blgc","_id":"cltgopenc001oqywh2nhm811i"},{"post_id":"cltgopena0015qywhbpa2b9c0","tag_id":"cltgopenc001mqywh8h7rge9d","_id":"cltgopend001sqywh2r31hkh4"},{"post_id":"cltgopena0018qywh1g9301qu","tag_id":"cltgopenc001mqywh8h7rge9d","_id":"cltgopend001wqywh60w59bon"},{"post_id":"cltgopena0019qywhgnhc54sv","tag_id":"cltgopenc001mqywh8h7rge9d","_id":"cltgopend0020qywhfycm3a9n"},{"post_id":"cltgopenb001bqywhex4bfz2a","tag_id":"cltgopenc001mqywh8h7rge9d","_id":"cltgopene0024qywhb7ln8mjc"},{"post_id":"cltgopenb001dqywh53y4f3ml","tag_id":"cltgopend0022qywhe8mgae76","_id":"cltgopene0028qywh6ybocc5x"},{"post_id":"cltgopenb001fqywhex55ebdo","tag_id":"cltgopene0026qywh5e6wdt8o","_id":"cltgopene002cqywh9hsmghtk"},{"post_id":"cltgopenb001hqywhhj525uwo","tag_id":"cltgopene002bqywh9t2r3b6f","_id":"cltgopenf002hqywh9a6jftk0"},{"post_id":"cltgopenc001jqywh42v31l6n","tag_id":"cltgopene002bqywh9t2r3b6f","_id":"cltgopenf002kqywh3smpce9t"},{"post_id":"cltgopenc001lqywh9hj2f57u","tag_id":"cltgopene002bqywh9t2r3b6f","_id":"cltgopeng002mqywhddmpbf29"},{"post_id":"cltgopenc001nqywhdxvqc0jy","tag_id":"cltgopene002bqywh9t2r3b6f","_id":"cltgopeng002oqywhd40a76d0"},{"post_id":"cltgopenc001pqywh5t9za8tz","tag_id":"cltgopene002bqywh9t2r3b6f","_id":"cltgopeng002qqywh5jdi2cxz"},{"post_id":"cltgopenc001rqywh1e20euw5","tag_id":"cltgopene002bqywh9t2r3b6f","_id":"cltgopeng002sqywh6pnt797b"},{"post_id":"cltgopend001tqywhd18h4g4h","tag_id":"cltgopene002bqywh9t2r3b6f","_id":"cltgopeng002uqywhfa23fcgj"},{"post_id":"cltgopend001vqywh52ab4wv1","tag_id":"cltgopene002bqywh9t2r3b6f","_id":"cltgopeng002wqywh0jh9au03"},{"post_id":"cltgopend001xqywhh41s2cre","tag_id":"cltgopene002bqywh9t2r3b6f","_id":"cltgopeng002yqywhgfk53xo2"},{"post_id":"cltgopend001zqywh5cpcegts","tag_id":"cltgopene002bqywh9t2r3b6f","_id":"cltgopeng0030qywhfreq1o5r"},{"post_id":"cltgopend0021qywh93q22jqd","tag_id":"cltgopene002bqywh9t2r3b6f","_id":"cltgopeng0032qywhgj6zh4m5"},{"post_id":"cltgopene0023qywhe4skah5s","tag_id":"cltgopene002bqywh9t2r3b6f","_id":"cltgopeng0034qywh1xnzdqh4"},{"post_id":"cltgopene0025qywhfs0dc1rd","tag_id":"cltgopene002bqywh9t2r3b6f","_id":"cltgopenh0036qywh2gyjea74"},{"post_id":"cltgopene0027qywhe476f7pe","tag_id":"cltgopene002bqywh9t2r3b6f","_id":"cltgopenh0038qywhcfqlceav"},{"post_id":"cltgopene0029qywh0t7b24xp","tag_id":"cltgopene002bqywh9t2r3b6f","_id":"cltgopenh003aqywhhiy23o7n"},{"post_id":"cltgopene002aqywhhib2fmj1","tag_id":"cltgopene002bqywh9t2r3b6f","_id":"cltgopenh003cqywh05y9bw7r"},{"post_id":"cltgopene002dqywhdrio0w5v","tag_id":"cltgopenh003bqywhdbklc1z4","_id":"cltgopenh003eqywh7yv0dfwm"},{"post_id":"cltgopenf002eqywh5q3w0oza","tag_id":"cltgopenh003bqywhdbklc1z4","_id":"cltgopenh003gqywhdyd4autj"},{"post_id":"cltgopenf002gqywhhk69ac4v","tag_id":"cltgopenh003fqywhhqgihov6","_id":"cltgopenh003iqywha1wi6zzg"},{"post_id":"cltgopenf002iqywh30ui7gk2","tag_id":"cltgopenh003hqywh9xzzct42","_id":"cltgopenh003jqywh8dz47jzy"}],"Tag":[{"name":"Shell","_id":"cltgopen40003qywh87jphwmx"},{"name":"ruby","_id":"cltgopen50007qywh2vfqgney"},{"name":"shell","_id":"cltgopen6000cqywh3lqqeujh"},{"name":"aac","_id":"cltgopen8000vqywh6u5106cj"},{"name":"c++","_id":"cltgopena0016qywh6uy2blgc"},{"name":"cmake","_id":"cltgopenc001mqywh8h7rge9d"},{"name":"hls","_id":"cltgopend0022qywhe8mgae76"},{"name":"hls,m3u8","_id":"cltgopene0026qywh5e6wdt8o"},{"name":"ffmpeg","_id":"cltgopene002bqywh9t2r3b6f"},{"name":"iOS","_id":"cltgopenh003bqywhdbklc1z4"},{"name":"lldb","_id":"cltgopenh003fqywhhqgihov6"},{"name":"webrtc","_id":"cltgopenh003hqywh9xzzct42"}]}}